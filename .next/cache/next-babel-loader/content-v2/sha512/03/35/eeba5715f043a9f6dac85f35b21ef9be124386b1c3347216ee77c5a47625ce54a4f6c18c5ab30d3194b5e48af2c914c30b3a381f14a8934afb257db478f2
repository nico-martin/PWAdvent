{"ast":null,"code":"\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nexports.__esModule = true;\nexports.markAssetError = markAssetError;\nexports.isAssetError = isAssetError;\nexports.getClientBuildManifest = getClientBuildManifest;\nexports[\"default\"] = void 0;\n\nvar _getAssetPathFromRoute = _interopRequireDefault(require(\"../next-server/lib/router/utils/get-asset-path-from-route\"));\n\nvar _requestIdleCallback = require(\"./request-idle-callback\"); // 3.8s was arbitrarily chosen as it's what https://web.dev/interactive\n// considers as \"Good\" time-to-interactive. We must assume something went\n// wrong beyond this point, and then fall-back to a full page transition to\n// show the user something of value.\n\n\nvar MS_MAX_IDLE_DELAY = 3800;\n\nfunction withFuture(key, map, generator) {\n  var entry = map.get(key);\n\n  if (entry) {\n    if ('future' in entry) {\n      return entry.future;\n    }\n\n    return Promise.resolve(entry);\n  }\n\n  var resolver;\n  var prom = new Promise(function (resolve) {\n    resolver = resolve;\n  });\n  map.set(key, entry = {\n    resolve: resolver,\n    future: prom\n  });\n  return generator ? // eslint-disable-next-line no-sequences\n  generator().then(function (value) {\n    return resolver(value), value;\n  }) : prom;\n}\n\nfunction hasPrefetch(link) {\n  try {\n    link = document.createElement('link');\n    return (// detect IE11 since it supports prefetch but isn't detected\n      // with relList.support\n      !!window.MSInputMethodContext && !!document.documentMode || link.relList.supports('prefetch')\n    );\n  } catch (_unused) {\n    return false;\n  }\n}\n\nvar canPrefetch = hasPrefetch();\n\nfunction prefetchViaDom(href, as, link) {\n  return new Promise(function (res, rej) {\n    if (document.querySelector(\"link[rel=\\\"prefetch\\\"][href^=\\\"\".concat(href, \"\\\"]\"))) {\n      return res();\n    }\n\n    link = document.createElement('link'); // The order of property assignment here is intentional:\n\n    if (as) link.as = as;\n    link.rel = \"prefetch\";\n    link.crossOrigin = process.env.__NEXT_CROSS_ORIGIN;\n    link.onload = res;\n    link.onerror = rej; // `href` should always be last:\n\n    link.href = href;\n    document.head.appendChild(link);\n  });\n}\n\nvar ASSET_LOAD_ERROR = Symbol('ASSET_LOAD_ERROR'); // TODO: unexport\n\nfunction markAssetError(err) {\n  return Object.defineProperty(err, ASSET_LOAD_ERROR, {});\n}\n\nfunction isAssetError(err) {\n  return err && ASSET_LOAD_ERROR in err;\n}\n\nfunction appendScript(src, script) {\n  return new Promise(function (resolve, reject) {\n    script = document.createElement('script'); // The order of property assignment here is intentional.\n    // 1. Setup success/failure hooks in case the browser synchronously\n    //    executes when `src` is set.\n\n    script.onload = resolve;\n\n    script.onerror = function () {\n      return reject(markAssetError(new Error(\"Failed to load script: \".concat(src))));\n    }; // 2. Configure the cross-origin attribute before setting `src` in case the\n    //    browser begins to fetch.\n\n\n    script.crossOrigin = process.env.__NEXT_CROSS_ORIGIN; // 3. Finally, set the source and inject into the DOM in case the child\n    //    must be appended for fetching to start.\n\n    script.src = src;\n    document.body.appendChild(script);\n  });\n} // Resolve a promise that times out after given amount of milliseconds.\n\n\nfunction resolvePromiseWithTimeout(p, ms, err) {\n  return new Promise(function (resolve, reject) {\n    var cancelled = false;\n    p.then(function (r) {\n      // Resolved, cancel the timeout\n      cancelled = true;\n      resolve(r);\n    })[\"catch\"](reject);\n    (0, _requestIdleCallback.requestIdleCallback)(function () {\n      return setTimeout(function () {\n        if (!cancelled) {\n          reject(err);\n        }\n      }, ms);\n    });\n  });\n} // TODO: stop exporting or cache the failure\n// It'd be best to stop exporting this. It's an implementation detail. We're\n// only exporting it for backwards compatibilty with the `page-loader`.\n// Only cache this response as a last resort if we cannot eliminate all other\n// code branches that use the Build Manifest Callback and push them through\n// the Route Loader interface.\n\n\nfunction getClientBuildManifest() {\n  if (self.__BUILD_MANIFEST) {\n    return Promise.resolve(self.__BUILD_MANIFEST);\n  }\n\n  var onBuildManifest = new Promise(function (resolve) {\n    // Mandatory because this is not concurrent safe:\n    var cb = self.__BUILD_MANIFEST_CB;\n\n    self.__BUILD_MANIFEST_CB = function () {\n      resolve(self.__BUILD_MANIFEST);\n      cb && cb();\n    };\n  });\n  return resolvePromiseWithTimeout(onBuildManifest, MS_MAX_IDLE_DELAY, markAssetError(new Error('Failed to load client build manifest')));\n}\n\nfunction getFilesForRoute(assetPrefix, route) {\n  if (true) {\n    return Promise.resolve({\n      scripts: [assetPrefix + '/_next/static/chunks/pages' + encodeURI((0, _getAssetPathFromRoute[\"default\"])(route, '.js'))],\n      // Styles are handled by `style-loader` in development:\n      css: []\n    });\n  }\n\n  return getClientBuildManifest().then(function (manifest) {\n    if (!(route in manifest)) {\n      throw markAssetError(new Error(\"Failed to lookup route: \".concat(route)));\n    }\n\n    var allFiles = manifest[route].map(function (entry) {\n      return assetPrefix + '/_next/' + encodeURI(entry);\n    });\n    return {\n      scripts: allFiles.filter(function (v) {\n        return v.endsWith('.js');\n      }),\n      css: allFiles.filter(function (v) {\n        return v.endsWith('.css');\n      })\n    };\n  });\n}\n\nfunction createRouteLoader(assetPrefix) {\n  var entrypoints = new Map();\n  var loadedScripts = new Map();\n  var styleSheets = new Map();\n  var routes = new Map();\n\n  function maybeExecuteScript(src) {\n    var prom = loadedScripts.get(src);\n\n    if (prom) {\n      return prom;\n    } // Skip executing script if it's already in the DOM:\n\n\n    if (document.querySelector(\"script[src^=\\\"\".concat(src, \"\\\"]\"))) {\n      return Promise.resolve();\n    }\n\n    loadedScripts.set(src, prom = appendScript(src));\n    return prom;\n  }\n\n  function fetchStyleSheet(href) {\n    var prom = styleSheets.get(href);\n\n    if (prom) {\n      return prom;\n    }\n\n    styleSheets.set(href, prom = fetch(href).then(function (res) {\n      if (!res.ok) {\n        throw new Error(\"Failed to load stylesheet: \".concat(href));\n      }\n\n      return res.text().then(function (text) {\n        return {\n          href: href,\n          content: text\n        };\n      });\n    })[\"catch\"](function (err) {\n      throw markAssetError(err);\n    }));\n    return prom;\n  }\n\n  return {\n    whenEntrypoint: function whenEntrypoint(route) {\n      return withFuture(route, entrypoints);\n    },\n    onEntrypoint: function onEntrypoint(route, execute) {\n      Promise.resolve(execute).then(function (fn) {\n        return fn();\n      }).then(function (exports) {\n        return {\n          component: exports && exports[\"default\"] || exports,\n          exports: exports\n        };\n      }, function (err) {\n        return {\n          error: err\n        };\n      }).then(function (input) {\n        var old = entrypoints.get(route);\n        entrypoints.set(route, input);\n        if (old && 'resolve' in old) old.resolve(input);\n      });\n    },\n    loadRoute: function loadRoute(route, prefetch) {\n      var _this = this;\n\n      return withFuture(route, routes, function () {\n        return resolvePromiseWithTimeout(getFilesForRoute(assetPrefix, route).then(function (_ref) {\n          var scripts = _ref.scripts,\n              css = _ref.css;\n          return Promise.all([entrypoints.has(route) ? [] : Promise.all(scripts.map(maybeExecuteScript)), Promise.all(css.map(fetchStyleSheet))]);\n        }).then(function (res) {\n          return _this.whenEntrypoint(route).then(function (entrypoint) {\n            return {\n              entrypoint: entrypoint,\n              styles: res[1]\n            };\n          });\n        }), MS_MAX_IDLE_DELAY, markAssetError(new Error(\"Route did not complete loading: \".concat(route)))).then(function (_ref2) {\n          var entrypoint = _ref2.entrypoint,\n              styles = _ref2.styles;\n          var res = Object.assign({\n            styles: styles\n          }, entrypoint);\n          return 'error' in entrypoint ? entrypoint : res;\n        })[\"catch\"](function (err) {\n          if (prefetch) {\n            // we don't want to cache errors during prefetch\n            throw err;\n          }\n\n          return {\n            error: err\n          };\n        });\n      });\n    },\n    prefetch: function prefetch(route) {\n      var _this2 = this;\n\n      // https://github.com/GoogleChromeLabs/quicklink/blob/453a661fa1fa940e2d2e044452398e38c67a98fb/src/index.mjs#L115-L118\n      // License: Apache 2.0\n      var cn;\n\n      if (cn = navigator.connection) {\n        // Don't prefetch if using 2G or if Save-Data is enabled.\n        if (cn.saveData || /2g/.test(cn.effectiveType)) return Promise.resolve();\n      }\n\n      return getFilesForRoute(assetPrefix, route).then(function (output) {\n        return Promise.all(canPrefetch ? output.scripts.map(function (script) {\n          return prefetchViaDom(script, 'script');\n        }) : []);\n      }).then(function () {\n        (0, _requestIdleCallback.requestIdleCallback)(function () {\n          return _this2.loadRoute(route, true)[\"catch\"](function () {});\n        });\n      })[\"catch\"]( // swallow prefetch errors\n      function () {});\n    }\n  };\n}\n\nvar _default = createRouteLoader;\nexports[\"default\"] = _default;","map":{"version":3,"sources":["../../client/route-loader.ts"],"names":["MS_MAX_IDLE_DELAY","entry","map","Promise","prom","resolve","resolver","future","generator","value","link","document","window","canPrefetch","hasPrefetch","res","process","ASSET_LOAD_ERROR","Symbol","Object","err","script","reject","markAssetError","cancelled","r","setTimeout","self","onBuildManifest","cb","resolvePromiseWithTimeout","scripts","assetPrefix","encodeURI","css","getClientBuildManifest","manifest","route","allFiles","v","entrypoints","loadedScripts","styleSheets","routes","appendScript","fetch","text","href","content","whenEntrypoint","withFuture","onEntrypoint","fn","exports","component","error","input","old","loadRoute","getFilesForRoute","entrypoint","styles","prefetch","cn","navigator","output","prefetchViaDom","createRouteLoader"],"mappings":"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","sourcesContent":["import { ComponentType } from 'react'\nimport { ClientBuildManifest } from '../build/webpack/plugins/build-manifest-plugin'\nimport getAssetPathFromRoute from '../next-server/lib/router/utils/get-asset-path-from-route'\nimport { requestIdleCallback } from './request-idle-callback'\n\n// 3.8s was arbitrarily chosen as it's what https://web.dev/interactive\n// considers as \"Good\" time-to-interactive. We must assume something went\n// wrong beyond this point, and then fall-back to a full page transition to\n// show the user something of value.\nconst MS_MAX_IDLE_DELAY = 3800\n\ndeclare global {\n  interface Window {\n    __BUILD_MANIFEST?: ClientBuildManifest\n    __BUILD_MANIFEST_CB?: Function\n  }\n}\n\nexport interface LoadedEntrypointSuccess {\n  component: ComponentType\n  exports: any\n}\nexport interface LoadedEntrypointFailure {\n  error: unknown\n}\nexport type RouteEntrypoint = LoadedEntrypointSuccess | LoadedEntrypointFailure\n\nexport interface RouteStyleSheet {\n  href: string\n  content: string\n}\n\nexport interface LoadedRouteSuccess extends LoadedEntrypointSuccess {\n  styles: RouteStyleSheet[]\n}\nexport interface LoadedRouteFailure {\n  error: unknown\n}\nexport type RouteLoaderEntry = LoadedRouteSuccess | LoadedRouteFailure\n\nexport type Future<V> = {\n  resolve: (entrypoint: V) => void\n  future: Promise<V>\n}\nfunction withFuture<T>(\n  key: string,\n  map: Map<string, Future<T> | T>,\n  generator?: () => Promise<T>\n): Promise<T> {\n  let entry: Future<T> | T | undefined = map.get(key)\n  if (entry) {\n    if ('future' in entry) {\n      return entry.future\n    }\n    return Promise.resolve(entry)\n  }\n  let resolver: (entrypoint: T) => void\n  const prom: Promise<T> = new Promise<T>((resolve) => {\n    resolver = resolve\n  })\n  map.set(key, (entry = { resolve: resolver!, future: prom }))\n  return generator\n    ? // eslint-disable-next-line no-sequences\n      generator().then((value) => (resolver(value), value))\n    : prom\n}\n\nexport interface RouteLoader {\n  whenEntrypoint(route: string): Promise<RouteEntrypoint>\n  onEntrypoint(route: string, execute: () => unknown): void\n  loadRoute(route: string, prefetch?: boolean): Promise<RouteLoaderEntry>\n  prefetch(route: string): Promise<void>\n}\n\nfunction hasPrefetch(link?: HTMLLinkElement): boolean {\n  try {\n    link = document.createElement('link')\n    return (\n      // detect IE11 since it supports prefetch but isn't detected\n      // with relList.support\n      (!!window.MSInputMethodContext && !!(document as any).documentMode) ||\n      link.relList.supports('prefetch')\n    )\n  } catch {\n    return false\n  }\n}\n\nconst canPrefetch: boolean = hasPrefetch()\n\nfunction prefetchViaDom(\n  href: string,\n  as: string,\n  link?: HTMLLinkElement\n): Promise<any> {\n  return new Promise((res, rej) => {\n    if (document.querySelector(`link[rel=\"prefetch\"][href^=\"${href}\"]`)) {\n      return res()\n    }\n\n    link = document.createElement('link')\n\n    // The order of property assignment here is intentional:\n    if (as) link!.as = as\n    link!.rel = `prefetch`\n    link!.crossOrigin = process.env.__NEXT_CROSS_ORIGIN!\n    link!.onload = res\n    link!.onerror = rej\n\n    // `href` should always be last:\n    link!.href = href\n\n    document.head.appendChild(link)\n  })\n}\n\nconst ASSET_LOAD_ERROR = Symbol('ASSET_LOAD_ERROR')\n// TODO: unexport\nexport function markAssetError(err: Error): Error {\n  return Object.defineProperty(err, ASSET_LOAD_ERROR, {})\n}\n\nexport function isAssetError(err?: Error): boolean | undefined {\n  return err && ASSET_LOAD_ERROR in err\n}\n\nfunction appendScript(\n  src: string,\n  script?: HTMLScriptElement\n): Promise<unknown> {\n  return new Promise((resolve, reject) => {\n    script = document.createElement('script')\n\n    // The order of property assignment here is intentional.\n    // 1. Setup success/failure hooks in case the browser synchronously\n    //    executes when `src` is set.\n    script.onload = resolve\n    script.onerror = () =>\n      reject(markAssetError(new Error(`Failed to load script: ${src}`)))\n\n    // 2. Configure the cross-origin attribute before setting `src` in case the\n    //    browser begins to fetch.\n    script.crossOrigin = process.env.__NEXT_CROSS_ORIGIN!\n\n    // 3. Finally, set the source and inject into the DOM in case the child\n    //    must be appended for fetching to start.\n    script.src = src\n    document.body.appendChild(script)\n  })\n}\n\n// Resolve a promise that times out after given amount of milliseconds.\nfunction resolvePromiseWithTimeout<T>(\n  p: Promise<T>,\n  ms: number,\n  err: Error\n): Promise<T> {\n  return new Promise((resolve, reject) => {\n    let cancelled = false\n\n    p.then((r) => {\n      // Resolved, cancel the timeout\n      cancelled = true\n      resolve(r)\n    }).catch(reject)\n\n    requestIdleCallback(() =>\n      setTimeout(() => {\n        if (!cancelled) {\n          reject(err)\n        }\n      }, ms)\n    )\n  })\n}\n\n// TODO: stop exporting or cache the failure\n// It'd be best to stop exporting this. It's an implementation detail. We're\n// only exporting it for backwards compatibilty with the `page-loader`.\n// Only cache this response as a last resort if we cannot eliminate all other\n// code branches that use the Build Manifest Callback and push them through\n// the Route Loader interface.\nexport function getClientBuildManifest(): Promise<ClientBuildManifest> {\n  if (self.__BUILD_MANIFEST) {\n    return Promise.resolve(self.__BUILD_MANIFEST)\n  }\n\n  const onBuildManifest: Promise<ClientBuildManifest> = new Promise<\n    ClientBuildManifest\n  >((resolve) => {\n    // Mandatory because this is not concurrent safe:\n    const cb = self.__BUILD_MANIFEST_CB\n    self.__BUILD_MANIFEST_CB = () => {\n      resolve(self.__BUILD_MANIFEST!)\n      cb && cb()\n    }\n  })\n\n  return resolvePromiseWithTimeout<ClientBuildManifest>(\n    onBuildManifest,\n    MS_MAX_IDLE_DELAY,\n    markAssetError(new Error('Failed to load client build manifest'))\n  )\n}\n\ninterface RouteFiles {\n  scripts: string[]\n  css: string[]\n}\nfunction getFilesForRoute(\n  assetPrefix: string,\n  route: string\n): Promise<RouteFiles> {\n  if (process.env.NODE_ENV === 'development') {\n    return Promise.resolve({\n      scripts: [\n        assetPrefix +\n          '/_next/static/chunks/pages' +\n          encodeURI(getAssetPathFromRoute(route, '.js')),\n      ],\n      // Styles are handled by `style-loader` in development:\n      css: [],\n    })\n  }\n  return getClientBuildManifest().then((manifest) => {\n    if (!(route in manifest)) {\n      throw markAssetError(new Error(`Failed to lookup route: ${route}`))\n    }\n    const allFiles = manifest[route].map(\n      (entry) => assetPrefix + '/_next/' + encodeURI(entry)\n    )\n    return {\n      scripts: allFiles.filter((v) => v.endsWith('.js')),\n      css: allFiles.filter((v) => v.endsWith('.css')),\n    }\n  })\n}\n\nfunction createRouteLoader(assetPrefix: string): RouteLoader {\n  const entrypoints: Map<\n    string,\n    Future<RouteEntrypoint> | RouteEntrypoint\n  > = new Map()\n  const loadedScripts: Map<string, Promise<unknown>> = new Map()\n  const styleSheets: Map<string, Promise<RouteStyleSheet>> = new Map()\n  const routes: Map<\n    string,\n    Future<RouteLoaderEntry> | RouteLoaderEntry\n  > = new Map()\n\n  function maybeExecuteScript(src: string): Promise<unknown> {\n    let prom: Promise<unknown> | undefined = loadedScripts.get(src)\n    if (prom) {\n      return prom\n    }\n\n    // Skip executing script if it's already in the DOM:\n    if (document.querySelector(`script[src^=\"${src}\"]`)) {\n      return Promise.resolve()\n    }\n\n    loadedScripts.set(src, (prom = appendScript(src)))\n    return prom\n  }\n\n  function fetchStyleSheet(href: string): Promise<RouteStyleSheet> {\n    let prom: Promise<RouteStyleSheet> | undefined = styleSheets.get(href)\n    if (prom) {\n      return prom\n    }\n\n    styleSheets.set(\n      href,\n      (prom = fetch(href)\n        .then((res) => {\n          if (!res.ok) {\n            throw new Error(`Failed to load stylesheet: ${href}`)\n          }\n          return res.text().then((text) => ({ href: href, content: text }))\n        })\n        .catch((err) => {\n          throw markAssetError(err)\n        }))\n    )\n    return prom\n  }\n\n  return {\n    whenEntrypoint(route: string) {\n      return withFuture(route, entrypoints)\n    },\n    onEntrypoint(route: string, execute: () => unknown) {\n      Promise.resolve(execute)\n        .then((fn) => fn())\n        .then(\n          (exports: any) => ({\n            component: (exports && exports.default) || exports,\n            exports: exports,\n          }),\n          (err) => ({ error: err })\n        )\n        .then((input: RouteEntrypoint) => {\n          const old = entrypoints.get(route)\n          entrypoints.set(route, input)\n          if (old && 'resolve' in old) old.resolve(input)\n        })\n    },\n    loadRoute(route: string, prefetch?: boolean) {\n      return withFuture<RouteLoaderEntry>(route, routes, () => {\n        return resolvePromiseWithTimeout(\n          getFilesForRoute(assetPrefix, route)\n            .then(({ scripts, css }) => {\n              return Promise.all([\n                entrypoints.has(route)\n                  ? []\n                  : Promise.all(scripts.map(maybeExecuteScript)),\n                Promise.all(css.map(fetchStyleSheet)),\n              ] as const)\n            })\n            .then((res) => {\n              return this.whenEntrypoint(route).then((entrypoint) => ({\n                entrypoint,\n                styles: res[1],\n              }))\n            }),\n          MS_MAX_IDLE_DELAY,\n          markAssetError(new Error(`Route did not complete loading: ${route}`))\n        )\n          .then(({ entrypoint, styles }) => {\n            const res: RouteLoaderEntry = Object.assign<\n              { styles: RouteStyleSheet[] },\n              RouteEntrypoint\n            >({ styles: styles! }, entrypoint)\n            return 'error' in entrypoint ? entrypoint : res\n          })\n          .catch((err) => {\n            if (prefetch) {\n              // we don't want to cache errors during prefetch\n              throw err\n            }\n            return { error: err }\n          })\n      })\n    },\n    prefetch(route: string): Promise<void> {\n      // https://github.com/GoogleChromeLabs/quicklink/blob/453a661fa1fa940e2d2e044452398e38c67a98fb/src/index.mjs#L115-L118\n      // License: Apache 2.0\n      let cn\n      if ((cn = (navigator as any).connection)) {\n        // Don't prefetch if using 2G or if Save-Data is enabled.\n        if (cn.saveData || /2g/.test(cn.effectiveType)) return Promise.resolve()\n      }\n      return getFilesForRoute(assetPrefix, route)\n        .then((output) =>\n          Promise.all(\n            canPrefetch\n              ? output.scripts.map((script) => prefetchViaDom(script, 'script'))\n              : []\n          )\n        )\n        .then(() => {\n          requestIdleCallback(() => this.loadRoute(route, true).catch(() => {}))\n        })\n        .catch(\n          // swallow prefetch errors\n          () => {}\n        )\n    },\n  }\n}\n\nexport default createRouteLoader\n"]},"metadata":{},"sourceType":"script"}