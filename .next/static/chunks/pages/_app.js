_N_E =
(window["webpackJsonp_N_E"] = window["webpackJsonp_N_E"] || []).push([["pages/_app"],{

/***/ "./components/About/About.module.css":
/*!*******************************************!*\
  !*** ./components/About/About.module.css ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var api = __webpack_require__(/*! ../../node_modules/next/dist/build/webpack/loaders/next-style-loader/runtime/injectStylesIntoStyleTag.js */ "./node_modules/next/dist/build/webpack/loaders/next-style-loader/runtime/injectStylesIntoStyleTag.js");
            var content = __webpack_require__(/*! !../../node_modules/next/dist/compiled/css-loader/cjs.js??ref--5-oneOf-2-1!../../node_modules/next/dist/compiled/postcss-loader/cjs.js??ref--5-oneOf-2-2!./About.module.css */ "./node_modules/next/dist/compiled/css-loader/cjs.js?!./node_modules/next/dist/compiled/postcss-loader/cjs.js?!./components/About/About.module.css");

            content = content.__esModule ? content.default : content;

            if (typeof content === 'string') {
              content = [[module.i, content, '']];
            }

var options = {};

options.insert = function(element){// These elements should always exist. If they do not,
// this code should fail.
var anchorElement=document.querySelector('#__next_css__DO_NOT_USE__');var parentNode=anchorElement.parentNode;// Normally <head>
// Each style tag should be placed right before our
// anchor. By inserting before and not after, we do not
// need to track the last inserted element.
parentNode.insertBefore(element,anchorElement);};
options.singleton = false;

var update = api(content, options);


if (true) {
  if (!content.locals || module.hot.invalidate) {
    var isEqualLocals = function isEqualLocals(a,b,isNamedExport){if(!a&&b||a&&!b){return false;}let p;for(p in a){if(isNamedExport&&p==='default'){// eslint-disable-next-line no-continue
continue;}if(a[p]!==b[p]){return false;}}for(p in b){if(isNamedExport&&p==='default'){// eslint-disable-next-line no-continue
continue;}if(!a[p]){return false;}}return true;};
    var oldLocals = content.locals;

    module.hot.accept(
      /*! !../../node_modules/next/dist/compiled/css-loader/cjs.js??ref--5-oneOf-2-1!../../node_modules/next/dist/compiled/postcss-loader/cjs.js??ref--5-oneOf-2-2!./About.module.css */ "./node_modules/next/dist/compiled/css-loader/cjs.js?!./node_modules/next/dist/compiled/postcss-loader/cjs.js?!./components/About/About.module.css",
      function () {
        content = __webpack_require__(/*! !../../node_modules/next/dist/compiled/css-loader/cjs.js??ref--5-oneOf-2-1!../../node_modules/next/dist/compiled/postcss-loader/cjs.js??ref--5-oneOf-2-2!./About.module.css */ "./node_modules/next/dist/compiled/css-loader/cjs.js?!./node_modules/next/dist/compiled/postcss-loader/cjs.js?!./components/About/About.module.css");

              content = content.__esModule ? content.default : content;

              if (typeof content === 'string') {
                content = [[module.i, content, '']];
              }

              if (!isEqualLocals(oldLocals, content.locals)) {
                module.hot.invalidate();

                return;
              }

              oldLocals = content.locals;

              update(content);
      }
    )
  }

  module.hot.dispose(function() {
    update();
  });
}

module.exports = content.locals || {};

/***/ }),

/***/ "./components/About/About.tsx":
/*!************************************!*\
  !*** ./components/About/About.tsx ***!
  \************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* WEBPACK VAR INJECTION */(function(module, __prefresh_utils__) {/* harmony import */ var C_Users_admin_Documents_Dev_PWAdvent_node_modules_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./node_modules/@babel/runtime/helpers/esm/extends */ "./node_modules/@babel/runtime/helpers/esm/extends.js");
/* harmony import */ var C_Users_admin_Documents_Dev_PWAdvent_node_modules_babel_runtime_helpers_esm_objectWithoutProperties__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./node_modules/@babel/runtime/helpers/esm/objectWithoutProperties */ "./node_modules/@babel/runtime/helpers/esm/objectWithoutProperties.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! react */ "./node_modules/preact/compat/dist/compat.module.js");
/* harmony import */ var unistore_hooks__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! unistore-hooks */ "./node_modules/unistore-hooks/dist/unistore-hooks.module.js");
/* harmony import */ var _theme__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @theme */ "./theme/index.ts");
/* harmony import */ var _comps_About_AboutControls__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @comps/About/AboutControls */ "./components/About/AboutControls.tsx");
/* harmony import */ var _comps_About_AboutNavigation__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @comps/About/AboutNavigation */ "./components/About/AboutNavigation.tsx");
/* harmony import */ var _store_index__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @store/index */ "./store/index.ts");
/* harmony import */ var _About_module_css__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./About.module.css */ "./components/About/About.module.css");
/* harmony import */ var _About_module_css__WEBPACK_IMPORTED_MODULE_8___default = /*#__PURE__*/__webpack_require__.n(_About_module_css__WEBPACK_IMPORTED_MODULE_8__);



var _jsxFileName = "C:\\Users\\admin\\Documents\\Dev\\PWAdvent\\components\\About\\About.tsx",
    _this = undefined,
    _s = $RefreshSig$();

var __jsx = react__WEBPACK_IMPORTED_MODULE_2__["default"].createElement;








var About = function About(_ref) {
  _s();

  var _ref$className = _ref.className,
      className = _ref$className === void 0 ? '' : _ref$className,
      props = Object(C_Users_admin_Documents_Dev_PWAdvent_node_modules_babel_runtime_helpers_esm_objectWithoutProperties__WEBPACK_IMPORTED_MODULE_1__["default"])(_ref, ["className"]);

  var _useActions = Object(unistore_hooks__WEBPACK_IMPORTED_MODULE_3__["useActions"])(_store_index__WEBPACK_IMPORTED_MODULE_7__["actions"]),
      setMenuOpen = _useActions.setMenuOpen;

  return __jsx("article", Object(C_Users_admin_Documents_Dev_PWAdvent_node_modules_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__["default"])({
    className: "".concat(className)
  }, props, {
    __self: _this,
    __source: {
      fileName: _jsxFileName,
      lineNumber: 19,
      columnNumber: 5
    }
  }), __jsx("header", {
    className: _About_module_css__WEBPACK_IMPORTED_MODULE_8___default.a.header,
    __self: _this,
    __source: {
      fileName: _jsxFileName,
      lineNumber: 20,
      columnNumber: 7
    }
  }, __jsx(_theme__WEBPACK_IMPORTED_MODULE_4__["Logo"], {
    className: _About_module_css__WEBPACK_IMPORTED_MODULE_8___default.a.logo,
    title: "PWAdvent Logo",
    alt: "PWAdvent Logo",
    __self: _this,
    __source: {
      fileName: _jsxFileName,
      lineNumber: 21,
      columnNumber: 9
    }
  }), __jsx(_theme__WEBPACK_IMPORTED_MODULE_4__["Button"], {
    onClick: function onClick() {
      return setMenuOpen(false);
    },
    className: _About_module_css__WEBPACK_IMPORTED_MODULE_8___default.a.button,
    layout: "ghost",
    icon: "mdi/calendar-month",
    round: true,
    size: "small",
    __self: _this,
    __source: {
      fileName: _jsxFileName,
      lineNumber: 26,
      columnNumber: 9
    }
  }, "Calendar")), __jsx("div", {
    className: _About_module_css__WEBPACK_IMPORTED_MODULE_8___default.a.description,
    __self: _this,
    __source: {
      fileName: _jsxFileName,
      lineNumber: 37,
      columnNumber: 7
    }
  }, __jsx("p", {
    __self: _this,
    __source: {
      fileName: _jsxFileName,
      lineNumber: 38,
      columnNumber: 9
    }
  }, "PWAdvent is the perfect advent calendar for everyone who's excited about the web platform. Take a look at all the great stuff the web has to offer."), __jsx("p", {
    __self: _this,
    __source: {
      fileName: _jsxFileName,
      lineNumber: 43,
      columnNumber: 9
    }
  }, "From the 1st to the 24th of December 2020 we will introduce a new progressive browser feature every day \u2014 stay tuned for a set of features you most certainly did not know the web is capable of.")), __jsx(_comps_About_AboutControls__WEBPACK_IMPORTED_MODULE_5__["default"], {
    className: _About_module_css__WEBPACK_IMPORTED_MODULE_8___default.a.controls,
    __self: _this,
    __source: {
      fileName: _jsxFileName,
      lineNumber: 49,
      columnNumber: 7
    }
  }), __jsx(_comps_About_AboutNavigation__WEBPACK_IMPORTED_MODULE_6__["default"], {
    className: _About_module_css__WEBPACK_IMPORTED_MODULE_8___default.a.navigation,
    __self: _this,
    __source: {
      fileName: _jsxFileName,
      lineNumber: 50,
      columnNumber: 7
    }
  }));
};

_s(About, "r0eCydogd53h4OAdgrsxTA902hg=", false, function () {
  return [unistore_hooks__WEBPACK_IMPORTED_MODULE_3__["useActions"]];
});

_c = About;
/* harmony default export */ __webpack_exports__["default"] = (About);

var _c;

$RefreshReg$(_c, "About");

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.i);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }


const isPrefreshComponent = __prefresh_utils__.shouldBind(module);

  if (true) {
    const currentExports = __prefresh_utils__.getExports(module);
    const previousHotModuleExports =
      module.hot.data && module.hot.data.moduleExports;

    __prefresh_utils__.registerExports(currentExports, module.i);

    if (isPrefreshComponent) {
      if (previousHotModuleExports) {
        try {
          __prefresh_utils__.flush();
          if (
            typeof __prefresh_errors__ !== 'undefined' &&
            __prefresh_errors__ &&
            __prefresh_errors__.clearRuntimeErrors
          ) {
            __prefresh_errors__.clearRuntimeErrors();
          }
        } catch (e) {
          // Only available in newer webpack versions.
          if (module.hot.invalidate) {
            module.hot.invalidate();
          } else {
            self.location.reload();
          }
        }
      }

      module.hot.dispose(data => {
        data.moduleExports = __prefresh_utils__.getExports(module);
      });

      module.hot.accept(function errorRecovery() {
        if (
          typeof __prefresh_errors__ !== 'undefined' &&
          __prefresh_errors__ &&
          __prefresh_errors__.handleRuntimeError
        ) {
          __prefresh_errors__.handleRuntimeError(error);
        }

        __webpack_require__.c[module.i].hot.accept(errorRecovery);
      });
    }
  }
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../node_modules/next/dist/compiled/webpack/harmony-module.js */ "./node_modules/next/dist/compiled/webpack/harmony-module.js")(module), __webpack_require__(/*! ./node_modules/@prefresh/webpack/src/utils/prefresh.js */ "./node_modules/@prefresh/webpack/src/utils/prefresh.js")))

/***/ }),

/***/ "./components/About/AboutControls.module.css":
/*!***************************************************!*\
  !*** ./components/About/AboutControls.module.css ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var api = __webpack_require__(/*! ../../node_modules/next/dist/build/webpack/loaders/next-style-loader/runtime/injectStylesIntoStyleTag.js */ "./node_modules/next/dist/build/webpack/loaders/next-style-loader/runtime/injectStylesIntoStyleTag.js");
            var content = __webpack_require__(/*! !../../node_modules/next/dist/compiled/css-loader/cjs.js??ref--5-oneOf-2-1!../../node_modules/next/dist/compiled/postcss-loader/cjs.js??ref--5-oneOf-2-2!./AboutControls.module.css */ "./node_modules/next/dist/compiled/css-loader/cjs.js?!./node_modules/next/dist/compiled/postcss-loader/cjs.js?!./components/About/AboutControls.module.css");

            content = content.__esModule ? content.default : content;

            if (typeof content === 'string') {
              content = [[module.i, content, '']];
            }

var options = {};

options.insert = function(element){// These elements should always exist. If they do not,
// this code should fail.
var anchorElement=document.querySelector('#__next_css__DO_NOT_USE__');var parentNode=anchorElement.parentNode;// Normally <head>
// Each style tag should be placed right before our
// anchor. By inserting before and not after, we do not
// need to track the last inserted element.
parentNode.insertBefore(element,anchorElement);};
options.singleton = false;

var update = api(content, options);


if (true) {
  if (!content.locals || module.hot.invalidate) {
    var isEqualLocals = function isEqualLocals(a,b,isNamedExport){if(!a&&b||a&&!b){return false;}let p;for(p in a){if(isNamedExport&&p==='default'){// eslint-disable-next-line no-continue
continue;}if(a[p]!==b[p]){return false;}}for(p in b){if(isNamedExport&&p==='default'){// eslint-disable-next-line no-continue
continue;}if(!a[p]){return false;}}return true;};
    var oldLocals = content.locals;

    module.hot.accept(
      /*! !../../node_modules/next/dist/compiled/css-loader/cjs.js??ref--5-oneOf-2-1!../../node_modules/next/dist/compiled/postcss-loader/cjs.js??ref--5-oneOf-2-2!./AboutControls.module.css */ "./node_modules/next/dist/compiled/css-loader/cjs.js?!./node_modules/next/dist/compiled/postcss-loader/cjs.js?!./components/About/AboutControls.module.css",
      function () {
        content = __webpack_require__(/*! !../../node_modules/next/dist/compiled/css-loader/cjs.js??ref--5-oneOf-2-1!../../node_modules/next/dist/compiled/postcss-loader/cjs.js??ref--5-oneOf-2-2!./AboutControls.module.css */ "./node_modules/next/dist/compiled/css-loader/cjs.js?!./node_modules/next/dist/compiled/postcss-loader/cjs.js?!./components/About/AboutControls.module.css");

              content = content.__esModule ? content.default : content;

              if (typeof content === 'string') {
                content = [[module.i, content, '']];
              }

              if (!isEqualLocals(oldLocals, content.locals)) {
                module.hot.invalidate();

                return;
              }

              oldLocals = content.locals;

              update(content);
      }
    )
  }

  module.hot.dispose(function() {
    update();
  });
}

module.exports = content.locals || {};

/***/ }),

/***/ "./components/About/AboutControls.tsx":
/*!********************************************!*\
  !*** ./components/About/AboutControls.tsx ***!
  \********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* WEBPACK VAR INJECTION */(function(module, __prefresh_utils__) {/* harmony import */ var C_Users_admin_Documents_Dev_PWAdvent_node_modules_babel_runtime_helpers_esm_slicedToArray__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./node_modules/@babel/runtime/helpers/esm/slicedToArray */ "./node_modules/@babel/runtime/helpers/esm/slicedToArray.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ "./node_modules/preact/compat/dist/compat.module.js");
/* harmony import */ var _theme__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @theme */ "./theme/index.ts");
/* harmony import */ var _comps_About_EmailSignup__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @comps/About/EmailSignup */ "./components/About/EmailSignup.tsx");
/* harmony import */ var _comps_About_PushNotifications__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @comps/About/PushNotifications */ "./components/About/PushNotifications.tsx");
/* harmony import */ var _utils_classnames__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @utils/classnames */ "./utils/classnames.tsx");
/* harmony import */ var _utils_constants__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @utils/constants */ "./utils/constants.ts");
/* harmony import */ var _AboutControls_module_css__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./AboutControls.module.css */ "./components/About/AboutControls.module.css");
/* harmony import */ var _AboutControls_module_css__WEBPACK_IMPORTED_MODULE_7___default = /*#__PURE__*/__webpack_require__.n(_AboutControls_module_css__WEBPACK_IMPORTED_MODULE_7__);


var _jsxFileName = "C:\\Users\\admin\\Documents\\Dev\\PWAdvent\\components\\About\\AboutControls.tsx",
    _this = undefined,
    _s = $RefreshSig$();

var __jsx = react__WEBPACK_IMPORTED_MODULE_1__["default"].createElement;








var AboutControls = function AboutControls(_ref) {
  _s();

  var _ref$className = _ref.className,
      className = _ref$className === void 0 ? '' : _ref$className;

  var _React$useState = react__WEBPACK_IMPORTED_MODULE_1__["default"].useState(false),
      _React$useState2 = Object(C_Users_admin_Documents_Dev_PWAdvent_node_modules_babel_runtime_helpers_esm_slicedToArray__WEBPACK_IMPORTED_MODULE_0__["default"])(_React$useState, 2),
      emailBox = _React$useState2[0],
      setEmailBox = _React$useState2[1];

  var _React$useState3 = react__WEBPACK_IMPORTED_MODULE_1__["default"].useState(false),
      _React$useState4 = Object(C_Users_admin_Documents_Dev_PWAdvent_node_modules_babel_runtime_helpers_esm_slicedToArray__WEBPACK_IMPORTED_MODULE_0__["default"])(_React$useState3, 2),
      pushBox = _React$useState4[0],
      setPushBox = _React$useState4[1];

  return __jsx(react__WEBPACK_IMPORTED_MODULE_1__["default"].Fragment, {
    __self: _this,
    __source: {
      fileName: _jsxFileName,
      lineNumber: 14,
      columnNumber: 5
    }
  }, __jsx("ul", {
    className: Object(_utils_classnames__WEBPACK_IMPORTED_MODULE_5__["default"])(_AboutControls_module_css__WEBPACK_IMPORTED_MODULE_7___default.a.root, className),
    __self: _this,
    __source: {
      fileName: _jsxFileName,
      lineNumber: 15,
      columnNumber: 7
    }
  }, __jsx("li", {
    className: Object(_utils_classnames__WEBPACK_IMPORTED_MODULE_5__["default"])(_AboutControls_module_css__WEBPACK_IMPORTED_MODULE_7___default.a.item),
    __self: _this,
    __source: {
      fileName: _jsxFileName,
      lineNumber: 16,
      columnNumber: 9
    }
  }, __jsx(_theme__WEBPACK_IMPORTED_MODULE_2__["Button"], {
    className: Object(_utils_classnames__WEBPACK_IMPORTED_MODULE_5__["default"])(_AboutControls_module_css__WEBPACK_IMPORTED_MODULE_7___default.a.button),
    onClick: function onClick() {
      return setEmailBox(true);
    },
    layout: "empty",
    round: true,
    icon: "mdi/email-outline",
    iconRight: true,
    __self: _this,
    __source: {
      fileName: _jsxFileName,
      lineNumber: 17,
      columnNumber: 11
    }
  }, "Subscribe Email")), __jsx("li", {
    className: Object(_utils_classnames__WEBPACK_IMPORTED_MODULE_5__["default"])(_AboutControls_module_css__WEBPACK_IMPORTED_MODULE_7___default.a.item),
    __self: _this,
    __source: {
      fileName: _jsxFileName,
      lineNumber: 28,
      columnNumber: 9
    }
  }, __jsx(_theme__WEBPACK_IMPORTED_MODULE_2__["Button"], {
    className: Object(_utils_classnames__WEBPACK_IMPORTED_MODULE_5__["default"])(_AboutControls_module_css__WEBPACK_IMPORTED_MODULE_7___default.a.button),
    onClick: function onClick() {
      return setPushBox(true);
    },
    layout: "empty",
    round: true,
    icon: "mdi/bell-outline",
    iconRight: true,
    __self: _this,
    __source: {
      fileName: _jsxFileName,
      lineNumber: 29,
      columnNumber: 11
    }
  }, "Push Notifications")), 'share' in navigator && __jsx("li", {
    className: Object(_utils_classnames__WEBPACK_IMPORTED_MODULE_5__["default"])(_AboutControls_module_css__WEBPACK_IMPORTED_MODULE_7___default.a.item),
    __self: _this,
    __source: {
      fileName: _jsxFileName,
      lineNumber: 41,
      columnNumber: 11
    }
  }, __jsx(_theme__WEBPACK_IMPORTED_MODULE_2__["Button"], {
    className: Object(_utils_classnames__WEBPACK_IMPORTED_MODULE_5__["default"])(_AboutControls_module_css__WEBPACK_IMPORTED_MODULE_7___default.a.button),
    onClick: function onClick() {
      return navigator.share({
        url: window.location.href,
        text: "Check out PWAdvent.dev. ".concat(_utils_constants__WEBPACK_IMPORTED_MODULE_6__["appDescription"]),
        title: _utils_constants__WEBPACK_IMPORTED_MODULE_6__["appTitle"]
      });
    },
    layout: "empty",
    round: true,
    icon: "mdi/share",
    iconRight: true,
    __self: _this,
    __source: {
      fileName: _jsxFileName,
      lineNumber: 42,
      columnNumber: 13
    }
  }, "Tell your friends")), window.installPrompt && __jsx("li", {
    className: Object(_utils_classnames__WEBPACK_IMPORTED_MODULE_5__["default"])(_AboutControls_module_css__WEBPACK_IMPORTED_MODULE_7___default.a.item),
    __self: _this,
    __source: {
      fileName: _jsxFileName,
      lineNumber: 61,
      columnNumber: 11
    }
  }, __jsx(_theme__WEBPACK_IMPORTED_MODULE_2__["Button"], {
    className: Object(_utils_classnames__WEBPACK_IMPORTED_MODULE_5__["default"])(_AboutControls_module_css__WEBPACK_IMPORTED_MODULE_7___default.a.button),
    onClick: function onClick() {
      return window.installPrompt.prompt();
    },
    layout: "empty",
    round: true,
    icon: "mdi/download",
    iconRight: true,
    __self: _this,
    __source: {
      fileName: _jsxFileName,
      lineNumber: 62,
      columnNumber: 13
    }
  }, "Add to homescreen"))), emailBox && __jsx(_theme__WEBPACK_IMPORTED_MODULE_2__["PortalBox"], {
    size: "small",
    close: function close() {
      //settingsDB.set('emailPopupClosed', true);
      setEmailBox(false);
    },
    title: "Email signup",
    __self: _this,
    __source: {
      fileName: _jsxFileName,
      lineNumber: 76,
      columnNumber: 9
    }
  }, __jsx(_comps_About_EmailSignup__WEBPACK_IMPORTED_MODULE_3__["default"], {
    __self: _this,
    __source: {
      fileName: _jsxFileName,
      lineNumber: 84,
      columnNumber: 11
    }
  })), pushBox && __jsx(_theme__WEBPACK_IMPORTED_MODULE_2__["PortalBox"], {
    size: "small",
    close: function close() {
      return setPushBox(false);
    },
    title: "Push Notifications",
    __self: _this,
    __source: {
      fileName: _jsxFileName,
      lineNumber: 88,
      columnNumber: 9
    }
  }, __jsx(_comps_About_PushNotifications__WEBPACK_IMPORTED_MODULE_4__["default"], {
    __self: _this,
    __source: {
      fileName: _jsxFileName,
      lineNumber: 93,
      columnNumber: 11
    }
  })));
};

_s(AboutControls, "pa0pxWTgkj3e9xVBO93py7a3l5E=");

_c = AboutControls;
/* harmony default export */ __webpack_exports__["default"] = (AboutControls);

var _c;

$RefreshReg$(_c, "AboutControls");

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.i);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }


const isPrefreshComponent = __prefresh_utils__.shouldBind(module);

  if (true) {
    const currentExports = __prefresh_utils__.getExports(module);
    const previousHotModuleExports =
      module.hot.data && module.hot.data.moduleExports;

    __prefresh_utils__.registerExports(currentExports, module.i);

    if (isPrefreshComponent) {
      if (previousHotModuleExports) {
        try {
          __prefresh_utils__.flush();
          if (
            typeof __prefresh_errors__ !== 'undefined' &&
            __prefresh_errors__ &&
            __prefresh_errors__.clearRuntimeErrors
          ) {
            __prefresh_errors__.clearRuntimeErrors();
          }
        } catch (e) {
          // Only available in newer webpack versions.
          if (module.hot.invalidate) {
            module.hot.invalidate();
          } else {
            self.location.reload();
          }
        }
      }

      module.hot.dispose(data => {
        data.moduleExports = __prefresh_utils__.getExports(module);
      });

      module.hot.accept(function errorRecovery() {
        if (
          typeof __prefresh_errors__ !== 'undefined' &&
          __prefresh_errors__ &&
          __prefresh_errors__.handleRuntimeError
        ) {
          __prefresh_errors__.handleRuntimeError(error);
        }

        __webpack_require__.c[module.i].hot.accept(errorRecovery);
      });
    }
  }
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../node_modules/next/dist/compiled/webpack/harmony-module.js */ "./node_modules/next/dist/compiled/webpack/harmony-module.js")(module), __webpack_require__(/*! ./node_modules/@prefresh/webpack/src/utils/prefresh.js */ "./node_modules/@prefresh/webpack/src/utils/prefresh.js")))

/***/ }),

/***/ "./components/About/AboutNavigation.module.css":
/*!*****************************************************!*\
  !*** ./components/About/AboutNavigation.module.css ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var api = __webpack_require__(/*! ../../node_modules/next/dist/build/webpack/loaders/next-style-loader/runtime/injectStylesIntoStyleTag.js */ "./node_modules/next/dist/build/webpack/loaders/next-style-loader/runtime/injectStylesIntoStyleTag.js");
            var content = __webpack_require__(/*! !../../node_modules/next/dist/compiled/css-loader/cjs.js??ref--5-oneOf-2-1!../../node_modules/next/dist/compiled/postcss-loader/cjs.js??ref--5-oneOf-2-2!./AboutNavigation.module.css */ "./node_modules/next/dist/compiled/css-loader/cjs.js?!./node_modules/next/dist/compiled/postcss-loader/cjs.js?!./components/About/AboutNavigation.module.css");

            content = content.__esModule ? content.default : content;

            if (typeof content === 'string') {
              content = [[module.i, content, '']];
            }

var options = {};

options.insert = function(element){// These elements should always exist. If they do not,
// this code should fail.
var anchorElement=document.querySelector('#__next_css__DO_NOT_USE__');var parentNode=anchorElement.parentNode;// Normally <head>
// Each style tag should be placed right before our
// anchor. By inserting before and not after, we do not
// need to track the last inserted element.
parentNode.insertBefore(element,anchorElement);};
options.singleton = false;

var update = api(content, options);


if (true) {
  if (!content.locals || module.hot.invalidate) {
    var isEqualLocals = function isEqualLocals(a,b,isNamedExport){if(!a&&b||a&&!b){return false;}let p;for(p in a){if(isNamedExport&&p==='default'){// eslint-disable-next-line no-continue
continue;}if(a[p]!==b[p]){return false;}}for(p in b){if(isNamedExport&&p==='default'){// eslint-disable-next-line no-continue
continue;}if(!a[p]){return false;}}return true;};
    var oldLocals = content.locals;

    module.hot.accept(
      /*! !../../node_modules/next/dist/compiled/css-loader/cjs.js??ref--5-oneOf-2-1!../../node_modules/next/dist/compiled/postcss-loader/cjs.js??ref--5-oneOf-2-2!./AboutNavigation.module.css */ "./node_modules/next/dist/compiled/css-loader/cjs.js?!./node_modules/next/dist/compiled/postcss-loader/cjs.js?!./components/About/AboutNavigation.module.css",
      function () {
        content = __webpack_require__(/*! !../../node_modules/next/dist/compiled/css-loader/cjs.js??ref--5-oneOf-2-1!../../node_modules/next/dist/compiled/postcss-loader/cjs.js??ref--5-oneOf-2-2!./AboutNavigation.module.css */ "./node_modules/next/dist/compiled/css-loader/cjs.js?!./node_modules/next/dist/compiled/postcss-loader/cjs.js?!./components/About/AboutNavigation.module.css");

              content = content.__esModule ? content.default : content;

              if (typeof content === 'string') {
                content = [[module.i, content, '']];
              }

              if (!isEqualLocals(oldLocals, content.locals)) {
                module.hot.invalidate();

                return;
              }

              oldLocals = content.locals;

              update(content);
      }
    )
  }

  module.hot.dispose(function() {
    update();
  });
}

module.exports = content.locals || {};

/***/ }),

/***/ "./components/About/AboutNavigation.tsx":
/*!**********************************************!*\
  !*** ./components/About/AboutNavigation.tsx ***!
  \**********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* WEBPACK VAR INJECTION */(function(module, __prefresh_utils__) {/* harmony import */ var C_Users_admin_Documents_Dev_PWAdvent_node_modules_babel_runtime_helpers_esm_slicedToArray__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./node_modules/@babel/runtime/helpers/esm/slicedToArray */ "./node_modules/@babel/runtime/helpers/esm/slicedToArray.js");
/* harmony import */ var next_link__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! next/link */ "./node_modules/next/link.js");
/* harmony import */ var next_link__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(next_link__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! react */ "./node_modules/preact/compat/dist/compat.module.js");
/* harmony import */ var _utils_classnames__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @utils/classnames */ "./utils/classnames.tsx");
/* harmony import */ var _AboutNavigation_module_css__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./AboutNavigation.module.css */ "./components/About/AboutNavigation.module.css");
/* harmony import */ var _AboutNavigation_module_css__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(_AboutNavigation_module_css__WEBPACK_IMPORTED_MODULE_4__);


var _jsxFileName = "C:\\Users\\admin\\Documents\\Dev\\PWAdvent\\components\\About\\AboutNavigation.tsx",
    _this = undefined;

var __jsx = react__WEBPACK_IMPORTED_MODULE_2__["default"].createElement;





var AboutNavigation = function AboutNavigation(_ref) {
  var _ref$className = _ref.className,
      className = _ref$className === void 0 ? '' : _ref$className;
  return __jsx("nav", {
    className: Object(_utils_classnames__WEBPACK_IMPORTED_MODULE_3__["default"])(className, _AboutNavigation_module_css__WEBPACK_IMPORTED_MODULE_4___default.a.root),
    __self: _this,
    __source: {
      fileName: _jsxFileName,
      lineNumber: 7,
      columnNumber: 3
    }
  }, Object.entries({
    legal: 'Legal',
    privacy: 'Privacy',
    credits: 'Credits'
  }).map(function (_ref2) {
    var _ref3 = Object(C_Users_admin_Documents_Dev_PWAdvent_node_modules_babel_runtime_helpers_esm_slicedToArray__WEBPACK_IMPORTED_MODULE_0__["default"])(_ref2, 2),
        slug = _ref3[0],
        title = _ref3[1];

    return __jsx(next_link__WEBPACK_IMPORTED_MODULE_1___default.a, {
      href: "/".concat(slug, "/"),
      __self: _this,
      __source: {
        fileName: _jsxFileName,
        lineNumber: 13,
        columnNumber: 7
      }
    }, __jsx("a", {
      className: _AboutNavigation_module_css__WEBPACK_IMPORTED_MODULE_4___default.a.item,
      __self: _this,
      __source: {
        fileName: _jsxFileName,
        lineNumber: 14,
        columnNumber: 9
      }
    }, title));
  }));
};

_c = AboutNavigation;
/* harmony default export */ __webpack_exports__["default"] = (AboutNavigation);

var _c;

$RefreshReg$(_c, "AboutNavigation");

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.i);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }


const isPrefreshComponent = __prefresh_utils__.shouldBind(module);

  if (true) {
    const currentExports = __prefresh_utils__.getExports(module);
    const previousHotModuleExports =
      module.hot.data && module.hot.data.moduleExports;

    __prefresh_utils__.registerExports(currentExports, module.i);

    if (isPrefreshComponent) {
      if (previousHotModuleExports) {
        try {
          __prefresh_utils__.flush();
          if (
            typeof __prefresh_errors__ !== 'undefined' &&
            __prefresh_errors__ &&
            __prefresh_errors__.clearRuntimeErrors
          ) {
            __prefresh_errors__.clearRuntimeErrors();
          }
        } catch (e) {
          // Only available in newer webpack versions.
          if (module.hot.invalidate) {
            module.hot.invalidate();
          } else {
            self.location.reload();
          }
        }
      }

      module.hot.dispose(data => {
        data.moduleExports = __prefresh_utils__.getExports(module);
      });

      module.hot.accept(function errorRecovery() {
        if (
          typeof __prefresh_errors__ !== 'undefined' &&
          __prefresh_errors__ &&
          __prefresh_errors__.handleRuntimeError
        ) {
          __prefresh_errors__.handleRuntimeError(error);
        }

        __webpack_require__.c[module.i].hot.accept(errorRecovery);
      });
    }
  }
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../node_modules/next/dist/compiled/webpack/harmony-module.js */ "./node_modules/next/dist/compiled/webpack/harmony-module.js")(module), __webpack_require__(/*! ./node_modules/@prefresh/webpack/src/utils/prefresh.js */ "./node_modules/@prefresh/webpack/src/utils/prefresh.js")))

/***/ }),

/***/ "./components/About/EmailSignup.module.css":
/*!*************************************************!*\
  !*** ./components/About/EmailSignup.module.css ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var api = __webpack_require__(/*! ../../node_modules/next/dist/build/webpack/loaders/next-style-loader/runtime/injectStylesIntoStyleTag.js */ "./node_modules/next/dist/build/webpack/loaders/next-style-loader/runtime/injectStylesIntoStyleTag.js");
            var content = __webpack_require__(/*! !../../node_modules/next/dist/compiled/css-loader/cjs.js??ref--5-oneOf-2-1!../../node_modules/next/dist/compiled/postcss-loader/cjs.js??ref--5-oneOf-2-2!./EmailSignup.module.css */ "./node_modules/next/dist/compiled/css-loader/cjs.js?!./node_modules/next/dist/compiled/postcss-loader/cjs.js?!./components/About/EmailSignup.module.css");

            content = content.__esModule ? content.default : content;

            if (typeof content === 'string') {
              content = [[module.i, content, '']];
            }

var options = {};

options.insert = function(element){// These elements should always exist. If they do not,
// this code should fail.
var anchorElement=document.querySelector('#__next_css__DO_NOT_USE__');var parentNode=anchorElement.parentNode;// Normally <head>
// Each style tag should be placed right before our
// anchor. By inserting before and not after, we do not
// need to track the last inserted element.
parentNode.insertBefore(element,anchorElement);};
options.singleton = false;

var update = api(content, options);


if (true) {
  if (!content.locals || module.hot.invalidate) {
    var isEqualLocals = function isEqualLocals(a,b,isNamedExport){if(!a&&b||a&&!b){return false;}let p;for(p in a){if(isNamedExport&&p==='default'){// eslint-disable-next-line no-continue
continue;}if(a[p]!==b[p]){return false;}}for(p in b){if(isNamedExport&&p==='default'){// eslint-disable-next-line no-continue
continue;}if(!a[p]){return false;}}return true;};
    var oldLocals = content.locals;

    module.hot.accept(
      /*! !../../node_modules/next/dist/compiled/css-loader/cjs.js??ref--5-oneOf-2-1!../../node_modules/next/dist/compiled/postcss-loader/cjs.js??ref--5-oneOf-2-2!./EmailSignup.module.css */ "./node_modules/next/dist/compiled/css-loader/cjs.js?!./node_modules/next/dist/compiled/postcss-loader/cjs.js?!./components/About/EmailSignup.module.css",
      function () {
        content = __webpack_require__(/*! !../../node_modules/next/dist/compiled/css-loader/cjs.js??ref--5-oneOf-2-1!../../node_modules/next/dist/compiled/postcss-loader/cjs.js??ref--5-oneOf-2-2!./EmailSignup.module.css */ "./node_modules/next/dist/compiled/css-loader/cjs.js?!./node_modules/next/dist/compiled/postcss-loader/cjs.js?!./components/About/EmailSignup.module.css");

              content = content.__esModule ? content.default : content;

              if (typeof content === 'string') {
                content = [[module.i, content, '']];
              }

              if (!isEqualLocals(oldLocals, content.locals)) {
                module.hot.invalidate();

                return;
              }

              oldLocals = content.locals;

              update(content);
      }
    )
  }

  module.hot.dispose(function() {
    update();
  });
}

module.exports = content.locals || {};

/***/ }),

/***/ "./components/About/EmailSignup.tsx":
/*!******************************************!*\
  !*** ./components/About/EmailSignup.tsx ***!
  \******************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* WEBPACK VAR INJECTION */(function(module, __prefresh_utils__) {/* harmony import */ var C_Users_admin_Documents_Dev_PWAdvent_node_modules_babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./node_modules/@babel/runtime/regenerator */ "./node_modules/@babel/runtime/regenerator/index.js");
/* harmony import */ var C_Users_admin_Documents_Dev_PWAdvent_node_modules_babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(C_Users_admin_Documents_Dev_PWAdvent_node_modules_babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var C_Users_admin_Documents_Dev_PWAdvent_node_modules_babel_runtime_helpers_esm_asyncToGenerator__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./node_modules/@babel/runtime/helpers/esm/asyncToGenerator */ "./node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js");
/* harmony import */ var C_Users_admin_Documents_Dev_PWAdvent_node_modules_babel_runtime_helpers_esm_slicedToArray__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./node_modules/@babel/runtime/helpers/esm/slicedToArray */ "./node_modules/@babel/runtime/helpers/esm/slicedToArray.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! react */ "./node_modules/preact/compat/dist/compat.module.js");
/* harmony import */ var _theme__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @theme */ "./theme/index.ts");
/* harmony import */ var _utils_classnames__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @utils/classnames */ "./utils/classnames.tsx");
/* harmony import */ var _utils_constants__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @utils/constants */ "./utils/constants.ts");
/* harmony import */ var _EmailSignup_module_css__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./EmailSignup.module.css */ "./components/About/EmailSignup.module.css");
/* harmony import */ var _EmailSignup_module_css__WEBPACK_IMPORTED_MODULE_7___default = /*#__PURE__*/__webpack_require__.n(_EmailSignup_module_css__WEBPACK_IMPORTED_MODULE_7__);




var _jsxFileName = "C:\\Users\\admin\\Documents\\Dev\\PWAdvent\\components\\About\\EmailSignup.tsx",
    _this = undefined,
    _s = $RefreshSig$();

var __jsx = react__WEBPACK_IMPORTED_MODULE_3__["default"].createElement;






var EmailSignup = function EmailSignup(_ref) {
  _s();

  var _ref$className = _ref.className,
      className = _ref$className === void 0 ? '' : _ref$className;

  var _React$useState = react__WEBPACK_IMPORTED_MODULE_3__["default"].useState(false),
      _React$useState2 = Object(C_Users_admin_Documents_Dev_PWAdvent_node_modules_babel_runtime_helpers_esm_slicedToArray__WEBPACK_IMPORTED_MODULE_2__["default"])(_React$useState, 2),
      loading = _React$useState2[0],
      setLoading = _React$useState2[1];

  var _React$useState3 = react__WEBPACK_IMPORTED_MODULE_3__["default"].useState(''),
      _React$useState4 = Object(C_Users_admin_Documents_Dev_PWAdvent_node_modules_babel_runtime_helpers_esm_slicedToArray__WEBPACK_IMPORTED_MODULE_2__["default"])(_React$useState3, 2),
      formSuccess = _React$useState4[0],
      setFormSuccess = _React$useState4[1];

  var _React$useState5 = react__WEBPACK_IMPORTED_MODULE_3__["default"].useState(''),
      _React$useState6 = Object(C_Users_admin_Documents_Dev_PWAdvent_node_modules_babel_runtime_helpers_esm_slicedToArray__WEBPACK_IMPORTED_MODULE_2__["default"])(_React$useState5, 2),
      formError = _React$useState6[0],
      setFormError = _React$useState6[1];

  return __jsx("div", {
    className: Object(_utils_classnames__WEBPACK_IMPORTED_MODULE_5__["default"])(className),
    __self: _this,
    __source: {
      fileName: _jsxFileName,
      lineNumber: 21,
      columnNumber: 5
    }
  }, __jsx("div", {
    className: Object(_utils_classnames__WEBPACK_IMPORTED_MODULE_5__["default"])(_EmailSignup_module_css__WEBPACK_IMPORTED_MODULE_7___default.a.content),
    __self: _this,
    __source: {
      fileName: _jsxFileName,
      lineNumber: 22,
      columnNumber: 7
    }
  }, __jsx("p", {
    __self: _this,
    __source: {
      fileName: _jsxFileName,
      lineNumber: 23,
      columnNumber: 9
    }
  }, "Are you excited for Progressive Web Apps? Let's get ready for PWAdvent! 24 features in 24 days."), __jsx("p", {
    __self: _this,
    __source: {
      fileName: _jsxFileName,
      lineNumber: 27,
      columnNumber: 9
    }
  }, "Make sure to subscribe and get notified as soon as a new feature is published.")), formError !== '' ? __jsx(_theme__WEBPACK_IMPORTED_MODULE_4__["Notification"], {
    className: Object(_utils_classnames__WEBPACK_IMPORTED_MODULE_5__["default"])(_EmailSignup_module_css__WEBPACK_IMPORTED_MODULE_7___default.a.notification),
    type: "error",
    __self: _this,
    __source: {
      fileName: _jsxFileName,
      lineNumber: 33,
      columnNumber: 9
    }
  }, formError) : formSuccess !== '' ? __jsx(_theme__WEBPACK_IMPORTED_MODULE_4__["Notification"], {
    className: Object(_utils_classnames__WEBPACK_IMPORTED_MODULE_5__["default"])(_EmailSignup_module_css__WEBPACK_IMPORTED_MODULE_7___default.a.notification),
    type: "success",
    __self: _this,
    __source: {
      fileName: _jsxFileName,
      lineNumber: 37,
      columnNumber: 9
    }
  }, formSuccess) : __jsx(react__WEBPACK_IMPORTED_MODULE_3__["default"].Fragment, {
    __self: _this,
    __source: {
      fileName: _jsxFileName,
      lineNumber: 41,
      columnNumber: 9
    }
  }, __jsx(_theme__WEBPACK_IMPORTED_MODULE_4__["Form"], {
    className: Object(_utils_classnames__WEBPACK_IMPORTED_MODULE_5__["default"])(_EmailSignup_module_css__WEBPACK_IMPORTED_MODULE_7___default.a.form),
    onSubmit: /*#__PURE__*/function () {
      var _ref2 = Object(C_Users_admin_Documents_Dev_PWAdvent_node_modules_babel_runtime_helpers_esm_asyncToGenerator__WEBPACK_IMPORTED_MODULE_1__["default"])( /*#__PURE__*/C_Users_admin_Documents_Dev_PWAdvent_node_modules_babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_0___default.a.mark(function _callee(data) {
        var resp;
        return C_Users_admin_Documents_Dev_PWAdvent_node_modules_babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_0___default.a.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                setLoading(true);
                setFormSuccess('');
                setFormError('');
                _context.prev = 3;
                _context.next = 6;
                return fetch("".concat(_utils_constants__WEBPACK_IMPORTED_MODULE_6__["apiBase"], "wp-json/advent-calendar/v1/email-notification/"), {
                  method: 'post',
                  body: JSON.stringify({
                    email: data.email,
                    timezoneOffset: new Date().getTimezoneOffset()
                  }),
                  headers: {
                    'Content-Type': 'application/json'
                  }
                });

              case 6:
                resp = _context.sent;

                if (resp.status === 409) {
                  setFormSuccess('Thank you very much. Your email has already been registered.');
                } else if (resp.status === 200) {
                  setFormSuccess('Thank you very much. You will receive an email shortly, in which you can confirm your address');
                } else {
                  new Error();
                }

                _context.next = 13;
                break;

              case 10:
                _context.prev = 10;
                _context.t0 = _context["catch"](3);
                setFormError('Oops.. Something went wrong. Please try again later.');

              case 13:
                setLoading(false);

              case 14:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, null, [[3, 10]]);
      }));

      return function (_x) {
        return _ref2.apply(this, arguments);
      };
    }(),
    __self: _this,
    __source: {
      fileName: _jsxFileName,
      lineNumber: 42,
      columnNumber: 11
    }
  }, __jsx(_theme__WEBPACK_IMPORTED_MODULE_4__["FormFieldset"], {
    stacked: true,
    __self: _this,
    __source: {
      fileName: _jsxFileName,
      lineNumber: 82,
      columnNumber: 13
    }
  }, __jsx(_theme__WEBPACK_IMPORTED_MODULE_4__["FormField"], {
    name: "email",
    label: "Email",
    component: _theme__WEBPACK_IMPORTED_MODULE_4__["InputText"],
    disabled: loading,
    type: "email",
    register: {
      required: 'This value is required',
      pattern: {
        value: /^(([^<>()\[\]\\.,;:\s@"]+(\.[^<>()\[\]\\.,;:\s@"]+)*)|(".+"))@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\])|(([a-zA-Z\-0-9]+\.)+[a-zA-Z]{2,}))$/,
        message: 'This needs to be a valid Email adress'
      }
    },
    __self: _this,
    __source: {
      fileName: _jsxFileName,
      lineNumber: 83,
      columnNumber: 15
    }
  }), __jsx(_theme__WEBPACK_IMPORTED_MODULE_4__["FormControls"], {
    __self: _this,
    __source: {
      fileName: _jsxFileName,
      lineNumber: 98,
      columnNumber: 15
    }
  }, __jsx(_theme__WEBPACK_IMPORTED_MODULE_4__["Button"], {
    type: "submit",
    loading: loading,
    disabled: loading,
    icon: "mdi/send",
    iconRight: true,
    __self: _this,
    __source: {
      fileName: _jsxFileName,
      lineNumber: 99,
      columnNumber: 17
    }
  }, "Submit")))), __jsx("p", {
    className: Object(_utils_classnames__WEBPACK_IMPORTED_MODULE_5__["default"])(_EmailSignup_module_css__WEBPACK_IMPORTED_MODULE_7___default.a.disclaimer),
    __self: _this,
    __source: {
      fileName: _jsxFileName,
      lineNumber: 111,
      columnNumber: 11
    }
  }, "We use your email exclusively to send you the link to the published entry every morning between 2020-12-01 and 2020-12-24. You can cancel this service at any time, your data will not be passed on to third parties.")));
};

_s(EmailSignup, "f5dnyrQj+9Wk+lbhG1ox9qHi+mo=");

_c = EmailSignup;
/* harmony default export */ __webpack_exports__["default"] = (EmailSignup);

var _c;

$RefreshReg$(_c, "EmailSignup");

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.i);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }


const isPrefreshComponent = __prefresh_utils__.shouldBind(module);

  if (true) {
    const currentExports = __prefresh_utils__.getExports(module);
    const previousHotModuleExports =
      module.hot.data && module.hot.data.moduleExports;

    __prefresh_utils__.registerExports(currentExports, module.i);

    if (isPrefreshComponent) {
      if (previousHotModuleExports) {
        try {
          __prefresh_utils__.flush();
          if (
            typeof __prefresh_errors__ !== 'undefined' &&
            __prefresh_errors__ &&
            __prefresh_errors__.clearRuntimeErrors
          ) {
            __prefresh_errors__.clearRuntimeErrors();
          }
        } catch (e) {
          // Only available in newer webpack versions.
          if (module.hot.invalidate) {
            module.hot.invalidate();
          } else {
            self.location.reload();
          }
        }
      }

      module.hot.dispose(data => {
        data.moduleExports = __prefresh_utils__.getExports(module);
      });

      module.hot.accept(function errorRecovery() {
        if (
          typeof __prefresh_errors__ !== 'undefined' &&
          __prefresh_errors__ &&
          __prefresh_errors__.handleRuntimeError
        ) {
          __prefresh_errors__.handleRuntimeError(error);
        }

        __webpack_require__.c[module.i].hot.accept(errorRecovery);
      });
    }
  }
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../node_modules/next/dist/compiled/webpack/harmony-module.js */ "./node_modules/next/dist/compiled/webpack/harmony-module.js")(module), __webpack_require__(/*! ./node_modules/@prefresh/webpack/src/utils/prefresh.js */ "./node_modules/@prefresh/webpack/src/utils/prefresh.js")))

/***/ }),

/***/ "./components/About/PushNotifications.module.css":
/*!*******************************************************!*\
  !*** ./components/About/PushNotifications.module.css ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var api = __webpack_require__(/*! ../../node_modules/next/dist/build/webpack/loaders/next-style-loader/runtime/injectStylesIntoStyleTag.js */ "./node_modules/next/dist/build/webpack/loaders/next-style-loader/runtime/injectStylesIntoStyleTag.js");
            var content = __webpack_require__(/*! !../../node_modules/next/dist/compiled/css-loader/cjs.js??ref--5-oneOf-2-1!../../node_modules/next/dist/compiled/postcss-loader/cjs.js??ref--5-oneOf-2-2!./PushNotifications.module.css */ "./node_modules/next/dist/compiled/css-loader/cjs.js?!./node_modules/next/dist/compiled/postcss-loader/cjs.js?!./components/About/PushNotifications.module.css");

            content = content.__esModule ? content.default : content;

            if (typeof content === 'string') {
              content = [[module.i, content, '']];
            }

var options = {};

options.insert = function(element){// These elements should always exist. If they do not,
// this code should fail.
var anchorElement=document.querySelector('#__next_css__DO_NOT_USE__');var parentNode=anchorElement.parentNode;// Normally <head>
// Each style tag should be placed right before our
// anchor. By inserting before and not after, we do not
// need to track the last inserted element.
parentNode.insertBefore(element,anchorElement);};
options.singleton = false;

var update = api(content, options);


if (true) {
  if (!content.locals || module.hot.invalidate) {
    var isEqualLocals = function isEqualLocals(a,b,isNamedExport){if(!a&&b||a&&!b){return false;}let p;for(p in a){if(isNamedExport&&p==='default'){// eslint-disable-next-line no-continue
continue;}if(a[p]!==b[p]){return false;}}for(p in b){if(isNamedExport&&p==='default'){// eslint-disable-next-line no-continue
continue;}if(!a[p]){return false;}}return true;};
    var oldLocals = content.locals;

    module.hot.accept(
      /*! !../../node_modules/next/dist/compiled/css-loader/cjs.js??ref--5-oneOf-2-1!../../node_modules/next/dist/compiled/postcss-loader/cjs.js??ref--5-oneOf-2-2!./PushNotifications.module.css */ "./node_modules/next/dist/compiled/css-loader/cjs.js?!./node_modules/next/dist/compiled/postcss-loader/cjs.js?!./components/About/PushNotifications.module.css",
      function () {
        content = __webpack_require__(/*! !../../node_modules/next/dist/compiled/css-loader/cjs.js??ref--5-oneOf-2-1!../../node_modules/next/dist/compiled/postcss-loader/cjs.js??ref--5-oneOf-2-2!./PushNotifications.module.css */ "./node_modules/next/dist/compiled/css-loader/cjs.js?!./node_modules/next/dist/compiled/postcss-loader/cjs.js?!./components/About/PushNotifications.module.css");

              content = content.__esModule ? content.default : content;

              if (typeof content === 'string') {
                content = [[module.i, content, '']];
              }

              if (!isEqualLocals(oldLocals, content.locals)) {
                module.hot.invalidate();

                return;
              }

              oldLocals = content.locals;

              update(content);
      }
    )
  }

  module.hot.dispose(function() {
    update();
  });
}

module.exports = content.locals || {};

/***/ }),

/***/ "./components/About/PushNotifications.tsx":
/*!************************************************!*\
  !*** ./components/About/PushNotifications.tsx ***!
  \************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* WEBPACK VAR INJECTION */(function(module, __prefresh_utils__) {/* harmony import */ var C_Users_admin_Documents_Dev_PWAdvent_node_modules_babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./node_modules/@babel/runtime/regenerator */ "./node_modules/@babel/runtime/regenerator/index.js");
/* harmony import */ var C_Users_admin_Documents_Dev_PWAdvent_node_modules_babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(C_Users_admin_Documents_Dev_PWAdvent_node_modules_babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var C_Users_admin_Documents_Dev_PWAdvent_node_modules_babel_runtime_helpers_esm_asyncToGenerator__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./node_modules/@babel/runtime/helpers/esm/asyncToGenerator */ "./node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js");
/* harmony import */ var C_Users_admin_Documents_Dev_PWAdvent_node_modules_babel_runtime_helpers_esm_slicedToArray__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./node_modules/@babel/runtime/helpers/esm/slicedToArray */ "./node_modules/@babel/runtime/helpers/esm/slicedToArray.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! react */ "./node_modules/preact/compat/dist/compat.module.js");
/* harmony import */ var _theme__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @theme */ "./theme/index.ts");
/* harmony import */ var _utils_classnames__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @utils/classnames */ "./utils/classnames.tsx");
/* harmony import */ var _utils_constants__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @utils/constants */ "./utils/constants.ts");
/* harmony import */ var _utils_helpers__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @utils/helpers */ "./utils/helpers.tsx");
/* harmony import */ var _PushNotifications_module_css__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./PushNotifications.module.css */ "./components/About/PushNotifications.module.css");
/* harmony import */ var _PushNotifications_module_css__WEBPACK_IMPORTED_MODULE_8___default = /*#__PURE__*/__webpack_require__.n(_PushNotifications_module_css__WEBPACK_IMPORTED_MODULE_8__);




var _jsxFileName = "C:\\Users\\admin\\Documents\\Dev\\PWAdvent\\components\\About\\PushNotifications.tsx",
    _this = undefined,
    _s = $RefreshSig$();

var __jsx = react__WEBPACK_IMPORTED_MODULE_3__["default"].createElement;







var PushNotifications = function PushNotifications(_ref) {
  _s();

  var _ref$className = _ref.className,
      className = _ref$className === void 0 ? '' : _ref$className;

  var _React$useState = react__WEBPACK_IMPORTED_MODULE_3__["default"].useState(''),
      _React$useState2 = Object(C_Users_admin_Documents_Dev_PWAdvent_node_modules_babel_runtime_helpers_esm_slicedToArray__WEBPACK_IMPORTED_MODULE_2__["default"])(_React$useState, 2),
      error = _React$useState2[0],
      setError = _React$useState2[1];

  var _React$useState3 = react__WEBPACK_IMPORTED_MODULE_3__["default"].useState(false),
      _React$useState4 = Object(C_Users_admin_Documents_Dev_PWAdvent_node_modules_babel_runtime_helpers_esm_slicedToArray__WEBPACK_IMPORTED_MODULE_2__["default"])(_React$useState3, 2),
      isSubscribed = _React$useState4[0],
      setIsSubscribed = _React$useState4[1];

  var _React$useState5 = react__WEBPACK_IMPORTED_MODULE_3__["default"].useState(false),
      _React$useState6 = Object(C_Users_admin_Documents_Dev_PWAdvent_node_modules_babel_runtime_helpers_esm_slicedToArray__WEBPACK_IMPORTED_MODULE_2__["default"])(_React$useState5, 2),
      loading = _React$useState6[0],
      setLoading = _React$useState6[1];

  var supportsPush = 'PushManager' in window && 'serviceWorker' in navigator;
  react__WEBPACK_IMPORTED_MODULE_3__["default"].useEffect(function () {
    (function () {
      var _effect = Object(C_Users_admin_Documents_Dev_PWAdvent_node_modules_babel_runtime_helpers_esm_asyncToGenerator__WEBPACK_IMPORTED_MODULE_1__["default"])( /*#__PURE__*/C_Users_admin_Documents_Dev_PWAdvent_node_modules_babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_0___default.a.mark(function _callee() {
        var reg, subscription;
        return C_Users_admin_Documents_Dev_PWAdvent_node_modules_babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_0___default.a.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                if (!(window.Notification.permission === 'denied')) {
                  _context.next = 3;
                  break;
                }

                setError('It looks like you already explicitly denied permission for pwadvent.dev to display system notifications. Please change this option in the site settings and reload this page.');
                return _context.abrupt("return");

              case 3:
                _context.next = 5;
                return navigator.serviceWorker.getRegistration();

              case 5:
                reg = _context.sent;
                _context.next = 8;
                return reg.pushManager.getSubscription();

              case 8:
                subscription = _context.sent;

                if (!subscription) {
                  _context.next = 13;
                  break;
                }

                _context.next = 12;
                return sendSubscription(subscription.toJSON());

              case 12:
                setIsSubscribed(true);

              case 13:
              case "end":
                return _context.stop();
            }
          }
        }, _callee);
      }));

      function effect() {
        return _effect.apply(this, arguments);
      }

      return effect;
    })()();
  }, []);

  var getVapidKey = /*#__PURE__*/function () {
    var _ref2 = Object(C_Users_admin_Documents_Dev_PWAdvent_node_modules_babel_runtime_helpers_esm_asyncToGenerator__WEBPACK_IMPORTED_MODULE_1__["default"])( /*#__PURE__*/C_Users_admin_Documents_Dev_PWAdvent_node_modules_babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_0___default.a.mark(function _callee2() {
      var key, resp, respJson;
      return C_Users_admin_Documents_Dev_PWAdvent_node_modules_babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_0___default.a.wrap(function _callee2$(_context2) {
        while (1) {
          switch (_context2.prev = _context2.next) {
            case 0:
              key = '';
              _context2.next = 3;
              return fetch("".concat(_utils_constants__WEBPACK_IMPORTED_MODULE_6__["apiBase"], "wp-json/advent-calendar/v1/web-push/public-key"));

            case 3:
              resp = _context2.sent;

              if (!resp.ok) {
                _context2.next = 9;
                break;
              }

              _context2.next = 7;
              return resp.json();

            case 7:
              respJson = _context2.sent;
              key = respJson.publicKey;

            case 9:
              return _context2.abrupt("return", key);

            case 10:
            case "end":
              return _context2.stop();
          }
        }
      }, _callee2);
    }));

    return function getVapidKey() {
      return _ref2.apply(this, arguments);
    };
  }();

  var subscribe = /*#__PURE__*/function () {
    var _ref3 = Object(C_Users_admin_Documents_Dev_PWAdvent_node_modules_babel_runtime_helpers_esm_asyncToGenerator__WEBPACK_IMPORTED_MODULE_1__["default"])( /*#__PURE__*/C_Users_admin_Documents_Dev_PWAdvent_node_modules_babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_0___default.a.mark(function _callee3() {
      var reg, vapidKey, subscription;
      return C_Users_admin_Documents_Dev_PWAdvent_node_modules_babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_0___default.a.wrap(function _callee3$(_context3) {
        while (1) {
          switch (_context3.prev = _context3.next) {
            case 0:
              setLoading(true);
              _context3.next = 3;
              return navigator.serviceWorker.getRegistration();

            case 3:
              reg = _context3.sent;
              _context3.next = 6;
              return getVapidKey();

            case 6:
              vapidKey = _context3.sent;

              if (vapidKey === '') {
                alert('something went wrong. Could not connect to the push server');
              }

              _context3.next = 10;
              return reg.pushManager.subscribe({
                userVisibleOnly: true,
                applicationServerKey: new Uint8Array(Object(_utils_helpers__WEBPACK_IMPORTED_MODULE_7__["urlB64ToUint8Array"])(vapidKey))
              });

            case 10:
              subscription = _context3.sent;
              _context3.next = 13;
              return sendSubscription(subscription.toJSON());

            case 13:
              setLoading(false);
              setIsSubscribed(true);

            case 15:
            case "end":
              return _context3.stop();
          }
        }
      }, _callee3);
    }));

    return function subscribe() {
      return _ref3.apply(this, arguments);
    };
  }();

  var unsubscribe = /*#__PURE__*/function () {
    var _ref4 = Object(C_Users_admin_Documents_Dev_PWAdvent_node_modules_babel_runtime_helpers_esm_asyncToGenerator__WEBPACK_IMPORTED_MODULE_1__["default"])( /*#__PURE__*/C_Users_admin_Documents_Dev_PWAdvent_node_modules_babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_0___default.a.mark(function _callee4() {
      var reg, subscription;
      return C_Users_admin_Documents_Dev_PWAdvent_node_modules_babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_0___default.a.wrap(function _callee4$(_context4) {
        while (1) {
          switch (_context4.prev = _context4.next) {
            case 0:
              setLoading(true);
              _context4.next = 3;
              return navigator.serviceWorker.getRegistration();

            case 3:
              reg = _context4.sent;
              _context4.next = 6;
              return reg.pushManager.getSubscription();

            case 6:
              subscription = _context4.sent;
              _context4.next = 9;
              return sendDeleteSubscription(subscription.toJSON());

            case 9:
              _context4.next = 11;
              return subscription.unsubscribe();

            case 11:
              setLoading(false);
              setIsSubscribed(false);

            case 13:
            case "end":
              return _context4.stop();
          }
        }
      }, _callee4);
    }));

    return function unsubscribe() {
      return _ref4.apply(this, arguments);
    };
  }();

  var sendSubscription = /*#__PURE__*/function () {
    var _ref5 = Object(C_Users_admin_Documents_Dev_PWAdvent_node_modules_babel_runtime_helpers_esm_asyncToGenerator__WEBPACK_IMPORTED_MODULE_1__["default"])( /*#__PURE__*/C_Users_admin_Documents_Dev_PWAdvent_node_modules_babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_0___default.a.mark(function _callee5(subscription) {
      return C_Users_admin_Documents_Dev_PWAdvent_node_modules_babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_0___default.a.wrap(function _callee5$(_context5) {
        while (1) {
          switch (_context5.prev = _context5.next) {
            case 0:
              return _context5.abrupt("return", fetch("".concat(_utils_constants__WEBPACK_IMPORTED_MODULE_6__["apiBase"], "wp-json/advent-calendar/v1/web-push/subscription/"), {
                method: 'post',
                body: JSON.stringify({
                  subscription: subscription,
                  timezoneOffset: new Date().getTimezoneOffset()
                }),
                headers: {
                  'Content-Type': 'application/json'
                }
              }));

            case 1:
            case "end":
              return _context5.stop();
          }
        }
      }, _callee5);
    }));

    return function sendSubscription(_x) {
      return _ref5.apply(this, arguments);
    };
  }();

  var sendDeleteSubscription = /*#__PURE__*/function () {
    var _ref6 = Object(C_Users_admin_Documents_Dev_PWAdvent_node_modules_babel_runtime_helpers_esm_asyncToGenerator__WEBPACK_IMPORTED_MODULE_1__["default"])( /*#__PURE__*/C_Users_admin_Documents_Dev_PWAdvent_node_modules_babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_0___default.a.mark(function _callee6(subscription) {
      return C_Users_admin_Documents_Dev_PWAdvent_node_modules_babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_0___default.a.wrap(function _callee6$(_context6) {
        while (1) {
          switch (_context6.prev = _context6.next) {
            case 0:
              return _context6.abrupt("return", fetch("".concat(_utils_constants__WEBPACK_IMPORTED_MODULE_6__["apiBase"], "wp-json/advent-calendar/v1/web-push/subscription/"), {
                method: 'delete',
                body: JSON.stringify({
                  subscription: subscription
                }),
                headers: {
                  'Content-Type': 'application/json'
                }
              }));

            case 1:
            case "end":
              return _context6.stop();
          }
        }
      }, _callee6);
    }));

    return function sendDeleteSubscription(_x2) {
      return _ref6.apply(this, arguments);
    };
  }();

  return __jsx("div", {
    className: Object(_utils_classnames__WEBPACK_IMPORTED_MODULE_5__["default"])(className),
    __self: _this,
    __source: {
      fileName: _jsxFileName,
      lineNumber: 98,
      columnNumber: 5
    }
  }, __jsx("p", {
    className: _PushNotifications_module_css__WEBPACK_IMPORTED_MODULE_8___default.a.about,
    __self: _this,
    __source: {
      fileName: _jsxFileName,
      lineNumber: 99,
      columnNumber: 7
    }
  }, __jsx("b", {
    __self: _this,
    __source: {
      fileName: _jsxFileName,
      lineNumber: 100,
      columnNumber: 9
    }
  }, "Never miss a feature again!"), __jsx("br", {
    __self: _this,
    __source: {
      fileName: _jsxFileName,
      lineNumber: 101,
      columnNumber: 9
    }
  }), "Subscribe to push notifications and receive a daily notification when the new window opens."), __jsx("div", {
    className: _PushNotifications_module_css__WEBPACK_IMPORTED_MODULE_8___default.a.feedback,
    __self: _this,
    __source: {
      fileName: _jsxFileName,
      lineNumber: 105,
      columnNumber: 7
    }
  }, error !== '' ? __jsx(_theme__WEBPACK_IMPORTED_MODULE_4__["Notification"], {
    type: "error",
    __self: _this,
    __source: {
      fileName: _jsxFileName,
      lineNumber: 107,
      columnNumber: 11
    }
  }, __jsx("p", {
    __self: _this,
    __source: {
      fileName: _jsxFileName,
      lineNumber: 108,
      columnNumber: 13
    }
  }, error)) : !supportsPush ? __jsx(react__WEBPACK_IMPORTED_MODULE_3__["default"].Fragment, {
    __self: _this,
    __source: {
      fileName: _jsxFileName,
      lineNumber: 111,
      columnNumber: 11
    }
  }, __jsx(_theme__WEBPACK_IMPORTED_MODULE_4__["Notification"], {
    type: "error",
    __self: _this,
    __source: {
      fileName: _jsxFileName,
      lineNumber: 112,
      columnNumber: 13
    }
  }, __jsx("p", {
    __self: _this,
    __source: {
      fileName: _jsxFileName,
      lineNumber: 113,
      columnNumber: 15
    }
  }, "Your browser does not support web push notifications.")), _utils_helpers__WEBPACK_IMPORTED_MODULE_7__["isIos"] && __jsx("p", {
    __self: _this,
    __source: {
      fileName: _jsxFileName,
      lineNumber: 116,
      columnNumber: 15
    }
  }, __jsx("br", {
    __self: _this,
    __source: {
      fileName: _jsxFileName,
      lineNumber: 117,
      columnNumber: 17
    }
  }), "Unfortunately, ", __jsx("b", {
    __self: _this,
    __source: {
      fileName: _jsxFileName,
      lineNumber: 118,
      columnNumber: 32
    }
  }, "Apple"), " tries to hold back the further development of rich web applications by", ' ', __jsx("b", {
    __self: _this,
    __source: {
      fileName: _jsxFileName,
      lineNumber: 120,
      columnNumber: 17
    }
  }, "not implementing features like web push into iOS."), __jsx("br", {
    __self: _this,
    __source: {
      fileName: _jsxFileName,
      lineNumber: 121,
      columnNumber: 17
    }
  }), "It is now up to us to build pressure by", ' ', __jsx("a", {
    href: "https://bugs.webkit.org/show_bug.cgi?id=182566",
    target: "_blank",
    __self: _this,
    __source: {
      fileName: _jsxFileName,
      lineNumber: 123,
      columnNumber: 17
    }
  }, "describing our usecase"), ' ', "and/or", ' ', __jsx("a", {
    href: "https://www.change.org/p/tim-cook-apple-inc-implement-web-push-notifications-on-ios-devices?utm_content=cl_sharecopy_18178670_fr-FR%3Av1&recruiter=1092330168&recruited_by_id=76293570-9ba6-11ea-bd01-e5d39501339a&utm_source=share_petition&utm_medium=copylink&utm_campaign=psf_combo_share_initial&utm_term=share_petition",
    target: "_blank",
    __self: _this,
    __source: {
      fileName: _jsxFileName,
      lineNumber: 130,
      columnNumber: 17
    }
  }, "making ourselves heard"), ".")) : !isSubscribed ? __jsx(react__WEBPACK_IMPORTED_MODULE_3__["default"].Fragment, {
    __self: _this,
    __source: {
      fileName: _jsxFileName,
      lineNumber: 141,
      columnNumber: 11
    }
  }, __jsx(_theme__WEBPACK_IMPORTED_MODULE_4__["Button"], {
    icon: "mdi/bell",
    onClick: function onClick() {
      return subscribe();
    },
    color: "red",
    loading: loading,
    __self: _this,
    __source: {
      fileName: _jsxFileName,
      lineNumber: 142,
      columnNumber: 13
    }
  }, "Subscribe"), __jsx("br", {
    __self: _this,
    __source: {
      fileName: _jsxFileName,
      lineNumber: 150,
      columnNumber: 13
    }
  }), __jsx("p", {
    className: "fs--xsmall",
    __self: _this,
    __source: {
      fileName: _jsxFileName,
      lineNumber: 151,
      columnNumber: 13
    }
  }, "From the first to the 24th of december 2020 we will send you a link to the latest article every morning. You are able to unsubscribe at any time here")) : __jsx(react__WEBPACK_IMPORTED_MODULE_3__["default"].Fragment, {
    __self: _this,
    __source: {
      fileName: _jsxFileName,
      lineNumber: 158,
      columnNumber: 11
    }
  }, __jsx("p", {
    className: _PushNotifications_module_css__WEBPACK_IMPORTED_MODULE_8___default.a.checked,
    __self: _this,
    __source: {
      fileName: _jsxFileName,
      lineNumber: 159,
      columnNumber: 13
    }
  }, __jsx(_theme__WEBPACK_IMPORTED_MODULE_4__["SVG"], {
    path: "icon/mdi/check.svg",
    inline: true,
    __self: _this,
    __source: {
      fileName: _jsxFileName,
      lineNumber: 160,
      columnNumber: 15
    }
  }), ' ', __jsx("b", {
    __self: _this,
    __source: {
      fileName: _jsxFileName,
      lineNumber: 161,
      columnNumber: 15
    }
  }, "Push notifications are activated")), __jsx(_theme__WEBPACK_IMPORTED_MODULE_4__["Button"], {
    layout: "ghost",
    size: "small",
    icon: "mdi/bell-outline",
    round: true,
    onClick: function onClick() {
      return unsubscribe();
    },
    loading: loading,
    fontWeight: "normal",
    __self: _this,
    __source: {
      fileName: _jsxFileName,
      lineNumber: 163,
      columnNumber: 13
    }
  }, "Unsubscribe"))));
};

_s(PushNotifications, "dafxC5Npf/Yyj3ESC0udQKrULq8=");

_c = PushNotifications;
/* harmony default export */ __webpack_exports__["default"] = (PushNotifications);

var _c;

$RefreshReg$(_c, "PushNotifications");

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.i);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }


const isPrefreshComponent = __prefresh_utils__.shouldBind(module);

  if (true) {
    const currentExports = __prefresh_utils__.getExports(module);
    const previousHotModuleExports =
      module.hot.data && module.hot.data.moduleExports;

    __prefresh_utils__.registerExports(currentExports, module.i);

    if (isPrefreshComponent) {
      if (previousHotModuleExports) {
        try {
          __prefresh_utils__.flush();
          if (
            typeof __prefresh_errors__ !== 'undefined' &&
            __prefresh_errors__ &&
            __prefresh_errors__.clearRuntimeErrors
          ) {
            __prefresh_errors__.clearRuntimeErrors();
          }
        } catch (e) {
          // Only available in newer webpack versions.
          if (module.hot.invalidate) {
            module.hot.invalidate();
          } else {
            self.location.reload();
          }
        }
      }

      module.hot.dispose(data => {
        data.moduleExports = __prefresh_utils__.getExports(module);
      });

      module.hot.accept(function errorRecovery() {
        if (
          typeof __prefresh_errors__ !== 'undefined' &&
          __prefresh_errors__ &&
          __prefresh_errors__.handleRuntimeError
        ) {
          __prefresh_errors__.handleRuntimeError(error);
        }

        __webpack_require__.c[module.i].hot.accept(errorRecovery);
      });
    }
  }
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../node_modules/next/dist/compiled/webpack/harmony-module.js */ "./node_modules/next/dist/compiled/webpack/harmony-module.js")(module), __webpack_require__(/*! ./node_modules/@prefresh/webpack/src/utils/prefresh.js */ "./node_modules/@prefresh/webpack/src/utils/prefresh.js")))

/***/ }),

/***/ "./components/Calendar/Calendar.module.css":
/*!*************************************************!*\
  !*** ./components/Calendar/Calendar.module.css ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var api = __webpack_require__(/*! ../../node_modules/next/dist/build/webpack/loaders/next-style-loader/runtime/injectStylesIntoStyleTag.js */ "./node_modules/next/dist/build/webpack/loaders/next-style-loader/runtime/injectStylesIntoStyleTag.js");
            var content = __webpack_require__(/*! !../../node_modules/next/dist/compiled/css-loader/cjs.js??ref--5-oneOf-2-1!../../node_modules/next/dist/compiled/postcss-loader/cjs.js??ref--5-oneOf-2-2!./Calendar.module.css */ "./node_modules/next/dist/compiled/css-loader/cjs.js?!./node_modules/next/dist/compiled/postcss-loader/cjs.js?!./components/Calendar/Calendar.module.css");

            content = content.__esModule ? content.default : content;

            if (typeof content === 'string') {
              content = [[module.i, content, '']];
            }

var options = {};

options.insert = function(element){// These elements should always exist. If they do not,
// this code should fail.
var anchorElement=document.querySelector('#__next_css__DO_NOT_USE__');var parentNode=anchorElement.parentNode;// Normally <head>
// Each style tag should be placed right before our
// anchor. By inserting before and not after, we do not
// need to track the last inserted element.
parentNode.insertBefore(element,anchorElement);};
options.singleton = false;

var update = api(content, options);


if (true) {
  if (!content.locals || module.hot.invalidate) {
    var isEqualLocals = function isEqualLocals(a,b,isNamedExport){if(!a&&b||a&&!b){return false;}let p;for(p in a){if(isNamedExport&&p==='default'){// eslint-disable-next-line no-continue
continue;}if(a[p]!==b[p]){return false;}}for(p in b){if(isNamedExport&&p==='default'){// eslint-disable-next-line no-continue
continue;}if(!a[p]){return false;}}return true;};
    var oldLocals = content.locals;

    module.hot.accept(
      /*! !../../node_modules/next/dist/compiled/css-loader/cjs.js??ref--5-oneOf-2-1!../../node_modules/next/dist/compiled/postcss-loader/cjs.js??ref--5-oneOf-2-2!./Calendar.module.css */ "./node_modules/next/dist/compiled/css-loader/cjs.js?!./node_modules/next/dist/compiled/postcss-loader/cjs.js?!./components/Calendar/Calendar.module.css",
      function () {
        content = __webpack_require__(/*! !../../node_modules/next/dist/compiled/css-loader/cjs.js??ref--5-oneOf-2-1!../../node_modules/next/dist/compiled/postcss-loader/cjs.js??ref--5-oneOf-2-2!./Calendar.module.css */ "./node_modules/next/dist/compiled/css-loader/cjs.js?!./node_modules/next/dist/compiled/postcss-loader/cjs.js?!./components/Calendar/Calendar.module.css");

              content = content.__esModule ? content.default : content;

              if (typeof content === 'string') {
                content = [[module.i, content, '']];
              }

              if (!isEqualLocals(oldLocals, content.locals)) {
                module.hot.invalidate();

                return;
              }

              oldLocals = content.locals;

              update(content);
      }
    )
  }

  module.hot.dispose(function() {
    update();
  });
}

module.exports = content.locals || {};

/***/ }),

/***/ "./components/Calendar/Calendar.tsx":
/*!******************************************!*\
  !*** ./components/Calendar/Calendar.tsx ***!
  \******************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* WEBPACK VAR INJECTION */(function(module, __prefresh_utils__) {/* harmony import */ var C_Users_admin_Documents_Dev_PWAdvent_node_modules_babel_runtime_helpers_esm_slicedToArray__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./node_modules/@babel/runtime/helpers/esm/slicedToArray */ "./node_modules/@babel/runtime/helpers/esm/slicedToArray.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ "./node_modules/preact/compat/dist/compat.module.js");
/* harmony import */ var unistore_hooks__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! unistore-hooks */ "./node_modules/unistore-hooks/dist/unistore-hooks.module.js");
/* harmony import */ var _comps_Calendar_CalendarDay__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @comps/Calendar/CalendarDay */ "./components/Calendar/CalendarDay.tsx");
/* harmony import */ var _comps_Calendar_CalendarDayList__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @comps/Calendar/CalendarDayList */ "./components/Calendar/CalendarDayList.tsx");
/* harmony import */ var _comps_Calendar_CalendarHeader__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @comps/Calendar/CalendarHeader */ "./components/Calendar/CalendarHeader.tsx");
/* harmony import */ var _comps_hooks_useWindowSize__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @comps/hooks/useWindowSize */ "./components/hooks/useWindowSize.tsx");
/* harmony import */ var _store_idb__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @store/idb */ "./store/idb.ts");
/* harmony import */ var _store_index__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! @store/index */ "./store/index.ts");
/* harmony import */ var _utils_calendar__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! @utils/calendar */ "./utils/calendar.ts");
/* harmony import */ var _utils_classnames__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! @utils/classnames */ "./utils/classnames.tsx");
/* harmony import */ var _utils_constants__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! @utils/constants */ "./utils/constants.ts");
/* harmony import */ var _Calendar_module_css__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./Calendar.module.css */ "./components/Calendar/Calendar.module.css");
/* harmony import */ var _Calendar_module_css__WEBPACK_IMPORTED_MODULE_12___default = /*#__PURE__*/__webpack_require__.n(_Calendar_module_css__WEBPACK_IMPORTED_MODULE_12__);


var _jsxFileName = "C:\\Users\\admin\\Documents\\Dev\\PWAdvent\\components\\Calendar\\Calendar.tsx",
    _this = undefined,
    _s = $RefreshSig$();

var __jsx = react__WEBPACK_IMPORTED_MODULE_1__["default"].createElement;













var Calendar = function Calendar(_ref) {
  _s();

  var _ref$className = _ref.className,
      className = _ref$className === void 0 ? '' : _ref$className;

  var _React$useState = react__WEBPACK_IMPORTED_MODULE_1__["default"].useState(null),
      _React$useState2 = Object(C_Users_admin_Documents_Dev_PWAdvent_node_modules_babel_runtime_helpers_esm_slicedToArray__WEBPACK_IMPORTED_MODULE_0__["default"])(_React$useState, 2),
      view = _React$useState2[0],
      setView = _React$useState2[1];

  var window = Object(_comps_hooks_useWindowSize__WEBPACK_IMPORTED_MODULE_6__["default"])();
  var calendarRef = react__WEBPACK_IMPORTED_MODULE_1__["default"].useRef(null);

  var _React$useState3 = react__WEBPACK_IMPORTED_MODULE_1__["default"].useState(null),
      _React$useState4 = Object(C_Users_admin_Documents_Dev_PWAdvent_node_modules_babel_runtime_helpers_esm_slicedToArray__WEBPACK_IMPORTED_MODULE_0__["default"])(_React$useState3, 2),
      height = _React$useState4[0],
      setHeight = _React$useState4[1];

  var _React$useState5 = react__WEBPACK_IMPORTED_MODULE_1__["default"].useState(0),
      _React$useState6 = Object(C_Users_admin_Documents_Dev_PWAdvent_node_modules_babel_runtime_helpers_esm_slicedToArray__WEBPACK_IMPORTED_MODULE_0__["default"])(_React$useState5, 2),
      opacity = _React$useState6[0],
      setOpacity = _React$useState6[1];

  var _useActions = Object(unistore_hooks__WEBPACK_IMPORTED_MODULE_2__["useActions"])(_store_index__WEBPACK_IMPORTED_MODULE_8__["actions"]),
      setMenuOpen = _useActions.setMenuOpen;

  var _useStoreState = Object(unistore_hooks__WEBPACK_IMPORTED_MODULE_2__["useStoreState"])(['menuOpen']),
      menuOpen = _useStoreState.menuOpen;

  var isCalendar = react__WEBPACK_IMPORTED_MODULE_1__["default"].useMemo(function () {
    return view === _utils_constants__WEBPACK_IMPORTED_MODULE_11__["VIEW_TYPES"].CALENDAR;
  }, [view]);
  react__WEBPACK_IMPORTED_MODULE_1__["default"].useEffect(function () {
    if (!_utils_calendar__WEBPACK_IMPORTED_MODULE_9__["DATE_TODAY"].isAfter(_utils_calendar__WEBPACK_IMPORTED_MODULE_9__["DATE_END"])) {
      setView(_utils_constants__WEBPACK_IMPORTED_MODULE_11__["VIEW_TYPES"].CALENDAR);
      return;
    }

    if (!view) {
      _store_idb__WEBPACK_IMPORTED_MODULE_7__["settingsDB"].get('view').then(function (v) {
        return setView(v || _utils_constants__WEBPACK_IMPORTED_MODULE_11__["VIEW_TYPES"].CALENDAR);
      });
    }

    _store_idb__WEBPACK_IMPORTED_MODULE_7__["settingsDB"].set('view', view);
  }, [view]);
  react__WEBPACK_IMPORTED_MODULE_1__["default"].useEffect(function () {
    setTimeout(function () {
      if (calendarRef.current && window.width) {
        if (!isCalendar) {
          setHeight(window.height - 220);
          return;
        }

        var isPortrait = window.height / window.width >= 1;
        var maxHeight = window.height - 200;

        var _height = Math.round(calendarRef.current.clientWidth * (isPortrait ? 1.3 : 0.9));

        if (_height >= maxHeight) {
          _height = maxHeight;
        }

        setHeight(_height);
      }
    }, 1);
  }, [window, calendarRef, view]);
  react__WEBPACK_IMPORTED_MODULE_1__["default"].useEffect(function () {
    height && setOpacity(1);
  }, [height]);
  return __jsx("div", {
    className: Object(_utils_classnames__WEBPACK_IMPORTED_MODULE_10__["default"])(_Calendar_module_css__WEBPACK_IMPORTED_MODULE_12___default.a.root, className),
    __self: _this,
    __source: {
      fileName: _jsxFileName,
      lineNumber: 66,
      columnNumber: 5
    }
  }, menuOpen && __jsx("button", {
    className: _Calendar_module_css__WEBPACK_IMPORTED_MODULE_12___default.a.buttonOverlay,
    onClick: function onClick() {
      return setMenuOpen(false);
    },
    __self: _this,
    __source: {
      fileName: _jsxFileName,
      lineNumber: 68,
      columnNumber: 9
    }
  }, "close"), __jsx(_comps_Calendar_CalendarHeader__WEBPACK_IMPORTED_MODULE_5__["default"], {
    className: _Calendar_module_css__WEBPACK_IMPORTED_MODULE_12___default.a.header,
    setView: setView,
    view: view,
    __self: _this,
    __source: {
      fileName: _jsxFileName,
      lineNumber: 75,
      columnNumber: 7
    }
  }), __jsx("div", {
    className: isCalendar ? _Calendar_module_css__WEBPACK_IMPORTED_MODULE_12___default.a.calendar : _Calendar_module_css__WEBPACK_IMPORTED_MODULE_12___default.a.list,
    style: {
      //height: isCalendar ? height : 'auto',
      height: height,
      opacity: opacity
    },
    ref: calendarRef,
    __self: _this,
    __source: {
      fileName: _jsxFileName,
      lineNumber: 76,
      columnNumber: 7
    }
  }, (isCalendar ? _utils_constants__WEBPACK_IMPORTED_MODULE_11__["daysOrder"] : _utils_constants__WEBPACK_IMPORTED_MODULE_11__["daysOrderCorrect"]).map(function (day) {
    return __jsx("div", {
      className: Object(_utils_classnames__WEBPACK_IMPORTED_MODULE_10__["default"])(_Calendar_module_css__WEBPACK_IMPORTED_MODULE_12___default.a.item, _Calendar_module_css__WEBPACK_IMPORTED_MODULE_12___default.a["item--".concat(day)], _Calendar_module_css__WEBPACK_IMPORTED_MODULE_12___default.a["item--".concat(view)]),
      __self: _this,
      __source: {
        fileName: _jsxFileName,
        lineNumber: 86,
        columnNumber: 11
      }
    }, isCalendar ? __jsx(_comps_Calendar_CalendarDay__WEBPACK_IMPORTED_MODULE_3__["default"], {
      day: parseInt(day),
      __self: _this,
      __source: {
        fileName: _jsxFileName,
        lineNumber: 94,
        columnNumber: 15
      }
    }) : __jsx(_comps_Calendar_CalendarDayList__WEBPACK_IMPORTED_MODULE_4__["default"], {
      day: parseInt(day),
      __self: _this,
      __source: {
        fileName: _jsxFileName,
        lineNumber: 96,
        columnNumber: 15
      }
    }));
  })));
};

_s(Calendar, "tXOTYZemcLBz3oIdGRv63UfmLIE=", false, function () {
  return [_comps_hooks_useWindowSize__WEBPACK_IMPORTED_MODULE_6__["default"], unistore_hooks__WEBPACK_IMPORTED_MODULE_2__["useActions"], unistore_hooks__WEBPACK_IMPORTED_MODULE_2__["useStoreState"]];
});

_c = Calendar;
/* harmony default export */ __webpack_exports__["default"] = (Calendar);

var _c;

$RefreshReg$(_c, "Calendar");

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.i);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }


const isPrefreshComponent = __prefresh_utils__.shouldBind(module);

  if (true) {
    const currentExports = __prefresh_utils__.getExports(module);
    const previousHotModuleExports =
      module.hot.data && module.hot.data.moduleExports;

    __prefresh_utils__.registerExports(currentExports, module.i);

    if (isPrefreshComponent) {
      if (previousHotModuleExports) {
        try {
          __prefresh_utils__.flush();
          if (
            typeof __prefresh_errors__ !== 'undefined' &&
            __prefresh_errors__ &&
            __prefresh_errors__.clearRuntimeErrors
          ) {
            __prefresh_errors__.clearRuntimeErrors();
          }
        } catch (e) {
          // Only available in newer webpack versions.
          if (module.hot.invalidate) {
            module.hot.invalidate();
          } else {
            self.location.reload();
          }
        }
      }

      module.hot.dispose(data => {
        data.moduleExports = __prefresh_utils__.getExports(module);
      });

      module.hot.accept(function errorRecovery() {
        if (
          typeof __prefresh_errors__ !== 'undefined' &&
          __prefresh_errors__ &&
          __prefresh_errors__.handleRuntimeError
        ) {
          __prefresh_errors__.handleRuntimeError(error);
        }

        __webpack_require__.c[module.i].hot.accept(errorRecovery);
      });
    }
  }
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../node_modules/next/dist/compiled/webpack/harmony-module.js */ "./node_modules/next/dist/compiled/webpack/harmony-module.js")(module), __webpack_require__(/*! ./node_modules/@prefresh/webpack/src/utils/prefresh.js */ "./node_modules/@prefresh/webpack/src/utils/prefresh.js")))

/***/ }),

/***/ "./components/Calendar/CalendarDay.module.css":
/*!****************************************************!*\
  !*** ./components/Calendar/CalendarDay.module.css ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var api = __webpack_require__(/*! ../../node_modules/next/dist/build/webpack/loaders/next-style-loader/runtime/injectStylesIntoStyleTag.js */ "./node_modules/next/dist/build/webpack/loaders/next-style-loader/runtime/injectStylesIntoStyleTag.js");
            var content = __webpack_require__(/*! !../../node_modules/next/dist/compiled/css-loader/cjs.js??ref--5-oneOf-2-1!../../node_modules/next/dist/compiled/postcss-loader/cjs.js??ref--5-oneOf-2-2!./CalendarDay.module.css */ "./node_modules/next/dist/compiled/css-loader/cjs.js?!./node_modules/next/dist/compiled/postcss-loader/cjs.js?!./components/Calendar/CalendarDay.module.css");

            content = content.__esModule ? content.default : content;

            if (typeof content === 'string') {
              content = [[module.i, content, '']];
            }

var options = {};

options.insert = function(element){// These elements should always exist. If they do not,
// this code should fail.
var anchorElement=document.querySelector('#__next_css__DO_NOT_USE__');var parentNode=anchorElement.parentNode;// Normally <head>
// Each style tag should be placed right before our
// anchor. By inserting before and not after, we do not
// need to track the last inserted element.
parentNode.insertBefore(element,anchorElement);};
options.singleton = false;

var update = api(content, options);


if (true) {
  if (!content.locals || module.hot.invalidate) {
    var isEqualLocals = function isEqualLocals(a,b,isNamedExport){if(!a&&b||a&&!b){return false;}let p;for(p in a){if(isNamedExport&&p==='default'){// eslint-disable-next-line no-continue
continue;}if(a[p]!==b[p]){return false;}}for(p in b){if(isNamedExport&&p==='default'){// eslint-disable-next-line no-continue
continue;}if(!a[p]){return false;}}return true;};
    var oldLocals = content.locals;

    module.hot.accept(
      /*! !../../node_modules/next/dist/compiled/css-loader/cjs.js??ref--5-oneOf-2-1!../../node_modules/next/dist/compiled/postcss-loader/cjs.js??ref--5-oneOf-2-2!./CalendarDay.module.css */ "./node_modules/next/dist/compiled/css-loader/cjs.js?!./node_modules/next/dist/compiled/postcss-loader/cjs.js?!./components/Calendar/CalendarDay.module.css",
      function () {
        content = __webpack_require__(/*! !../../node_modules/next/dist/compiled/css-loader/cjs.js??ref--5-oneOf-2-1!../../node_modules/next/dist/compiled/postcss-loader/cjs.js??ref--5-oneOf-2-2!./CalendarDay.module.css */ "./node_modules/next/dist/compiled/css-loader/cjs.js?!./node_modules/next/dist/compiled/postcss-loader/cjs.js?!./components/Calendar/CalendarDay.module.css");

              content = content.__esModule ? content.default : content;

              if (typeof content === 'string') {
                content = [[module.i, content, '']];
              }

              if (!isEqualLocals(oldLocals, content.locals)) {
                module.hot.invalidate();

                return;
              }

              oldLocals = content.locals;

              update(content);
      }
    )
  }

  module.hot.dispose(function() {
    update();
  });
}

module.exports = content.locals || {};

/***/ }),

/***/ "./components/Calendar/CalendarDay.tsx":
/*!*********************************************!*\
  !*** ./components/Calendar/CalendarDay.tsx ***!
  \*********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* WEBPACK VAR INJECTION */(function(module, __prefresh_utils__) {/* harmony import */ var C_Users_admin_Documents_Dev_PWAdvent_node_modules_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./node_modules/@babel/runtime/helpers/esm/defineProperty */ "./node_modules/@babel/runtime/helpers/esm/defineProperty.js");
/* harmony import */ var C_Users_admin_Documents_Dev_PWAdvent_node_modules_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./node_modules/@babel/runtime/helpers/esm/extends */ "./node_modules/@babel/runtime/helpers/esm/extends.js");
/* harmony import */ var C_Users_admin_Documents_Dev_PWAdvent_node_modules_babel_runtime_helpers_esm_objectWithoutProperties__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./node_modules/@babel/runtime/helpers/esm/objectWithoutProperties */ "./node_modules/@babel/runtime/helpers/esm/objectWithoutProperties.js");
/* harmony import */ var next_link__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! next/link */ "./node_modules/next/link.js");
/* harmony import */ var next_link__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(next_link__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! react */ "./node_modules/preact/compat/dist/compat.module.js");
/* harmony import */ var unistore_hooks__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! unistore-hooks */ "./node_modules/unistore-hooks/dist/unistore-hooks.module.js");
/* harmony import */ var _theme__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @theme */ "./theme/index.ts");
/* harmony import */ var _utils_calendar__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @utils/calendar */ "./utils/calendar.ts");
/* harmony import */ var _utils_classnames__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! @utils/classnames */ "./utils/classnames.tsx");
/* harmony import */ var _utils_dayjs__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! @utils/dayjs */ "./utils/dayjs.ts");
/* harmony import */ var _utils_helpers__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! @utils/helpers */ "./utils/helpers.tsx");
/* harmony import */ var _CalendarDay_module_css__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./CalendarDay.module.css */ "./components/Calendar/CalendarDay.module.css");
/* harmony import */ var _CalendarDay_module_css__WEBPACK_IMPORTED_MODULE_11___default = /*#__PURE__*/__webpack_require__.n(_CalendarDay_module_css__WEBPACK_IMPORTED_MODULE_11__);




var _jsxFileName = "C:\\Users\\admin\\Documents\\Dev\\PWAdvent\\components\\Calendar\\CalendarDay.tsx",
    _this = undefined,
    _s = $RefreshSig$();

var __jsx = react__WEBPACK_IMPORTED_MODULE_4__["default"].createElement;










var CalendarDay = function CalendarDay(_ref) {
  _s();

  var day = _ref.day,
      _ref$className = _ref.className,
      className = _ref$className === void 0 ? '' : _ref$className;

  var _useStoreState = Object(unistore_hooks__WEBPACK_IMPORTED_MODULE_5__["useStoreState"])(['days']),
      storeDays = _useStoreState.days;

  var dayObject = react__WEBPACK_IMPORTED_MODULE_4__["default"].useMemo(function () {
    return storeDays[day];
  }, [storeDays[day], day]);
  var isActive = react__WEBPACK_IMPORTED_MODULE_4__["default"].useMemo(function () {
    return !Object(_utils_dayjs__WEBPACK_IMPORTED_MODULE_9__["default"])(dayObject.data.date).isAfter(_utils_calendar__WEBPACK_IMPORTED_MODULE_7__["DATE_TODAY"]);
  }, [dayObject]);

  var Wrapper = function Wrapper(_ref2) {
    var children = _ref2.children,
        props = Object(C_Users_admin_Documents_Dev_PWAdvent_node_modules_babel_runtime_helpers_esm_objectWithoutProperties__WEBPACK_IMPORTED_MODULE_2__["default"])(_ref2, ["children"]);

    return isActive ? __jsx(next_link__WEBPACK_IMPORTED_MODULE_3___default.a, {
      href: "/day/".concat(day, "/"),
      __self: _this,
      __source: {
        fileName: _jsxFileName,
        lineNumber: 35,
        columnNumber: 7
      }
    }, __jsx("a", Object(C_Users_admin_Documents_Dev_PWAdvent_node_modules_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_1__["default"])({}, props, {
      __self: _this,
      __source: {
        fileName: _jsxFileName,
        lineNumber: 36,
        columnNumber: 9
      }
    }), children)) : __jsx("div", Object(C_Users_admin_Documents_Dev_PWAdvent_node_modules_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_1__["default"])({}, props, {
      __self: _this,
      __source: {
        fileName: _jsxFileName,
        lineNumber: 39,
        columnNumber: 7
      }
    }), children);
  };

  return __jsx(Wrapper, {
    className: Object(_utils_classnames__WEBPACK_IMPORTED_MODULE_8__["default"])(className, _CalendarDay_module_css__WEBPACK_IMPORTED_MODULE_11___default.a.day, Object(C_Users_admin_Documents_Dev_PWAdvent_node_modules_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])({}, _CalendarDay_module_css__WEBPACK_IMPORTED_MODULE_11___default.a.dayActive, isActive)),
    __self: _this,
    __source: {
      fileName: _jsxFileName,
      lineNumber: 43,
      columnNumber: 5
    }
  }, __jsx("div", {
    className: _CalendarDay_module_css__WEBPACK_IMPORTED_MODULE_11___default.a.inner,
    __self: _this,
    __source: {
      fileName: _jsxFileName,
      lineNumber: 48,
      columnNumber: 7
    }
  }, day));
};

_s(CalendarDay, "keeMZGHzecvbcjiQiRUAnUBa3sY=", false, function () {
  return [unistore_hooks__WEBPACK_IMPORTED_MODULE_5__["useStoreState"]];
});

_c = CalendarDay;

var CalendarDayWrapper = function CalendarDayWrapper(_ref3) {
  var day = _ref3.day,
      _ref3$className = _ref3.className,
      className = _ref3$className === void 0 ? '' : _ref3$className;
  return __jsx("div", {
    className: Object(_utils_classnames__WEBPACK_IMPORTED_MODULE_8__["default"])(className, _CalendarDay_module_css__WEBPACK_IMPORTED_MODULE_11___default.a.wrapper),
    __self: _this,
    __source: {
      fileName: _jsxFileName,
      lineNumber: 60,
      columnNumber: 3
    }
  }, __jsx(_theme__WEBPACK_IMPORTED_MODULE_6__["SVG"], {
    className: Object(_utils_classnames__WEBPACK_IMPORTED_MODULE_8__["default"])(_CalendarDay_module_css__WEBPACK_IMPORTED_MODULE_11___default.a.snow, _CalendarDay_module_css__WEBPACK_IMPORTED_MODULE_11___default.a["snow--".concat(day)]),
    path: "snowwall-".concat(Object(_utils_helpers__WEBPACK_IMPORTED_MODULE_10__["zeroPad"])(day, 2), ".svg"),
    __self: _this,
    __source: {
      fileName: _jsxFileName,
      lineNumber: 61,
      columnNumber: 5
    }
  }), __jsx(CalendarDay, {
    day: day,
    className: Object(_utils_classnames__WEBPACK_IMPORTED_MODULE_8__["default"])(_CalendarDay_module_css__WEBPACK_IMPORTED_MODULE_11___default.a.inner),
    __self: _this,
    __source: {
      fileName: _jsxFileName,
      lineNumber: 65,
      columnNumber: 5
    }
  }));
};

_c2 = CalendarDayWrapper;
/* harmony default export */ __webpack_exports__["default"] = (CalendarDayWrapper);

var _c, _c2;

$RefreshReg$(_c, "CalendarDay");
$RefreshReg$(_c2, "CalendarDayWrapper");

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.i);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }


const isPrefreshComponent = __prefresh_utils__.shouldBind(module);

  if (true) {
    const currentExports = __prefresh_utils__.getExports(module);
    const previousHotModuleExports =
      module.hot.data && module.hot.data.moduleExports;

    __prefresh_utils__.registerExports(currentExports, module.i);

    if (isPrefreshComponent) {
      if (previousHotModuleExports) {
        try {
          __prefresh_utils__.flush();
          if (
            typeof __prefresh_errors__ !== 'undefined' &&
            __prefresh_errors__ &&
            __prefresh_errors__.clearRuntimeErrors
          ) {
            __prefresh_errors__.clearRuntimeErrors();
          }
        } catch (e) {
          // Only available in newer webpack versions.
          if (module.hot.invalidate) {
            module.hot.invalidate();
          } else {
            self.location.reload();
          }
        }
      }

      module.hot.dispose(data => {
        data.moduleExports = __prefresh_utils__.getExports(module);
      });

      module.hot.accept(function errorRecovery() {
        if (
          typeof __prefresh_errors__ !== 'undefined' &&
          __prefresh_errors__ &&
          __prefresh_errors__.handleRuntimeError
        ) {
          __prefresh_errors__.handleRuntimeError(error);
        }

        __webpack_require__.c[module.i].hot.accept(errorRecovery);
      });
    }
  }
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../node_modules/next/dist/compiled/webpack/harmony-module.js */ "./node_modules/next/dist/compiled/webpack/harmony-module.js")(module), __webpack_require__(/*! ./node_modules/@prefresh/webpack/src/utils/prefresh.js */ "./node_modules/@prefresh/webpack/src/utils/prefresh.js")))

/***/ }),

/***/ "./components/Calendar/CalendarDayList.module.css":
/*!********************************************************!*\
  !*** ./components/Calendar/CalendarDayList.module.css ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var api = __webpack_require__(/*! ../../node_modules/next/dist/build/webpack/loaders/next-style-loader/runtime/injectStylesIntoStyleTag.js */ "./node_modules/next/dist/build/webpack/loaders/next-style-loader/runtime/injectStylesIntoStyleTag.js");
            var content = __webpack_require__(/*! !../../node_modules/next/dist/compiled/css-loader/cjs.js??ref--5-oneOf-2-1!../../node_modules/next/dist/compiled/postcss-loader/cjs.js??ref--5-oneOf-2-2!./CalendarDayList.module.css */ "./node_modules/next/dist/compiled/css-loader/cjs.js?!./node_modules/next/dist/compiled/postcss-loader/cjs.js?!./components/Calendar/CalendarDayList.module.css");

            content = content.__esModule ? content.default : content;

            if (typeof content === 'string') {
              content = [[module.i, content, '']];
            }

var options = {};

options.insert = function(element){// These elements should always exist. If they do not,
// this code should fail.
var anchorElement=document.querySelector('#__next_css__DO_NOT_USE__');var parentNode=anchorElement.parentNode;// Normally <head>
// Each style tag should be placed right before our
// anchor. By inserting before and not after, we do not
// need to track the last inserted element.
parentNode.insertBefore(element,anchorElement);};
options.singleton = false;

var update = api(content, options);


if (true) {
  if (!content.locals || module.hot.invalidate) {
    var isEqualLocals = function isEqualLocals(a,b,isNamedExport){if(!a&&b||a&&!b){return false;}let p;for(p in a){if(isNamedExport&&p==='default'){// eslint-disable-next-line no-continue
continue;}if(a[p]!==b[p]){return false;}}for(p in b){if(isNamedExport&&p==='default'){// eslint-disable-next-line no-continue
continue;}if(!a[p]){return false;}}return true;};
    var oldLocals = content.locals;

    module.hot.accept(
      /*! !../../node_modules/next/dist/compiled/css-loader/cjs.js??ref--5-oneOf-2-1!../../node_modules/next/dist/compiled/postcss-loader/cjs.js??ref--5-oneOf-2-2!./CalendarDayList.module.css */ "./node_modules/next/dist/compiled/css-loader/cjs.js?!./node_modules/next/dist/compiled/postcss-loader/cjs.js?!./components/Calendar/CalendarDayList.module.css",
      function () {
        content = __webpack_require__(/*! !../../node_modules/next/dist/compiled/css-loader/cjs.js??ref--5-oneOf-2-1!../../node_modules/next/dist/compiled/postcss-loader/cjs.js??ref--5-oneOf-2-2!./CalendarDayList.module.css */ "./node_modules/next/dist/compiled/css-loader/cjs.js?!./node_modules/next/dist/compiled/postcss-loader/cjs.js?!./components/Calendar/CalendarDayList.module.css");

              content = content.__esModule ? content.default : content;

              if (typeof content === 'string') {
                content = [[module.i, content, '']];
              }

              if (!isEqualLocals(oldLocals, content.locals)) {
                module.hot.invalidate();

                return;
              }

              oldLocals = content.locals;

              update(content);
      }
    )
  }

  module.hot.dispose(function() {
    update();
  });
}

module.exports = content.locals || {};

/***/ }),

/***/ "./components/Calendar/CalendarDayList.tsx":
/*!*************************************************!*\
  !*** ./components/Calendar/CalendarDayList.tsx ***!
  \*************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* WEBPACK VAR INJECTION */(function(module, __prefresh_utils__) {/* harmony import */ var C_Users_admin_Documents_Dev_PWAdvent_node_modules_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./node_modules/@babel/runtime/helpers/esm/defineProperty */ "./node_modules/@babel/runtime/helpers/esm/defineProperty.js");
/* harmony import */ var C_Users_admin_Documents_Dev_PWAdvent_node_modules_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./node_modules/@babel/runtime/helpers/esm/extends */ "./node_modules/@babel/runtime/helpers/esm/extends.js");
/* harmony import */ var C_Users_admin_Documents_Dev_PWAdvent_node_modules_babel_runtime_helpers_esm_objectWithoutProperties__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./node_modules/@babel/runtime/helpers/esm/objectWithoutProperties */ "./node_modules/@babel/runtime/helpers/esm/objectWithoutProperties.js");
/* harmony import */ var next_link__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! next/link */ "./node_modules/next/link.js");
/* harmony import */ var next_link__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(next_link__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! react */ "./node_modules/preact/compat/dist/compat.module.js");
/* harmony import */ var unistore_hooks__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! unistore-hooks */ "./node_modules/unistore-hooks/dist/unistore-hooks.module.js");
/* harmony import */ var _utils_calendar__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @utils/calendar */ "./utils/calendar.ts");
/* harmony import */ var _utils_classnames__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @utils/classnames */ "./utils/classnames.tsx");
/* harmony import */ var _utils_constants__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! @utils/constants */ "./utils/constants.ts");
/* harmony import */ var _utils_dayjs__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! @utils/dayjs */ "./utils/dayjs.ts");
/* harmony import */ var _CalendarDayList_module_css__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./CalendarDayList.module.css */ "./components/Calendar/CalendarDayList.module.css");
/* harmony import */ var _CalendarDayList_module_css__WEBPACK_IMPORTED_MODULE_10___default = /*#__PURE__*/__webpack_require__.n(_CalendarDayList_module_css__WEBPACK_IMPORTED_MODULE_10__);




var _jsxFileName = "C:\\Users\\admin\\Documents\\Dev\\PWAdvent\\components\\Calendar\\CalendarDayList.tsx",
    _this = undefined,
    _s = $RefreshSig$();

var __jsx = react__WEBPACK_IMPORTED_MODULE_4__["default"].createElement;









var CalendarDay = function CalendarDay(_ref) {
  _s();

  var day = _ref.day,
      _ref$className = _ref.className,
      className = _ref$className === void 0 ? '' : _ref$className;

  var _useStoreState = Object(unistore_hooks__WEBPACK_IMPORTED_MODULE_5__["useStoreState"])(['days']),
      storeDays = _useStoreState.days;

  var dayObject = react__WEBPACK_IMPORTED_MODULE_4__["default"].useMemo(function () {
    return storeDays[day];
  }, [storeDays[day], day]);
  var isActive = react__WEBPACK_IMPORTED_MODULE_4__["default"].useMemo(function () {
    return !Object(_utils_dayjs__WEBPACK_IMPORTED_MODULE_9__["default"])(dayObject.data.date).isAfter(_utils_calendar__WEBPACK_IMPORTED_MODULE_6__["DATE_TODAY"]);
  }, [dayObject]);

  var Wrapper = function Wrapper(_ref2) {
    var children = _ref2.children,
        props = Object(C_Users_admin_Documents_Dev_PWAdvent_node_modules_babel_runtime_helpers_esm_objectWithoutProperties__WEBPACK_IMPORTED_MODULE_2__["default"])(_ref2, ["children"]);

    if (isActive) {
      return __jsx(next_link__WEBPACK_IMPORTED_MODULE_3___default.a, {
        href: "/day/".concat(day, "/"),
        __self: _this,
        __source: {
          fileName: _jsxFileName,
          lineNumber: 35,
          columnNumber: 9
        }
      }, __jsx("a", Object(C_Users_admin_Documents_Dev_PWAdvent_node_modules_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_1__["default"])({}, props, {
        __self: _this,
        __source: {
          fileName: _jsxFileName,
          lineNumber: 36,
          columnNumber: 11
        }
      }), children));
    } else {
      return __jsx("div", Object(C_Users_admin_Documents_Dev_PWAdvent_node_modules_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_1__["default"])({}, props, {
        __self: _this,
        __source: {
          fileName: _jsxFileName,
          lineNumber: 40,
          columnNumber: 14
        }
      }), children);
    }
  };

  return __jsx(Wrapper, {
    className: Object(_utils_classnames__WEBPACK_IMPORTED_MODULE_7__["default"])(className, _CalendarDayList_module_css__WEBPACK_IMPORTED_MODULE_10___default.a.root, Object(C_Users_admin_Documents_Dev_PWAdvent_node_modules_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])({}, _CalendarDayList_module_css__WEBPACK_IMPORTED_MODULE_10___default.a.rootActive, isActive)),
    __self: _this,
    __source: {
      fileName: _jsxFileName,
      lineNumber: 45,
      columnNumber: 5
    }
  }, __jsx("span", {
    className: _CalendarDayList_module_css__WEBPACK_IMPORTED_MODULE_10___default.a.number,
    __self: _this,
    __source: {
      fileName: _jsxFileName,
      lineNumber: 50,
      columnNumber: 7
    }
  }, day), __jsx("span", {
    className: _CalendarDayList_module_css__WEBPACK_IMPORTED_MODULE_10___default.a.title,
    __self: _this,
    __source: {
      fileName: _jsxFileName,
      lineNumber: 51,
      columnNumber: 7
    }
  }, _utils_constants__WEBPACK_IMPORTED_MODULE_8__["SUBJECTS"][day - 1]));
};

_s(CalendarDay, "keeMZGHzecvbcjiQiRUAnUBa3sY=", false, function () {
  return [unistore_hooks__WEBPACK_IMPORTED_MODULE_5__["useStoreState"]];
});

_c = CalendarDay;

var CalendarDayWrapper = function CalendarDayWrapper(_ref3) {
  var day = _ref3.day,
      _ref3$className = _ref3.className,
      className = _ref3$className === void 0 ? '' : _ref3$className;
  return __jsx("div", {
    className: Object(_utils_classnames__WEBPACK_IMPORTED_MODULE_7__["default"])(className, _CalendarDayList_module_css__WEBPACK_IMPORTED_MODULE_10___default.a.wrapper),
    __self: _this,
    __source: {
      fileName: _jsxFileName,
      lineNumber: 63,
      columnNumber: 3
    }
  }, __jsx(CalendarDay, {
    day: day,
    className: Object(_utils_classnames__WEBPACK_IMPORTED_MODULE_7__["default"])(_CalendarDayList_module_css__WEBPACK_IMPORTED_MODULE_10___default.a.wrapperInner),
    __self: _this,
    __source: {
      fileName: _jsxFileName,
      lineNumber: 64,
      columnNumber: 5
    }
  }));
};

_c2 = CalendarDayWrapper;
/* harmony default export */ __webpack_exports__["default"] = (CalendarDayWrapper);

var _c, _c2;

$RefreshReg$(_c, "CalendarDay");
$RefreshReg$(_c2, "CalendarDayWrapper");

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.i);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }


const isPrefreshComponent = __prefresh_utils__.shouldBind(module);

  if (true) {
    const currentExports = __prefresh_utils__.getExports(module);
    const previousHotModuleExports =
      module.hot.data && module.hot.data.moduleExports;

    __prefresh_utils__.registerExports(currentExports, module.i);

    if (isPrefreshComponent) {
      if (previousHotModuleExports) {
        try {
          __prefresh_utils__.flush();
          if (
            typeof __prefresh_errors__ !== 'undefined' &&
            __prefresh_errors__ &&
            __prefresh_errors__.clearRuntimeErrors
          ) {
            __prefresh_errors__.clearRuntimeErrors();
          }
        } catch (e) {
          // Only available in newer webpack versions.
          if (module.hot.invalidate) {
            module.hot.invalidate();
          } else {
            self.location.reload();
          }
        }
      }

      module.hot.dispose(data => {
        data.moduleExports = __prefresh_utils__.getExports(module);
      });

      module.hot.accept(function errorRecovery() {
        if (
          typeof __prefresh_errors__ !== 'undefined' &&
          __prefresh_errors__ &&
          __prefresh_errors__.handleRuntimeError
        ) {
          __prefresh_errors__.handleRuntimeError(error);
        }

        __webpack_require__.c[module.i].hot.accept(errorRecovery);
      });
    }
  }
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../node_modules/next/dist/compiled/webpack/harmony-module.js */ "./node_modules/next/dist/compiled/webpack/harmony-module.js")(module), __webpack_require__(/*! ./node_modules/@prefresh/webpack/src/utils/prefresh.js */ "./node_modules/@prefresh/webpack/src/utils/prefresh.js")))

/***/ }),

/***/ "./components/Calendar/CalendarHeader.module.css":
/*!*******************************************************!*\
  !*** ./components/Calendar/CalendarHeader.module.css ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var api = __webpack_require__(/*! ../../node_modules/next/dist/build/webpack/loaders/next-style-loader/runtime/injectStylesIntoStyleTag.js */ "./node_modules/next/dist/build/webpack/loaders/next-style-loader/runtime/injectStylesIntoStyleTag.js");
            var content = __webpack_require__(/*! !../../node_modules/next/dist/compiled/css-loader/cjs.js??ref--5-oneOf-2-1!../../node_modules/next/dist/compiled/postcss-loader/cjs.js??ref--5-oneOf-2-2!./CalendarHeader.module.css */ "./node_modules/next/dist/compiled/css-loader/cjs.js?!./node_modules/next/dist/compiled/postcss-loader/cjs.js?!./components/Calendar/CalendarHeader.module.css");

            content = content.__esModule ? content.default : content;

            if (typeof content === 'string') {
              content = [[module.i, content, '']];
            }

var options = {};

options.insert = function(element){// These elements should always exist. If they do not,
// this code should fail.
var anchorElement=document.querySelector('#__next_css__DO_NOT_USE__');var parentNode=anchorElement.parentNode;// Normally <head>
// Each style tag should be placed right before our
// anchor. By inserting before and not after, we do not
// need to track the last inserted element.
parentNode.insertBefore(element,anchorElement);};
options.singleton = false;

var update = api(content, options);


if (true) {
  if (!content.locals || module.hot.invalidate) {
    var isEqualLocals = function isEqualLocals(a,b,isNamedExport){if(!a&&b||a&&!b){return false;}let p;for(p in a){if(isNamedExport&&p==='default'){// eslint-disable-next-line no-continue
continue;}if(a[p]!==b[p]){return false;}}for(p in b){if(isNamedExport&&p==='default'){// eslint-disable-next-line no-continue
continue;}if(!a[p]){return false;}}return true;};
    var oldLocals = content.locals;

    module.hot.accept(
      /*! !../../node_modules/next/dist/compiled/css-loader/cjs.js??ref--5-oneOf-2-1!../../node_modules/next/dist/compiled/postcss-loader/cjs.js??ref--5-oneOf-2-2!./CalendarHeader.module.css */ "./node_modules/next/dist/compiled/css-loader/cjs.js?!./node_modules/next/dist/compiled/postcss-loader/cjs.js?!./components/Calendar/CalendarHeader.module.css",
      function () {
        content = __webpack_require__(/*! !../../node_modules/next/dist/compiled/css-loader/cjs.js??ref--5-oneOf-2-1!../../node_modules/next/dist/compiled/postcss-loader/cjs.js??ref--5-oneOf-2-2!./CalendarHeader.module.css */ "./node_modules/next/dist/compiled/css-loader/cjs.js?!./node_modules/next/dist/compiled/postcss-loader/cjs.js?!./components/Calendar/CalendarHeader.module.css");

              content = content.__esModule ? content.default : content;

              if (typeof content === 'string') {
                content = [[module.i, content, '']];
              }

              if (!isEqualLocals(oldLocals, content.locals)) {
                module.hot.invalidate();

                return;
              }

              oldLocals = content.locals;

              update(content);
      }
    )
  }

  module.hot.dispose(function() {
    update();
  });
}

module.exports = content.locals || {};

/***/ }),

/***/ "./components/Calendar/CalendarHeader.tsx":
/*!************************************************!*\
  !*** ./components/Calendar/CalendarHeader.tsx ***!
  \************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* WEBPACK VAR INJECTION */(function(module, __prefresh_utils__) {/* harmony import */ var C_Users_admin_Documents_Dev_PWAdvent_node_modules_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./node_modules/@babel/runtime/helpers/esm/defineProperty */ "./node_modules/@babel/runtime/helpers/esm/defineProperty.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ "./node_modules/preact/compat/dist/compat.module.js");
/* harmony import */ var unistore_hooks__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! unistore-hooks */ "./node_modules/unistore-hooks/dist/unistore-hooks.module.js");
/* harmony import */ var _theme__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @theme */ "./theme/index.ts");
/* harmony import */ var _store_index__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @store/index */ "./store/index.ts");
/* harmony import */ var _utils_calendar__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @utils/calendar */ "./utils/calendar.ts");
/* harmony import */ var _utils_classnames__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @utils/classnames */ "./utils/classnames.tsx");
/* harmony import */ var _utils_constants__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @utils/constants */ "./utils/constants.ts");
/* harmony import */ var _CalendarHeader_module_css__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./CalendarHeader.module.css */ "./components/Calendar/CalendarHeader.module.css");
/* harmony import */ var _CalendarHeader_module_css__WEBPACK_IMPORTED_MODULE_8___default = /*#__PURE__*/__webpack_require__.n(_CalendarHeader_module_css__WEBPACK_IMPORTED_MODULE_8__);


var _jsxFileName = "C:\\Users\\admin\\Documents\\Dev\\PWAdvent\\components\\Calendar\\CalendarHeader.tsx",
    _this = undefined,
    _s = $RefreshSig$();

var __jsx = react__WEBPACK_IMPORTED_MODULE_1__["default"].createElement;









var CalendarHeader = function CalendarHeader(_ref) {
  _s();

  var _ref$className = _ref.className,
      className = _ref$className === void 0 ? '' : _ref$className,
      setView = _ref.setView,
      view = _ref.view;

  var _useActions = Object(unistore_hooks__WEBPACK_IMPORTED_MODULE_2__["useActions"])(_store_index__WEBPACK_IMPORTED_MODULE_4__["actions"]),
      setMenuOpen = _useActions.setMenuOpen;

  return __jsx("header", {
    className: Object(_utils_classnames__WEBPACK_IMPORTED_MODULE_6__["default"])(className, _CalendarHeader_module_css__WEBPACK_IMPORTED_MODULE_8___default.a.root),
    __self: _this,
    __source: {
      fileName: _jsxFileName,
      lineNumber: 22,
      columnNumber: 5
    }
  }, __jsx(_theme__WEBPACK_IMPORTED_MODULE_3__["Logo"], {
    className: _CalendarHeader_module_css__WEBPACK_IMPORTED_MODULE_8___default.a.logo,
    title: "PWAdvent Logo",
    alt: "PWAdvent Logo",
    sameheight: true,
    __self: _this,
    __source: {
      fileName: _jsxFileName,
      lineNumber: 23,
      columnNumber: 7
    }
  }), __jsx(_theme__WEBPACK_IMPORTED_MODULE_3__["Button"], {
    className: _CalendarHeader_module_css__WEBPACK_IMPORTED_MODULE_8___default.a.button,
    onClick: function onClick() {
      return setMenuOpen(true);
    },
    icon: "mdi/menu",
    layout: "ghost",
    round: true,
    size: "small",
    __self: _this,
    __source: {
      fileName: _jsxFileName,
      lineNumber: 29,
      columnNumber: 7
    }
  }, "About"), _utils_calendar__WEBPACK_IMPORTED_MODULE_5__["DATE_TODAY"].isAfter(_utils_calendar__WEBPACK_IMPORTED_MODULE_5__["DATE_END"]) && __jsx("div", {
    className: _CalendarHeader_module_css__WEBPACK_IMPORTED_MODULE_8___default.a.view,
    __self: _this,
    __source: {
      fileName: _jsxFileName,
      lineNumber: 40,
      columnNumber: 9
    }
  }, Object.values(_utils_constants__WEBPACK_IMPORTED_MODULE_7__["VIEW_TYPES"]).map(function (type) {
    return __jsx(_theme__WEBPACK_IMPORTED_MODULE_3__["Button"], {
      onClick: function onClick() {
        return setView(type);
      },
      className: Object(_utils_classnames__WEBPACK_IMPORTED_MODULE_6__["default"])(_CalendarHeader_module_css__WEBPACK_IMPORTED_MODULE_8___default.a.viewButton, Object(C_Users_admin_Documents_Dev_PWAdvent_node_modules_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])({}, _CalendarHeader_module_css__WEBPACK_IMPORTED_MODULE_8___default.a.viewButtonActive, type === view)),
      size: "small",
      layout: type === view ? 'solid' : 'ghost',
      icon: "mdi/".concat(type),
      round: true,
      color: type === view ? 'red' : 'black',
      __self: _this,
      __source: {
        fileName: _jsxFileName,
        lineNumber: 42,
        columnNumber: 13
      }
    }, type === _utils_constants__WEBPACK_IMPORTED_MODULE_7__["VIEW_TYPES"].CALENDAR ? 'Calendar' : 'List');
  })));
};

_s(CalendarHeader, "r0eCydogd53h4OAdgrsxTA902hg=", false, function () {
  return [unistore_hooks__WEBPACK_IMPORTED_MODULE_2__["useActions"]];
});

_c = CalendarHeader;
/* harmony default export */ __webpack_exports__["default"] = (CalendarHeader);

var _c;

$RefreshReg$(_c, "CalendarHeader");

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.i);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }


const isPrefreshComponent = __prefresh_utils__.shouldBind(module);

  if (true) {
    const currentExports = __prefresh_utils__.getExports(module);
    const previousHotModuleExports =
      module.hot.data && module.hot.data.moduleExports;

    __prefresh_utils__.registerExports(currentExports, module.i);

    if (isPrefreshComponent) {
      if (previousHotModuleExports) {
        try {
          __prefresh_utils__.flush();
          if (
            typeof __prefresh_errors__ !== 'undefined' &&
            __prefresh_errors__ &&
            __prefresh_errors__.clearRuntimeErrors
          ) {
            __prefresh_errors__.clearRuntimeErrors();
          }
        } catch (e) {
          // Only available in newer webpack versions.
          if (module.hot.invalidate) {
            module.hot.invalidate();
          } else {
            self.location.reload();
          }
        }
      }

      module.hot.dispose(data => {
        data.moduleExports = __prefresh_utils__.getExports(module);
      });

      module.hot.accept(function errorRecovery() {
        if (
          typeof __prefresh_errors__ !== 'undefined' &&
          __prefresh_errors__ &&
          __prefresh_errors__.handleRuntimeError
        ) {
          __prefresh_errors__.handleRuntimeError(error);
        }

        __webpack_require__.c[module.i].hot.accept(errorRecovery);
      });
    }
  }
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../node_modules/next/dist/compiled/webpack/harmony-module.js */ "./node_modules/next/dist/compiled/webpack/harmony-module.js")(module), __webpack_require__(/*! ./node_modules/@prefresh/webpack/src/utils/prefresh.js */ "./node_modules/@prefresh/webpack/src/utils/prefresh.js")))

/***/ }),

/***/ "./components/Content/Content.tsx":
/*!****************************************!*\
  !*** ./components/Content/Content.tsx ***!
  \****************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* WEBPACK VAR INJECTION */(function(module, __prefresh_utils__) {/* harmony import */ var C_Users_admin_Documents_Dev_PWAdvent_node_modules_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./node_modules/@babel/runtime/helpers/esm/extends */ "./node_modules/@babel/runtime/helpers/esm/extends.js");
/* harmony import */ var next_head__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! next/head */ "./node_modules/next/head.js");
/* harmony import */ var next_head__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(next_head__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! react */ "./node_modules/preact/compat/dist/compat.module.js");
/* harmony import */ var unistore_hooks__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! unistore-hooks */ "./node_modules/unistore-hooks/dist/unistore-hooks.module.js");
/* harmony import */ var _theme__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @theme */ "./theme/index.ts");
/* harmony import */ var _store_index__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @store/index */ "./store/index.ts");
/* harmony import */ var _utils_metas__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @utils/metas */ "./utils/metas.ts");
/* harmony import */ var _ContentCalendar__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./ContentCalendar */ "./components/Content/ContentCalendar.tsx");
/* harmony import */ var _ContentPage__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./ContentPage */ "./components/Content/ContentPage.tsx");


var _jsxFileName = "C:\\Users\\admin\\Documents\\Dev\\PWAdvent\\components\\Content\\Content.tsx",
    _this = undefined,
    _s = $RefreshSig$();

var __jsx = react__WEBPACK_IMPORTED_MODULE_2__["default"].createElement;
//import { useParams, useHistory, Route, Switch } from 'react-router-dom';









var Content = function Content(_ref) {
  _s();

  var _ref$className = _ref.className,
      className = _ref$className === void 0 ? '' : _ref$className;

  var _useActions = Object(unistore_hooks__WEBPACK_IMPORTED_MODULE_3__["useActions"])(_store_index__WEBPACK_IMPORTED_MODULE_5__["actions"]),
      loadDay = _useActions.loadDay;

  var _useParams = useParams(),
      _useParams$page = _useParams.page,
      page = _useParams$page === void 0 ? null : _useParams$page,
      _useParams$slug = _useParams.slug,
      slug = _useParams$slug === void 0 ? null : _useParams$slug;

  var _useHistory = useHistory(),
      push = _useHistory.push;

  var _useStoreState = Object(unistore_hooks__WEBPACK_IMPORTED_MODULE_3__["useStoreState"])(['days']),
      storeDays = _useStoreState.days;

  var active = react__WEBPACK_IMPORTED_MODULE_2__["default"].useMemo(function () {
    return !!page;
  }, [page]);
  var activeDay = react__WEBPACK_IMPORTED_MODULE_2__["default"].useMemo(function () {
    return active !== false && page === 'day' && storeDays[slug] || false;
  }, [active, storeDays[slug], slug]);
  react__WEBPACK_IMPORTED_MODULE_2__["default"].useEffect(function () {
    activeDay && loadDay(slug);
  }, [slug]);

  if (!active) {
    return __jsx(next_head__WEBPACK_IMPORTED_MODULE_1___default.a, {
      __self: _this,
      __source: {
        fileName: _jsxFileName,
        lineNumber: 33,
        columnNumber: 7
      }
    }, __jsx("title", {
      __self: _this,
      __source: {
        fileName: _jsxFileName,
        lineNumber: 34,
        columnNumber: 9
      }
    }, Object(_utils_metas__WEBPACK_IMPORTED_MODULE_6__["metaTitle"])()));
  }

  if (activeDay) {
    return __jsx(_theme__WEBPACK_IMPORTED_MODULE_4__["ContentModal"], {
      title: activeDay.error !== '' ? "Day ".concat(slug) : activeDay.data.title || '',
      onClose: function onClose() {
        return push('/');
      },
      loading: activeDay.loading,
      __self: _this,
      __source: {
        fileName: _jsxFileName,
        lineNumber: 41,
        columnNumber: 7
      }
    }, __jsx(_ContentCalendar__WEBPACK_IMPORTED_MODULE_7__["default"], {
      day: activeDay.data,
      number: slug,
      error: activeDay.error,
      __self: _this,
      __source: {
        fileName: _jsxFileName,
        lineNumber: 48,
        columnNumber: 9
      }
    }));
  }

  if (page === 'email-notification') {
    return __jsx(_theme__WEBPACK_IMPORTED_MODULE_4__["ContentModal"], {
      className: className,
      onClose: function onClose() {
        return push('/');
      },
      title: "Email Notification",
      full: false,
      __self: _this,
      __source: {
        fileName: _jsxFileName,
        lineNumber: 59,
        columnNumber: 7
      }
    }, slug === 'success' ? __jsx("p", {
      __self: _this,
      __source: {
        fileName: _jsxFileName,
        lineNumber: 66,
        columnNumber: 11
      }
    }, "Thank you very much. Your email address has been successfully verified.") : slug === 'unsubscribe' ? __jsx("p", {
      __self: _this,
      __source: {
        fileName: _jsxFileName,
        lineNumber: 71,
        columnNumber: 11
      }
    }, "You have been successfully signed out.") : __jsx("p", {
      __self: _this,
      __source: {
        fileName: _jsxFileName,
        lineNumber: 73,
        columnNumber: 11
      }
    }, "Ooops.. Something went wrong."));
  }

  return __jsx(_ContentPage__WEBPACK_IMPORTED_MODULE_8__["default"], {
    className: className,
    slug: page,
    onClose: function onClose() {
      return push('/');
    },
    __self: _this,
    __source: {
      fileName: _jsxFileName,
      lineNumber: 80,
      columnNumber: 5
    }
  });
};

_s(Content, "wPztbkSHhafF941lpB381N2I91A=", true, function () {
  return [unistore_hooks__WEBPACK_IMPORTED_MODULE_3__["useActions"], unistore_hooks__WEBPACK_IMPORTED_MODULE_3__["useStoreState"]];
});

_c = Content;
/* harmony default export */ __webpack_exports__["default"] = (function (props) {
  return __jsx(Switch, {
    __self: _this,
    __source: {
      fileName: _jsxFileName,
      lineNumber: 85,
      columnNumber: 3
    }
  }, __jsx(Route, {
    path: "/:page?/:slug?/",
    __self: _this,
    __source: {
      fileName: _jsxFileName,
      lineNumber: 86,
      columnNumber: 5
    }
  }, __jsx(Content, Object(C_Users_admin_Documents_Dev_PWAdvent_node_modules_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__["default"])({}, props, {
    __self: _this,
    __source: {
      fileName: _jsxFileName,
      lineNumber: 87,
      columnNumber: 7
    }
  }))));
});

var _c;

$RefreshReg$(_c, "Content");

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.i);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }


const isPrefreshComponent = __prefresh_utils__.shouldBind(module);

  if (true) {
    const currentExports = __prefresh_utils__.getExports(module);
    const previousHotModuleExports =
      module.hot.data && module.hot.data.moduleExports;

    __prefresh_utils__.registerExports(currentExports, module.i);

    if (isPrefreshComponent) {
      if (previousHotModuleExports) {
        try {
          __prefresh_utils__.flush();
          if (
            typeof __prefresh_errors__ !== 'undefined' &&
            __prefresh_errors__ &&
            __prefresh_errors__.clearRuntimeErrors
          ) {
            __prefresh_errors__.clearRuntimeErrors();
          }
        } catch (e) {
          // Only available in newer webpack versions.
          if (module.hot.invalidate) {
            module.hot.invalidate();
          } else {
            self.location.reload();
          }
        }
      }

      module.hot.dispose(data => {
        data.moduleExports = __prefresh_utils__.getExports(module);
      });

      module.hot.accept(function errorRecovery() {
        if (
          typeof __prefresh_errors__ !== 'undefined' &&
          __prefresh_errors__ &&
          __prefresh_errors__.handleRuntimeError
        ) {
          __prefresh_errors__.handleRuntimeError(error);
        }

        __webpack_require__.c[module.i].hot.accept(errorRecovery);
      });
    }
  }
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../node_modules/next/dist/compiled/webpack/harmony-module.js */ "./node_modules/next/dist/compiled/webpack/harmony-module.js")(module), __webpack_require__(/*! ./node_modules/@prefresh/webpack/src/utils/prefresh.js */ "./node_modules/@prefresh/webpack/src/utils/prefresh.js")))

/***/ }),

/***/ "./components/Content/ContentAuthor.module.css":
/*!*****************************************************!*\
  !*** ./components/Content/ContentAuthor.module.css ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var api = __webpack_require__(/*! ../../node_modules/next/dist/build/webpack/loaders/next-style-loader/runtime/injectStylesIntoStyleTag.js */ "./node_modules/next/dist/build/webpack/loaders/next-style-loader/runtime/injectStylesIntoStyleTag.js");
            var content = __webpack_require__(/*! !../../node_modules/next/dist/compiled/css-loader/cjs.js??ref--5-oneOf-2-1!../../node_modules/next/dist/compiled/postcss-loader/cjs.js??ref--5-oneOf-2-2!./ContentAuthor.module.css */ "./node_modules/next/dist/compiled/css-loader/cjs.js?!./node_modules/next/dist/compiled/postcss-loader/cjs.js?!./components/Content/ContentAuthor.module.css");

            content = content.__esModule ? content.default : content;

            if (typeof content === 'string') {
              content = [[module.i, content, '']];
            }

var options = {};

options.insert = function(element){// These elements should always exist. If they do not,
// this code should fail.
var anchorElement=document.querySelector('#__next_css__DO_NOT_USE__');var parentNode=anchorElement.parentNode;// Normally <head>
// Each style tag should be placed right before our
// anchor. By inserting before and not after, we do not
// need to track the last inserted element.
parentNode.insertBefore(element,anchorElement);};
options.singleton = false;

var update = api(content, options);


if (true) {
  if (!content.locals || module.hot.invalidate) {
    var isEqualLocals = function isEqualLocals(a,b,isNamedExport){if(!a&&b||a&&!b){return false;}let p;for(p in a){if(isNamedExport&&p==='default'){// eslint-disable-next-line no-continue
continue;}if(a[p]!==b[p]){return false;}}for(p in b){if(isNamedExport&&p==='default'){// eslint-disable-next-line no-continue
continue;}if(!a[p]){return false;}}return true;};
    var oldLocals = content.locals;

    module.hot.accept(
      /*! !../../node_modules/next/dist/compiled/css-loader/cjs.js??ref--5-oneOf-2-1!../../node_modules/next/dist/compiled/postcss-loader/cjs.js??ref--5-oneOf-2-2!./ContentAuthor.module.css */ "./node_modules/next/dist/compiled/css-loader/cjs.js?!./node_modules/next/dist/compiled/postcss-loader/cjs.js?!./components/Content/ContentAuthor.module.css",
      function () {
        content = __webpack_require__(/*! !../../node_modules/next/dist/compiled/css-loader/cjs.js??ref--5-oneOf-2-1!../../node_modules/next/dist/compiled/postcss-loader/cjs.js??ref--5-oneOf-2-2!./ContentAuthor.module.css */ "./node_modules/next/dist/compiled/css-loader/cjs.js?!./node_modules/next/dist/compiled/postcss-loader/cjs.js?!./components/Content/ContentAuthor.module.css");

              content = content.__esModule ? content.default : content;

              if (typeof content === 'string') {
                content = [[module.i, content, '']];
              }

              if (!isEqualLocals(oldLocals, content.locals)) {
                module.hot.invalidate();

                return;
              }

              oldLocals = content.locals;

              update(content);
      }
    )
  }

  module.hot.dispose(function() {
    update();
  });
}

module.exports = content.locals || {};

/***/ }),

/***/ "./components/Content/ContentAuthor.tsx":
/*!**********************************************!*\
  !*** ./components/Content/ContentAuthor.tsx ***!
  \**********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* WEBPACK VAR INJECTION */(function(module, __prefresh_utils__) {/* harmony import */ var C_Users_admin_Documents_Dev_PWAdvent_node_modules_babel_runtime_helpers_esm_slicedToArray__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./node_modules/@babel/runtime/helpers/esm/slicedToArray */ "./node_modules/@babel/runtime/helpers/esm/slicedToArray.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ "./node_modules/preact/compat/dist/compat.module.js");
/* harmony import */ var _utils_classnames__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @utils/classnames */ "./utils/classnames.tsx");
/* harmony import */ var _ContentAuthor_module_css__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./ContentAuthor.module.css */ "./components/Content/ContentAuthor.module.css");
/* harmony import */ var _ContentAuthor_module_css__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_ContentAuthor_module_css__WEBPACK_IMPORTED_MODULE_3__);


var _jsxFileName = "C:\\Users\\admin\\Documents\\Dev\\PWAdvent\\components\\Content\\ContentAuthor.tsx",
    _this = undefined,
    _s = $RefreshSig$();

var __jsx = react__WEBPACK_IMPORTED_MODULE_1__["default"].createElement;



var linkList = {
  twitter: 'Twitter',
  devto: 'Dev.to',
  webdev: 'Web.dev'
};

var ContentAuthor = function ContentAuthor(_ref) {
  _s();

  var author = _ref.author,
      _ref$className = _ref.className,
      className = _ref$className === void 0 ? '' : _ref$className,
      _ref$small = _ref.small,
      small = _ref$small === void 0 ? false : _ref$small;
  var links = react__WEBPACK_IMPORTED_MODULE_1__["default"].useMemo(function () {
    return Object.entries(linkList).map(function (_ref2) {
      var _ref3 = Object(C_Users_admin_Documents_Dev_PWAdvent_node_modules_babel_runtime_helpers_esm_slicedToArray__WEBPACK_IMPORTED_MODULE_0__["default"])(_ref2, 2),
          key = _ref3[0],
          title = _ref3[1];

      return key in author && author[key] !== '' ? {
        title: title,
        link: author[key]
      } : null;
    }).filter(function (e) {
      return !!e;
    });
  }, [author]);
  return __jsx("div", {
    className: Object(_utils_classnames__WEBPACK_IMPORTED_MODULE_2__["default"])(_ContentAuthor_module_css__WEBPACK_IMPORTED_MODULE_3___default.a.root, className),
    __self: _this,
    __source: {
      fileName: _jsxFileName,
      lineNumber: 40,
      columnNumber: 5
    }
  }, author.image.src !== '' && __jsx("img", {
    className: Object(_utils_classnames__WEBPACK_IMPORTED_MODULE_2__["default"])(_ContentAuthor_module_css__WEBPACK_IMPORTED_MODULE_3___default.a.image),
    alt: author.name,
    src: author.image.src,
    width: small ? 50 : author.image.width,
    height: small ? 50 : author.image.width,
    __self: _this,
    __source: {
      fileName: _jsxFileName,
      lineNumber: 42,
      columnNumber: 9
    }
  }), __jsx("div", {
    className: Object(_utils_classnames__WEBPACK_IMPORTED_MODULE_2__["default"])(_ContentAuthor_module_css__WEBPACK_IMPORTED_MODULE_3___default.a.about),
    __self: _this,
    __source: {
      fileName: _jsxFileName,
      lineNumber: 50,
      columnNumber: 7
    }
  }, __jsx("p", {
    className: Object(_utils_classnames__WEBPACK_IMPORTED_MODULE_2__["default"])(_ContentAuthor_module_css__WEBPACK_IMPORTED_MODULE_3___default.a.name),
    __self: _this,
    __source: {
      fileName: _jsxFileName,
      lineNumber: 51,
      columnNumber: 9
    }
  }, 'personal' in author && author.personal !== '' ? __jsx("a", {
    href: author.personal,
    target: "_blank",
    __self: _this,
    __source: {
      fileName: _jsxFileName,
      lineNumber: 53,
      columnNumber: 13
    }
  }, author.name) : author.name), links.length !== 0 && __jsx("ul", {
    className: Object(_utils_classnames__WEBPACK_IMPORTED_MODULE_2__["default"])(_ContentAuthor_module_css__WEBPACK_IMPORTED_MODULE_3___default.a.links),
    __self: _this,
    __source: {
      fileName: _jsxFileName,
      lineNumber: 61,
      columnNumber: 11
    }
  }, links.map(function (_ref4) {
    var title = _ref4.title,
        link = _ref4.link;
    return __jsx("li", {
      className: Object(_utils_classnames__WEBPACK_IMPORTED_MODULE_2__["default"])(_ContentAuthor_module_css__WEBPACK_IMPORTED_MODULE_3___default.a.linksItem),
      __self: _this,
      __source: {
        fileName: _jsxFileName,
        lineNumber: 63,
        columnNumber: 15
      }
    }, __jsx("a", {
      target: "_blank",
      href: link,
      className: Object(_utils_classnames__WEBPACK_IMPORTED_MODULE_2__["default"])(_ContentAuthor_module_css__WEBPACK_IMPORTED_MODULE_3___default.a.linksItem),
      __self: _this,
      __source: {
        fileName: _jsxFileName,
        lineNumber: 64,
        columnNumber: 17
      }
    }, title));
  }))));
};

_s(ContentAuthor, "Od6DDt8bCBXHV35K1L/JP6jrfAY=");

_c = ContentAuthor;
/* harmony default export */ __webpack_exports__["default"] = (ContentAuthor);

var _c;

$RefreshReg$(_c, "ContentAuthor");

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.i);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }


const isPrefreshComponent = __prefresh_utils__.shouldBind(module);

  if (true) {
    const currentExports = __prefresh_utils__.getExports(module);
    const previousHotModuleExports =
      module.hot.data && module.hot.data.moduleExports;

    __prefresh_utils__.registerExports(currentExports, module.i);

    if (isPrefreshComponent) {
      if (previousHotModuleExports) {
        try {
          __prefresh_utils__.flush();
          if (
            typeof __prefresh_errors__ !== 'undefined' &&
            __prefresh_errors__ &&
            __prefresh_errors__.clearRuntimeErrors
          ) {
            __prefresh_errors__.clearRuntimeErrors();
          }
        } catch (e) {
          // Only available in newer webpack versions.
          if (module.hot.invalidate) {
            module.hot.invalidate();
          } else {
            self.location.reload();
          }
        }
      }

      module.hot.dispose(data => {
        data.moduleExports = __prefresh_utils__.getExports(module);
      });

      module.hot.accept(function errorRecovery() {
        if (
          typeof __prefresh_errors__ !== 'undefined' &&
          __prefresh_errors__ &&
          __prefresh_errors__.handleRuntimeError
        ) {
          __prefresh_errors__.handleRuntimeError(error);
        }

        __webpack_require__.c[module.i].hot.accept(errorRecovery);
      });
    }
  }
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../node_modules/next/dist/compiled/webpack/harmony-module.js */ "./node_modules/next/dist/compiled/webpack/harmony-module.js")(module), __webpack_require__(/*! ./node_modules/@prefresh/webpack/src/utils/prefresh.js */ "./node_modules/@prefresh/webpack/src/utils/prefresh.js")))

/***/ }),

/***/ "./components/Content/ContentCalendar.module.css":
/*!*******************************************************!*\
  !*** ./components/Content/ContentCalendar.module.css ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var api = __webpack_require__(/*! ../../node_modules/next/dist/build/webpack/loaders/next-style-loader/runtime/injectStylesIntoStyleTag.js */ "./node_modules/next/dist/build/webpack/loaders/next-style-loader/runtime/injectStylesIntoStyleTag.js");
            var content = __webpack_require__(/*! !../../node_modules/next/dist/compiled/css-loader/cjs.js??ref--5-oneOf-2-1!../../node_modules/next/dist/compiled/postcss-loader/cjs.js??ref--5-oneOf-2-2!./ContentCalendar.module.css */ "./node_modules/next/dist/compiled/css-loader/cjs.js?!./node_modules/next/dist/compiled/postcss-loader/cjs.js?!./components/Content/ContentCalendar.module.css");

            content = content.__esModule ? content.default : content;

            if (typeof content === 'string') {
              content = [[module.i, content, '']];
            }

var options = {};

options.insert = function(element){// These elements should always exist. If they do not,
// this code should fail.
var anchorElement=document.querySelector('#__next_css__DO_NOT_USE__');var parentNode=anchorElement.parentNode;// Normally <head>
// Each style tag should be placed right before our
// anchor. By inserting before and not after, we do not
// need to track the last inserted element.
parentNode.insertBefore(element,anchorElement);};
options.singleton = false;

var update = api(content, options);


if (true) {
  if (!content.locals || module.hot.invalidate) {
    var isEqualLocals = function isEqualLocals(a,b,isNamedExport){if(!a&&b||a&&!b){return false;}let p;for(p in a){if(isNamedExport&&p==='default'){// eslint-disable-next-line no-continue
continue;}if(a[p]!==b[p]){return false;}}for(p in b){if(isNamedExport&&p==='default'){// eslint-disable-next-line no-continue
continue;}if(!a[p]){return false;}}return true;};
    var oldLocals = content.locals;

    module.hot.accept(
      /*! !../../node_modules/next/dist/compiled/css-loader/cjs.js??ref--5-oneOf-2-1!../../node_modules/next/dist/compiled/postcss-loader/cjs.js??ref--5-oneOf-2-2!./ContentCalendar.module.css */ "./node_modules/next/dist/compiled/css-loader/cjs.js?!./node_modules/next/dist/compiled/postcss-loader/cjs.js?!./components/Content/ContentCalendar.module.css",
      function () {
        content = __webpack_require__(/*! !../../node_modules/next/dist/compiled/css-loader/cjs.js??ref--5-oneOf-2-1!../../node_modules/next/dist/compiled/postcss-loader/cjs.js??ref--5-oneOf-2-2!./ContentCalendar.module.css */ "./node_modules/next/dist/compiled/css-loader/cjs.js?!./node_modules/next/dist/compiled/postcss-loader/cjs.js?!./components/Content/ContentCalendar.module.css");

              content = content.__esModule ? content.default : content;

              if (typeof content === 'string') {
                content = [[module.i, content, '']];
              }

              if (!isEqualLocals(oldLocals, content.locals)) {
                module.hot.invalidate();

                return;
              }

              oldLocals = content.locals;

              update(content);
      }
    )
  }

  module.hot.dispose(function() {
    update();
  });
}

module.exports = content.locals || {};

/***/ }),

/***/ "./components/Content/ContentCalendar.tsx":
/*!************************************************!*\
  !*** ./components/Content/ContentCalendar.tsx ***!
  \************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* WEBPACK VAR INJECTION */(function(module, __prefresh_utils__) {/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ "./node_modules/preact/compat/dist/compat.module.js");
/* harmony import */ var _theme__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @theme */ "./theme/index.ts");
/* harmony import */ var _comps_Content_ContentAuthor__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @comps/Content/ContentAuthor */ "./components/Content/ContentAuthor.tsx");
/* harmony import */ var _comps_hooks_useWindowSize__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @comps/hooks/useWindowSize */ "./components/hooks/useWindowSize.tsx");
/* harmony import */ var _utils_classnames__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @utils/classnames */ "./utils/classnames.tsx");
/* harmony import */ var _utils_dayjs__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @utils/dayjs */ "./utils/dayjs.ts");
/* harmony import */ var _utils_prism__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @utils/prism */ "./utils/prism.js");
/* harmony import */ var _utils_prism__WEBPACK_IMPORTED_MODULE_6___default = /*#__PURE__*/__webpack_require__.n(_utils_prism__WEBPACK_IMPORTED_MODULE_6__);
/* harmony import */ var _ContentCalendar_module_css__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./ContentCalendar.module.css */ "./components/Content/ContentCalendar.module.css");
/* harmony import */ var _ContentCalendar_module_css__WEBPACK_IMPORTED_MODULE_7___default = /*#__PURE__*/__webpack_require__.n(_ContentCalendar_module_css__WEBPACK_IMPORTED_MODULE_7__);
var _jsxFileName = "C:\\Users\\admin\\Documents\\Dev\\PWAdvent\\components\\Content\\ContentCalendar.tsx",
    _this = undefined,
    _s = $RefreshSig$();

var __jsx = react__WEBPACK_IMPORTED_MODULE_0__["default"].createElement;









var ContentCalendar = function ContentCalendar(_ref) {
  _s();

  var day = _ref.day,
      number = _ref.number,
      _ref$className = _ref.className,
      className = _ref$className === void 0 ? '' : _ref$className,
      _ref$error = _ref.error,
      error = _ref$error === void 0 ? '' : _ref$error;
  var contentRef = react__WEBPACK_IMPORTED_MODULE_0__["default"].useRef(null);
  var date = react__WEBPACK_IMPORTED_MODULE_0__["default"].useMemo(function () {
    return Object(_utils_dayjs__WEBPACK_IMPORTED_MODULE_5__["default"])(day.date);
  }, [day.date]);

  var _useWindowSize = Object(_comps_hooks_useWindowSize__WEBPACK_IMPORTED_MODULE_3__["default"])(),
      width = _useWindowSize.width;

  var originalSource = react__WEBPACK_IMPORTED_MODULE_0__["default"].useMemo(function () {
    return day.source ? new URL(day.source) : null;
  }, [day.source]);
  var content = react__WEBPACK_IMPORTED_MODULE_0__["default"].useMemo(function () {
    var regex = /<code class="language-markup">((.|\n)*?)<\/code>/gm;
    var m;
    var c = day.content;

    while ((m = regex.exec(c)) !== null) {
      if (m.index === regex.lastIndex) {
        regex.lastIndex++;
      }

      c = c.replace(m[1], m[1].replace(/</g, '&lt;'));
    }

    return c;
  }, [day.content]);
  react__WEBPACK_IMPORTED_MODULE_0__["default"].useEffect(function () {
    _utils_prism__WEBPACK_IMPORTED_MODULE_6___default.a.highlightAll();
  }, [contentRef, content]);

  if (error !== '') {
    return __jsx("div", {
      className: className,
      __self: _this,
      __source: {
        fileName: _jsxFileName,
        lineNumber: 53,
        columnNumber: 7
      }
    }, __jsx("p", {
      className: Object(_utils_classnames__WEBPACK_IMPORTED_MODULE_4__["default"])(_ContentCalendar_module_css__WEBPACK_IMPORTED_MODULE_7___default.a.error),
      __self: _this,
      __source: {
        fileName: _jsxFileName,
        lineNumber: 54,
        columnNumber: 9
      }
    }, error));
  }

  return __jsx("div", {
    className: className,
    __self: _this,
    __source: {
      fileName: _jsxFileName,
      lineNumber: 60,
      columnNumber: 5
    }
  }, __jsx("p", {
    className: Object(_utils_classnames__WEBPACK_IMPORTED_MODULE_4__["default"])(_ContentCalendar_module_css__WEBPACK_IMPORTED_MODULE_7___default.a.date),
    __self: _this,
    __source: {
      fileName: _jsxFileName,
      lineNumber: 61,
      columnNumber: 7
    }
  }, __jsx("b", {
    __self: _this,
    __source: {
      fileName: _jsxFileName,
      lineNumber: 62,
      columnNumber: 9
    }
  }, "Day ", number, ":"), " ", date && date.format('L')), day.excerpt && __jsx("p", {
    className: Object(_utils_classnames__WEBPACK_IMPORTED_MODULE_4__["default"])(_ContentCalendar_module_css__WEBPACK_IMPORTED_MODULE_7___default.a.excerpt),
    __self: _this,
    __source: {
      fileName: _jsxFileName,
      lineNumber: 64,
      columnNumber: 23
    }
  }, day.excerpt), day.image && __jsx(_theme__WEBPACK_IMPORTED_MODULE_1__["LazyImage"], {
    image: day.image,
    className: Object(_utils_classnames__WEBPACK_IMPORTED_MODULE_4__["default"])(_ContentCalendar_module_css__WEBPACK_IMPORTED_MODULE_7___default.a.image),
    __self: _this,
    __source: {
      fileName: _jsxFileName,
      lineNumber: 66,
      columnNumber: 9
    }
  }), day.author && __jsx("div", {
    className: Object(_utils_classnames__WEBPACK_IMPORTED_MODULE_4__["default"])(_ContentCalendar_module_css__WEBPACK_IMPORTED_MODULE_7___default.a.meta),
    __self: _this,
    __source: {
      fileName: _jsxFileName,
      lineNumber: 69,
      columnNumber: 9
    }
  }, __jsx(_comps_Content_ContentAuthor__WEBPACK_IMPORTED_MODULE_2__["default"], {
    author: day.author,
    className: Object(_utils_classnames__WEBPACK_IMPORTED_MODULE_4__["default"])(_ContentCalendar_module_css__WEBPACK_IMPORTED_MODULE_7___default.a.author),
    small: width <= 700,
    __self: _this,
    __source: {
      fileName: _jsxFileName,
      lineNumber: 70,
      columnNumber: 11
    }
  }), 'share' in navigator && __jsx(_theme__WEBPACK_IMPORTED_MODULE_1__["Button"], {
    className: "content-share ".concat(className),
    onClick: function onClick() {
      return navigator.share({
        url: window.location.href,
        text: 'Have a look at the awesome article on PWAdvent.dev',
        title: "".concat(day.title, " - PWAdvent")
      });
    },
    layout: "ghost",
    round: true,
    icon: "mdi/share",
    iconRight: true,
    size: width <= 700 ? 'small' : 'medium',
    __self: _this,
    __source: {
      fileName: _jsxFileName,
      lineNumber: 76,
      columnNumber: 13
    }
  }, "Share")), __jsx("div", {
    ref: contentRef,
    className: "gutenberg-content",
    dangerouslySetInnerHTML: {
      __html: content
    },
    __self: _this,
    __source: {
      fileName: _jsxFileName,
      lineNumber: 96,
      columnNumber: 7
    }
  }), originalSource && __jsx(_theme__WEBPACK_IMPORTED_MODULE_1__["Notification"], {
    className: Object(_utils_classnames__WEBPACK_IMPORTED_MODULE_4__["default"])(_ContentCalendar_module_css__WEBPACK_IMPORTED_MODULE_7___default.a.cannonical),
    __self: _this,
    __source: {
      fileName: _jsxFileName,
      lineNumber: 104,
      columnNumber: 9
    }
  }, "This article was originally published on", ' ', __jsx("a", {
    href: originalSource.href,
    target: "_blank",
    __self: _this,
    __source: {
      fileName: _jsxFileName,
      lineNumber: 106,
      columnNumber: 11
    }
  }, originalSource.host)));
};

_s(ContentCalendar, "1uZJNj2SPCUrS6nVHxxduvuR/sM=", false, function () {
  return [_comps_hooks_useWindowSize__WEBPACK_IMPORTED_MODULE_3__["default"]];
});

_c = ContentCalendar;
/* harmony default export */ __webpack_exports__["default"] = (ContentCalendar);

var _c;

$RefreshReg$(_c, "ContentCalendar");

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.i);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }


const isPrefreshComponent = __prefresh_utils__.shouldBind(module);

  if (true) {
    const currentExports = __prefresh_utils__.getExports(module);
    const previousHotModuleExports =
      module.hot.data && module.hot.data.moduleExports;

    __prefresh_utils__.registerExports(currentExports, module.i);

    if (isPrefreshComponent) {
      if (previousHotModuleExports) {
        try {
          __prefresh_utils__.flush();
          if (
            typeof __prefresh_errors__ !== 'undefined' &&
            __prefresh_errors__ &&
            __prefresh_errors__.clearRuntimeErrors
          ) {
            __prefresh_errors__.clearRuntimeErrors();
          }
        } catch (e) {
          // Only available in newer webpack versions.
          if (module.hot.invalidate) {
            module.hot.invalidate();
          } else {
            self.location.reload();
          }
        }
      }

      module.hot.dispose(data => {
        data.moduleExports = __prefresh_utils__.getExports(module);
      });

      module.hot.accept(function errorRecovery() {
        if (
          typeof __prefresh_errors__ !== 'undefined' &&
          __prefresh_errors__ &&
          __prefresh_errors__.handleRuntimeError
        ) {
          __prefresh_errors__.handleRuntimeError(error);
        }

        __webpack_require__.c[module.i].hot.accept(errorRecovery);
      });
    }
  }
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../node_modules/next/dist/compiled/webpack/harmony-module.js */ "./node_modules/next/dist/compiled/webpack/harmony-module.js")(module), __webpack_require__(/*! ./node_modules/@prefresh/webpack/src/utils/prefresh.js */ "./node_modules/@prefresh/webpack/src/utils/prefresh.js")))

/***/ }),

/***/ "./components/Content/ContentPage.tsx":
/*!********************************************!*\
  !*** ./components/Content/ContentPage.tsx ***!
  \********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* WEBPACK VAR INJECTION */(function(module, __prefresh_utils__) {/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ "./node_modules/preact/compat/dist/compat.module.js");
/* harmony import */ var unistore_hooks__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! unistore-hooks */ "./node_modules/unistore-hooks/dist/unistore-hooks.module.js");
/* harmony import */ var _theme__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @theme */ "./theme/index.ts");
/* harmony import */ var _store_index__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @store/index */ "./store/index.ts");
/* harmony import */ var _utils_classnames__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @utils/classnames */ "./utils/classnames.tsx");
var _jsxFileName = "C:\\Users\\admin\\Documents\\Dev\\PWAdvent\\components\\Content\\ContentPage.tsx",
    _this = undefined,
    _s = $RefreshSig$();

var __jsx = react__WEBPACK_IMPORTED_MODULE_0__["default"].createElement;






var ContentPage = function ContentPage(_ref) {
  _s();

  var _ref$className = _ref.className,
      className = _ref$className === void 0 ? '' : _ref$className,
      onClose = _ref.onClose,
      slug = _ref.slug;

  var _useActions = Object(unistore_hooks__WEBPACK_IMPORTED_MODULE_1__["useActions"])(_store_index__WEBPACK_IMPORTED_MODULE_3__["actions"]),
      loadPage = _useActions.loadPage;

  var _useStoreState = Object(unistore_hooks__WEBPACK_IMPORTED_MODULE_1__["useStoreState"])(['page']),
      page = _useStoreState.page;

  react__WEBPACK_IMPORTED_MODULE_0__["default"].useEffect(function () {
    loadPage(slug);
  }, [slug]);
  return __jsx(_theme__WEBPACK_IMPORTED_MODULE_2__["ContentModal"], {
    className: Object(_utils_classnames__WEBPACK_IMPORTED_MODULE_4__["default"])(className, 'content-page'),
    onClose: onClose,
    title: page.data.title,
    loading: page.loading,
    __self: _this,
    __source: {
      fileName: _jsxFileName,
      lineNumber: 27,
      columnNumber: 5
    }
  }, __jsx("div", {
    className: "gutenberg-content",
    dangerouslySetInnerHTML: {
      __html: page.data.content
    },
    __self: _this,
    __source: {
      fileName: _jsxFileName,
      lineNumber: 33,
      columnNumber: 7
    }
  }));
};

_s(ContentPage, "OS37nMa9du0p/lxZQlP/aIQrldM=", false, function () {
  return [unistore_hooks__WEBPACK_IMPORTED_MODULE_1__["useActions"], unistore_hooks__WEBPACK_IMPORTED_MODULE_1__["useStoreState"]];
});

_c = ContentPage;
/* harmony default export */ __webpack_exports__["default"] = (ContentPage);

var _c;

$RefreshReg$(_c, "ContentPage");

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.i);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }


const isPrefreshComponent = __prefresh_utils__.shouldBind(module);

  if (true) {
    const currentExports = __prefresh_utils__.getExports(module);
    const previousHotModuleExports =
      module.hot.data && module.hot.data.moduleExports;

    __prefresh_utils__.registerExports(currentExports, module.i);

    if (isPrefreshComponent) {
      if (previousHotModuleExports) {
        try {
          __prefresh_utils__.flush();
          if (
            typeof __prefresh_errors__ !== 'undefined' &&
            __prefresh_errors__ &&
            __prefresh_errors__.clearRuntimeErrors
          ) {
            __prefresh_errors__.clearRuntimeErrors();
          }
        } catch (e) {
          // Only available in newer webpack versions.
          if (module.hot.invalidate) {
            module.hot.invalidate();
          } else {
            self.location.reload();
          }
        }
      }

      module.hot.dispose(data => {
        data.moduleExports = __prefresh_utils__.getExports(module);
      });

      module.hot.accept(function errorRecovery() {
        if (
          typeof __prefresh_errors__ !== 'undefined' &&
          __prefresh_errors__ &&
          __prefresh_errors__.handleRuntimeError
        ) {
          __prefresh_errors__.handleRuntimeError(error);
        }

        __webpack_require__.c[module.i].hot.accept(errorRecovery);
      });
    }
  }
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../node_modules/next/dist/compiled/webpack/harmony-module.js */ "./node_modules/next/dist/compiled/webpack/harmony-module.js")(module), __webpack_require__(/*! ./node_modules/@prefresh/webpack/src/utils/prefresh.js */ "./node_modules/@prefresh/webpack/src/utils/prefresh.js")))

/***/ }),

/***/ "./components/hooks/useWindowSize.tsx":
/*!********************************************!*\
  !*** ./components/hooks/useWindowSize.tsx ***!
  \********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* WEBPACK VAR INJECTION */(function(module, __prefresh_utils__) {/* harmony import */ var C_Users_admin_Documents_Dev_PWAdvent_node_modules_babel_runtime_helpers_esm_slicedToArray__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./node_modules/@babel/runtime/helpers/esm/slicedToArray */ "./node_modules/@babel/runtime/helpers/esm/slicedToArray.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ "./node_modules/preact/compat/dist/compat.module.js");


var _s = $RefreshSig$();



var useWindowSize = function useWindowSize() {
  _s();

  var _React$useState = react__WEBPACK_IMPORTED_MODULE_1__["default"].useState({
    width: null,
    height: null
  }),
      _React$useState2 = Object(C_Users_admin_Documents_Dev_PWAdvent_node_modules_babel_runtime_helpers_esm_slicedToArray__WEBPACK_IMPORTED_MODULE_0__["default"])(_React$useState, 2),
      windowSize = _React$useState2[0],
      setWindowSize = _React$useState2[1];

  react__WEBPACK_IMPORTED_MODULE_1__["default"].useEffect(function () {
    var handleResize = function handleResize() {
      return setWindowSize({
        width: window.innerWidth,
        height: window.innerHeight
      });
    };

    window.addEventListener('resize', handleResize);
    window.addEventListener('orientationchange', handleResize);
    window.setTimeout(function () {
      return handleResize();
    }, 1000);
    handleResize();
    return function () {
      window.removeEventListener('resize', handleResize);
      window.removeEventListener('orientationchange', handleResize);
    };
  }, []);
  return windowSize;
};

_s(useWindowSize, "FSP7Buo8FOcjg8j3u3kVi66AwhQ=");

/* harmony default export */ __webpack_exports__["default"] = (useWindowSize);

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.i);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }


const isPrefreshComponent = __prefresh_utils__.shouldBind(module);

  if (true) {
    const currentExports = __prefresh_utils__.getExports(module);
    const previousHotModuleExports =
      module.hot.data && module.hot.data.moduleExports;

    __prefresh_utils__.registerExports(currentExports, module.i);

    if (isPrefreshComponent) {
      if (previousHotModuleExports) {
        try {
          __prefresh_utils__.flush();
          if (
            typeof __prefresh_errors__ !== 'undefined' &&
            __prefresh_errors__ &&
            __prefresh_errors__.clearRuntimeErrors
          ) {
            __prefresh_errors__.clearRuntimeErrors();
          }
        } catch (e) {
          // Only available in newer webpack versions.
          if (module.hot.invalidate) {
            module.hot.invalidate();
          } else {
            self.location.reload();
          }
        }
      }

      module.hot.dispose(data => {
        data.moduleExports = __prefresh_utils__.getExports(module);
      });

      module.hot.accept(function errorRecovery() {
        if (
          typeof __prefresh_errors__ !== 'undefined' &&
          __prefresh_errors__ &&
          __prefresh_errors__.handleRuntimeError
        ) {
          __prefresh_errors__.handleRuntimeError(error);
        }

        __webpack_require__.c[module.i].hot.accept(errorRecovery);
      });
    }
  }
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../node_modules/next/dist/compiled/webpack/harmony-module.js */ "./node_modules/next/dist/compiled/webpack/harmony-module.js")(module), __webpack_require__(/*! ./node_modules/@prefresh/webpack/src/utils/prefresh.js */ "./node_modules/@prefresh/webpack/src/utils/prefresh.js")))

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/arrayLikeToArray.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/arrayLikeToArray.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

function _arrayLikeToArray(arr, len) {
  if (len == null || len > arr.length) len = arr.length;

  for (var i = 0, arr2 = new Array(len); i < len; i++) {
    arr2[i] = arr[i];
  }

  return arr2;
}

module.exports = _arrayLikeToArray;

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/arrayWithHoles.js":
/*!***************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/arrayWithHoles.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

function _arrayWithHoles(arr) {
  if (Array.isArray(arr)) return arr;
}

module.exports = _arrayWithHoles;

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/arrayWithoutHoles.js":
/*!******************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/arrayWithoutHoles.js ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var arrayLikeToArray = __webpack_require__(/*! ./arrayLikeToArray */ "./node_modules/@babel/runtime/helpers/arrayLikeToArray.js");

function _arrayWithoutHoles(arr) {
  if (Array.isArray(arr)) return arrayLikeToArray(arr);
}

module.exports = _arrayWithoutHoles;

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/assertThisInitialized.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/assertThisInitialized.js ***!
  \**********************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

function _assertThisInitialized(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return self;
}

module.exports = _assertThisInitialized;

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/asyncToGenerator.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/asyncToGenerator.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
  try {
    var info = gen[key](arg);
    var value = info.value;
  } catch (error) {
    reject(error);
    return;
  }

  if (info.done) {
    resolve(value);
  } else {
    Promise.resolve(value).then(_next, _throw);
  }
}

function _asyncToGenerator(fn) {
  return function () {
    var self = this,
        args = arguments;
    return new Promise(function (resolve, reject) {
      var gen = fn.apply(self, args);

      function _next(value) {
        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
      }

      function _throw(err) {
        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
      }

      _next(undefined);
    });
  };
}

module.exports = _asyncToGenerator;

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/classCallCheck.js":
/*!***************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/classCallCheck.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

module.exports = _classCallCheck;

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/construct.js":
/*!**********************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/construct.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var setPrototypeOf = __webpack_require__(/*! ./setPrototypeOf */ "./node_modules/@babel/runtime/helpers/setPrototypeOf.js");

var isNativeReflectConstruct = __webpack_require__(/*! ./isNativeReflectConstruct */ "./node_modules/@babel/runtime/helpers/isNativeReflectConstruct.js");

function _construct(Parent, args, Class) {
  if (isNativeReflectConstruct()) {
    module.exports = _construct = Reflect.construct;
  } else {
    module.exports = _construct = function _construct(Parent, args, Class) {
      var a = [null];
      a.push.apply(a, args);
      var Constructor = Function.bind.apply(Parent, a);
      var instance = new Constructor();
      if (Class) setPrototypeOf(instance, Class.prototype);
      return instance;
    };
  }

  return _construct.apply(null, arguments);
}

module.exports = _construct;

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/createClass.js":
/*!************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/createClass.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  return Constructor;
}

module.exports = _createClass;

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/defineProperty.js":
/*!***************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/defineProperty.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

module.exports = _defineProperty;

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/esm/arrayLikeToArray.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/esm/arrayLikeToArray.js ***!
  \*********************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return _arrayLikeToArray; });
function _arrayLikeToArray(arr, len) {
  if (len == null || len > arr.length) len = arr.length;

  for (var i = 0, arr2 = new Array(len); i < len; i++) {
    arr2[i] = arr[i];
  }

  return arr2;
}

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/esm/arrayWithHoles.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/esm/arrayWithHoles.js ***!
  \*******************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return _arrayWithHoles; });
function _arrayWithHoles(arr) {
  if (Array.isArray(arr)) return arr;
}

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/esm/arrayWithoutHoles.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/esm/arrayWithoutHoles.js ***!
  \**********************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return _arrayWithoutHoles; });
/* harmony import */ var _babel_runtime_helpers_esm_arrayLikeToArray__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/esm/arrayLikeToArray */ "./node_modules/@babel/runtime/helpers/esm/arrayLikeToArray.js");

function _arrayWithoutHoles(arr) {
  if (Array.isArray(arr)) return Object(_babel_runtime_helpers_esm_arrayLikeToArray__WEBPACK_IMPORTED_MODULE_0__["default"])(arr);
}

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js ***!
  \*********************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return _asyncToGenerator; });
function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
  try {
    var info = gen[key](arg);
    var value = info.value;
  } catch (error) {
    reject(error);
    return;
  }

  if (info.done) {
    resolve(value);
  } else {
    Promise.resolve(value).then(_next, _throw);
  }
}

function _asyncToGenerator(fn) {
  return function () {
    var self = this,
        args = arguments;
    return new Promise(function (resolve, reject) {
      var gen = fn.apply(self, args);

      function _next(value) {
        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
      }

      function _throw(err) {
        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
      }

      _next(undefined);
    });
  };
}

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/esm/defineProperty.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/esm/defineProperty.js ***!
  \*******************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return _defineProperty; });
function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/esm/extends.js":
/*!************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/esm/extends.js ***!
  \************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return _extends; });
function _extends() {
  _extends = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };

  return _extends.apply(this, arguments);
}

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/esm/iterableToArray.js":
/*!********************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/esm/iterableToArray.js ***!
  \********************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return _iterableToArray; });
function _iterableToArray(iter) {
  if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter)) return Array.from(iter);
}

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/esm/iterableToArrayLimit.js":
/*!*************************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/esm/iterableToArrayLimit.js ***!
  \*************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return _iterableToArrayLimit; });
function _iterableToArrayLimit(arr, i) {
  if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr))) return;
  var _arr = [];
  var _n = true;
  var _d = false;
  var _e = undefined;

  try {
    for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
      _arr.push(_s.value);

      if (i && _arr.length === i) break;
    }
  } catch (err) {
    _d = true;
    _e = err;
  } finally {
    try {
      if (!_n && _i["return"] != null) _i["return"]();
    } finally {
      if (_d) throw _e;
    }
  }

  return _arr;
}

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/esm/nonIterableRest.js":
/*!********************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/esm/nonIterableRest.js ***!
  \********************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return _nonIterableRest; });
function _nonIterableRest() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/esm/nonIterableSpread.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/esm/nonIterableSpread.js ***!
  \**********************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return _nonIterableSpread; });
function _nonIterableSpread() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/esm/objectWithoutProperties.js":
/*!****************************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/esm/objectWithoutProperties.js ***!
  \****************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return _objectWithoutProperties; });
/* harmony import */ var _babel_runtime_helpers_esm_objectWithoutPropertiesLoose__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/esm/objectWithoutPropertiesLoose */ "./node_modules/@babel/runtime/helpers/esm/objectWithoutPropertiesLoose.js");

function _objectWithoutProperties(source, excluded) {
  if (source == null) return {};
  var target = Object(_babel_runtime_helpers_esm_objectWithoutPropertiesLoose__WEBPACK_IMPORTED_MODULE_0__["default"])(source, excluded);
  var key, i;

  if (Object.getOwnPropertySymbols) {
    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);

    for (i = 0; i < sourceSymbolKeys.length; i++) {
      key = sourceSymbolKeys[i];
      if (excluded.indexOf(key) >= 0) continue;
      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
      target[key] = source[key];
    }
  }

  return target;
}

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/esm/objectWithoutPropertiesLoose.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/esm/objectWithoutPropertiesLoose.js ***!
  \*********************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return _objectWithoutPropertiesLoose; });
function _objectWithoutPropertiesLoose(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;

  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }

  return target;
}

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/esm/slicedToArray.js":
/*!******************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/esm/slicedToArray.js ***!
  \******************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return _slicedToArray; });
/* harmony import */ var _babel_runtime_helpers_esm_arrayWithHoles__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/esm/arrayWithHoles */ "./node_modules/@babel/runtime/helpers/esm/arrayWithHoles.js");
/* harmony import */ var _babel_runtime_helpers_esm_iterableToArrayLimit__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @babel/runtime/helpers/esm/iterableToArrayLimit */ "./node_modules/@babel/runtime/helpers/esm/iterableToArrayLimit.js");
/* harmony import */ var _babel_runtime_helpers_esm_unsupportedIterableToArray__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @babel/runtime/helpers/esm/unsupportedIterableToArray */ "./node_modules/@babel/runtime/helpers/esm/unsupportedIterableToArray.js");
/* harmony import */ var _babel_runtime_helpers_esm_nonIterableRest__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @babel/runtime/helpers/esm/nonIterableRest */ "./node_modules/@babel/runtime/helpers/esm/nonIterableRest.js");




function _slicedToArray(arr, i) {
  return Object(_babel_runtime_helpers_esm_arrayWithHoles__WEBPACK_IMPORTED_MODULE_0__["default"])(arr) || Object(_babel_runtime_helpers_esm_iterableToArrayLimit__WEBPACK_IMPORTED_MODULE_1__["default"])(arr, i) || Object(_babel_runtime_helpers_esm_unsupportedIterableToArray__WEBPACK_IMPORTED_MODULE_2__["default"])(arr, i) || Object(_babel_runtime_helpers_esm_nonIterableRest__WEBPACK_IMPORTED_MODULE_3__["default"])();
}

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/esm/toConsumableArray.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/esm/toConsumableArray.js ***!
  \**********************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return _toConsumableArray; });
/* harmony import */ var _babel_runtime_helpers_esm_arrayWithoutHoles__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/esm/arrayWithoutHoles */ "./node_modules/@babel/runtime/helpers/esm/arrayWithoutHoles.js");
/* harmony import */ var _babel_runtime_helpers_esm_iterableToArray__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @babel/runtime/helpers/esm/iterableToArray */ "./node_modules/@babel/runtime/helpers/esm/iterableToArray.js");
/* harmony import */ var _babel_runtime_helpers_esm_unsupportedIterableToArray__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @babel/runtime/helpers/esm/unsupportedIterableToArray */ "./node_modules/@babel/runtime/helpers/esm/unsupportedIterableToArray.js");
/* harmony import */ var _babel_runtime_helpers_esm_nonIterableSpread__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @babel/runtime/helpers/esm/nonIterableSpread */ "./node_modules/@babel/runtime/helpers/esm/nonIterableSpread.js");




function _toConsumableArray(arr) {
  return Object(_babel_runtime_helpers_esm_arrayWithoutHoles__WEBPACK_IMPORTED_MODULE_0__["default"])(arr) || Object(_babel_runtime_helpers_esm_iterableToArray__WEBPACK_IMPORTED_MODULE_1__["default"])(arr) || Object(_babel_runtime_helpers_esm_unsupportedIterableToArray__WEBPACK_IMPORTED_MODULE_2__["default"])(arr) || Object(_babel_runtime_helpers_esm_nonIterableSpread__WEBPACK_IMPORTED_MODULE_3__["default"])();
}

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/esm/unsupportedIterableToArray.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/esm/unsupportedIterableToArray.js ***!
  \*******************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return _unsupportedIterableToArray; });
/* harmony import */ var _babel_runtime_helpers_esm_arrayLikeToArray__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/esm/arrayLikeToArray */ "./node_modules/@babel/runtime/helpers/esm/arrayLikeToArray.js");

function _unsupportedIterableToArray(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return Object(_babel_runtime_helpers_esm_arrayLikeToArray__WEBPACK_IMPORTED_MODULE_0__["default"])(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor) n = o.constructor.name;
  if (n === "Map" || n === "Set") return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return Object(_babel_runtime_helpers_esm_arrayLikeToArray__WEBPACK_IMPORTED_MODULE_0__["default"])(o, minLen);
}

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/getPrototypeOf.js":
/*!***************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/getPrototypeOf.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

function _getPrototypeOf(o) {
  module.exports = _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
    return o.__proto__ || Object.getPrototypeOf(o);
  };
  return _getPrototypeOf(o);
}

module.exports = _getPrototypeOf;

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/inherits.js":
/*!*********************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/inherits.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var setPrototypeOf = __webpack_require__(/*! ./setPrototypeOf */ "./node_modules/@babel/runtime/helpers/setPrototypeOf.js");

function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }

  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      writable: true,
      configurable: true
    }
  });
  if (superClass) setPrototypeOf(subClass, superClass);
}

module.exports = _inherits;

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/interopRequireDefault.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/interopRequireDefault.js ***!
  \**********************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    "default": obj
  };
}

module.exports = _interopRequireDefault;

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/interopRequireWildcard.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/interopRequireWildcard.js ***!
  \***********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var _typeof = __webpack_require__(/*! @babel/runtime/helpers/typeof */ "./node_modules/@babel/runtime/helpers/typeof.js");

function _getRequireWildcardCache() {
  if (typeof WeakMap !== "function") return null;
  var cache = new WeakMap();

  _getRequireWildcardCache = function _getRequireWildcardCache() {
    return cache;
  };

  return cache;
}

function _interopRequireWildcard(obj) {
  if (obj && obj.__esModule) {
    return obj;
  }

  if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") {
    return {
      "default": obj
    };
  }

  var cache = _getRequireWildcardCache();

  if (cache && cache.has(obj)) {
    return cache.get(obj);
  }

  var newObj = {};
  var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;

  for (var key in obj) {
    if (Object.prototype.hasOwnProperty.call(obj, key)) {
      var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;

      if (desc && (desc.get || desc.set)) {
        Object.defineProperty(newObj, key, desc);
      } else {
        newObj[key] = obj[key];
      }
    }
  }

  newObj["default"] = obj;

  if (cache) {
    cache.set(obj, newObj);
  }

  return newObj;
}

module.exports = _interopRequireWildcard;

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/isNativeReflectConstruct.js":
/*!*************************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/isNativeReflectConstruct.js ***!
  \*************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

function _isNativeReflectConstruct() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;

  try {
    Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));
    return true;
  } catch (e) {
    return false;
  }
}

module.exports = _isNativeReflectConstruct;

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/iterableToArray.js":
/*!****************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/iterableToArray.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

function _iterableToArray(iter) {
  if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter)) return Array.from(iter);
}

module.exports = _iterableToArray;

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/iterableToArrayLimit.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/iterableToArrayLimit.js ***!
  \*********************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

function _iterableToArrayLimit(arr, i) {
  if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr))) return;
  var _arr = [];
  var _n = true;
  var _d = false;
  var _e = undefined;

  try {
    for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
      _arr.push(_s.value);

      if (i && _arr.length === i) break;
    }
  } catch (err) {
    _d = true;
    _e = err;
  } finally {
    try {
      if (!_n && _i["return"] != null) _i["return"]();
    } finally {
      if (_d) throw _e;
    }
  }

  return _arr;
}

module.exports = _iterableToArrayLimit;

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/nonIterableRest.js":
/*!****************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/nonIterableRest.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

function _nonIterableRest() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}

module.exports = _nonIterableRest;

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/nonIterableSpread.js":
/*!******************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/nonIterableSpread.js ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

function _nonIterableSpread() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}

module.exports = _nonIterableSpread;

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/possibleConstructorReturn.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/possibleConstructorReturn.js ***!
  \**************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var _typeof = __webpack_require__(/*! @babel/runtime/helpers/typeof */ "./node_modules/@babel/runtime/helpers/typeof.js");

var assertThisInitialized = __webpack_require__(/*! ./assertThisInitialized */ "./node_modules/@babel/runtime/helpers/assertThisInitialized.js");

function _possibleConstructorReturn(self, call) {
  if (call && (_typeof(call) === "object" || typeof call === "function")) {
    return call;
  }

  return assertThisInitialized(self);
}

module.exports = _possibleConstructorReturn;

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/setPrototypeOf.js":
/*!***************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/setPrototypeOf.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

function _setPrototypeOf(o, p) {
  module.exports = _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  };

  return _setPrototypeOf(o, p);
}

module.exports = _setPrototypeOf;

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/slicedToArray.js":
/*!**************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/slicedToArray.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var arrayWithHoles = __webpack_require__(/*! ./arrayWithHoles */ "./node_modules/@babel/runtime/helpers/arrayWithHoles.js");

var iterableToArrayLimit = __webpack_require__(/*! ./iterableToArrayLimit */ "./node_modules/@babel/runtime/helpers/iterableToArrayLimit.js");

var unsupportedIterableToArray = __webpack_require__(/*! ./unsupportedIterableToArray */ "./node_modules/@babel/runtime/helpers/unsupportedIterableToArray.js");

var nonIterableRest = __webpack_require__(/*! ./nonIterableRest */ "./node_modules/@babel/runtime/helpers/nonIterableRest.js");

function _slicedToArray(arr, i) {
  return arrayWithHoles(arr) || iterableToArrayLimit(arr, i) || unsupportedIterableToArray(arr, i) || nonIterableRest();
}

module.exports = _slicedToArray;

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/toConsumableArray.js":
/*!******************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/toConsumableArray.js ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var arrayWithoutHoles = __webpack_require__(/*! ./arrayWithoutHoles */ "./node_modules/@babel/runtime/helpers/arrayWithoutHoles.js");

var iterableToArray = __webpack_require__(/*! ./iterableToArray */ "./node_modules/@babel/runtime/helpers/iterableToArray.js");

var unsupportedIterableToArray = __webpack_require__(/*! ./unsupportedIterableToArray */ "./node_modules/@babel/runtime/helpers/unsupportedIterableToArray.js");

var nonIterableSpread = __webpack_require__(/*! ./nonIterableSpread */ "./node_modules/@babel/runtime/helpers/nonIterableSpread.js");

function _toConsumableArray(arr) {
  return arrayWithoutHoles(arr) || iterableToArray(arr) || unsupportedIterableToArray(arr) || nonIterableSpread();
}

module.exports = _toConsumableArray;

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/typeof.js":
/*!*******************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/typeof.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

function _typeof(obj) {
  "@babel/helpers - typeof";

  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    module.exports = _typeof = function _typeof(obj) {
      return typeof obj;
    };
  } else {
    module.exports = _typeof = function _typeof(obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };
  }

  return _typeof(obj);
}

module.exports = _typeof;

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/unsupportedIterableToArray.js":
/*!***************************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/unsupportedIterableToArray.js ***!
  \***************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var arrayLikeToArray = __webpack_require__(/*! ./arrayLikeToArray */ "./node_modules/@babel/runtime/helpers/arrayLikeToArray.js");

function _unsupportedIterableToArray(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return arrayLikeToArray(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor) n = o.constructor.name;
  if (n === "Map" || n === "Set") return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return arrayLikeToArray(o, minLen);
}

module.exports = _unsupportedIterableToArray;

/***/ }),

/***/ "./node_modules/@babel/runtime/regenerator/index.js":
/*!**********************************************************!*\
  !*** ./node_modules/@babel/runtime/regenerator/index.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(/*! regenerator-runtime */ "./node_modules/regenerator-runtime/runtime.js");


/***/ }),

/***/ "./node_modules/@prefresh/core/src/computeKey.js":
/*!*******************************************************!*\
  !*** ./node_modules/@prefresh/core/src/computeKey.js ***!
  \*******************************************************/
/*! exports provided: computeKey */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "computeKey", function() { return computeKey; });
/* harmony import */ var _runtime_signaturesForType__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./runtime/signaturesForType */ "./node_modules/@prefresh/core/src/runtime/signaturesForType.js");


/**
 *
 * This part has been vendored from "react-refresh"
 * https://github.com/facebook/react/blob/master/packages/react-refresh/src/ReactFreshRuntime.js#L83
 */
const computeKey = signature => {
  let fullKey = signature.key;
  let hooks;

  try {
    hooks = signature.getCustomHooks();
  } catch (err) {
    signature.forceReset = true;
    return fullKey;
  }

  for (let i = 0; i < hooks.length; i++) {
    const hook = hooks[i];
    if (typeof hook !== 'function') {
      signature.forceReset = true;
      return fullKey;
    }

    const nestedHookSignature = _runtime_signaturesForType__WEBPACK_IMPORTED_MODULE_0__["signaturesForType"].get(hook);
    if (nestedHookSignature === undefined) continue;

    const nestedHookKey = computeKey(nestedHookSignature);
    if (nestedHookSignature.forceReset) signature.forceReset = true;

    fullKey += '\n---\n' + nestedHookKey;
  }

  return fullKey;
};


/***/ }),

/***/ "./node_modules/@prefresh/core/src/constants.js":
/*!******************************************************!*\
  !*** ./node_modules/@prefresh/core/src/constants.js ***!
  \******************************************************/
/*! exports provided: VNODE_COMPONENT, NAMESPACE, COMPONENT_HOOKS, HOOKS_LIST, EFFECTS_LIST, RERENDER_COUNT, CATCH_ERROR_OPTION, COMPONENT_DIRTY, VNODE_DOM, VNODE_CHILDREN, HOOK_VALUE, HOOK_ARGS, HOOK_CLEANUP */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "VNODE_COMPONENT", function() { return VNODE_COMPONENT; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "NAMESPACE", function() { return NAMESPACE; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "COMPONENT_HOOKS", function() { return COMPONENT_HOOKS; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "HOOKS_LIST", function() { return HOOKS_LIST; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "EFFECTS_LIST", function() { return EFFECTS_LIST; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RERENDER_COUNT", function() { return RERENDER_COUNT; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CATCH_ERROR_OPTION", function() { return CATCH_ERROR_OPTION; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "COMPONENT_DIRTY", function() { return COMPONENT_DIRTY; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "VNODE_DOM", function() { return VNODE_DOM; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "VNODE_CHILDREN", function() { return VNODE_CHILDREN; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "HOOK_VALUE", function() { return HOOK_VALUE; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "HOOK_ARGS", function() { return HOOK_ARGS; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "HOOK_CLEANUP", function() { return HOOK_CLEANUP; });
const VNODE_COMPONENT = '__c';
const NAMESPACE = '__PREFRESH__';
const COMPONENT_HOOKS = '__H';
const HOOKS_LIST = '__';
const EFFECTS_LIST = '__h';
const RERENDER_COUNT = '__r';
const CATCH_ERROR_OPTION = '__e';
const COMPONENT_DIRTY = '__d';
const VNODE_DOM = '__e';
const VNODE_CHILDREN = '__k';
const HOOK_VALUE = '__';
const HOOK_ARGS = '__H';
const HOOK_CLEANUP = '__c';


/***/ }),

/***/ "./node_modules/@prefresh/core/src/index.js":
/*!**************************************************!*\
  !*** ./node_modules/@prefresh/core/src/index.js ***!
  \**************************************************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _runtime_catchError__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./runtime/catchError */ "./node_modules/@prefresh/core/src/runtime/catchError.js");
/* harmony import */ var _runtime_debounceRendering__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./runtime/debounceRendering */ "./node_modules/@prefresh/core/src/runtime/debounceRendering.js");
/* harmony import */ var _runtime_vnode__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./runtime/vnode */ "./node_modules/@prefresh/core/src/runtime/vnode.js");
/* harmony import */ var _runtime_unmount__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./runtime/unmount */ "./node_modules/@prefresh/core/src/runtime/unmount.js");
/* harmony import */ var preact__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! preact */ "./node_modules/preact/dist/preact.module.js");
/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./constants */ "./node_modules/@prefresh/core/src/constants.js");
/* harmony import */ var _computeKey__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./computeKey */ "./node_modules/@prefresh/core/src/computeKey.js");
/* harmony import */ var _runtime_vnodesForComponent__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./runtime/vnodesForComponent */ "./node_modules/@prefresh/core/src/runtime/vnodesForComponent.js");
/* harmony import */ var _runtime_signaturesForType__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./runtime/signaturesForType */ "./node_modules/@prefresh/core/src/runtime/signaturesForType.js");
// Options for Preact.












let typesById = new Map();
let pendingUpdates = [];

function sign(type, key, forceReset, getCustomHooks, status) {
  if (type) {
    let signature = _runtime_signaturesForType__WEBPACK_IMPORTED_MODULE_8__["signaturesForType"].get(type);
    if (status === 'begin') {
      _runtime_signaturesForType__WEBPACK_IMPORTED_MODULE_8__["signaturesForType"].set(type, {
        type,
        key,
        forceReset,
        getCustomHooks: getCustomHooks || (() => []),
      });

      return 'needsHooks';
    } else if (status === 'needsHooks') {
      signature.fullKey = Object(_computeKey__WEBPACK_IMPORTED_MODULE_6__["computeKey"])(signature);
    }
  }
}

function replaceComponent(OldType, NewType, resetHookState) {
  const vnodes = _runtime_vnodesForComponent__WEBPACK_IMPORTED_MODULE_7__["vnodesForComponent"].get(OldType);
  if (!vnodes) return;

  // migrate the list to our new constructor reference
  _runtime_vnodesForComponent__WEBPACK_IMPORTED_MODULE_7__["vnodesForComponent"].delete(OldType);
  _runtime_vnodesForComponent__WEBPACK_IMPORTED_MODULE_7__["vnodesForComponent"].set(NewType, vnodes);

  _runtime_vnodesForComponent__WEBPACK_IMPORTED_MODULE_7__["mappedVNodes"].set(OldType, NewType);

  pendingUpdates = pendingUpdates.filter(p => p[0] !== OldType);

  vnodes.forEach(vnode => {
    // update the type in-place to reference the new component
    vnode.type = NewType;

    if (vnode[_constants__WEBPACK_IMPORTED_MODULE_5__["VNODE_COMPONENT"]]) {
      vnode[_constants__WEBPACK_IMPORTED_MODULE_5__["VNODE_COMPONENT"]].constructor = vnode.type;

      try {
        if (vnode[_constants__WEBPACK_IMPORTED_MODULE_5__["VNODE_COMPONENT"]] instanceof OldType) {
          const oldInst = vnode[_constants__WEBPACK_IMPORTED_MODULE_5__["VNODE_COMPONENT"]];

          const newInst = new NewType(
            vnode[_constants__WEBPACK_IMPORTED_MODULE_5__["VNODE_COMPONENT"]].props,
            vnode[_constants__WEBPACK_IMPORTED_MODULE_5__["VNODE_COMPONENT"]].context
          );

          vnode[_constants__WEBPACK_IMPORTED_MODULE_5__["VNODE_COMPONENT"]] = newInst;
          // copy old properties onto the new instance.
          //   - Objects (including refs) in the new instance are updated with their old values
          //   - Missing or null properties are restored to their old values
          //   - Updated Functions are not reverted
          //   - Scalars are copied
          for (let i in oldInst) {
            const type = typeof oldInst[i];
            if (!(i in newInst)) {
              newInst[i] = oldInst[i];
            } else if (type !== 'function' && typeof newInst[i] === type) {
              if (
                type === 'object' &&
                newInst[i] != null &&
                newInst[i].constructor === oldInst[i].constructor
              ) {
                Object.assign(newInst[i], oldInst[i]);
              } else {
                newInst[i] = oldInst[i];
              }
            }
          }
        }
      } catch (e) {
        /* Functional component */
        vnode[_constants__WEBPACK_IMPORTED_MODULE_5__["VNODE_COMPONENT"]].constructor = NewType;
      }

      if (resetHookState) {
        if (
          vnode[_constants__WEBPACK_IMPORTED_MODULE_5__["VNODE_COMPONENT"]][_constants__WEBPACK_IMPORTED_MODULE_5__["COMPONENT_HOOKS"]] &&
          vnode[_constants__WEBPACK_IMPORTED_MODULE_5__["VNODE_COMPONENT"]][_constants__WEBPACK_IMPORTED_MODULE_5__["COMPONENT_HOOKS"]][_constants__WEBPACK_IMPORTED_MODULE_5__["HOOKS_LIST"]] &&
          vnode[_constants__WEBPACK_IMPORTED_MODULE_5__["VNODE_COMPONENT"]][_constants__WEBPACK_IMPORTED_MODULE_5__["COMPONENT_HOOKS"]][_constants__WEBPACK_IMPORTED_MODULE_5__["HOOKS_LIST"]].length
        ) {
          vnode[_constants__WEBPACK_IMPORTED_MODULE_5__["VNODE_COMPONENT"]][_constants__WEBPACK_IMPORTED_MODULE_5__["COMPONENT_HOOKS"]][_constants__WEBPACK_IMPORTED_MODULE_5__["HOOKS_LIST"]].forEach(
            possibleEffect => {
              if (
                possibleEffect[_constants__WEBPACK_IMPORTED_MODULE_5__["HOOK_CLEANUP"]] &&
                typeof possibleEffect[_constants__WEBPACK_IMPORTED_MODULE_5__["HOOK_CLEANUP"]] === 'function'
              ) {
                possibleEffect[_constants__WEBPACK_IMPORTED_MODULE_5__["HOOK_CLEANUP"]]();
              } else if (
                possibleEffect[_constants__WEBPACK_IMPORTED_MODULE_5__["HOOK_ARGS"]] &&
                possibleEffect[_constants__WEBPACK_IMPORTED_MODULE_5__["HOOK_VALUE"]] &&
                Object.keys(possibleEffect).length === 3
              ) {
                const cleanupKey = Object.keys(possibleEffect).find(
                  key => key !== _constants__WEBPACK_IMPORTED_MODULE_5__["HOOK_ARGS"] && key !== _constants__WEBPACK_IMPORTED_MODULE_5__["HOOK_VALUE"]
                );
                if (
                  cleanupKey &&
                  typeof possibleEffect[cleanupKey] == 'function'
                )
                  possibleEffect[cleanupKey]();
              }
            }
          );
        }

        vnode[_constants__WEBPACK_IMPORTED_MODULE_5__["VNODE_COMPONENT"]][_constants__WEBPACK_IMPORTED_MODULE_5__["COMPONENT_HOOKS"]] = {
          [_constants__WEBPACK_IMPORTED_MODULE_5__["HOOKS_LIST"]]: [],
          [_constants__WEBPACK_IMPORTED_MODULE_5__["EFFECTS_LIST"]]: [],
        };
      } else {
        if (
          vnode[_constants__WEBPACK_IMPORTED_MODULE_5__["VNODE_COMPONENT"]][_constants__WEBPACK_IMPORTED_MODULE_5__["COMPONENT_HOOKS"]] &&
          vnode[_constants__WEBPACK_IMPORTED_MODULE_5__["VNODE_COMPONENT"]][_constants__WEBPACK_IMPORTED_MODULE_5__["COMPONENT_HOOKS"]][_constants__WEBPACK_IMPORTED_MODULE_5__["HOOKS_LIST"]] &&
          vnode[_constants__WEBPACK_IMPORTED_MODULE_5__["VNODE_COMPONENT"]][_constants__WEBPACK_IMPORTED_MODULE_5__["COMPONENT_HOOKS"]][_constants__WEBPACK_IMPORTED_MODULE_5__["HOOKS_LIST"]].length
        ) {
          vnode[_constants__WEBPACK_IMPORTED_MODULE_5__["VNODE_COMPONENT"]][_constants__WEBPACK_IMPORTED_MODULE_5__["COMPONENT_HOOKS"]][_constants__WEBPACK_IMPORTED_MODULE_5__["HOOKS_LIST"]].forEach(
            possibleEffect => {
              if (
                possibleEffect[_constants__WEBPACK_IMPORTED_MODULE_5__["HOOK_CLEANUP"]] &&
                typeof possibleEffect[_constants__WEBPACK_IMPORTED_MODULE_5__["HOOK_CLEANUP"]] === 'function'
              ) {
                possibleEffect[_constants__WEBPACK_IMPORTED_MODULE_5__["HOOK_CLEANUP"]]();
              } else if (
                possibleEffect[_constants__WEBPACK_IMPORTED_MODULE_5__["HOOK_ARGS"]] &&
                possibleEffect[_constants__WEBPACK_IMPORTED_MODULE_5__["HOOK_VALUE"]] &&
                Object.keys(possibleEffect).length === 3
              ) {
                const cleanupKey = Object.keys(possibleEffect).find(
                  key => key !== _constants__WEBPACK_IMPORTED_MODULE_5__["HOOK_ARGS"] && key !== _constants__WEBPACK_IMPORTED_MODULE_5__["HOOK_VALUE"]
                );
                if (
                  cleanupKey &&
                  typeof possibleEffect[cleanupKey] == 'function'
                )
                  possibleEffect[cleanupKey]();
              }
            }
          );

          vnode[_constants__WEBPACK_IMPORTED_MODULE_5__["VNODE_COMPONENT"]][_constants__WEBPACK_IMPORTED_MODULE_5__["COMPONENT_HOOKS"]][_constants__WEBPACK_IMPORTED_MODULE_5__["HOOKS_LIST"]].forEach(
            hook => {
              if (
                hook.__H &&
                Array.isArray(hook.__H)
              ) {
                hook.__H = undefined;
              }
            }
          );
        }
      }

      // Cleanup when an async component has thrown.
      if (
        (vnode[_constants__WEBPACK_IMPORTED_MODULE_5__["VNODE_DOM"]] && !document.contains(vnode[_constants__WEBPACK_IMPORTED_MODULE_5__["VNODE_DOM"]])) ||
        (!vnode[_constants__WEBPACK_IMPORTED_MODULE_5__["VNODE_DOM"]] && !vnode[_constants__WEBPACK_IMPORTED_MODULE_5__["VNODE_CHILDREN"]])
      ) {
        location.reload();
      }

      preact__WEBPACK_IMPORTED_MODULE_4__["Component"].prototype.forceUpdate.call(vnode[_constants__WEBPACK_IMPORTED_MODULE_5__["VNODE_COMPONENT"]]);
    }
  });
}

self[_constants__WEBPACK_IMPORTED_MODULE_5__["NAMESPACE"]] = {
  getSignature: type => _runtime_signaturesForType__WEBPACK_IMPORTED_MODULE_8__["signaturesForType"].get(type),
  register: (type, id) => {
    if (typeof type !== 'function') return;

    if (typesById.has(id)) {
      const existing = typesById.get(id);
      if (existing !== type) {
        pendingUpdates.push([existing, type]);
        typesById.set(id, type);
      }
    } else {
      typesById.set(id, type);
    }

    if (!_runtime_signaturesForType__WEBPACK_IMPORTED_MODULE_8__["signaturesForType"].has(type)) {
      _runtime_signaturesForType__WEBPACK_IMPORTED_MODULE_8__["signaturesForType"].set(type, {
        getCustomHooks: () => [],
        type,
      });
    }
  },
  getPendingUpdates: () => pendingUpdates,
  flush: () => {
    pendingUpdates = [];
  },
  replaceComponent,
  sign,
  computeKey: _computeKey__WEBPACK_IMPORTED_MODULE_6__["computeKey"],
};


/***/ }),

/***/ "./node_modules/@prefresh/core/src/runtime/catchError.js":
/*!***************************************************************!*\
  !*** ./node_modules/@prefresh/core/src/runtime/catchError.js ***!
  \***************************************************************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var preact__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! preact */ "./node_modules/preact/dist/preact.module.js");
/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../constants */ "./node_modules/@prefresh/core/src/constants.js");



const oldCatchError = preact__WEBPACK_IMPORTED_MODULE_0__["options"][_constants__WEBPACK_IMPORTED_MODULE_1__["CATCH_ERROR_OPTION"]];
preact__WEBPACK_IMPORTED_MODULE_0__["options"][_constants__WEBPACK_IMPORTED_MODULE_1__["CATCH_ERROR_OPTION"]] = (error, vnode, oldVNode) => {
  if (vnode[_constants__WEBPACK_IMPORTED_MODULE_1__["VNODE_COMPONENT"]] && vnode[_constants__WEBPACK_IMPORTED_MODULE_1__["VNODE_COMPONENT"]][_constants__WEBPACK_IMPORTED_MODULE_1__["COMPONENT_DIRTY"]]) {
    vnode[_constants__WEBPACK_IMPORTED_MODULE_1__["VNODE_COMPONENT"]][_constants__WEBPACK_IMPORTED_MODULE_1__["COMPONENT_DIRTY"]] = false;
  }

  if (oldCatchError) oldCatchError(error, vnode, oldVNode);
};


/***/ }),

/***/ "./node_modules/@prefresh/core/src/runtime/debounceRendering.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@prefresh/core/src/runtime/debounceRendering.js ***!
  \**********************************************************************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var preact__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! preact */ "./node_modules/preact/dist/preact.module.js");
/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../constants */ "./node_modules/@prefresh/core/src/constants.js");




const defer =
  typeof Promise == 'function'
    ? Promise.prototype.then.bind(Promise.resolve())
    : setTimeout;

preact__WEBPACK_IMPORTED_MODULE_0__["options"].debounceRendering = process => {
  defer(() => {
    try {
      process();
    } catch (e) {
      process[_constants__WEBPACK_IMPORTED_MODULE_1__["RERENDER_COUNT"]] = 0;
      throw e;
    }
  });
};


/***/ }),

/***/ "./node_modules/@prefresh/core/src/runtime/signaturesForType.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@prefresh/core/src/runtime/signaturesForType.js ***!
  \**********************************************************************/
/*! exports provided: signaturesForType */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "signaturesForType", function() { return signaturesForType; });
// Signatures for functional components and custom hooks.
const signaturesForType = new WeakMap();


/***/ }),

/***/ "./node_modules/@prefresh/core/src/runtime/unmount.js":
/*!************************************************************!*\
  !*** ./node_modules/@prefresh/core/src/runtime/unmount.js ***!
  \************************************************************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var preact__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! preact */ "./node_modules/preact/dist/preact.module.js");
/* harmony import */ var _vnodesForComponent__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./vnodesForComponent */ "./node_modules/@prefresh/core/src/runtime/vnodesForComponent.js");



const oldUnmount = preact__WEBPACK_IMPORTED_MODULE_0__["options"].unmount;
preact__WEBPACK_IMPORTED_MODULE_0__["options"].unmount = vnode => {
  const type = (vnode || {}).type;
  if (typeof type === 'function' && _vnodesForComponent__WEBPACK_IMPORTED_MODULE_1__["vnodesForComponent"].has(type)) {
    const vnodes = _vnodesForComponent__WEBPACK_IMPORTED_MODULE_1__["vnodesForComponent"].get(type);
    if (vnodes) {
      const index = vnodes.indexOf(vnode);
      if (index !== -1) {
        vnodes.splice(index, 1);
      }
    }
  }

  if (oldUnmount) oldUnmount(vnode);
};


/***/ }),

/***/ "./node_modules/@prefresh/core/src/runtime/vnode.js":
/*!**********************************************************!*\
  !*** ./node_modules/@prefresh/core/src/runtime/vnode.js ***!
  \**********************************************************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var preact__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! preact */ "./node_modules/preact/dist/preact.module.js");
/* harmony import */ var _vnodesForComponent__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./vnodesForComponent */ "./node_modules/@prefresh/core/src/runtime/vnodesForComponent.js");
/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../constants */ "./node_modules/@prefresh/core/src/constants.js");




const getMappedVnode = type => {
  if (_vnodesForComponent__WEBPACK_IMPORTED_MODULE_1__["mappedVNodes"].has(type)) {
    return getMappedVnode(_vnodesForComponent__WEBPACK_IMPORTED_MODULE_1__["mappedVNodes"].get(type));
  }

  return type;
};

const oldVnode = preact__WEBPACK_IMPORTED_MODULE_0__["options"].vnode;
preact__WEBPACK_IMPORTED_MODULE_0__["options"].vnode = vnode => {
  if (vnode && typeof vnode.type === 'function') {
    const vnodes = _vnodesForComponent__WEBPACK_IMPORTED_MODULE_1__["vnodesForComponent"].get(vnode.type);
    if (!vnodes) {
      _vnodesForComponent__WEBPACK_IMPORTED_MODULE_1__["vnodesForComponent"].set(vnode.type, [vnode]);
    } else {
      vnodes.push(vnode);
    }

    const foundType = getMappedVnode(vnode.type);
    vnode.type = foundType;
    if (vnode[_constants__WEBPACK_IMPORTED_MODULE_2__["VNODE_COMPONENT"]]) {
      vnode[_constants__WEBPACK_IMPORTED_MODULE_2__["VNODE_COMPONENT"]].constructor = foundType;
    }
  }

  if (oldVnode) oldVnode(vnode);
};


/***/ }),

/***/ "./node_modules/@prefresh/core/src/runtime/vnodesForComponent.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@prefresh/core/src/runtime/vnodesForComponent.js ***!
  \***********************************************************************/
/*! exports provided: vnodesForComponent, mappedVNodes */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "vnodesForComponent", function() { return vnodesForComponent; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "mappedVNodes", function() { return mappedVNodes; });
// all vnodes referencing a given constructor
const vnodesForComponent = new WeakMap();
const mappedVNodes = new WeakMap();


/***/ }),

/***/ "./node_modules/@prefresh/utils/src/index.js":
/*!***************************************************!*\
  !*** ./node_modules/@prefresh/utils/src/index.js ***!
  \***************************************************/
/*! exports provided: flush, isComponent */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "flush", function() { return flush; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isComponent", function() { return isComponent; });
const compareSignatures = (prev, next) => {
  const prevSignature = self.__PREFRESH__.getSignature(prev) || {};
  const nextSignature = self.__PREFRESH__.getSignature(next) || {};

  if (
    prevSignature.key !== nextSignature.key ||
    self.__PREFRESH__.computeKey(prevSignature) !==
      self.__PREFRESH__.computeKey(nextSignature) ||
    nextSignature.forceReset
  ) {
    self.__PREFRESH__.replaceComponent(prev, next, true);
  } else {
    self.__PREFRESH__.replaceComponent(prev, next, false);
  }
};

const flush = () => {
  const pending = [...self.__PREFRESH__.getPendingUpdates()];
  self.__PREFRESH__.flush();

  if (pending.length > 0) {
    pending.forEach(([prev, next]) => {
      compareSignatures(prev, next);
    });
  }
};

const isComponent = exportValue => {
  if (typeof exportValue === 'function') {
    if (
      exportValue.prototype != null &&
      exportValue.prototype.isReactComponent
    ) {
      return true;
    }

    const name = exportValue.name || exportValue.displayName;
    return (
      typeof name === 'string' && name[0] && name[0] == name[0].toUpperCase()
    );
  }
  return false;
};


/***/ }),

/***/ "./node_modules/@prefresh/webpack/src/utils/prefresh.js":
/*!**************************************************************!*\
  !*** ./node_modules/@prefresh/webpack/src/utils/prefresh.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

const { isComponent, flush } = __webpack_require__(/*! @prefresh/utils */ "./node_modules/@prefresh/utils/src/index.js");

// eslint-disable-next-line
const getExports = m => m.exports || m.__proto__.exports;

function isSafeExport(key) {
  return (
    key === '__esModule' ||
    key === '__N_SSG' ||
    key === '__N_SSP' ||
    key === 'config'
  );
}

function registerExports(moduleExports, moduleId) {
  self['__PREFRESH__'].register(moduleExports, moduleId + ' %exports%');
  if (moduleExports == null || typeof moduleExports !== 'object') return;

  for (const key in moduleExports) {
    if (isSafeExport(key)) continue;
    const exportValue = moduleExports[key];
    const typeID = moduleId + ' %exports% ' + key;
    self['__PREFRESH__'].register(exportValue, typeID);
  }
}

const shouldBind = m => {
  let isCitizen = false;
  const moduleExports = getExports(m);

  if (isComponent(moduleExports)) {
    isCitizen = true;
  }

  if (
    moduleExports === undefined ||
    moduleExports === null ||
    typeof moduleExports !== 'object'
  ) {
    isCitizen = isCitizen || false;
  } else {
    for (const key in moduleExports) {
      if (key === '__esModule') continue;

      const exportValue = moduleExports[key];
      if (isComponent(exportValue)) {
        isCitizen = isCitizen || true;
      }
    }
  }

  return isCitizen;
};

module.exports = Object.freeze({
  getExports,
  shouldBind,
  flush,
  registerExports,
});


/***/ }),

/***/ "./node_modules/dayjs/dayjs.min.js":
/*!*****************************************!*\
  !*** ./node_modules/dayjs/dayjs.min.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

!function(t,e){ true?module.exports=e():undefined}(this,function(){"use strict";var t="millisecond",e="second",n="minute",r="hour",i="day",s="week",u="month",a="quarter",o="year",f="date",h=/^(\d{4})[-/]?(\d{1,2})?[-/]?(\d{0,2})[^0-9]*(\d{1,2})?:?(\d{1,2})?:?(\d{1,2})?.?(\d+)?$/,c=/\[([^\]]+)]|Y{2,4}|M{1,4}|D{1,2}|d{1,4}|H{1,2}|h{1,2}|a|A|m{1,2}|s{1,2}|Z{1,2}|SSS/g,d={name:"en",weekdays:"Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"),months:"January_February_March_April_May_June_July_August_September_October_November_December".split("_")},$=function(t,e,n){var r=String(t);return!r||r.length>=e?t:""+Array(e+1-r.length).join(n)+t},l={s:$,z:function(t){var e=-t.utcOffset(),n=Math.abs(e),r=Math.floor(n/60),i=n%60;return(e<=0?"+":"-")+$(r,2,"0")+":"+$(i,2,"0")},m:function t(e,n){if(e.date()<n.date())return-t(n,e);var r=12*(n.year()-e.year())+(n.month()-e.month()),i=e.clone().add(r,u),s=n-i<0,a=e.clone().add(r+(s?-1:1),u);return+(-(r+(n-i)/(s?i-a:a-i))||0)},a:function(t){return t<0?Math.ceil(t)||0:Math.floor(t)},p:function(h){return{M:u,y:o,w:s,d:i,D:f,h:r,m:n,s:e,ms:t,Q:a}[h]||String(h||"").toLowerCase().replace(/s$/,"")},u:function(t){return void 0===t}},y="en",M={};M[y]=d;var m=function(t){return t instanceof S},D=function(t,e,n){var r;if(!t)return y;if("string"==typeof t)M[t]&&(r=t),e&&(M[t]=e,r=t);else{var i=t.name;M[i]=t,r=i}return!n&&r&&(y=r),r||!n&&y},v=function(t,e){if(m(t))return t.clone();var n="object"==typeof e?e:{};return n.date=t,n.args=arguments,new S(n)},g=l;g.l=D,g.i=m,g.w=function(t,e){return v(t,{locale:e.$L,utc:e.$u,x:e.$x,$offset:e.$offset})};var S=function(){function d(t){this.$L=D(t.locale,null,!0),this.parse(t)}var $=d.prototype;return $.parse=function(t){this.$d=function(t){var e=t.date,n=t.utc;if(null===e)return new Date(NaN);if(g.u(e))return new Date;if(e instanceof Date)return new Date(e);if("string"==typeof e&&!/Z$/i.test(e)){var r=e.match(h);if(r){var i=r[2]-1||0,s=(r[7]||"0").substring(0,3);return n?new Date(Date.UTC(r[1],i,r[3]||1,r[4]||0,r[5]||0,r[6]||0,s)):new Date(r[1],i,r[3]||1,r[4]||0,r[5]||0,r[6]||0,s)}}return new Date(e)}(t),this.$x=t.x||{},this.init()},$.init=function(){var t=this.$d;this.$y=t.getFullYear(),this.$M=t.getMonth(),this.$D=t.getDate(),this.$W=t.getDay(),this.$H=t.getHours(),this.$m=t.getMinutes(),this.$s=t.getSeconds(),this.$ms=t.getMilliseconds()},$.$utils=function(){return g},$.isValid=function(){return!("Invalid Date"===this.$d.toString())},$.isSame=function(t,e){var n=v(t);return this.startOf(e)<=n&&n<=this.endOf(e)},$.isAfter=function(t,e){return v(t)<this.startOf(e)},$.isBefore=function(t,e){return this.endOf(e)<v(t)},$.$g=function(t,e,n){return g.u(t)?this[e]:this.set(n,t)},$.unix=function(){return Math.floor(this.valueOf()/1e3)},$.valueOf=function(){return this.$d.getTime()},$.startOf=function(t,a){var h=this,c=!!g.u(a)||a,d=g.p(t),$=function(t,e){var n=g.w(h.$u?Date.UTC(h.$y,e,t):new Date(h.$y,e,t),h);return c?n:n.endOf(i)},l=function(t,e){return g.w(h.toDate()[t].apply(h.toDate("s"),(c?[0,0,0,0]:[23,59,59,999]).slice(e)),h)},y=this.$W,M=this.$M,m=this.$D,D="set"+(this.$u?"UTC":"");switch(d){case o:return c?$(1,0):$(31,11);case u:return c?$(1,M):$(0,M+1);case s:var v=this.$locale().weekStart||0,S=(y<v?y+7:y)-v;return $(c?m-S:m+(6-S),M);case i:case f:return l(D+"Hours",0);case r:return l(D+"Minutes",1);case n:return l(D+"Seconds",2);case e:return l(D+"Milliseconds",3);default:return this.clone()}},$.endOf=function(t){return this.startOf(t,!1)},$.$set=function(s,a){var h,c=g.p(s),d="set"+(this.$u?"UTC":""),$=(h={},h[i]=d+"Date",h[f]=d+"Date",h[u]=d+"Month",h[o]=d+"FullYear",h[r]=d+"Hours",h[n]=d+"Minutes",h[e]=d+"Seconds",h[t]=d+"Milliseconds",h)[c],l=c===i?this.$D+(a-this.$W):a;if(c===u||c===o){var y=this.clone().set(f,1);y.$d[$](l),y.init(),this.$d=y.set(f,Math.min(this.$D,y.daysInMonth())).$d}else $&&this.$d[$](l);return this.init(),this},$.set=function(t,e){return this.clone().$set(t,e)},$.get=function(t){return this[g.p(t)]()},$.add=function(t,a){var f,h=this;t=Number(t);var c=g.p(a),d=function(e){var n=v(h);return g.w(n.date(n.date()+Math.round(e*t)),h)};if(c===u)return this.set(u,this.$M+t);if(c===o)return this.set(o,this.$y+t);if(c===i)return d(1);if(c===s)return d(7);var $=(f={},f[n]=6e4,f[r]=36e5,f[e]=1e3,f)[c]||1,l=this.$d.getTime()+t*$;return g.w(l,this)},$.subtract=function(t,e){return this.add(-1*t,e)},$.format=function(t){var e=this;if(!this.isValid())return"Invalid Date";var n=t||"YYYY-MM-DDTHH:mm:ssZ",r=g.z(this),i=this.$locale(),s=this.$H,u=this.$m,a=this.$M,o=i.weekdays,f=i.months,h=function(t,r,i,s){return t&&(t[r]||t(e,n))||i[r].substr(0,s)},d=function(t){return g.s(s%12||12,t,"0")},$=i.meridiem||function(t,e,n){var r=t<12?"AM":"PM";return n?r.toLowerCase():r},l={YY:String(this.$y).slice(-2),YYYY:this.$y,M:a+1,MM:g.s(a+1,2,"0"),MMM:h(i.monthsShort,a,f,3),MMMM:h(f,a),D:this.$D,DD:g.s(this.$D,2,"0"),d:String(this.$W),dd:h(i.weekdaysMin,this.$W,o,2),ddd:h(i.weekdaysShort,this.$W,o,3),dddd:o[this.$W],H:String(s),HH:g.s(s,2,"0"),h:d(1),hh:d(2),a:$(s,u,!0),A:$(s,u,!1),m:String(u),mm:g.s(u,2,"0"),s:String(this.$s),ss:g.s(this.$s,2,"0"),SSS:g.s(this.$ms,3,"0"),Z:r};return n.replace(c,function(t,e){return e||l[t]||r.replace(":","")})},$.utcOffset=function(){return 15*-Math.round(this.$d.getTimezoneOffset()/15)},$.diff=function(t,f,h){var c,d=g.p(f),$=v(t),l=6e4*($.utcOffset()-this.utcOffset()),y=this-$,M=g.m(this,$);return M=(c={},c[o]=M/12,c[u]=M,c[a]=M/3,c[s]=(y-l)/6048e5,c[i]=(y-l)/864e5,c[r]=y/36e5,c[n]=y/6e4,c[e]=y/1e3,c)[d]||y,h?M:g.a(M)},$.daysInMonth=function(){return this.endOf(u).$D},$.$locale=function(){return M[this.$L]},$.locale=function(t,e){if(!t)return this.$L;var n=this.clone(),r=D(t,e,!0);return r&&(n.$L=r),n},$.clone=function(){return g.w(this.$d,this)},$.toDate=function(){return new Date(this.valueOf())},$.toJSON=function(){return this.isValid()?this.toISOString():null},$.toISOString=function(){return this.$d.toISOString()},$.toString=function(){return this.$d.toUTCString()},d}(),p=S.prototype;return v.prototype=p,[["$ms",t],["$s",e],["$m",n],["$H",r],["$W",i],["$M",u],["$y",o],["$D",f]].forEach(function(t){p[t[1]]=function(e){return this.$g(e,t[0],t[1])}}),v.extend=function(t,e){return t(e,S,v),v},v.locale=D,v.isDayjs=m,v.unix=function(t){return v(1e3*t)},v.en=M[y],v.Ls=M,v.p={},v});


/***/ }),

/***/ "./node_modules/dayjs/plugin/localizedFormat.js":
/*!******************************************************!*\
  !*** ./node_modules/dayjs/plugin/localizedFormat.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

!function(e,t){ true?module.exports=t():undefined}(this,function(){"use strict";var e={LTS:"h:mm:ss A",LT:"h:mm A",L:"MM/DD/YYYY",LL:"MMMM D, YYYY",LLL:"MMMM D, YYYY h:mm A",LLLL:"dddd, MMMM D, YYYY h:mm A"};return function(t,n,o){var r=n.prototype,M=r.format;o.en.formats=e,r.format=function(t){void 0===t&&(t="YYYY-MM-DDTHH:mm:ssZ");var n=this.$locale().formats,o=function(t,n){return t.replace(/(\[[^\]]+])|(LTS?|l{1,4}|L{1,4})/g,function(t,o,r){var M=r&&r.toUpperCase();return o||n[r]||e[r]||n[M].replace(/(\[[^\]]+])|(MMMM|MM|DD|dddd)/g,function(e,t,n){return t||n.slice(1)})})}(t,void 0===n?{}:n);return M.call(this,o)}}});


/***/ }),

/***/ "./node_modules/dayjs/plugin/timezone.js":
/*!***********************************************!*\
  !*** ./node_modules/dayjs/plugin/timezone.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

!function(t,e){ true?module.exports=e():undefined}(this,function(){"use strict";var t={year:0,month:1,day:2,hour:3,minute:4,second:5},e={};return function(n,i,o){var r,u=o().utcOffset(),a=function(t,n,i){void 0===i&&(i={});var o=new Date(t);return function(t,n){void 0===n&&(n={});var i=n.timeZoneName||"short",o=t+"|"+i,r=e[o];return r||(r=new Intl.DateTimeFormat("en-US",{hour12:!1,timeZone:t,year:"numeric",month:"2-digit",day:"2-digit",hour:"2-digit",minute:"2-digit",second:"2-digit",timeZoneName:i}),e[o]=r),r}(n,i).formatToParts(o)},f=function(e,n){for(var i=a(e,n),r=[],u=0;u<i.length;u+=1){var f=i[u],s=f.type,m=f.value,c=t[s];c>=0&&(r[c]=parseInt(m,10))}var d=r[3],v=24===d?0:d,h=r[0]+"-"+r[1]+"-"+r[2]+" "+v+":"+r[4]+":"+r[5]+":000",l=+e;return(o.utc(h).valueOf()-(l-=l%1e3))/6e4},s=i.prototype;s.tz=function(t,e){void 0===t&&(t=r);var n=this.utcOffset(),i=this.toDate().toLocaleString("en-US",{timeZone:t}),a=Math.round((this.toDate()-new Date(i))/1e3/60),f=o(i).$set("millisecond",this.$ms).utcOffset(u-a,!0);if(e){var s=f.utcOffset();f=f.add(n-s,"minute")}return f.$x.$timezone=t,f},s.offsetName=function(t){var e=this.$x.$timezone||o.tz.guess(),n=a(this.valueOf(),e,{timeZoneName:t}).find(function(t){return"timezonename"===t.type.toLowerCase()});return n&&n.value},o.tz=function(t,e,n){var i=n&&e,u=n||e||r,a=f(+o(),u);if("string"!=typeof t)return o(t).tz(u);var s=function(t,e,n){var i=t-60*e*1e3,o=f(i,n);if(e===o)return[i,e];var r=f(i-=60*(o-e)*1e3,n);return o===r?[i,o]:[t-60*Math.min(o,r)*1e3,Math.max(o,r)]}(o.utc(t,i).valueOf(),a,u),m=s[0],c=s[1],d=o(m).utcOffset(c);return d.$x.$timezone=u,d},o.tz.guess=function(){return Intl.DateTimeFormat().resolvedOptions().timeZone},o.tz.setDefault=function(t){r=t}}});


/***/ }),

/***/ "./node_modules/dayjs/plugin/utc.js":
/*!******************************************!*\
  !*** ./node_modules/dayjs/plugin/utc.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

!function(t,i){ true?module.exports=i():undefined}(this,function(){"use strict";return function(t,i,e){var s=i.prototype;e.utc=function(t){return new i({date:t,utc:!0,args:arguments})},s.utc=function(t){var i=e(this.toDate(),{locale:this.$L,utc:!0});return t?i.add(this.utcOffset(),"minute"):i},s.local=function(){return e(this.toDate(),{locale:this.$L,utc:!1})};var f=s.parse;s.parse=function(t){t.utc&&(this.$u=!0),this.$utils().u(t.$offset)||(this.$offset=t.$offset),f.call(this,t)};var n=s.init;s.init=function(){if(this.$u){var t=this.$d;this.$y=t.getUTCFullYear(),this.$M=t.getUTCMonth(),this.$D=t.getUTCDate(),this.$W=t.getUTCDay(),this.$H=t.getUTCHours(),this.$m=t.getUTCMinutes(),this.$s=t.getUTCSeconds(),this.$ms=t.getUTCMilliseconds()}else n.call(this)};var u=s.utcOffset;s.utcOffset=function(t,i){var e=this.$utils().u;if(e(t))return this.$u?0:e(this.$offset)?u.call(this):this.$offset;var s=Math.abs(t)<=16?60*t:t,f=this;if(i)return f.$offset=s,f.$u=0===t,f;if(0!==t){var n=this.$u?this.toDate().getTimezoneOffset():-1*this.utcOffset();(f=this.local().add(s+n,"minute")).$offset=s,f.$x.$localOffset=n}else f=this.utc();return f};var o=s.format;s.format=function(t){var i=t||(this.$u?"YYYY-MM-DDTHH:mm:ss[Z]":"");return o.call(this,i)},s.valueOf=function(){var t=this.$utils().u(this.$offset)?0:this.$offset+(this.$x.$localOffset||(new Date).getTimezoneOffset());return this.$d.valueOf()-6e4*t},s.isUTC=function(){return!!this.$u},s.toISOString=function(){return this.toDate().toISOString()},s.toString=function(){return this.toDate().toUTCString()};var r=s.toDate;s.toDate=function(t){return"s"===t&&this.$offset?e(this.format("YYYY-MM-DD HH:mm:ss:SSS")).toDate():r.call(this)};var a=s.diff;s.diff=function(t,i,s){if(this.$u===t.$u)return a.call(this,t,i,s);var f=this.local(),n=e(t).local();return a.call(f,n,i,s)}}});


/***/ }),

/***/ "./node_modules/idb/build/esm/index.js":
/*!*********************************************!*\
  !*** ./node_modules/idb/build/esm/index.js ***!
  \*********************************************/
/*! exports provided: unwrap, wrap, deleteDB, openDB */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "deleteDB", function() { return deleteDB; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "openDB", function() { return openDB; });
/* harmony import */ var _wrap_idb_value_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./wrap-idb-value.js */ "./node_modules/idb/build/esm/wrap-idb-value.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "unwrap", function() { return _wrap_idb_value_js__WEBPACK_IMPORTED_MODULE_0__["u"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "wrap", function() { return _wrap_idb_value_js__WEBPACK_IMPORTED_MODULE_0__["w"]; });




/**
 * Open a database.
 *
 * @param name Name of the database.
 * @param version Schema version.
 * @param callbacks Additional callbacks.
 */
function openDB(name, version, { blocked, upgrade, blocking, terminated } = {}) {
    const request = indexedDB.open(name, version);
    const openPromise = Object(_wrap_idb_value_js__WEBPACK_IMPORTED_MODULE_0__["w"])(request);
    if (upgrade) {
        request.addEventListener('upgradeneeded', (event) => {
            upgrade(Object(_wrap_idb_value_js__WEBPACK_IMPORTED_MODULE_0__["w"])(request.result), event.oldVersion, event.newVersion, Object(_wrap_idb_value_js__WEBPACK_IMPORTED_MODULE_0__["w"])(request.transaction));
        });
    }
    if (blocked)
        request.addEventListener('blocked', () => blocked());
    openPromise
        .then((db) => {
        if (terminated)
            db.addEventListener('close', () => terminated());
        if (blocking)
            db.addEventListener('versionchange', () => blocking());
    })
        .catch(() => { });
    return openPromise;
}
/**
 * Delete a database.
 *
 * @param name Name of the database.
 */
function deleteDB(name, { blocked } = {}) {
    const request = indexedDB.deleteDatabase(name);
    if (blocked)
        request.addEventListener('blocked', () => blocked());
    return Object(_wrap_idb_value_js__WEBPACK_IMPORTED_MODULE_0__["w"])(request).then(() => undefined);
}

const readMethods = ['get', 'getKey', 'getAll', 'getAllKeys', 'count'];
const writeMethods = ['put', 'add', 'delete', 'clear'];
const cachedMethods = new Map();
function getMethod(target, prop) {
    if (!(target instanceof IDBDatabase &&
        !(prop in target) &&
        typeof prop === 'string')) {
        return;
    }
    if (cachedMethods.get(prop))
        return cachedMethods.get(prop);
    const targetFuncName = prop.replace(/FromIndex$/, '');
    const useIndex = prop !== targetFuncName;
    const isWrite = writeMethods.includes(targetFuncName);
    if (
    // Bail if the target doesn't exist on the target. Eg, getAll isn't in Edge.
    !(targetFuncName in (useIndex ? IDBIndex : IDBObjectStore).prototype) ||
        !(isWrite || readMethods.includes(targetFuncName))) {
        return;
    }
    const method = async function (storeName, ...args) {
        // isWrite ? 'readwrite' : undefined gzipps better, but fails in Edge :(
        const tx = this.transaction(storeName, isWrite ? 'readwrite' : 'readonly');
        let target = tx.store;
        if (useIndex)
            target = target.index(args.shift());
        const returnVal = await target[targetFuncName](...args);
        if (isWrite)
            await tx.done;
        return returnVal;
    };
    cachedMethods.set(prop, method);
    return method;
}
Object(_wrap_idb_value_js__WEBPACK_IMPORTED_MODULE_0__["r"])((oldTraps) => ({
    ...oldTraps,
    get: (target, prop, receiver) => getMethod(target, prop) || oldTraps.get(target, prop, receiver),
    has: (target, prop) => !!getMethod(target, prop) || oldTraps.has(target, prop),
}));




/***/ }),

/***/ "./node_modules/idb/build/esm/wrap-idb-value.js":
/*!******************************************************!*\
  !*** ./node_modules/idb/build/esm/wrap-idb-value.js ***!
  \******************************************************/
/*! exports provided: a, i, r, u, w */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return reverseTransformCache; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "i", function() { return instanceOfAny; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "r", function() { return replaceTraps; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "u", function() { return unwrap; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "w", function() { return wrap; });
const instanceOfAny = (object, constructors) => constructors.some((c) => object instanceof c);

let idbProxyableTypes;
let cursorAdvanceMethods;
// This is a function to prevent it throwing up in node environments.
function getIdbProxyableTypes() {
    return (idbProxyableTypes ||
        (idbProxyableTypes = [
            IDBDatabase,
            IDBObjectStore,
            IDBIndex,
            IDBCursor,
            IDBTransaction,
        ]));
}
// This is a function to prevent it throwing up in node environments.
function getCursorAdvanceMethods() {
    return (cursorAdvanceMethods ||
        (cursorAdvanceMethods = [
            IDBCursor.prototype.advance,
            IDBCursor.prototype.continue,
            IDBCursor.prototype.continuePrimaryKey,
        ]));
}
const cursorRequestMap = new WeakMap();
const transactionDoneMap = new WeakMap();
const transactionStoreNamesMap = new WeakMap();
const transformCache = new WeakMap();
const reverseTransformCache = new WeakMap();
function promisifyRequest(request) {
    const promise = new Promise((resolve, reject) => {
        const unlisten = () => {
            request.removeEventListener('success', success);
            request.removeEventListener('error', error);
        };
        const success = () => {
            resolve(wrap(request.result));
            unlisten();
        };
        const error = () => {
            reject(request.error);
            unlisten();
        };
        request.addEventListener('success', success);
        request.addEventListener('error', error);
    });
    promise
        .then((value) => {
        // Since cursoring reuses the IDBRequest (*sigh*), we cache it for later retrieval
        // (see wrapFunction).
        if (value instanceof IDBCursor) {
            cursorRequestMap.set(value, request);
        }
        // Catching to avoid "Uncaught Promise exceptions"
    })
        .catch(() => { });
    // This mapping exists in reverseTransformCache but doesn't doesn't exist in transformCache. This
    // is because we create many promises from a single IDBRequest.
    reverseTransformCache.set(promise, request);
    return promise;
}
function cacheDonePromiseForTransaction(tx) {
    // Early bail if we've already created a done promise for this transaction.
    if (transactionDoneMap.has(tx))
        return;
    const done = new Promise((resolve, reject) => {
        const unlisten = () => {
            tx.removeEventListener('complete', complete);
            tx.removeEventListener('error', error);
            tx.removeEventListener('abort', error);
        };
        const complete = () => {
            resolve();
            unlisten();
        };
        const error = () => {
            reject(tx.error || new DOMException('AbortError', 'AbortError'));
            unlisten();
        };
        tx.addEventListener('complete', complete);
        tx.addEventListener('error', error);
        tx.addEventListener('abort', error);
    });
    // Cache it for later retrieval.
    transactionDoneMap.set(tx, done);
}
let idbProxyTraps = {
    get(target, prop, receiver) {
        if (target instanceof IDBTransaction) {
            // Special handling for transaction.done.
            if (prop === 'done')
                return transactionDoneMap.get(target);
            // Polyfill for objectStoreNames because of Edge.
            if (prop === 'objectStoreNames') {
                return target.objectStoreNames || transactionStoreNamesMap.get(target);
            }
            // Make tx.store return the only store in the transaction, or undefined if there are many.
            if (prop === 'store') {
                return receiver.objectStoreNames[1]
                    ? undefined
                    : receiver.objectStore(receiver.objectStoreNames[0]);
            }
        }
        // Else transform whatever we get back.
        return wrap(target[prop]);
    },
    set(target, prop, value) {
        target[prop] = value;
        return true;
    },
    has(target, prop) {
        if (target instanceof IDBTransaction &&
            (prop === 'done' || prop === 'store')) {
            return true;
        }
        return prop in target;
    },
};
function replaceTraps(callback) {
    idbProxyTraps = callback(idbProxyTraps);
}
function wrapFunction(func) {
    // Due to expected object equality (which is enforced by the caching in `wrap`), we
    // only create one new func per func.
    // Edge doesn't support objectStoreNames (booo), so we polyfill it here.
    if (func === IDBDatabase.prototype.transaction &&
        !('objectStoreNames' in IDBTransaction.prototype)) {
        return function (storeNames, ...args) {
            const tx = func.call(unwrap(this), storeNames, ...args);
            transactionStoreNamesMap.set(tx, storeNames.sort ? storeNames.sort() : [storeNames]);
            return wrap(tx);
        };
    }
    // Cursor methods are special, as the behaviour is a little more different to standard IDB. In
    // IDB, you advance the cursor and wait for a new 'success' on the IDBRequest that gave you the
    // cursor. It's kinda like a promise that can resolve with many values. That doesn't make sense
    // with real promises, so each advance methods returns a new promise for the cursor object, or
    // undefined if the end of the cursor has been reached.
    if (getCursorAdvanceMethods().includes(func)) {
        return function (...args) {
            // Calling the original function with the proxy as 'this' causes ILLEGAL INVOCATION, so we use
            // the original object.
            func.apply(unwrap(this), args);
            return wrap(cursorRequestMap.get(this));
        };
    }
    return function (...args) {
        // Calling the original function with the proxy as 'this' causes ILLEGAL INVOCATION, so we use
        // the original object.
        return wrap(func.apply(unwrap(this), args));
    };
}
function transformCachableValue(value) {
    if (typeof value === 'function')
        return wrapFunction(value);
    // This doesn't return, it just creates a 'done' promise for the transaction,
    // which is later returned for transaction.done (see idbObjectHandler).
    if (value instanceof IDBTransaction)
        cacheDonePromiseForTransaction(value);
    if (instanceOfAny(value, getIdbProxyableTypes()))
        return new Proxy(value, idbProxyTraps);
    // Return the same value back if we're not going to transform it.
    return value;
}
function wrap(value) {
    // We sometimes generate multiple promises from a single IDBRequest (eg when cursoring), because
    // IDB is weird and a single IDBRequest can yield many responses, so these can't be cached.
    if (value instanceof IDBRequest)
        return promisifyRequest(value);
    // If we've already transformed this value before, reuse the transformed value.
    // This is faster, but it also provides object equality.
    if (transformCache.has(value))
        return transformCache.get(value);
    const newValue = transformCachableValue(value);
    // Not all types are transformed.
    // These may be primitive types, so they can't be WeakMap keys.
    if (newValue !== value) {
        transformCache.set(value, newValue);
        reverseTransformCache.set(newValue, value);
    }
    return newValue;
}
const unwrap = (value) => reverseTransformCache.get(value);




/***/ }),

/***/ "./node_modules/next/dist/build/webpack/loaders/next-client-pages-loader.js?page=%2F_app&absolutePagePath=private-next-pages%2F_app.tsx!./":
/*!**********************************************************************************************************************************************!*\
  !*** ./node_modules/next/dist/build/webpack/loaders/next-client-pages-loader.js?page=%2F_app&absolutePagePath=private-next-pages%2F_app.tsx ***!
  \**********************************************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {


    (window.__NEXT_P = window.__NEXT_P || []).push([
      "/_app",
      function () {
        return __webpack_require__(/*! private-next-pages/_app.tsx */ "./pages/_app.tsx");
      }
    ]);
  

/***/ }),

/***/ "./node_modules/next/dist/build/webpack/loaders/next-style-loader/runtime/injectStylesIntoStyleTag.js":
/*!************************************************************************************************************!*\
  !*** ./node_modules/next/dist/build/webpack/loaders/next-style-loader/runtime/injectStylesIntoStyleTag.js ***!
  \************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
const isOldIE=function isOldIE(){let memo;return function memorize(){if(typeof memo==='undefined'){// Test for IE <= 9 as proposed by Browserhacks
// @see http://browserhacks.com/#hack-e71d8692f65334173fee715c222cb805
// Tests for existence of standard globals is to allow style-loader
// to operate correctly into non-standard environments
// @see https://github.com/webpack-contrib/style-loader/issues/177
memo=Boolean(window&&document&&document.all&&!window.atob);}return memo;};}();const getTarget=function getTarget(){const memo={};return function memorize(target){if(typeof memo[target]==='undefined'){let styleTarget=document.querySelector(target);// Special case to return head of iframe instead of iframe itself
if(window.HTMLIFrameElement&&styleTarget instanceof window.HTMLIFrameElement){try{// This will throw an exception if access to iframe is blocked
// due to cross-origin restrictions
styleTarget=styleTarget.contentDocument.head;}catch(e){// istanbul ignore next
styleTarget=null;}}memo[target]=styleTarget;}return memo[target];};}();const stylesInDom=[];function getIndexByIdentifier(identifier){let result=-1;for(let i=0;i<stylesInDom.length;i++){if(stylesInDom[i].identifier===identifier){result=i;break;}}return result;}function modulesToDom(list,options){const idCountMap={};const identifiers=[];for(let i=0;i<list.length;i++){const item=list[i];const id=options.base?item[0]+options.base:item[0];const count=idCountMap[id]||0;const identifier=id+' '+count.toString();idCountMap[id]=count+1;const index=getIndexByIdentifier(identifier);const obj={css:item[1],media:item[2],sourceMap:item[3]};if(index!==-1){stylesInDom[index].references++;stylesInDom[index].updater(obj);}else{stylesInDom.push({identifier:identifier,updater:addStyle(obj,options),references:1});}identifiers.push(identifier);}return identifiers;}function insertStyleElement(options){const style=document.createElement('style');const attributes=options.attributes||{};if(typeof attributes.nonce==='undefined'){const nonce=// eslint-disable-next-line no-undef
 true?__webpack_require__.nc:undefined;if(nonce){attributes.nonce=nonce;}}Object.keys(attributes).forEach(function(key){style.setAttribute(key,attributes[key]);});if(typeof options.insert==='function'){options.insert(style);}else{const target=getTarget(options.insert||'head');if(!target){throw new Error("Couldn't find a style target. This probably means that the value for the 'insert' parameter is invalid.");}target.appendChild(style);}return style;}function removeStyleElement(style){// istanbul ignore if
if(style.parentNode===null){return false;}style.parentNode.removeChild(style);}/* istanbul ignore next  */const replaceText=function replaceText(){const textStore=[];return function replace(index,replacement){textStore[index]=replacement;return textStore.filter(Boolean).join('\n');};}();function applyToSingletonTag(style,index,remove,obj){const css=remove?'':obj.media?'@media '+obj.media+' {'+obj.css+'}':obj.css;// For old IE
/* istanbul ignore if  */if(style.styleSheet){style.styleSheet.cssText=replaceText(index,css);}else{const cssNode=document.createTextNode(css);const childNodes=style.childNodes;if(childNodes[index]){style.removeChild(childNodes[index]);}if(childNodes.length){style.insertBefore(cssNode,childNodes[index]);}else{style.appendChild(cssNode);}}}function applyToTag(style,options,obj){let css=obj.css;const media=obj.media;const sourceMap=obj.sourceMap;if(media){style.setAttribute('media',media);}else{style.removeAttribute('media');}if(sourceMap&&typeof btoa!=='undefined'){css+='\n/*# sourceMappingURL=data:application/json;base64,'+btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap))))+' */';}// For old IE
/* istanbul ignore if  */if(style.styleSheet){style.styleSheet.cssText=css;}else{while(style.firstChild){style.removeChild(style.firstChild);}style.appendChild(document.createTextNode(css));}}let singleton=null;let singletonCounter=0;function addStyle(obj,options){let style;let update;let remove;if(options.singleton){const styleIndex=singletonCounter++;style=singleton||(singleton=insertStyleElement(options));update=applyToSingletonTag.bind(null,style,styleIndex,false);remove=applyToSingletonTag.bind(null,style,styleIndex,true);}else{style=insertStyleElement(options);update=applyToTag.bind(null,style,options);remove=function(){removeStyleElement(style);};}update(obj);return function updateStyle(newObj){if(newObj){if(newObj.css===obj.css&&newObj.media===obj.media&&newObj.sourceMap===obj.sourceMap){return;}update(obj=newObj);}else{remove();}};}module.exports=function(list,options){options=options||{};// Force single-tag solution on IE6-9, which has a hard limit on the # of <style>
// tags it will allow on a page
if(!options.singleton&&typeof options.singleton!=='boolean'){options.singleton=isOldIE();}list=list||[];let lastIdentifiers=modulesToDom(list,options);return function update(newList){newList=newList||[];if(Object.prototype.toString.call(newList)!=='[object Array]'){return;}for(let i=0;i<lastIdentifiers.length;i++){const identifier=lastIdentifiers[i];const index=getIndexByIdentifier(identifier);stylesInDom[index].references--;}const newLastIdentifiers=modulesToDom(newList,options);for(let i=0;i<lastIdentifiers.length;i++){const identifier=lastIdentifiers[i];const index=getIndexByIdentifier(identifier);if(stylesInDom[index].references===0){stylesInDom[index].updater();stylesInDom.splice(index,1);}}lastIdentifiers=newLastIdentifiers;};};
//# sourceMappingURL=injectStylesIntoStyleTag.js.map

/***/ }),

/***/ "./node_modules/next/dist/client/link.js":
/*!***********************************************!*\
  !*** ./node_modules/next/dist/client/link.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(module) {

var _slicedToArray = __webpack_require__(/*! ./node_modules/@babel/runtime/helpers/slicedToArray */ "./node_modules/@babel/runtime/helpers/slicedToArray.js");

var _s = $RefreshSig$();

var _interopRequireWildcard = __webpack_require__(/*! @babel/runtime/helpers/interopRequireWildcard */ "./node_modules/@babel/runtime/helpers/interopRequireWildcard.js");

exports.__esModule = true;
exports["default"] = void 0;

var _react = _interopRequireWildcard(__webpack_require__(/*! react */ "./node_modules/preact/compat/dist/compat.module.js"));

var _router = __webpack_require__(/*! ../next-server/lib/router/router */ "./node_modules/next/dist/next-server/lib/router/router.js");

var _router2 = __webpack_require__(/*! ./router */ "./node_modules/next/dist/client/router.js");

var _useIntersection = __webpack_require__(/*! ./use-intersection */ "./node_modules/next/dist/client/use-intersection.js");

var prefetched = {};

function prefetch(router, href, as, options) {
  if ( false || !router) return;
  if (!(0, _router.isLocalURL)(href)) return; // Prefetch the JSON page if asked (only in the client)
  // We need to handle a prefetch error here since we may be
  // loading with priority which can reject but we don't
  // want to force navigation since this is only a prefetch

  router.prefetch(href, as, options)["catch"](function (err) {
    if (true) {
      // rethrow to show invalid URL errors
      throw err;
    }
  });
  var curLocale = options && typeof options.locale !== 'undefined' ? options.locale : router && router.locale; // Join on an invalid URI character

  prefetched[href + '%' + as + (curLocale ? '%' + curLocale : '')] = true;
}

function isModifiedEvent(event) {
  var target = event.currentTarget.target;
  return target && target !== '_self' || event.metaKey || event.ctrlKey || event.shiftKey || event.altKey || // triggers resource download
  event.nativeEvent && event.nativeEvent.which === 2;
}

function linkClicked(e, router, href, as, replace, shallow, scroll, locale) {
  var nodeName = e.currentTarget.nodeName;

  if (nodeName === 'A' && (isModifiedEvent(e) || !(0, _router.isLocalURL)(href))) {
    // ignore click for browsers default behavior
    return;
  }

  e.preventDefault(); //  avoid scroll for urls with anchor refs

  if (scroll == null) {
    scroll = as.indexOf('#') < 0;
  } // replace state instead of push if prop is present


  router[replace ? 'replace' : 'push'](href, as, {
    shallow: shallow,
    locale: locale,
    scroll: scroll
  });
}

function Link(props) {
  _s();

  if (true) {
    var createPropError = function createPropError(args) {
      return new Error("Failed prop type: The prop `".concat(args.key, "` expects a ").concat(args.expected, " in `<Link>`, but got `").concat(args.actual, "` instead.") + (true ? "\nOpen your browser's console to view the Component stack trace." : undefined));
    }; // TypeScript trick for type-guarding:


    var requiredPropsGuard = {
      href: true
    };
    var requiredProps = Object.keys(requiredPropsGuard);
    requiredProps.forEach(function (key) {
      if (key === 'href') {
        if (props[key] == null || typeof props[key] !== 'string' && typeof props[key] !== 'object') {
          throw createPropError({
            key: key,
            expected: '`string` or `object`',
            actual: props[key] === null ? 'null' : typeof props[key]
          });
        }
      } else {
        // TypeScript trick for type-guarding:
        // eslint-disable-next-line @typescript-eslint/no-unused-vars
        var _ = key;
      }
    }); // TypeScript trick for type-guarding:

    var optionalPropsGuard = {
      as: true,
      replace: true,
      scroll: true,
      shallow: true,
      passHref: true,
      prefetch: true,
      locale: true
    };
    var optionalProps = Object.keys(optionalPropsGuard);
    optionalProps.forEach(function (key) {
      var valType = typeof props[key];

      if (key === 'as') {
        if (props[key] && valType !== 'string' && valType !== 'object') {
          throw createPropError({
            key: key,
            expected: '`string` or `object`',
            actual: valType
          });
        }
      } else if (key === 'locale') {
        if (props[key] && valType !== 'string') {
          throw createPropError({
            key: key,
            expected: '`string`',
            actual: valType
          });
        }
      } else if (key === 'replace' || key === 'scroll' || key === 'shallow' || key === 'passHref' || key === 'prefetch') {
        if (props[key] != null && valType !== 'boolean') {
          throw createPropError({
            key: key,
            expected: '`boolean`',
            actual: valType
          });
        }
      } else {
        // TypeScript trick for type-guarding:
        // eslint-disable-next-line @typescript-eslint/no-unused-vars
        var _ = key;
      }
    }); // This hook is in a conditional but that is ok because `process.env.NODE_ENV` never changes
    // eslint-disable-next-line react-hooks/rules-of-hooks

    var hasWarned = _react["default"].useRef(false);

    if (props.prefetch && !hasWarned.current) {
      hasWarned.current = true;
      console.warn('Next.js auto-prefetches automatically based on viewport. The prefetch attribute is no longer needed. More: https://nextjs.org/docs/messages/prefetch-true-deprecated');
    }
  }

  var p = props.prefetch !== false;
  var router = (0, _router2.useRouter)();
  var pathname = router && router.asPath || '/';

  var _react$default$useMem = _react["default"].useMemo(function () {
    var _ref = (0, _router.resolveHref)(pathname, props.href, true),
        _ref2 = _slicedToArray(_ref, 2),
        resolvedHref = _ref2[0],
        resolvedAs = _ref2[1];

    return {
      href: resolvedHref,
      as: props.as ? (0, _router.resolveHref)(pathname, props.as) : resolvedAs || resolvedHref
    };
  }, [pathname, props.href, props.as]),
      href = _react$default$useMem.href,
      as = _react$default$useMem.as;

  var children = props.children,
      replace = props.replace,
      shallow = props.shallow,
      scroll = props.scroll,
      locale = props.locale; // Deprecated. Warning shown by propType check. If the children provided is a string (<Link>example</Link>) we wrap it in an <a> tag

  if (typeof children === 'string') {
    children = /*#__PURE__*/_react["default"].createElement("a", null, children);
  } // This will return the first child, if multiple are provided it will throw an error


  var child = _react.Children.only(children);

  var childRef = child && typeof child === 'object' && child.ref;

  var _ref3 = (0, _useIntersection.useIntersection)({
    rootMargin: '200px'
  }),
      _ref4 = _slicedToArray(_ref3, 2),
      setIntersectionRef = _ref4[0],
      isVisible = _ref4[1];

  var setRef = _react["default"].useCallback(function (el) {
    setIntersectionRef(el);

    if (childRef) {
      if (typeof childRef === 'function') childRef(el);else if (typeof childRef === 'object') {
        childRef.current = el;
      }
    }
  }, [childRef, setIntersectionRef]);

  (0, _react.useEffect)(function () {
    var shouldPrefetch = isVisible && p && (0, _router.isLocalURL)(href);
    var curLocale = typeof locale !== 'undefined' ? locale : router && router.locale;
    var isPrefetched = prefetched[href + '%' + as + (curLocale ? '%' + curLocale : '')];

    if (shouldPrefetch && !isPrefetched) {
      prefetch(router, href, as, {
        locale: curLocale
      });
    }
  }, [as, href, isVisible, locale, p, router]);
  var childProps = {
    ref: setRef,
    onClick: function onClick(e) {
      if (child.props && typeof child.props.onClick === 'function') {
        child.props.onClick(e);
      }

      if (!e.defaultPrevented) {
        linkClicked(e, router, href, as, replace, shallow, scroll, locale);
      }
    }
  };

  childProps.onMouseEnter = function (e) {
    if (!(0, _router.isLocalURL)(href)) return;

    if (child.props && typeof child.props.onMouseEnter === 'function') {
      child.props.onMouseEnter(e);
    }

    prefetch(router, href, as, {
      priority: true
    });
  }; // If child is an <a> tag and doesn't have a href attribute, or if the 'passHref' property is
  // defined, we specify the current 'href', so that repetition is not needed by the user


  if (props.passHref || child.type === 'a' && !('href' in child.props)) {
    var curLocale = typeof locale !== 'undefined' ? locale : router && router.locale; // we only render domain locales if we are currently on a domain locale
    // so that locale links are still visitable in development/preview envs

    var localeDomain = router && router.isLocaleDomain && (0, _router.getDomainLocale)(as, curLocale, router && router.locales, router && router.domainLocales);
    childProps.href = localeDomain || (0, _router.addBasePath)((0, _router.addLocale)(as, curLocale, router && router.defaultLocale));
  }

  return /*#__PURE__*/_react["default"].cloneElement(child, childProps);
}

_s(Link, "7cX92ILFgstKFyzTMH+g73G4t5k=");

_c = Link;
var _default = Link;
exports["default"] = _default;

var _c;

$RefreshReg$(_c, "Link");

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.i);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../compiled/webpack/module.js */ "./node_modules/next/dist/compiled/webpack/module.js")(module)))

/***/ }),

/***/ "./node_modules/next/dist/client/normalize-trailing-slash.js":
/*!*******************************************************************!*\
  !*** ./node_modules/next/dist/client/normalize-trailing-slash.js ***!
  \*******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(module) {

exports.__esModule = true;
exports.removePathTrailingSlash = removePathTrailingSlash;
exports.normalizePathTrailingSlash = void 0;
/**
* Removes the trailing slash of a path if there is one. Preserves the root path `/`.
*/

function removePathTrailingSlash(path) {
  return path.endsWith('/') && path !== '/' ? path.slice(0, -1) : path;
}
/**
* Normalizes the trailing slash of a path according to the `trailingSlash` option
* in `next.config.js`.
*/


var normalizePathTrailingSlash =  false ? undefined : removePathTrailingSlash;
exports.normalizePathTrailingSlash = normalizePathTrailingSlash;

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.i);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../compiled/webpack/module.js */ "./node_modules/next/dist/compiled/webpack/module.js")(module)))

/***/ }),

/***/ "./node_modules/next/dist/client/request-idle-callback.js":
/*!****************************************************************!*\
  !*** ./node_modules/next/dist/client/request-idle-callback.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(module) {

exports.__esModule = true;
exports.cancelIdleCallback = exports.requestIdleCallback = void 0;

var requestIdleCallback = typeof self !== 'undefined' && self.requestIdleCallback || function (cb) {
  var start = Date.now();
  return setTimeout(function () {
    cb({
      didTimeout: false,
      timeRemaining: function timeRemaining() {
        return Math.max(0, 50 - (Date.now() - start));
      }
    });
  }, 1);
};

exports.requestIdleCallback = requestIdleCallback;

var cancelIdleCallback = typeof self !== 'undefined' && self.cancelIdleCallback || function (id) {
  return clearTimeout(id);
};

exports.cancelIdleCallback = cancelIdleCallback;

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.i);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../compiled/webpack/module.js */ "./node_modules/next/dist/compiled/webpack/module.js")(module)))

/***/ }),

/***/ "./node_modules/next/dist/client/route-loader.js":
/*!*******************************************************!*\
  !*** ./node_modules/next/dist/client/route-loader.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(module) {

var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "./node_modules/@babel/runtime/helpers/interopRequireDefault.js");

exports.__esModule = true;
exports.markAssetError = markAssetError;
exports.isAssetError = isAssetError;
exports.getClientBuildManifest = getClientBuildManifest;
exports["default"] = void 0;

var _getAssetPathFromRoute = _interopRequireDefault(__webpack_require__(/*! ../next-server/lib/router/utils/get-asset-path-from-route */ "./node_modules/next/dist/next-server/lib/router/utils/get-asset-path-from-route.js"));

var _requestIdleCallback = __webpack_require__(/*! ./request-idle-callback */ "./node_modules/next/dist/client/request-idle-callback.js"); // 3.8s was arbitrarily chosen as it's what https://web.dev/interactive
// considers as "Good" time-to-interactive. We must assume something went
// wrong beyond this point, and then fall-back to a full page transition to
// show the user something of value.


var MS_MAX_IDLE_DELAY = 3800;

function withFuture(key, map, generator) {
  var entry = map.get(key);

  if (entry) {
    if ('future' in entry) {
      return entry.future;
    }

    return Promise.resolve(entry);
  }

  var resolver;
  var prom = new Promise(function (resolve) {
    resolver = resolve;
  });
  map.set(key, entry = {
    resolve: resolver,
    future: prom
  });
  return generator ? // eslint-disable-next-line no-sequences
  generator().then(function (value) {
    return resolver(value), value;
  }) : prom;
}

function hasPrefetch(link) {
  try {
    link = document.createElement('link');
    return (// detect IE11 since it supports prefetch but isn't detected
      // with relList.support
      !!window.MSInputMethodContext && !!document.documentMode || link.relList.supports('prefetch')
    );
  } catch (_unused) {
    return false;
  }
}

var canPrefetch = hasPrefetch();

function prefetchViaDom(href, as, link) {
  return new Promise(function (res, rej) {
    if (document.querySelector("link[rel=\"prefetch\"][href^=\"".concat(href, "\"]"))) {
      return res();
    }

    link = document.createElement('link'); // The order of property assignment here is intentional:

    if (as) link.as = as;
    link.rel = "prefetch";
    link.crossOrigin = undefined;
    link.onload = res;
    link.onerror = rej; // `href` should always be last:

    link.href = href;
    document.head.appendChild(link);
  });
}

var ASSET_LOAD_ERROR = Symbol('ASSET_LOAD_ERROR'); // TODO: unexport

function markAssetError(err) {
  return Object.defineProperty(err, ASSET_LOAD_ERROR, {});
}

function isAssetError(err) {
  return err && ASSET_LOAD_ERROR in err;
}

function appendScript(src, script) {
  return new Promise(function (resolve, reject) {
    script = document.createElement('script'); // The order of property assignment here is intentional.
    // 1. Setup success/failure hooks in case the browser synchronously
    //    executes when `src` is set.

    script.onload = resolve;

    script.onerror = function () {
      return reject(markAssetError(new Error("Failed to load script: ".concat(src))));
    }; // 2. Configure the cross-origin attribute before setting `src` in case the
    //    browser begins to fetch.


    script.crossOrigin = undefined; // 3. Finally, set the source and inject into the DOM in case the child
    //    must be appended for fetching to start.

    script.src = src;
    document.body.appendChild(script);
  });
} // Resolve a promise that times out after given amount of milliseconds.


function resolvePromiseWithTimeout(p, ms, err) {
  return new Promise(function (resolve, reject) {
    var cancelled = false;
    p.then(function (r) {
      // Resolved, cancel the timeout
      cancelled = true;
      resolve(r);
    })["catch"](reject);
    (0, _requestIdleCallback.requestIdleCallback)(function () {
      return setTimeout(function () {
        if (!cancelled) {
          reject(err);
        }
      }, ms);
    });
  });
} // TODO: stop exporting or cache the failure
// It'd be best to stop exporting this. It's an implementation detail. We're
// only exporting it for backwards compatibilty with the `page-loader`.
// Only cache this response as a last resort if we cannot eliminate all other
// code branches that use the Build Manifest Callback and push them through
// the Route Loader interface.


function getClientBuildManifest() {
  if (self.__BUILD_MANIFEST) {
    return Promise.resolve(self.__BUILD_MANIFEST);
  }

  var onBuildManifest = new Promise(function (resolve) {
    // Mandatory because this is not concurrent safe:
    var cb = self.__BUILD_MANIFEST_CB;

    self.__BUILD_MANIFEST_CB = function () {
      resolve(self.__BUILD_MANIFEST);
      cb && cb();
    };
  });
  return resolvePromiseWithTimeout(onBuildManifest, MS_MAX_IDLE_DELAY, markAssetError(new Error('Failed to load client build manifest')));
}

function getFilesForRoute(assetPrefix, route) {
  if (true) {
    return Promise.resolve({
      scripts: [assetPrefix + '/_next/static/chunks/pages' + encodeURI((0, _getAssetPathFromRoute["default"])(route, '.js'))],
      // Styles are handled by `style-loader` in development:
      css: []
    });
  }

  return getClientBuildManifest().then(function (manifest) {
    if (!(route in manifest)) {
      throw markAssetError(new Error("Failed to lookup route: ".concat(route)));
    }

    var allFiles = manifest[route].map(function (entry) {
      return assetPrefix + '/_next/' + encodeURI(entry);
    });
    return {
      scripts: allFiles.filter(function (v) {
        return v.endsWith('.js');
      }),
      css: allFiles.filter(function (v) {
        return v.endsWith('.css');
      })
    };
  });
}

function createRouteLoader(assetPrefix) {
  var entrypoints = new Map();
  var loadedScripts = new Map();
  var styleSheets = new Map();
  var routes = new Map();

  function maybeExecuteScript(src) {
    var prom = loadedScripts.get(src);

    if (prom) {
      return prom;
    } // Skip executing script if it's already in the DOM:


    if (document.querySelector("script[src^=\"".concat(src, "\"]"))) {
      return Promise.resolve();
    }

    loadedScripts.set(src, prom = appendScript(src));
    return prom;
  }

  function fetchStyleSheet(href) {
    var prom = styleSheets.get(href);

    if (prom) {
      return prom;
    }

    styleSheets.set(href, prom = fetch(href).then(function (res) {
      if (!res.ok) {
        throw new Error("Failed to load stylesheet: ".concat(href));
      }

      return res.text().then(function (text) {
        return {
          href: href,
          content: text
        };
      });
    })["catch"](function (err) {
      throw markAssetError(err);
    }));
    return prom;
  }

  return {
    whenEntrypoint: function whenEntrypoint(route) {
      return withFuture(route, entrypoints);
    },
    onEntrypoint: function onEntrypoint(route, execute) {
      Promise.resolve(execute).then(function (fn) {
        return fn();
      }).then(function (exports) {
        return {
          component: exports && exports["default"] || exports,
          exports: exports
        };
      }, function (err) {
        return {
          error: err
        };
      }).then(function (input) {
        var old = entrypoints.get(route);
        entrypoints.set(route, input);
        if (old && 'resolve' in old) old.resolve(input);
      });
    },
    loadRoute: function loadRoute(route, prefetch) {
      var _this = this;

      return withFuture(route, routes, function () {
        return resolvePromiseWithTimeout(getFilesForRoute(assetPrefix, route).then(function (_ref) {
          var scripts = _ref.scripts,
              css = _ref.css;
          return Promise.all([entrypoints.has(route) ? [] : Promise.all(scripts.map(maybeExecuteScript)), Promise.all(css.map(fetchStyleSheet))]);
        }).then(function (res) {
          return _this.whenEntrypoint(route).then(function (entrypoint) {
            return {
              entrypoint: entrypoint,
              styles: res[1]
            };
          });
        }), MS_MAX_IDLE_DELAY, markAssetError(new Error("Route did not complete loading: ".concat(route)))).then(function (_ref2) {
          var entrypoint = _ref2.entrypoint,
              styles = _ref2.styles;
          var res = Object.assign({
            styles: styles
          }, entrypoint);
          return 'error' in entrypoint ? entrypoint : res;
        })["catch"](function (err) {
          if (prefetch) {
            // we don't want to cache errors during prefetch
            throw err;
          }

          return {
            error: err
          };
        });
      });
    },
    prefetch: function prefetch(route) {
      var _this2 = this;

      // https://github.com/GoogleChromeLabs/quicklink/blob/453a661fa1fa940e2d2e044452398e38c67a98fb/src/index.mjs#L115-L118
      // License: Apache 2.0
      var cn;

      if (cn = navigator.connection) {
        // Don't prefetch if using 2G or if Save-Data is enabled.
        if (cn.saveData || /2g/.test(cn.effectiveType)) return Promise.resolve();
      }

      return getFilesForRoute(assetPrefix, route).then(function (output) {
        return Promise.all(canPrefetch ? output.scripts.map(function (script) {
          return prefetchViaDom(script, 'script');
        }) : []);
      }).then(function () {
        (0, _requestIdleCallback.requestIdleCallback)(function () {
          return _this2.loadRoute(route, true)["catch"](function () {});
        });
      })["catch"]( // swallow prefetch errors
      function () {});
    }
  };
}

var _default = createRouteLoader;
exports["default"] = _default;

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.i);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../compiled/webpack/module.js */ "./node_modules/next/dist/compiled/webpack/module.js")(module)))

/***/ }),

/***/ "./node_modules/next/dist/client/router.js":
/*!*************************************************!*\
  !*** ./node_modules/next/dist/client/router.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(module) {

var _construct = __webpack_require__(/*! ./node_modules/@babel/runtime/helpers/construct */ "./node_modules/@babel/runtime/helpers/construct.js");

var _s = $RefreshSig$();

function _createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

var _interopRequireWildcard = __webpack_require__(/*! @babel/runtime/helpers/interopRequireWildcard */ "./node_modules/@babel/runtime/helpers/interopRequireWildcard.js");

var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "./node_modules/@babel/runtime/helpers/interopRequireDefault.js");

exports.__esModule = true;
exports.useRouter = useRouter;
exports.makePublicRouterInstance = makePublicRouterInstance;
exports.createRouter = exports.withRouter = exports["default"] = void 0;

var _react = _interopRequireDefault(__webpack_require__(/*! react */ "./node_modules/preact/compat/dist/compat.module.js"));

var _router2 = _interopRequireWildcard(__webpack_require__(/*! ../next-server/lib/router/router */ "./node_modules/next/dist/next-server/lib/router/router.js"));

exports.Router = _router2["default"];
exports.NextRouter = _router2.NextRouter;

var _routerContext = __webpack_require__(/*! ../next-server/lib/router-context */ "./node_modules/next/dist/next-server/lib/router-context.js");

var _withRouter = _interopRequireDefault(__webpack_require__(/*! ./with-router */ "./node_modules/next/dist/client/with-router.js"));

exports.withRouter = _withRouter["default"];
/* global window */

var singletonRouter = {
  router: null,
  // holds the actual router instance
  readyCallbacks: [],
  ready: function ready(cb) {
    if (this.router) return cb();

    if (true) {
      this.readyCallbacks.push(cb);
    }
  }
}; // Create public properties and methods of the router in the singletonRouter

var urlPropertyFields = ['pathname', 'route', 'query', 'asPath', 'components', 'isFallback', 'basePath', 'locale', 'locales', 'defaultLocale', 'isReady', 'isPreview', 'isLocaleDomain'];
var routerEvents = ['routeChangeStart', 'beforeHistoryChange', 'routeChangeComplete', 'routeChangeError', 'hashChangeStart', 'hashChangeComplete'];
var coreMethodFields = ['push', 'replace', 'reload', 'back', 'prefetch', 'beforePopState']; // Events is a static property on the router, the router doesn't have to be initialized to use it

Object.defineProperty(singletonRouter, 'events', {
  get: function get() {
    return _router2["default"].events;
  }
});
urlPropertyFields.forEach(function (field) {
  // Here we need to use Object.defineProperty because, we need to return
  // the property assigned to the actual router
  // The value might get changed as we change routes and this is the
  // proper way to access it
  Object.defineProperty(singletonRouter, field, {
    get: function get() {
      var router = getRouter();
      return router[field];
    }
  });
});
coreMethodFields.forEach(function (field) {
  // We don't really know the types here, so we add them later instead
  ;

  singletonRouter[field] = function () {
    var router = getRouter();
    return router[field].apply(router, arguments);
  };
});
routerEvents.forEach(function (event) {
  singletonRouter.ready(function () {
    _router2["default"].events.on(event, function () {
      var eventField = "on".concat(event.charAt(0).toUpperCase()).concat(event.substring(1));
      var _singletonRouter = singletonRouter;

      if (_singletonRouter[eventField]) {
        try {
          _singletonRouter[eventField].apply(_singletonRouter, arguments);
        } catch (err) {
          console.error("Error when running the Router event: ".concat(eventField));
          console.error("".concat(err.message, "\n").concat(err.stack));
        }
      }
    });
  });
});

function getRouter() {
  if (!singletonRouter.router) {
    var message = 'No router instance found.\n' + 'You should only use "next/router" inside the client side of your app.\n';
    throw new Error(message);
  }

  return singletonRouter.router;
} // Export the singletonRouter and this is the public API.


var _default = singletonRouter; // Reexport the withRoute HOC

exports["default"] = _default;

function useRouter() {
  _s();

  return _react["default"].useContext(_routerContext.RouterContext);
} // INTERNAL APIS
// -------------
// (do not use following exports inside the app)
// Create a router and assign it as the singleton instance.
// This is used in client side when we are initilizing the app.
// This should **not** use inside the server.


_s(useRouter, "gDsCjeeItUuvgOWf1v4qoK9RF6k=");

var createRouter = function createRouter() {
  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
    args[_key] = arguments[_key];
  }

  singletonRouter.router = _construct(_router2["default"], args);
  singletonRouter.readyCallbacks.forEach(function (cb) {
    return cb();
  });
  singletonRouter.readyCallbacks = [];
  return singletonRouter.router;
}; // This function is used to create the `withRouter` router instance


exports.createRouter = createRouter;

function makePublicRouterInstance(router) {
  var _router = router;
  var instance = {};

  var _iterator = _createForOfIteratorHelper(urlPropertyFields),
      _step;

  try {
    for (_iterator.s(); !(_step = _iterator.n()).done;) {
      var property = _step.value;

      if (typeof _router[property] === 'object') {
        instance[property] = Object.assign(Array.isArray(_router[property]) ? [] : {}, _router[property]); // makes sure query is not stateful

        continue;
      }

      instance[property] = _router[property];
    } // Events is a static property on the router, the router doesn't have to be initialized to use it

  } catch (err) {
    _iterator.e(err);
  } finally {
    _iterator.f();
  }

  instance.events = _router2["default"].events;
  coreMethodFields.forEach(function (field) {
    instance[field] = function () {
      return _router[field].apply(_router, arguments);
    };
  });
  return instance;
}

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.i);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../compiled/webpack/module.js */ "./node_modules/next/dist/compiled/webpack/module.js")(module)))

/***/ }),

/***/ "./node_modules/next/dist/client/use-intersection.js":
/*!***********************************************************!*\
  !*** ./node_modules/next/dist/client/use-intersection.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(module) {

var _slicedToArray = __webpack_require__(/*! ./node_modules/@babel/runtime/helpers/slicedToArray */ "./node_modules/@babel/runtime/helpers/slicedToArray.js");

exports.__esModule = true;
exports.useIntersection = useIntersection;

var _react = __webpack_require__(/*! react */ "./node_modules/preact/compat/dist/compat.module.js");

var _requestIdleCallback = __webpack_require__(/*! ./request-idle-callback */ "./node_modules/next/dist/client/request-idle-callback.js");

var hasIntersectionObserver = typeof IntersectionObserver !== 'undefined';

function useIntersection(_ref) {
  var rootMargin = _ref.rootMargin,
      disabled = _ref.disabled;
  var isDisabled = disabled || !hasIntersectionObserver;
  var unobserve = (0, _react.useRef)();

  var _ref2 = (0, _react.useState)(false),
      _ref3 = _slicedToArray(_ref2, 2),
      visible = _ref3[0],
      setVisible = _ref3[1];

  var setRef = (0, _react.useCallback)(function (el) {
    if (unobserve.current) {
      unobserve.current();
      unobserve.current = undefined;
    }

    if (isDisabled || visible) return;

    if (el && el.tagName) {
      unobserve.current = observe(el, function (isVisible) {
        return isVisible && setVisible(isVisible);
      }, {
        rootMargin: rootMargin
      });
    }
  }, [isDisabled, rootMargin, visible]);
  (0, _react.useEffect)(function () {
    if (!hasIntersectionObserver) {
      if (!visible) {
        var idleCallback = (0, _requestIdleCallback.requestIdleCallback)(function () {
          return setVisible(true);
        });
        return function () {
          return (0, _requestIdleCallback.cancelIdleCallback)(idleCallback);
        };
      }
    }
  }, [visible]);
  return [setRef, visible];
}

function observe(element, callback, options) {
  var _createObserver = createObserver(options),
      id = _createObserver.id,
      observer = _createObserver.observer,
      elements = _createObserver.elements;

  elements.set(element, callback);
  observer.observe(element);
  return function unobserve() {
    elements["delete"](element);
    observer.unobserve(element); // Destroy observer when there's nothing left to watch:

    if (elements.size === 0) {
      observer.disconnect();
      observers["delete"](id);
    }
  };
}

var observers = new Map();

function createObserver(options) {
  var id = options.rootMargin || '';
  var instance = observers.get(id);

  if (instance) {
    return instance;
  }

  var elements = new Map();
  var observer = new IntersectionObserver(function (entries) {
    entries.forEach(function (entry) {
      var callback = elements.get(entry.target);
      var isVisible = entry.isIntersecting || entry.intersectionRatio > 0;

      if (callback && isVisible) {
        callback(isVisible);
      }
    });
  }, options);
  observers.set(id, instance = {
    id: id,
    observer: observer,
    elements: elements
  });
  return instance;
}

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.i);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../compiled/webpack/module.js */ "./node_modules/next/dist/compiled/webpack/module.js")(module)))

/***/ }),

/***/ "./node_modules/next/dist/client/with-router.js":
/*!******************************************************!*\
  !*** ./node_modules/next/dist/client/with-router.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(module) {

var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "./node_modules/@babel/runtime/helpers/interopRequireDefault.js");

exports.__esModule = true;
exports["default"] = withRouter;

var _react = _interopRequireDefault(__webpack_require__(/*! react */ "./node_modules/preact/compat/dist/compat.module.js"));

var _router = __webpack_require__(/*! ./router */ "./node_modules/next/dist/client/router.js");

function withRouter(ComposedComponent) {
  function WithRouterWrapper(props) {
    return /*#__PURE__*/_react["default"].createElement(ComposedComponent, Object.assign({
      router: (0, _router.useRouter)()
    }, props));
  }

  WithRouterWrapper.getInitialProps = ComposedComponent.getInitialProps // This is needed to allow checking for custom getInitialProps in _app
  ;
  WithRouterWrapper.origGetInitialProps = ComposedComponent.origGetInitialProps;

  if (true) {
    var name = ComposedComponent.displayName || ComposedComponent.name || 'Unknown';
    WithRouterWrapper.displayName = "withRouter(".concat(name, ")");
  }

  return WithRouterWrapper;
}

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.i);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../compiled/webpack/module.js */ "./node_modules/next/dist/compiled/webpack/module.js")(module)))

/***/ }),

/***/ "./node_modules/next/dist/compiled/css-loader/api.js":
/*!***********************************!*\
  !*** (webpack)/css-loader/api.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports) {

/* WEBPACK VAR INJECTION */(function(__dirname) {module.exports=function(){"use strict";var n={762:function(n){n.exports=function(n){var t=[];t.toString=function toString(){return this.map(function(t){var r=cssWithMappingToString(t,n);if(t[2]){return"@media ".concat(t[2]," {").concat(r,"}")}return r}).join("")};t.i=function(n,r,o){if(typeof n==="string"){n=[[null,n,""]]}var e={};if(o){for(var a=0;a<this.length;a++){var c=this[a][0];if(c!=null){e[c]=true}}}for(var i=0;i<n.length;i++){var u=[].concat(n[i]);if(o&&e[u[0]]){continue}if(r){if(!u[2]){u[2]=r}else{u[2]="".concat(r," and ").concat(u[2])}}t.push(u)}};return t};function cssWithMappingToString(n,t){var r=n[1]||"";var o=n[3];if(!o){return r}if(t&&typeof btoa==="function"){var e=toComment(o);var a=o.sources.map(function(n){return"/*# sourceURL=".concat(o.sourceRoot||"").concat(n," */")});return[r].concat(a).concat([e]).join("\n")}return[r].join("\n")}function toComment(n){var t=btoa(unescape(encodeURIComponent(JSON.stringify(n))));var r="sourceMappingURL=data:application/json;charset=utf-8;base64,".concat(t);return"/*# ".concat(r," */")}}};var t={};function __nccwpck_require__(r){if(t[r]){return t[r].exports}var o=t[r]={exports:{}};var e=true;try{n[r](o,o.exports,__nccwpck_require__);e=false}finally{if(e)delete t[r]}return o.exports}__nccwpck_require__.ab=__dirname+"/";return __nccwpck_require__(762)}();
/* WEBPACK VAR INJECTION */}.call(this, "/"))

/***/ }),

/***/ "./node_modules/next/dist/compiled/css-loader/cjs.js?!./node_modules/next/dist/compiled/postcss-loader/cjs.js?!./components/About/About.module.css":
/*!*******************************************************************************************************************************************!*\
  !*** (webpack)/css-loader/cjs.js??ref--5-oneOf-2-1!(webpack)/postcss-loader/cjs.js??ref--5-oneOf-2-2!./components/About/About.module.css ***!
  \*******************************************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// Imports
var ___CSS_LOADER_API_IMPORT___ = __webpack_require__(/*! ../../node_modules/next/dist/compiled/css-loader/api.js */ "./node_modules/next/dist/compiled/css-loader/api.js");
var ___CSS_LOADER_EXPORT___ = ___CSS_LOADER_API_IMPORT___(true);
// Module
___CSS_LOADER_EXPORT___.push([module.i, ".About_controls__3UJzm,\n.About_navigation__jm_3W {\n    margin-top: var(--space-xl) !important;\n}\n\n.About_header__2BA8C {\n    display: flex;\n    align-items: center;\n    margin-bottom: var(--space-l);\n}\n\n.About_logo__2eAaF {\n    width: 70%;\n    padding-right: var(--space-l);\n}\n\n.About_description__3nH5W > * + * {\n    margin-top: 0.5em;\n}\n\n[data-layout='desktop'] .About_button__1zLlL {\n    display: none;\n}\n", "",{"version":3,"sources":["webpack://components/About/About.module.css"],"names":[],"mappings":"AAAA;;IAEI,sCAAsC;AAC1C;;AAEA;IACI,aAAa;IACb,mBAAmB;IACnB,6BAA6B;AACjC;;AAEA;IACI,UAAU;IACV,6BAA6B;AACjC;;AAEA;IACI,iBAAiB;AACrB;;AAEA;IACI,aAAa;AACjB","sourcesContent":[".controls,\n.navigation {\n    margin-top: var(--space-xl) !important;\n}\n\n.header {\n    display: flex;\n    align-items: center;\n    margin-bottom: var(--space-l);\n}\n\n.logo {\n    width: 70%;\n    padding-right: var(--space-l);\n}\n\n.description > * + * {\n    margin-top: 0.5em;\n}\n\n[data-layout='desktop'] .button {\n    display: none;\n}\n"],"sourceRoot":""}]);
// Exports
___CSS_LOADER_EXPORT___.locals = {
	"controls": "About_controls__3UJzm",
	"navigation": "About_navigation__jm_3W",
	"header": "About_header__2BA8C",
	"logo": "About_logo__2eAaF",
	"description": "About_description__3nH5W",
	"button": "About_button__1zLlL"
};
module.exports = ___CSS_LOADER_EXPORT___;


/***/ }),

/***/ "./node_modules/next/dist/compiled/css-loader/cjs.js?!./node_modules/next/dist/compiled/postcss-loader/cjs.js?!./components/About/AboutControls.module.css":
/*!***************************************************************************************************************************************************!*\
  !*** (webpack)/css-loader/cjs.js??ref--5-oneOf-2-1!(webpack)/postcss-loader/cjs.js??ref--5-oneOf-2-2!./components/About/AboutControls.module.css ***!
  \***************************************************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// Imports
var ___CSS_LOADER_API_IMPORT___ = __webpack_require__(/*! ../../node_modules/next/dist/compiled/css-loader/api.js */ "./node_modules/next/dist/compiled/css-loader/api.js");
var ___CSS_LOADER_EXPORT___ = ___CSS_LOADER_API_IMPORT___(true);
// Module
___CSS_LOADER_EXPORT___.push([module.i, ".AboutControls_root__1BcLv {\r\n    list-style: none;\r\n    border-bottom: 1px solid var(--c-border);\r\n}\r\n\r\n.AboutControls_item__ldPU0 {\r\n    display: flex;\r\n    justify-content: flex-end;\r\n    border-top: 1px solid var(--c-border);\r\n}\r\n\r\n.AboutControls_button__18P4m {\r\n}\r\n", "",{"version":3,"sources":["webpack://components/About/AboutControls.module.css"],"names":[],"mappings":"AAAA;IACI,gBAAgB;IAChB,wCAAwC;AAC5C;;AAEA;IACI,aAAa;IACb,yBAAyB;IACzB,qCAAqC;AACzC;;AAEA;AACA","sourcesContent":[".root {\r\n    list-style: none;\r\n    border-bottom: 1px solid var(--c-border);\r\n}\r\n\r\n.item {\r\n    display: flex;\r\n    justify-content: flex-end;\r\n    border-top: 1px solid var(--c-border);\r\n}\r\n\r\n.button {\r\n}\r\n"],"sourceRoot":""}]);
// Exports
___CSS_LOADER_EXPORT___.locals = {
	"root": "AboutControls_root__1BcLv",
	"item": "AboutControls_item__ldPU0",
	"button": "AboutControls_button__18P4m"
};
module.exports = ___CSS_LOADER_EXPORT___;


/***/ }),

/***/ "./node_modules/next/dist/compiled/css-loader/cjs.js?!./node_modules/next/dist/compiled/postcss-loader/cjs.js?!./components/About/AboutNavigation.module.css":
/*!*****************************************************************************************************************************************************!*\
  !*** (webpack)/css-loader/cjs.js??ref--5-oneOf-2-1!(webpack)/postcss-loader/cjs.js??ref--5-oneOf-2-2!./components/About/AboutNavigation.module.css ***!
  \*****************************************************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// Imports
var ___CSS_LOADER_API_IMPORT___ = __webpack_require__(/*! ../../node_modules/next/dist/compiled/css-loader/api.js */ "./node_modules/next/dist/compiled/css-loader/api.js");
var ___CSS_LOADER_EXPORT___ = ___CSS_LOADER_API_IMPORT___(true);
// Module
___CSS_LOADER_EXPORT___.push([module.i, ".AboutNavigation_root__23sd0 {\r\n    display: flex;\r\n    justify-content: center;\r\n}\r\n\r\n.AboutNavigation_item__1a-Dj {\r\n    color: var(--c-p);\r\n    font-size: var(--fs-small)\r\n}\r\n\r\n.AboutNavigation_item__1a-Dj + .AboutNavigation_item__1a-Dj {\r\n        margin-left: var(--space);\r\n    }\r\n", "",{"version":3,"sources":["webpack://components/About/AboutNavigation.module.css"],"names":[],"mappings":"AAAA;IACI,aAAa;IACb,uBAAuB;AAC3B;;AAEA;IACI,iBAAiB;IACjB;AAKJ;;AAHI;QACI,yBAAyB;IAC7B","sourcesContent":[".root {\r\n    display: flex;\r\n    justify-content: center;\r\n}\r\n\r\n.item {\r\n    color: var(--c-p);\r\n    font-size: var(--fs-small);\r\n\r\n    & + .item {\r\n        margin-left: var(--space);\r\n    }\r\n}\r\n"],"sourceRoot":""}]);
// Exports
___CSS_LOADER_EXPORT___.locals = {
	"root": "AboutNavigation_root__23sd0",
	"item": "AboutNavigation_item__1a-Dj"
};
module.exports = ___CSS_LOADER_EXPORT___;


/***/ }),

/***/ "./node_modules/next/dist/compiled/css-loader/cjs.js?!./node_modules/next/dist/compiled/postcss-loader/cjs.js?!./components/About/EmailSignup.module.css":
/*!*************************************************************************************************************************************************!*\
  !*** (webpack)/css-loader/cjs.js??ref--5-oneOf-2-1!(webpack)/postcss-loader/cjs.js??ref--5-oneOf-2-2!./components/About/EmailSignup.module.css ***!
  \*************************************************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// Imports
var ___CSS_LOADER_API_IMPORT___ = __webpack_require__(/*! ../../node_modules/next/dist/compiled/css-loader/api.js */ "./node_modules/next/dist/compiled/css-loader/api.js");
var ___CSS_LOADER_EXPORT___ = ___CSS_LOADER_API_IMPORT___(true);
// Module
___CSS_LOADER_EXPORT___.push([module.i, "\r\n    .EmailSignup_content__1Vyfq > * + * {\r\n        margin-top: 0.5em;\r\n    }\r\n\r\n.EmailSignup_form__2BRfT {\r\n    margin-top: var(--space);\r\n}\r\n\r\n.EmailSignup_notification__PUBiG {\r\n    margin-top: var(--space-xl);\r\n}\r\n\r\n.EmailSignup_disclaimer__LQ7oF {\r\n    margin-top: var(--space);\r\n    font-size: var(--fs-xsmall);\r\n}\r\n", "",{"version":3,"sources":["webpack://components/About/EmailSignup.module.css"],"names":[],"mappings":";IACI;QACI,iBAAiB;IACrB;;AAGJ;IACI,wBAAwB;AAC5B;;AAEA;IACI,2BAA2B;AAC/B;;AAEA;IACI,wBAAwB;IACxB,2BAA2B;AAC/B","sourcesContent":[".content {\r\n    & > * + * {\r\n        margin-top: 0.5em;\r\n    }\r\n}\r\n\r\n.form {\r\n    margin-top: var(--space);\r\n}\r\n\r\n.notification {\r\n    margin-top: var(--space-xl);\r\n}\r\n\r\n.disclaimer {\r\n    margin-top: var(--space);\r\n    font-size: var(--fs-xsmall);\r\n}\r\n"],"sourceRoot":""}]);
// Exports
___CSS_LOADER_EXPORT___.locals = {
	"content": "EmailSignup_content__1Vyfq",
	"form": "EmailSignup_form__2BRfT",
	"notification": "EmailSignup_notification__PUBiG",
	"disclaimer": "EmailSignup_disclaimer__LQ7oF"
};
module.exports = ___CSS_LOADER_EXPORT___;


/***/ }),

/***/ "./node_modules/next/dist/compiled/css-loader/cjs.js?!./node_modules/next/dist/compiled/postcss-loader/cjs.js?!./components/About/PushNotifications.module.css":
/*!*******************************************************************************************************************************************************!*\
  !*** (webpack)/css-loader/cjs.js??ref--5-oneOf-2-1!(webpack)/postcss-loader/cjs.js??ref--5-oneOf-2-2!./components/About/PushNotifications.module.css ***!
  \*******************************************************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// Imports
var ___CSS_LOADER_API_IMPORT___ = __webpack_require__(/*! ../../node_modules/next/dist/compiled/css-loader/api.js */ "./node_modules/next/dist/compiled/css-loader/api.js");
var ___CSS_LOADER_EXPORT___ = ___CSS_LOADER_API_IMPORT___(true);
// Module
___CSS_LOADER_EXPORT___.push([module.i, ".PushNotifications_about__oHHFu {\n}\n\n.PushNotifications_feedback__3wMc5 {\n    margin-top: var(--space);\n}\n\n.PushNotifications_loader__1j0t1 {\n    width: 100%;\n    font-size: 1.6rem;\n    padding-top: var(--space)\n}\n\n.PushNotifications_loader__1j0t1:after {\n        margin: 0 auto;\n    }\n\n.PushNotifications_checked__VXUMQ {\n    display: flex;\n    align-items: center;\n    margin-bottom: var(--space);\n\n    .PushNotifications_svg__16ZpQ {\n        margin-right: 0.5rem;\n        color: var(--c-secondary);\n    }\n}\n", "",{"version":3,"sources":["webpack://components/About/PushNotifications.module.css"],"names":[],"mappings":"AAAA;AACA;;AAEA;IACI,wBAAwB;AAC5B;;AAEA;IACI,WAAW;IACX,iBAAiB;IACjB;AAKJ;;AAHI;QACI,cAAc;IAClB;;AAGJ;IACI,aAAa;IACb,mBAAmB;IACnB,2BAA2B;;IAE3B;QACI,oBAAoB;QACpB,yBAAyB;IAC7B;AACJ","sourcesContent":[".about {\n}\n\n.feedback {\n    margin-top: var(--space);\n}\n\n.loader {\n    width: 100%;\n    font-size: 1.6rem;\n    padding-top: var(--space);\n\n    &:after {\n        margin: 0 auto;\n    }\n}\n\n.checked {\n    display: flex;\n    align-items: center;\n    margin-bottom: var(--space);\n\n    .svg {\n        margin-right: 0.5rem;\n        color: var(--c-secondary);\n    }\n}\n"],"sourceRoot":""}]);
// Exports
___CSS_LOADER_EXPORT___.locals = {
	"about": "PushNotifications_about__oHHFu",
	"feedback": "PushNotifications_feedback__3wMc5",
	"loader": "PushNotifications_loader__1j0t1",
	"checked": "PushNotifications_checked__VXUMQ",
	"svg": "PushNotifications_svg__16ZpQ"
};
module.exports = ___CSS_LOADER_EXPORT___;


/***/ }),

/***/ "./node_modules/next/dist/compiled/css-loader/cjs.js?!./node_modules/next/dist/compiled/postcss-loader/cjs.js?!./components/Calendar/Calendar.module.css":
/*!*************************************************************************************************************************************************!*\
  !*** (webpack)/css-loader/cjs.js??ref--5-oneOf-2-1!(webpack)/postcss-loader/cjs.js??ref--5-oneOf-2-2!./components/Calendar/Calendar.module.css ***!
  \*************************************************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// Imports
var ___CSS_LOADER_API_IMPORT___ = __webpack_require__(/*! ../../node_modules/next/dist/compiled/css-loader/api.js */ "./node_modules/next/dist/compiled/css-loader/api.js");
var ___CSS_LOADER_EXPORT___ = ___CSS_LOADER_API_IMPORT___(true);
// Module
___CSS_LOADER_EXPORT___.push([module.i, ".Calendar_root__3RNyC {\n    position: relative;\n}\n\n.Calendar_header__2UO0k {\n    padding-bottom: var(--space-xl);\n}\n\n.Calendar_calendar__253ID {\n    display: grid;\n    grid-template-columns: 1fr 1fr 1fr 1fr 1fr;\n    grid-template-rows: 1fr 1fr 1fr 1fr 1fr;\n    grid-auto-columns: 1fr;\n    grid-auto-rows: 1fr;\n    grid-gap: var(--space-s)\n}\n\n@media (orientation: portrait) {\n\n.Calendar_calendar__253ID {\n        grid-template-columns: 1fr 1fr 1fr 1fr;\n        grid-template-rows: 1fr 1fr 1fr 1fr 1fr 1fr;\n        grid-gap: var(--space-xs)\n}\n    }\n\n.Calendar_calendar__253ID {\n\n    .Calendar_item__Cbyts {\n        position: relative;\n    }\n}\n\n.Calendar_item--24__2KuNY {\n    grid-column: span 2\n}\n\n@media (orientation: portrait) {\n\n.Calendar_item--24__2KuNY {\n        grid-column: span 1\n}\n    }\n\n.Calendar_item--list__38v-l {\n    grid-column: span 1\n}\n\n@media (orientation: portrait) {\n\n.Calendar_item--list__38v-l {\n        grid-column: span 1\n}\n    }\n\n.Calendar_list__1tLDt {\n    display: grid;\n    grid-template-columns: 1fr 1fr;\n}\n\n@media (orientation: portrait) {\n\n.Calendar_list__1tLDt {\n        grid-template-columns: 1fr;\n}\n    }\n\n.Calendar_list__1tLDt {\n    grid-auto-columns: 1fr;\n    grid-auto-rows: 1fr;\n    grid-gap: var(--space-s);\n    margin: 0 calc(var(--space-xl) * 2);\n}\n\n@media (orientation: portrait) {\n\n.Calendar_list__1tLDt {\n        margin: 0 0;\n}\n    }\n\n.Calendar_list__1tLDt {\n\n    overflow-y: auto;\n}\n\n.Calendar_list__1tLDt::-webkit-scrollbar {\n    width: 5px;\n}\n\n.Calendar_list__1tLDt::-webkit-scrollbar-thumb {\n    background-color: transparent;\n    -webkit-transition: background-color 200ms;\n    transition: background-color 200ms;\n    will-change: background-color;\n    border-radius: 5px;\n}\n\n.Calendar_list__1tLDt::-webkit-scrollbar-track {\n    background: transparent;\n}\n\n.Calendar_list__1tLDt:hover ::-webkit-scrollbar-thumb {\n    background-color: var(--c-border-dark);\n}\n\n\n.Calendar_buttonOverlay__KFBom {\n    cursor: pointer;\n    display: block;\n    position: absolute;\n    bottom: 0;\n    right: 0;\n    left: 0;\n    top: 0;\n    width: 100%;\n    z-index: 9999;\n    text-indent: -9999px;\n}\n\n[data-layout=\"desktop\"] .Calendar_buttonOverlay__KFBom {\n    display: none;\n}\n", "",{"version":3,"sources":["webpack://components/Calendar/Calendar.module.css"],"names":[],"mappings":"AAAA;IACI,kBAAkB;AACtB;;AAEA;IACI,+BAA+B;AACnC;;AAEA;IACI,aAAa;IACb,0CAA0C;IAC1C,uCAAuC;IACvC,sBAAsB;IACtB,mBAAmB;IACnB;AAWJ;;AATI;;AARJ;QASQ,sCAAsC;QACtC,2CAA2C;QAC3C;AAMR;IALI;;AAZJ;;IAcI;QACI,kBAAkB;IACtB;AACJ;;AAEA;IACI;AAIJ;;AAHI;;AAFJ;QAGQ;AAER;IADI;;AAGJ;IACI;AAIJ;;AAHI;;AAFJ;QAGQ;AAER;IADI;;AAGJ;IACI,aAAa;IACb,8BAA8B;AAalC;;AAZI;;AAHJ;QAIQ,0BAA0B;AAWlC;IAVI;;AALJ;IAMI,sBAAsB;IACtB,mBAAmB;IACnB,wBAAwB;IACxB,mCAAmC;AAMvC;;AALI;;AAVJ;QAWQ,WAAW;AAInB;IAHI;;AAZJ;;IAcI,gBAAgB;AACpB;;AAEA;IACI,UAAU;AACd;;AAEA;IACI,6BAA6B;IAC7B,0CAAkC;IAAlC,kCAAkC;IAClC,6BAA6B;IAC7B,kBAAkB;AACtB;;AAEA;IACI,uBAAuB;AAC3B;;AAEA;IACI,sCAAsC;AAC1C;;;AAGA;IACI,eAAe;IACf,cAAc;IACd,kBAAkB;IAClB,SAAS;IACT,QAAQ;IACR,OAAO;IACP,MAAM;IACN,WAAW;IACX,aAAa;IACb,oBAAoB;AACxB;;AAEA;IACI,aAAa;AACjB","sourcesContent":[".root {\n    position: relative;\n}\n\n.header {\n    padding-bottom: var(--space-xl);\n}\n\n.calendar {\n    display: grid;\n    grid-template-columns: 1fr 1fr 1fr 1fr 1fr;\n    grid-template-rows: 1fr 1fr 1fr 1fr 1fr;\n    grid-auto-columns: 1fr;\n    grid-auto-rows: 1fr;\n    grid-gap: var(--space-s);\n\n    @media (orientation: portrait) {\n        grid-template-columns: 1fr 1fr 1fr 1fr;\n        grid-template-rows: 1fr 1fr 1fr 1fr 1fr 1fr;\n        grid-gap: var(--space-xs);\n    }\n\n    .item {\n        position: relative;\n    }\n}\n\n.item--24 {\n    grid-column: span 2;\n    @media (orientation: portrait) {\n        grid-column: span 1;\n    }\n}\n\n.item--list {\n    grid-column: span 1;\n    @media (orientation: portrait) {\n        grid-column: span 1;\n    }\n}\n\n.list {\n    display: grid;\n    grid-template-columns: 1fr 1fr;\n    @media (orientation: portrait) {\n        grid-template-columns: 1fr;\n    }\n    grid-auto-columns: 1fr;\n    grid-auto-rows: 1fr;\n    grid-gap: var(--space-s);\n    margin: 0 calc(var(--space-xl) * 2);\n    @media (orientation: portrait) {\n        margin: 0 0;\n    }\n\n    overflow-y: auto;\n}\n\n.list::-webkit-scrollbar {\n    width: 5px;\n}\n\n.list::-webkit-scrollbar-thumb {\n    background-color: transparent;\n    transition: background-color 200ms;\n    will-change: background-color;\n    border-radius: 5px;\n}\n\n.list::-webkit-scrollbar-track {\n    background: transparent;\n}\n\n.list:hover ::-webkit-scrollbar-thumb {\n    background-color: var(--c-border-dark);\n}\n\n\n.buttonOverlay {\n    cursor: pointer;\n    display: block;\n    position: absolute;\n    bottom: 0;\n    right: 0;\n    left: 0;\n    top: 0;\n    width: 100%;\n    z-index: 9999;\n    text-indent: -9999px;\n}\n\n[data-layout=\"desktop\"] .buttonOverlay {\n    display: none;\n}\n"],"sourceRoot":""}]);
// Exports
___CSS_LOADER_EXPORT___.locals = {
	"root": "Calendar_root__3RNyC",
	"header": "Calendar_header__2UO0k",
	"calendar": "Calendar_calendar__253ID",
	"item": "Calendar_item__Cbyts",
	"item--24": "Calendar_item--24__2KuNY",
	"item--list": "Calendar_item--list__38v-l",
	"list": "Calendar_list__1tLDt",
	"buttonOverlay": "Calendar_buttonOverlay__KFBom"
};
module.exports = ___CSS_LOADER_EXPORT___;


/***/ }),

/***/ "./node_modules/next/dist/compiled/css-loader/cjs.js?!./node_modules/next/dist/compiled/postcss-loader/cjs.js?!./components/Calendar/CalendarDay.module.css":
/*!****************************************************************************************************************************************************!*\
  !*** (webpack)/css-loader/cjs.js??ref--5-oneOf-2-1!(webpack)/postcss-loader/cjs.js??ref--5-oneOf-2-2!./components/Calendar/CalendarDay.module.css ***!
  \****************************************************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// Imports
var ___CSS_LOADER_API_IMPORT___ = __webpack_require__(/*! ../../node_modules/next/dist/compiled/css-loader/api.js */ "./node_modules/next/dist/compiled/css-loader/api.js");
var ___CSS_LOADER_EXPORT___ = ___CSS_LOADER_API_IMPORT___(true);
// Module
___CSS_LOADER_EXPORT___.push([module.i, ".CalendarDay_wrapper__Ukmgx, .CalendarDay_day__12tHB {\n    width: 100%;\n    height: 100%;\n    position: relative;\n    display: block;\n}\n\n.CalendarDay_inner__1bjJY {\n}\n\n.CalendarDay_wrapper__Ukmgx {\n    .CalendarDay_snow__28FnX {\n        pointer-events: none;\n        position: absolute;\n        z-index: 2;\n        left: 0;\n        top: 0;\n        width: 100%;\n        transform: translateY(-60%);\n    }\n\n    .CalendarDay_snow--1__sciiH {\n        transform: translateY(-55%) translateX(-30%) scale(0.5);\n    }\n\n    .CalendarDay_snow--2__200kD {\n        transform: translateY(-61%) translateX(2%) scale(1.1);\n    }\n\n    .CalendarDay_snow--3__3JmUT {\n        transform: translateY(-61%) translateX(2%) scale(0.8);\n    }\n\n    .CalendarDay_snow--4__1tNNW {\n        transform: translateY(-45%) translateX(-30%) scale(0.5);\n    }\n\n    .CalendarDay_snow--5__3EqHi {\n        transform: translateY(-18%) scale(1.05) rotate(4deg);\n    }\n\n    .CalendarDay_snow--6__2hxqZ {\n        transform: translateY(-50%) scale(1.1);\n    }\n\n    .CalendarDay_snow--7__2-Kwo {\n    }\n\n    .CalendarDay_snow--8__3WV3M {\n        transform: translateY(-45%);\n    }\n\n    .CalendarDay_snow--9__3sc_8 {\n        transform: translateY(-50%) scale(1.1);\n    }\n\n    .CalendarDay_snow--10__G1fcy {\n        transform: translateY(-50%) translateX(20%) scale(0.7) rotate(5deg);\n    }\n\n    .CalendarDay_snow--11__3UBj1 {\n        transform: translateY(-35%);\n    }\n\n    .CalendarDay_snow--12__3WURA {\n        transform: translateY(-45%) scale(0.8);\n    }\n\n    .CalendarDay_snow--13__1rmwj {\n        transform: translateY(-30%) rotate(2deg);\n    }\n\n    .CalendarDay_snow--14__3dp6e {\n        transform: translateY(-20%);\n    }\n\n    .CalendarDay_snow--15__XKnfA {\n        transform: translateY(-50%) scale(0.9);\n    }\n\n    .CalendarDay_snow--16__4sb7H {\n        transform: translateY(-50%) translateX(-40%) scale(0.4) rotate(-10deg);\n    }\n\n    .CalendarDay_snow--17__3Sq80 {\n        transform: translateY(-50%) scale(0.8) translateX(20%);\n    }\n\n    .CalendarDay_snow--18__1jg9Q {\n        transform: translateY(-50%);\n    }\n\n    .CalendarDay_snow--19__O2CVP {\n        transform: translateY(-40%) scale(0.6) translateX(-45%) rotate(-8deg);\n    }\n\n    .CalendarDay_snow--20__3a7JQ {\n        transform: translateY(-45%) scale(0.4) translateX(85%) rotate(15deg);\n    }\n\n    .CalendarDay_snow--21__1V8mr {\n        transform: translateY(-45%);\n    }\n\n    .CalendarDay_snow--22__2y4mS {\n        transform: translateY(-61%) translateX(2%) scale(0.8);\n    }\n\n    .CalendarDay_snow--23__1Cfc6 {\n        transform: translateY(-60%) scale(0.7);\n    }\n\n\n    .CalendarDay_snow--24__3VPlT {\n        transform: translateY(-50%) scale(0.8);\n    }\n}\n\n.CalendarDay_day__12tHB {\n    background-color: transparent;\n    border: 2px dashed var(--c-border);\n    color: var(--c-p);\n    text-decoration: none;\n    padding: var(--space-grid);\n    font-weight: 900;\n    font-size: 1.6rem;\n}\n\n@media (max-width: 800px) {\n\n.CalendarDay_day__12tHB {\n        font-size: 1rem;\n}\n    }\n\n.CalendarDay_day__12tHB {\n    line-height: 1;\n}\n\n.CalendarDay_dayActive__1vu72 {\n    background-color: var(--c-primary);\n    border-color: transparent;\n    color: var(--c-white);\n}\n\n", "",{"version":3,"sources":["webpack://components/Calendar/CalendarDay.module.css"],"names":[],"mappings":"AAAA;IACI,WAAW;IACX,YAAY;IACZ,kBAAkB;IAClB,cAAc;AAClB;;AAEA;AACA;;AAEA;IACI;QACI,oBAAoB;QACpB,kBAAkB;QAClB,UAAU;QACV,OAAO;QACP,MAAM;QACN,WAAW;QACX,2BAA2B;IAC/B;;IAEA;QACI,uDAAuD;IAC3D;;IAEA;QACI,qDAAqD;IACzD;;IAEA;QACI,qDAAqD;IACzD;;IAEA;QACI,uDAAuD;IAC3D;;IAEA;QACI,oDAAoD;IACxD;;IAEA;QACI,sCAAsC;IAC1C;;IAEA;IACA;;IAEA;QACI,2BAA2B;IAC/B;;IAEA;QACI,sCAAsC;IAC1C;;IAEA;QACI,mEAAmE;IACvE;;IAEA;QACI,2BAA2B;IAC/B;;IAEA;QACI,sCAAsC;IAC1C;;IAEA;QACI,wCAAwC;IAC5C;;IAEA;QACI,2BAA2B;IAC/B;;IAEA;QACI,sCAAsC;IAC1C;;IAEA;QACI,sEAAsE;IAC1E;;IAEA;QACI,sDAAsD;IAC1D;;IAEA;QACI,2BAA2B;IAC/B;;IAEA;QACI,qEAAqE;IACzE;;IAEA;QACI,oEAAoE;IACxE;;IAEA;QACI,2BAA2B;IAC/B;;IAEA;QACI,qDAAqD;IACzD;;IAEA;QACI,sCAAsC;IAC1C;;;IAGA;QACI,sCAAsC;IAC1C;AACJ;;AAEA;IACI,6BAA6B;IAC7B,kCAAkC;IAClC,iBAAiB;IACjB,qBAAqB;IACrB,0BAA0B;IAC1B,gBAAgB;IAChB,iBAAiB;AAKrB;;AAJI;;AARJ;QASQ,eAAe;AAGvB;IAFI;;AAVJ;IAWI,cAAc;AAClB;;AAEA;IACI,kCAAkC;IAClC,yBAAyB;IACzB,qBAAqB;AACzB","sourcesContent":[".wrapper, .day {\n    width: 100%;\n    height: 100%;\n    position: relative;\n    display: block;\n}\n\n.inner {\n}\n\n.wrapper {\n    .snow {\n        pointer-events: none;\n        position: absolute;\n        z-index: 2;\n        left: 0;\n        top: 0;\n        width: 100%;\n        transform: translateY(-60%);\n    }\n\n    .snow--1 {\n        transform: translateY(-55%) translateX(-30%) scale(0.5);\n    }\n\n    .snow--2 {\n        transform: translateY(-61%) translateX(2%) scale(1.1);\n    }\n\n    .snow--3 {\n        transform: translateY(-61%) translateX(2%) scale(0.8);\n    }\n\n    .snow--4 {\n        transform: translateY(-45%) translateX(-30%) scale(0.5);\n    }\n\n    .snow--5 {\n        transform: translateY(-18%) scale(1.05) rotate(4deg);\n    }\n\n    .snow--6 {\n        transform: translateY(-50%) scale(1.1);\n    }\n\n    .snow--7 {\n    }\n\n    .snow--8 {\n        transform: translateY(-45%);\n    }\n\n    .snow--9 {\n        transform: translateY(-50%) scale(1.1);\n    }\n\n    .snow--10 {\n        transform: translateY(-50%) translateX(20%) scale(0.7) rotate(5deg);\n    }\n\n    .snow--11 {\n        transform: translateY(-35%);\n    }\n\n    .snow--12 {\n        transform: translateY(-45%) scale(0.8);\n    }\n\n    .snow--13 {\n        transform: translateY(-30%) rotate(2deg);\n    }\n\n    .snow--14 {\n        transform: translateY(-20%);\n    }\n\n    .snow--15 {\n        transform: translateY(-50%) scale(0.9);\n    }\n\n    .snow--16 {\n        transform: translateY(-50%) translateX(-40%) scale(0.4) rotate(-10deg);\n    }\n\n    .snow--17 {\n        transform: translateY(-50%) scale(0.8) translateX(20%);\n    }\n\n    .snow--18 {\n        transform: translateY(-50%);\n    }\n\n    .snow--19 {\n        transform: translateY(-40%) scale(0.6) translateX(-45%) rotate(-8deg);\n    }\n\n    .snow--20 {\n        transform: translateY(-45%) scale(0.4) translateX(85%) rotate(15deg);\n    }\n\n    .snow--21 {\n        transform: translateY(-45%);\n    }\n\n    .snow--22 {\n        transform: translateY(-61%) translateX(2%) scale(0.8);\n    }\n\n    .snow--23 {\n        transform: translateY(-60%) scale(0.7);\n    }\n\n\n    .snow--24 {\n        transform: translateY(-50%) scale(0.8);\n    }\n}\n\n.day {\n    background-color: transparent;\n    border: 2px dashed var(--c-border);\n    color: var(--c-p);\n    text-decoration: none;\n    padding: var(--space-grid);\n    font-weight: 900;\n    font-size: 1.6rem;\n    @media (max-width: 800px) {\n        font-size: 1rem;\n    }\n    line-height: 1;\n}\n\n.dayActive {\n    background-color: var(--c-primary);\n    border-color: transparent;\n    color: var(--c-white);\n}\n\n"],"sourceRoot":""}]);
// Exports
___CSS_LOADER_EXPORT___.locals = {
	"wrapper": "CalendarDay_wrapper__Ukmgx",
	"day": "CalendarDay_day__12tHB",
	"inner": "CalendarDay_inner__1bjJY",
	"snow": "CalendarDay_snow__28FnX",
	"snow--1": "CalendarDay_snow--1__sciiH",
	"snow--2": "CalendarDay_snow--2__200kD",
	"snow--3": "CalendarDay_snow--3__3JmUT",
	"snow--4": "CalendarDay_snow--4__1tNNW",
	"snow--5": "CalendarDay_snow--5__3EqHi",
	"snow--6": "CalendarDay_snow--6__2hxqZ",
	"snow--7": "CalendarDay_snow--7__2-Kwo",
	"snow--8": "CalendarDay_snow--8__3WV3M",
	"snow--9": "CalendarDay_snow--9__3sc_8",
	"snow--10": "CalendarDay_snow--10__G1fcy",
	"snow--11": "CalendarDay_snow--11__3UBj1",
	"snow--12": "CalendarDay_snow--12__3WURA",
	"snow--13": "CalendarDay_snow--13__1rmwj",
	"snow--14": "CalendarDay_snow--14__3dp6e",
	"snow--15": "CalendarDay_snow--15__XKnfA",
	"snow--16": "CalendarDay_snow--16__4sb7H",
	"snow--17": "CalendarDay_snow--17__3Sq80",
	"snow--18": "CalendarDay_snow--18__1jg9Q",
	"snow--19": "CalendarDay_snow--19__O2CVP",
	"snow--20": "CalendarDay_snow--20__3a7JQ",
	"snow--21": "CalendarDay_snow--21__1V8mr",
	"snow--22": "CalendarDay_snow--22__2y4mS",
	"snow--23": "CalendarDay_snow--23__1Cfc6",
	"snow--24": "CalendarDay_snow--24__3VPlT",
	"dayActive": "CalendarDay_dayActive__1vu72"
};
module.exports = ___CSS_LOADER_EXPORT___;


/***/ }),

/***/ "./node_modules/next/dist/compiled/css-loader/cjs.js?!./node_modules/next/dist/compiled/postcss-loader/cjs.js?!./components/Calendar/CalendarDayList.module.css":
/*!********************************************************************************************************************************************************!*\
  !*** (webpack)/css-loader/cjs.js??ref--5-oneOf-2-1!(webpack)/postcss-loader/cjs.js??ref--5-oneOf-2-2!./components/Calendar/CalendarDayList.module.css ***!
  \********************************************************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// Imports
var ___CSS_LOADER_API_IMPORT___ = __webpack_require__(/*! ../../node_modules/next/dist/compiled/css-loader/api.js */ "./node_modules/next/dist/compiled/css-loader/api.js");
var ___CSS_LOADER_EXPORT___ = ___CSS_LOADER_API_IMPORT___(true);
// Module
___CSS_LOADER_EXPORT___.push([module.i, ".CalendarDayList_root__30_x9 {\n    display: flex;\n    text-decoration: none;\n    align-items: center;\n}\n\n.CalendarDayList_rootActive__1AEcI {\n    .CalendarDayList_number__fB0v_ {\n        background-color: var(--c-primary);\n        border-color: transparent;\n        color: var(--c-white);\n    }\n}\n\n.CalendarDayList_number__fB0v_ {\n    background-color: transparent;\n    border: 2px dashed var(--c-border);\n    color: var(--c-p);\n    width: 2.5rem;\n    height: 2.5rem;\n    display: flex;\n    font-size: 1rem;\n    font-weight: bold;\n    justify-content: center;\n    align-items: center;\n    margin-right: 1rem;\n}\n\n.CalendarDayList_title__HPzCc {\n    font-weight: bold;\n    color: var(--c-p);\n}\n\n.CalendarDayList_wrapper__3uAJ3 {\n}\n\n.CalendarDayList_wrapperInner__2S7fu {\n}\n", "",{"version":3,"sources":["webpack://components/Calendar/CalendarDayList.module.css"],"names":[],"mappings":"AAAA;IACI,aAAa;IACb,qBAAqB;IACrB,mBAAmB;AACvB;;AAEA;IACI;QACI,kCAAkC;QAClC,yBAAyB;QACzB,qBAAqB;IACzB;AACJ;;AAEA;IACI,6BAA6B;IAC7B,kCAAkC;IAClC,iBAAiB;IACjB,aAAa;IACb,cAAc;IACd,aAAa;IACb,eAAe;IACf,iBAAiB;IACjB,uBAAuB;IACvB,mBAAmB;IACnB,kBAAkB;AACtB;;AAEA;IACI,iBAAiB;IACjB,iBAAiB;AACrB;;AAEA;AACA;;AAEA;AACA","sourcesContent":[".root {\n    display: flex;\n    text-decoration: none;\n    align-items: center;\n}\n\n.rootActive {\n    .number {\n        background-color: var(--c-primary);\n        border-color: transparent;\n        color: var(--c-white);\n    }\n}\n\n.number {\n    background-color: transparent;\n    border: 2px dashed var(--c-border);\n    color: var(--c-p);\n    width: 2.5rem;\n    height: 2.5rem;\n    display: flex;\n    font-size: 1rem;\n    font-weight: bold;\n    justify-content: center;\n    align-items: center;\n    margin-right: 1rem;\n}\n\n.title {\n    font-weight: bold;\n    color: var(--c-p);\n}\n\n.wrapper {\n}\n\n.wrapperInner {\n}\n"],"sourceRoot":""}]);
// Exports
___CSS_LOADER_EXPORT___.locals = {
	"root": "CalendarDayList_root__30_x9",
	"rootActive": "CalendarDayList_rootActive__1AEcI",
	"number": "CalendarDayList_number__fB0v_",
	"title": "CalendarDayList_title__HPzCc",
	"wrapper": "CalendarDayList_wrapper__3uAJ3",
	"wrapperInner": "CalendarDayList_wrapperInner__2S7fu"
};
module.exports = ___CSS_LOADER_EXPORT___;


/***/ }),

/***/ "./node_modules/next/dist/compiled/css-loader/cjs.js?!./node_modules/next/dist/compiled/postcss-loader/cjs.js?!./components/Calendar/CalendarHeader.module.css":
/*!*******************************************************************************************************************************************************!*\
  !*** (webpack)/css-loader/cjs.js??ref--5-oneOf-2-1!(webpack)/postcss-loader/cjs.js??ref--5-oneOf-2-2!./components/Calendar/CalendarHeader.module.css ***!
  \*******************************************************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// Imports
var ___CSS_LOADER_API_IMPORT___ = __webpack_require__(/*! ../../node_modules/next/dist/compiled/css-loader/api.js */ "./node_modules/next/dist/compiled/css-loader/api.js");
var ___CSS_LOADER_EXPORT___ = ___CSS_LOADER_API_IMPORT___(true);
// Module
___CSS_LOADER_EXPORT___.push([module.i, ".CalendarHeader_root__1i0l2 {\n    display: flex;\n    justify-content: space-between;\n    align-items: center;\n    flex-wrap: wrap;\n    transition: opacity 200ms ease-in-out;\n    opacity: 1;\n}\n\n.CalendarHeader_logo__ix__5 {\n    width: 12rem;\n    max-width: 50%;\n}\n\n.CalendarHeader_view__1GWBf {\n    width: 100%;\n    display: flex;\n    justify-content: center;\n    margin-top: var(--space-xl);\n}\n\n.CalendarHeader_viewButton__31Acd:first-child {\n        border-bottom-right-radius: 0;\n        border-top-right-radius: 0;\n    }\n\n.CalendarHeader_viewButton__31Acd:last-child {\n        border-bottom-left-radius: 0;\n        border-top-left-radius: 0;\n    }\n\n.CalendarHeader_viewButtonActive__1jhxW {\n}\n\n[data-menu='open'] .CalendarHeader_root__1i0l2 {\n    opacity: 0.1;\n}\n\n[data-layout='desktop'] .CalendarHeader_logo__ix__5,\n[data-layout='desktop'] .CalendarHeader_button__3UyoW {\n    display: none;\n}\n\n\n", "",{"version":3,"sources":["webpack://components/Calendar/CalendarHeader.module.css"],"names":[],"mappings":"AAAA;IACI,aAAa;IACb,8BAA8B;IAC9B,mBAAmB;IACnB,eAAe;IACf,qCAAqC;IACrC,UAAU;AACd;;AAEA;IACI,YAAY;IACZ,cAAc;AAClB;;AAEA;IACI,WAAW;IACX,aAAa;IACb,uBAAuB;IACvB,2BAA2B;AAC/B;;AAGI;QACI,6BAA6B;QAC7B,0BAA0B;IAC9B;;AAGA;QACI,4BAA4B;QAC5B,yBAAyB;IAC7B;;AAGJ;AACA;;AAEA;IACI,YAAY;AAChB;;AAEA;;IAEI,aAAa;AACjB","sourcesContent":[".root {\n    display: flex;\n    justify-content: space-between;\n    align-items: center;\n    flex-wrap: wrap;\n    transition: opacity 200ms ease-in-out;\n    opacity: 1;\n}\n\n.logo {\n    width: 12rem;\n    max-width: 50%;\n}\n\n.view {\n    width: 100%;\n    display: flex;\n    justify-content: center;\n    margin-top: var(--space-xl);\n}\n\n.viewButton {\n    &:first-child {\n        border-bottom-right-radius: 0;\n        border-top-right-radius: 0;\n    }\n\n\n    &:last-child {\n        border-bottom-left-radius: 0;\n        border-top-left-radius: 0;\n    }\n}\n\n.viewButtonActive {\n}\n\n[data-menu='open'] .root {\n    opacity: 0.1;\n}\n\n[data-layout='desktop'] .logo,\n[data-layout='desktop'] .button {\n    display: none;\n}\n\n\n"],"sourceRoot":""}]);
// Exports
___CSS_LOADER_EXPORT___.locals = {
	"root": "CalendarHeader_root__1i0l2",
	"logo": "CalendarHeader_logo__ix__5",
	"view": "CalendarHeader_view__1GWBf",
	"viewButton": "CalendarHeader_viewButton__31Acd",
	"viewButtonActive": "CalendarHeader_viewButtonActive__1jhxW",
	"button": "CalendarHeader_button__3UyoW"
};
module.exports = ___CSS_LOADER_EXPORT___;


/***/ }),

/***/ "./node_modules/next/dist/compiled/css-loader/cjs.js?!./node_modules/next/dist/compiled/postcss-loader/cjs.js?!./components/Content/ContentAuthor.module.css":
/*!*****************************************************************************************************************************************************!*\
  !*** (webpack)/css-loader/cjs.js??ref--5-oneOf-2-1!(webpack)/postcss-loader/cjs.js??ref--5-oneOf-2-2!./components/Content/ContentAuthor.module.css ***!
  \*****************************************************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// Imports
var ___CSS_LOADER_API_IMPORT___ = __webpack_require__(/*! ../../node_modules/next/dist/compiled/css-loader/api.js */ "./node_modules/next/dist/compiled/css-loader/api.js");
var ___CSS_LOADER_EXPORT___ = ___CSS_LOADER_API_IMPORT___(true);
// Module
___CSS_LOADER_EXPORT___.push([module.i, ".ContentAuthor_root__2fH9L {\r\n    display: flex;\r\n    align-items: center;\r\n}\r\n\r\n.ContentAuthor_image__2ImfT {\r\n    border-radius: 50%;\r\n    margin-right: var(--space);\r\n    box-shadow: 0 0 1px rgba(0, 0, 0, 0.2);\r\n}\r\n\r\n.ContentAuthor_name__3bFRl,\r\n.ContentAuthor_linksItem__3JwSE {\r\n    font-size: var(--fs-small);\r\n}\r\n\r\n.ContentAuthor_name__3bFRl a,\r\n.ContentAuthor_linksItem__3JwSE a {\r\n    color: var(--c-p)\r\n}\r\n\r\n.ContentAuthor_name__3bFRl a:hover, .ContentAuthor_linksItem__3JwSE a:hover {\r\n        text-decoration: none;\r\n    }\r\n\r\n.ContentAuthor_about__NFd32 {\r\n}\r\n\r\n.ContentAuthor_name__3bFRl a {\r\n    text-decoration: none\r\n}\r\n\r\n.ContentAuthor_name__3bFRl a:hover {\r\n        text-decoration: underline;\r\n    }\r\n\r\n.ContentAuthor_links__1cCMR {\r\n    display: flex;\r\n    list-style: none;\r\n}\r\n\r\n.ContentAuthor_linksItem__3JwSE + .ContentAuthor_linksItem__3JwSE::before {\r\n        content: '';\r\n        display: inline-block;\r\n        margin: 0 0.4em;\r\n    }\r\n", "",{"version":3,"sources":["webpack://components/Content/ContentAuthor.module.css"],"names":[],"mappings":"AAAA;IACI,aAAa;IACb,mBAAmB;AACvB;;AAEA;IACI,kBAAkB;IAClB,0BAA0B;IAC1B,sCAAsC;AAC1C;;AAEA;;IAEI,0BAA0B;AAC9B;;AAEA;;IAEI;AAKJ;;AAHI;QACI,qBAAqB;IACzB;;AAGJ;AACA;;AAEA;IACI;AAKJ;;AAHI;QACI,0BAA0B;IAC9B;;AAGJ;IACI,aAAa;IACb,gBAAgB;AACpB;;AAGI;QACI,YAAY;QACZ,qBAAqB;QACrB,eAAe;IACnB","sourcesContent":[".root {\r\n    display: flex;\r\n    align-items: center;\r\n}\r\n\r\n.image {\r\n    border-radius: 50%;\r\n    margin-right: var(--space);\r\n    box-shadow: 0 0 1px rgba(0, 0, 0, 0.2);\r\n}\r\n\r\n.name,\r\n.linksItem {\r\n    font-size: var(--fs-small);\r\n}\r\n\r\n.name a,\r\n.linksItem a {\r\n    color: var(--c-p);\r\n\r\n    &:hover {\r\n        text-decoration: none;\r\n    }\r\n}\r\n\r\n.about {\r\n}\r\n\r\n.name a {\r\n    text-decoration: none;\r\n\r\n    &:hover {\r\n        text-decoration: underline;\r\n    }\r\n}\r\n\r\n.links {\r\n    display: flex;\r\n    list-style: none;\r\n}\r\n\r\n.linksItem + .linksItem {\r\n    &::before {\r\n        content: '';\r\n        display: inline-block;\r\n        margin: 0 0.4em;\r\n    }\r\n}\r\n"],"sourceRoot":""}]);
// Exports
___CSS_LOADER_EXPORT___.locals = {
	"root": "ContentAuthor_root__2fH9L",
	"image": "ContentAuthor_image__2ImfT",
	"name": "ContentAuthor_name__3bFRl",
	"linksItem": "ContentAuthor_linksItem__3JwSE",
	"about": "ContentAuthor_about__NFd32",
	"links": "ContentAuthor_links__1cCMR"
};
module.exports = ___CSS_LOADER_EXPORT___;


/***/ }),

/***/ "./node_modules/next/dist/compiled/css-loader/cjs.js?!./node_modules/next/dist/compiled/postcss-loader/cjs.js?!./components/Content/ContentCalendar.module.css":
/*!*******************************************************************************************************************************************************!*\
  !*** (webpack)/css-loader/cjs.js??ref--5-oneOf-2-1!(webpack)/postcss-loader/cjs.js??ref--5-oneOf-2-2!./components/Content/ContentCalendar.module.css ***!
  \*******************************************************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// Imports
var ___CSS_LOADER_API_IMPORT___ = __webpack_require__(/*! ../../node_modules/next/dist/compiled/css-loader/api.js */ "./node_modules/next/dist/compiled/css-loader/api.js");
var ___CSS_LOADER_EXPORT___ = ___CSS_LOADER_API_IMPORT___(true);
// Module
___CSS_LOADER_EXPORT___.push([module.i, ".ContentCalendar_excerpt__TamnA {\n    font-size: var(--fs-big);\n    font-weight: bold;\n    line-height: 1.4;\n}\n\n.ContentCalendar_error__1PRml {\n}\n\n.ContentCalendar_image__3iNeE {\n    width: 100%;\n    display: block;\n}\n\n.ContentCalendar_date__6ZFCE, .ContentCalendar_cannonical__1rqtm {\n    margin-top: var(--space);\n}\n\n.ContentCalendar_date__6ZFCE {\n    margin-bottom: var(--space-s);\n}\n\n.ContentCalendar_meta__yHfjb,\n.ContentCalendar_excerpt__TamnA,\n.ContentCalendar_image__3iNeE {\n    margin-bottom: var(--space-l);\n}\n\n.ContentCalendar_meta__yHfjb {\n    display: flex;\n    align-items: center;\n    justify-content: space-between;\n}\n\n.ContentCalendar_author__1UtRI {\n    margin-right: var(--space);\n}\n", "",{"version":3,"sources":["webpack://components/Content/ContentCalendar.module.css"],"names":[],"mappings":"AAAA;IACI,wBAAwB;IACxB,iBAAiB;IACjB,gBAAgB;AACpB;;AAEA;AACA;;AAEA;IACI,WAAW;IACX,cAAc;AAClB;;AAEA;IACI,wBAAwB;AAC5B;;AAEA;IACI,6BAA6B;AACjC;;AAEA;;;IAGI,6BAA6B;AACjC;;AAEA;IACI,aAAa;IACb,mBAAmB;IACnB,8BAA8B;AAClC;;AAEA;IACI,0BAA0B;AAC9B","sourcesContent":[".excerpt {\n    font-size: var(--fs-big);\n    font-weight: bold;\n    line-height: 1.4;\n}\n\n.error {\n}\n\n.image {\n    width: 100%;\n    display: block;\n}\n\n.date, .cannonical {\n    margin-top: var(--space);\n}\n\n.date {\n    margin-bottom: var(--space-s);\n}\n\n.meta,\n.excerpt,\n.image {\n    margin-bottom: var(--space-l);\n}\n\n.meta {\n    display: flex;\n    align-items: center;\n    justify-content: space-between;\n}\n\n.author {\n    margin-right: var(--space);\n}\n"],"sourceRoot":""}]);
// Exports
___CSS_LOADER_EXPORT___.locals = {
	"excerpt": "ContentCalendar_excerpt__TamnA",
	"error": "ContentCalendar_error__1PRml",
	"image": "ContentCalendar_image__3iNeE",
	"date": "ContentCalendar_date__6ZFCE",
	"cannonical": "ContentCalendar_cannonical__1rqtm",
	"meta": "ContentCalendar_meta__yHfjb",
	"author": "ContentCalendar_author__1UtRI"
};
module.exports = ___CSS_LOADER_EXPORT___;


/***/ }),

/***/ "./node_modules/next/dist/compiled/css-loader/cjs.js?!./node_modules/next/dist/compiled/postcss-loader/cjs.js?!./pages/_app.css":
/*!************************************************************************************************************************!*\
  !*** (webpack)/css-loader/cjs.js??ref--5-oneOf-6-1!(webpack)/postcss-loader/cjs.js??ref--5-oneOf-6-2!./pages/_app.css ***!
  \************************************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _node_modules_next_dist_compiled_css_loader_api_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../node_modules/next/dist/compiled/css-loader/api.js */ "./node_modules/next/dist/compiled/css-loader/api.js");
/* harmony import */ var _node_modules_next_dist_compiled_css_loader_api_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_next_dist_compiled_css_loader_api_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _node_modules_next_dist_compiled_css_loader_cjs_js_ref_5_oneOf_6_1_node_modules_next_dist_compiled_postcss_loader_cjs_js_ref_5_oneOf_6_2_styles_fonts_font_woff2_css__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! -!../node_modules/next/dist/compiled/css-loader/cjs.js??ref--5-oneOf-6-1!../node_modules/next/dist/compiled/postcss-loader/cjs.js??ref--5-oneOf-6-2!../styles/fonts/font-woff2.css */ "./node_modules/next/dist/compiled/css-loader/cjs.js?!./node_modules/next/dist/compiled/postcss-loader/cjs.js?!./styles/fonts/font-woff2.css");
/* harmony import */ var _node_modules_next_dist_compiled_css_loader_cjs_js_ref_5_oneOf_6_1_node_modules_next_dist_compiled_postcss_loader_cjs_js_ref_5_oneOf_6_2_styles_keyframes_spinner_css__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! -!../node_modules/next/dist/compiled/css-loader/cjs.js??ref--5-oneOf-6-1!../node_modules/next/dist/compiled/postcss-loader/cjs.js??ref--5-oneOf-6-2!../styles/keyframes/spinner.css */ "./node_modules/next/dist/compiled/css-loader/cjs.js?!./node_modules/next/dist/compiled/postcss-loader/cjs.js?!./styles/keyframes/spinner.css");
/* harmony import */ var _node_modules_next_dist_compiled_css_loader_cjs_js_ref_5_oneOf_6_1_node_modules_next_dist_compiled_postcss_loader_cjs_js_ref_5_oneOf_6_2_styles_reset_css__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! -!../node_modules/next/dist/compiled/css-loader/cjs.js??ref--5-oneOf-6-1!../node_modules/next/dist/compiled/postcss-loader/cjs.js??ref--5-oneOf-6-2!../styles/reset.css */ "./node_modules/next/dist/compiled/css-loader/cjs.js?!./node_modules/next/dist/compiled/postcss-loader/cjs.js?!./styles/reset.css");
/* harmony import */ var _node_modules_next_dist_compiled_css_loader_cjs_js_ref_5_oneOf_6_1_node_modules_next_dist_compiled_postcss_loader_cjs_js_ref_5_oneOf_6_2_styles_grid_css__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! -!../node_modules/next/dist/compiled/css-loader/cjs.js??ref--5-oneOf-6-1!../node_modules/next/dist/compiled/postcss-loader/cjs.js??ref--5-oneOf-6-2!../styles/grid.css */ "./node_modules/next/dist/compiled/css-loader/cjs.js?!./node_modules/next/dist/compiled/postcss-loader/cjs.js?!./styles/grid.css");
/* harmony import */ var _node_modules_next_dist_compiled_css_loader_cjs_js_ref_5_oneOf_6_1_node_modules_next_dist_compiled_postcss_loader_cjs_js_ref_5_oneOf_6_2_styles_vars_css__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! -!../node_modules/next/dist/compiled/css-loader/cjs.js??ref--5-oneOf-6-1!../node_modules/next/dist/compiled/postcss-loader/cjs.js??ref--5-oneOf-6-2!../styles/vars.css */ "./node_modules/next/dist/compiled/css-loader/cjs.js?!./node_modules/next/dist/compiled/postcss-loader/cjs.js?!./styles/vars.css");
/* harmony import */ var _node_modules_next_dist_compiled_css_loader_cjs_js_ref_5_oneOf_6_1_node_modules_next_dist_compiled_postcss_loader_cjs_js_ref_5_oneOf_6_2_styles_typography_css__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! -!../node_modules/next/dist/compiled/css-loader/cjs.js??ref--5-oneOf-6-1!../node_modules/next/dist/compiled/postcss-loader/cjs.js??ref--5-oneOf-6-2!../styles/typography.css */ "./node_modules/next/dist/compiled/css-loader/cjs.js?!./node_modules/next/dist/compiled/postcss-loader/cjs.js?!./styles/typography.css");
/* harmony import */ var _node_modules_next_dist_compiled_css_loader_cjs_js_ref_5_oneOf_6_1_node_modules_next_dist_compiled_postcss_loader_cjs_js_ref_5_oneOf_6_2_styles_colors_css__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! -!../node_modules/next/dist/compiled/css-loader/cjs.js??ref--5-oneOf-6-1!../node_modules/next/dist/compiled/postcss-loader/cjs.js??ref--5-oneOf-6-2!../styles/colors.css */ "./node_modules/next/dist/compiled/css-loader/cjs.js?!./node_modules/next/dist/compiled/postcss-loader/cjs.js?!./styles/colors.css");
/* harmony import */ var _node_modules_next_dist_compiled_css_loader_cjs_js_ref_5_oneOf_6_1_node_modules_next_dist_compiled_postcss_loader_cjs_js_ref_5_oneOf_6_2_styles_document_css__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! -!../node_modules/next/dist/compiled/css-loader/cjs.js??ref--5-oneOf-6-1!../node_modules/next/dist/compiled/postcss-loader/cjs.js??ref--5-oneOf-6-2!../styles/document.css */ "./node_modules/next/dist/compiled/css-loader/cjs.js?!./node_modules/next/dist/compiled/postcss-loader/cjs.js?!./styles/document.css");
// Imports









var ___CSS_LOADER_EXPORT___ = _node_modules_next_dist_compiled_css_loader_api_js__WEBPACK_IMPORTED_MODULE_0___default()(true);
___CSS_LOADER_EXPORT___.i(_node_modules_next_dist_compiled_css_loader_cjs_js_ref_5_oneOf_6_1_node_modules_next_dist_compiled_postcss_loader_cjs_js_ref_5_oneOf_6_2_styles_fonts_font_woff2_css__WEBPACK_IMPORTED_MODULE_1__["default"]);
___CSS_LOADER_EXPORT___.i(_node_modules_next_dist_compiled_css_loader_cjs_js_ref_5_oneOf_6_1_node_modules_next_dist_compiled_postcss_loader_cjs_js_ref_5_oneOf_6_2_styles_keyframes_spinner_css__WEBPACK_IMPORTED_MODULE_2__["default"]);
___CSS_LOADER_EXPORT___.i(_node_modules_next_dist_compiled_css_loader_cjs_js_ref_5_oneOf_6_1_node_modules_next_dist_compiled_postcss_loader_cjs_js_ref_5_oneOf_6_2_styles_reset_css__WEBPACK_IMPORTED_MODULE_3__["default"]);
___CSS_LOADER_EXPORT___.i(_node_modules_next_dist_compiled_css_loader_cjs_js_ref_5_oneOf_6_1_node_modules_next_dist_compiled_postcss_loader_cjs_js_ref_5_oneOf_6_2_styles_grid_css__WEBPACK_IMPORTED_MODULE_4__["default"]);
___CSS_LOADER_EXPORT___.i(_node_modules_next_dist_compiled_css_loader_cjs_js_ref_5_oneOf_6_1_node_modules_next_dist_compiled_postcss_loader_cjs_js_ref_5_oneOf_6_2_styles_vars_css__WEBPACK_IMPORTED_MODULE_5__["default"]);
___CSS_LOADER_EXPORT___.i(_node_modules_next_dist_compiled_css_loader_cjs_js_ref_5_oneOf_6_1_node_modules_next_dist_compiled_postcss_loader_cjs_js_ref_5_oneOf_6_2_styles_typography_css__WEBPACK_IMPORTED_MODULE_6__["default"]);
___CSS_LOADER_EXPORT___.i(_node_modules_next_dist_compiled_css_loader_cjs_js_ref_5_oneOf_6_1_node_modules_next_dist_compiled_postcss_loader_cjs_js_ref_5_oneOf_6_2_styles_colors_css__WEBPACK_IMPORTED_MODULE_7__["default"]);
___CSS_LOADER_EXPORT___.i(_node_modules_next_dist_compiled_css_loader_cjs_js_ref_5_oneOf_6_1_node_modules_next_dist_compiled_postcss_loader_cjs_js_ref_5_oneOf_6_2_styles_document_css__WEBPACK_IMPORTED_MODULE_8__["default"]);
// Module
___CSS_LOADER_EXPORT___.push([module.i, ".app {\r\n    width: 1200px;\r\n    max-width: 100%;\r\n    margin: 0 auto;\r\n    height: 100vh;\r\n    padding: var(--space) 0;\r\n    overflow: hidden;\r\n    will-change: opacity;\r\n    transition: opacity 100ms ease-in;\r\n\r\n    &__inner {\r\n        display: flex;\r\n        height: 100%;\r\n        width: 100%;\r\n    }\r\n\r\n    &__sidebar,\r\n    &__content {\r\n        padding: 0 var(--space);\r\n        display: flex;\r\n        justify-content: center;\r\n        flex-direction: column;\r\n    }\r\n\r\n    &__sidebar {\r\n        flex: 0 1 var(--menu-width);\r\n        padding-right: var(--space-l);\r\n    }\r\n\r\n    &__content {\r\n        height: calc(100% - var(--space));\r\n        flex-grow: 1;\r\n    }\r\n\r\n    &__snow {\r\n        position: absolute;\r\n        top: 0;\r\n        right: 0;\r\n        bottom: 0;\r\n        left: 0;\r\n        pointer-events: none;\r\n        z-index: 5000;\r\n    }\r\n}\r\n\r\n[data-layout='mobile'] {\r\n    --menu-width: 80vw;\r\n\r\n    .app {\r\n        &__inner {\r\n            width: calc(100% + var(--menu-width));\r\n            transform: translateX(calc(var(--menu-width) * -1));\r\n        }\r\n\r\n        &__content {\r\n            width: 100vw;\r\n        }\r\n    }\r\n}\r\n\r\n[data-layout-transition='true'] {\r\n    .app {\r\n        &__inner,\r\n        &__content {\r\n            will-change: transform;\r\n            transition: transform 200ms ease-in-out;\r\n        }\r\n    }\r\n}\r\n\r\n[data-layout='mobile'][data-menu='open'] {\r\n    .app {\r\n        &__inner {\r\n            transform: translateX(0);\r\n        }\r\n\r\n        &__content {\r\n            transform: scale(0.8);\r\n            transform-origin: left center;\r\n            opacity: 0.5;\r\n\r\n            a {\r\n                pointer-events: none !important;\r\n            }\r\n        }\r\n    }\r\n}\r\n", "",{"version":3,"sources":["webpack://pages/_app.css"],"names":[],"mappings":"AASA;IACI,aAAa;IACb,eAAe;IACf,cAAc;IACd,aAAa;IACb,uBAAuB;IACvB,gBAAgB;IAChB,oBAAoB;IACpB,iCAAiC;;IAEjC;QACI,aAAa;QACb,YAAY;QACZ,WAAW;IACf;;IAEA;;QAEI,uBAAuB;QACvB,aAAa;QACb,uBAAuB;QACvB,sBAAsB;IAC1B;;IAEA;QACI,2BAA2B;QAC3B,6BAA6B;IACjC;;IAEA;QACI,iCAAiC;QACjC,YAAY;IAChB;;IAEA;QACI,kBAAkB;QAClB,MAAM;QACN,QAAQ;QACR,SAAS;QACT,OAAO;QACP,oBAAoB;QACpB,aAAa;IACjB;AACJ;;AAEA;IACI,kBAAkB;;IAElB;QACI;YACI,qCAAqC;YACrC,mDAAmD;QACvD;;QAEA;YACI,YAAY;QAChB;IACJ;AACJ;;AAEA;IACI;QACI;;YAEI,sBAAsB;YACtB,uCAAuC;QAC3C;IACJ;AACJ;;AAEA;IACI;QACI;YACI,wBAAwB;QAC5B;;QAEA;YACI,qBAAqB;YACrB,6BAA6B;YAC7B,YAAY;;YAEZ;gBACI,+BAA+B;YACnC;QACJ;IACJ;AACJ","sourcesContent":["@import '../styles/fonts/font-woff2.css';\r\n@import '../styles/keyframes/spinner.css';\r\n@import '../styles/reset.css';\r\n@import '../styles/grid.css';\r\n@import '../styles/vars.css';\r\n@import '../styles/typography.css';\r\n@import '../styles/colors.css';\r\n@import '../styles/document.css';\r\n\r\n.app {\r\n    width: 1200px;\r\n    max-width: 100%;\r\n    margin: 0 auto;\r\n    height: 100vh;\r\n    padding: var(--space) 0;\r\n    overflow: hidden;\r\n    will-change: opacity;\r\n    transition: opacity 100ms ease-in;\r\n\r\n    &__inner {\r\n        display: flex;\r\n        height: 100%;\r\n        width: 100%;\r\n    }\r\n\r\n    &__sidebar,\r\n    &__content {\r\n        padding: 0 var(--space);\r\n        display: flex;\r\n        justify-content: center;\r\n        flex-direction: column;\r\n    }\r\n\r\n    &__sidebar {\r\n        flex: 0 1 var(--menu-width);\r\n        padding-right: var(--space-l);\r\n    }\r\n\r\n    &__content {\r\n        height: calc(100% - var(--space));\r\n        flex-grow: 1;\r\n    }\r\n\r\n    &__snow {\r\n        position: absolute;\r\n        top: 0;\r\n        right: 0;\r\n        bottom: 0;\r\n        left: 0;\r\n        pointer-events: none;\r\n        z-index: 5000;\r\n    }\r\n}\r\n\r\n[data-layout='mobile'] {\r\n    --menu-width: 80vw;\r\n\r\n    .app {\r\n        &__inner {\r\n            width: calc(100% + var(--menu-width));\r\n            transform: translateX(calc(var(--menu-width) * -1));\r\n        }\r\n\r\n        &__content {\r\n            width: 100vw;\r\n        }\r\n    }\r\n}\r\n\r\n[data-layout-transition='true'] {\r\n    .app {\r\n        &__inner,\r\n        &__content {\r\n            will-change: transform;\r\n            transition: transform 200ms ease-in-out;\r\n        }\r\n    }\r\n}\r\n\r\n[data-layout='mobile'][data-menu='open'] {\r\n    .app {\r\n        &__inner {\r\n            transform: translateX(0);\r\n        }\r\n\r\n        &__content {\r\n            transform: scale(0.8);\r\n            transform-origin: left center;\r\n            opacity: 0.5;\r\n\r\n            a {\r\n                pointer-events: none !important;\r\n            }\r\n        }\r\n    }\r\n}\r\n"],"sourceRoot":""}]);
// Exports
/* harmony default export */ __webpack_exports__["default"] = (___CSS_LOADER_EXPORT___);


/***/ }),

/***/ "./node_modules/next/dist/compiled/css-loader/cjs.js?!./node_modules/next/dist/compiled/postcss-loader/cjs.js?!./styles/colors.css":
/*!***************************************************************************************************************************!*\
  !*** (webpack)/css-loader/cjs.js??ref--5-oneOf-6-1!(webpack)/postcss-loader/cjs.js??ref--5-oneOf-6-2!./styles/colors.css ***!
  \***************************************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _node_modules_next_dist_compiled_css_loader_api_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../node_modules/next/dist/compiled/css-loader/api.js */ "./node_modules/next/dist/compiled/css-loader/api.js");
/* harmony import */ var _node_modules_next_dist_compiled_css_loader_api_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_next_dist_compiled_css_loader_api_js__WEBPACK_IMPORTED_MODULE_0__);
// Imports

var ___CSS_LOADER_EXPORT___ = _node_modules_next_dist_compiled_css_loader_api_js__WEBPACK_IMPORTED_MODULE_0___default()(true);
// Module
___CSS_LOADER_EXPORT___.push([module.i, ":root {\n  --c-white: #faf6f5;\n  --c-p: #333;\n  --c-bkg: #f1dfd4;\n  --c-bkg-light: #fff;\n  --c-shadow: #000;\n  --c-primary: #cb5454;\n  --c-primary-dark: #994d4d;\n  --c-secondary: #355454;\n  --c-border: rgba(106, 106, 106, 0.42);\n  --c-border-dark: rgba(106, 106, 106, 0.6);\n  --c-feedback: #5480cb;\n  --c-feedback-error: var(--c-primary);\n  --c-feedback-success: var(--c-secondary);\n}\n", "",{"version":3,"sources":["webpack://styles/colors.css"],"names":[],"mappings":"AAAA;EACE,kBAAkB;EAClB,WAAW;EACX,gBAAgB;EAChB,mBAAmB;EACnB,gBAAgB;EAChB,oBAAoB;EACpB,yBAAyB;EACzB,sBAAsB;EACtB,qCAAqC;EACrC,yCAAyC;EACzC,qBAAqB;EACrB,oCAAoC;EACpC,wCAAwC;AAC1C","sourcesContent":[":root {\n  --c-white: #faf6f5;\n  --c-p: #333;\n  --c-bkg: #f1dfd4;\n  --c-bkg-light: #fff;\n  --c-shadow: #000;\n  --c-primary: #cb5454;\n  --c-primary-dark: #994d4d;\n  --c-secondary: #355454;\n  --c-border: rgba(106, 106, 106, 0.42);\n  --c-border-dark: rgba(106, 106, 106, 0.6);\n  --c-feedback: #5480cb;\n  --c-feedback-error: var(--c-primary);\n  --c-feedback-success: var(--c-secondary);\n}\n"],"sourceRoot":""}]);
// Exports
/* harmony default export */ __webpack_exports__["default"] = (___CSS_LOADER_EXPORT___);


/***/ }),

/***/ "./node_modules/next/dist/compiled/css-loader/cjs.js?!./node_modules/next/dist/compiled/postcss-loader/cjs.js?!./styles/document.css":
/*!*****************************************************************************************************************************!*\
  !*** (webpack)/css-loader/cjs.js??ref--5-oneOf-6-1!(webpack)/postcss-loader/cjs.js??ref--5-oneOf-6-2!./styles/document.css ***!
  \*****************************************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _node_modules_next_dist_compiled_css_loader_api_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../node_modules/next/dist/compiled/css-loader/api.js */ "./node_modules/next/dist/compiled/css-loader/api.js");
/* harmony import */ var _node_modules_next_dist_compiled_css_loader_api_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_next_dist_compiled_css_loader_api_js__WEBPACK_IMPORTED_MODULE_0__);
// Imports

var ___CSS_LOADER_EXPORT___ = _node_modules_next_dist_compiled_css_loader_api_js__WEBPACK_IMPORTED_MODULE_0___default()(true);
// Module
___CSS_LOADER_EXPORT___.push([module.i, "img {\n  max-width: 100%;\n  height: auto;\n}\n\nbody {\n  background-color: var(--c-bkg);\n}\n\n#app {\n  position: fixed;\n  bottom: 0;\n  right: 0;\n  left: 0;\n  top: 0;\n}\n", "",{"version":3,"sources":["webpack://styles/document.css"],"names":[],"mappings":"AAAA;EACE,eAAe;EACf,YAAY;AACd;;AAEA;EACE,8BAA8B;AAChC;;AAEA;EACE,eAAe;EACf,SAAS;EACT,QAAQ;EACR,OAAO;EACP,MAAM;AACR","sourcesContent":["img {\n  max-width: 100%;\n  height: auto;\n}\n\nbody {\n  background-color: var(--c-bkg);\n}\n\n#app {\n  position: fixed;\n  bottom: 0;\n  right: 0;\n  left: 0;\n  top: 0;\n}\n"],"sourceRoot":""}]);
// Exports
/* harmony default export */ __webpack_exports__["default"] = (___CSS_LOADER_EXPORT___);


/***/ }),

/***/ "./node_modules/next/dist/compiled/css-loader/cjs.js?!./node_modules/next/dist/compiled/postcss-loader/cjs.js?!./styles/fonts/font-woff2.css":
/*!*************************************************************************************************************************************!*\
  !*** (webpack)/css-loader/cjs.js??ref--5-oneOf-6-1!(webpack)/postcss-loader/cjs.js??ref--5-oneOf-6-2!./styles/fonts/font-woff2.css ***!
  \*************************************************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _node_modules_next_dist_compiled_css_loader_api_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../node_modules/next/dist/compiled/css-loader/api.js */ "./node_modules/next/dist/compiled/css-loader/api.js");
/* harmony import */ var _node_modules_next_dist_compiled_css_loader_api_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_next_dist_compiled_css_loader_api_js__WEBPACK_IMPORTED_MODULE_0__);
// Imports

var ___CSS_LOADER_EXPORT___ = _node_modules_next_dist_compiled_css_loader_api_js__WEBPACK_IMPORTED_MODULE_0___default()(true);
// Module
___CSS_LOADER_EXPORT___.push([module.i, "@font-face {\r\n  font-family: 'Affogato';\r\n  src: url(data:application/font-woff2;charset=utf-8;base64,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)\r\n    format('woff2');\r\n  font-weight: 900;\r\n  font-style: normal;\r\n}\r\n\r\n@font-face {\r\n  font-family: 'Affogato';\r\n  src: url(data:application/font-woff2;charset=utf-8;base64,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)\r\n    format('woff2');\r\n  font-weight: 500;\r\n  font-style: normal;\r\n}\r\n\r\n@font-face {\r\n  font-family: 'Affogato';\r\n  src: url(data:application/font-woff2;charset=utf-8;base64,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)\r\n    format('woff2');\r\n  font-weight: bold;\r\n  font-style: normal;\r\n}\r\n\r\n@font-face {\r\n  font-family: 'Affogato';\r\n  src: url(data:application/font-woff2;charset=utf-8;base64,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)\r\n    format('woff2');\r\n  font-weight: normal;\r\n  font-style: normal;\r\n}\r\n\r\n@font-face {\r\n  font-family: 'Affogato';\r\n  src: url(data:application/font-woff2;charset=utf-8;base64,d09GMgABAAAAADXgABEAAAAAdugAADV+AAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAGi4bmGAcg3YGYACBRAg8CZoWEQgKgZoggYRlC4MgAAE2AiQDhjwEIAWGAAeFOQyBDRtiaSVsm0b0bgegSFb3F0VRtld7UcQYBzCebM7+/1sCFzISThdote9mkgq0qtRjUVBsdz1a9mpZ7B3IyD4/xSOExzEGsK2qc+9txcSf+/RyGXA8WIYa+rhpHZViGdhkCuMRQzcZv2RYOt04B+Z/PP46vr2b6r2yLq6hVf1Zv+loT+hkiJ67j9DYJ7n2PM3ZvL+ajUMCnloOtlyobNpiSzUNrYeqpm4CdaQiyomld86JtU78L1Xzhf93FwATlOmUS42nd6kA8RxixYETjetcdFFXFlea5//ZH3z73PfFkOT4IzxWs/pMqPTq4uoT8jSwi2eAtvl/KDoxAQNOUQ+khIM7aKkQEDAAwXjOAowZvXybLqJc5t9z0e22F7lo9/7e1j6o86snWWY5lgycxDEmcZxPMKQBzO4eY1Fe09x01S63C/G8295BLyvToA6TfjtAGysxusEBcLH+ZGc/k+vetKF2g/v0WYm7z7IJtYkP5uJDvuWv7Z44akEy2ZO8puKdtKh8nR6akq4D/h9t35CiFEtzw0NsBrGVwfINfNcTNPNli5qiTledDH7kVs7Cvc1ARN+cqLSm5cIC+3/EeSljtrRcG1U5iUsZgtTr9b8VqgOxSFgtrkwtX356B/sESRnO82QNZE1+PBljUkVKFQ1mdoHdHSzsGWBxBiTPEecALI8CreD4D97dO54M31OK3voIh3M0b8i3xmXKrI1Vij6IlIYuckEaiOd59nN1/9zN0xwieSVRIimYP6zCb1TTapIyqXDwZT8rXxJAnBZWEadYsG699n37e9Uq6BpOl7N4PkoIp9g6KvsowcQvX13r3t/E0dKJOHhC7KIXA/r+J+1BAJPimmYEnKPIGZeRK65irrmGXHcPQwCFWw3s7HkOD2C57+aOJsCCByCF/Bd07+1tTYAMYADCiOPAABxTYnIWScIDLPyaaWewkcababnTHvrVf8qUIRY8gSKCU5QYseJUVKBQkWKEp2Li+0RFOoGDi5NDFIc4LhV1QurQEQuAEWgULhyBSuFSSGEgNERpKWtL2FuioKUKW6qoIcUNudASIoGfQlfg0t2liEMxlxY6QQBU0EFt0zGOUF5xQgK4ZS7x/Uon/Dw8YB0MxTFAuESREl7ZvxsyYS53d9o5hO/fvYJIHPzY4yVguNpiTFwgJOFNCaMQiEghEishdkGWMUE0CBMrOPsYzwUiuxAnrJIE3DzoHqK8FMStvSIiIGUgj83wAgwDcGwWtVdESj8iEXio58S4pSC8ytK00BpxI8dN1JuJKVgW44G+nNEUkRB+tdjcUgraQi3orSDd/6SAHmCO/bRR/Ov3WTC8l/qzj1zFC6dG6F1gWCeRlniw9yV0qhVjSa8UTN3v/vr4kVBqNIZMGVL3yd+vWkB8TTXRxphEEgHccZIUFFdeNV4GNaUxy5DNxs/PaaDhoow0XaKZZvKYZ75URxxRFROPY2eSJGOUYqQyE0EKHZFPedKrqY5oIIyXcGoSXi3CpBFBBpFlElEWkehElk0M/IQMf1cy0gRkImEm2clk0zFqwCiIbL7gCAoOHYSYxECEKNhEIliJhZ1YRBLiJlZJhKQolGOkBgwiW48wwwLmMB8TNMC7mjWUw6wxMWv6rjYtBdjkErPWxKwNsWlLzNoRUXti01nYeI9ZjYDiHSZMbYKFlh141xXWMFtrg76R2sw22x7JTjvfeZd9bA44yHmIkaNEzAqIopAYFRFZMTG4QCwuCnsewSLY2m4S3cJJMWPZjAf6duoZREGS493+3esKApcvBgIlciPhklSBXtEv4QfFCy+SX3VR3DhoX2EWtWpehdmV6CQ47akr1WjY0f/Ci+lXXXnQDFBFKcT7n3L6y9QSUoEv6KBRvInm4XZh5mqltTbaaqeDjjpZaZXV1thksy222ma7nfY72sltTBRfIJyGRJJDOI0JaUKY5kLCFexAcKGMZcxjTgh16aKjTpfcq9fgbBIsQDEX4+wPhHOUcK4T5qYuJJJNEBHRisUYz0wDuRylVwJx+MQuS1aZnHCIrEovcqohR45ZZjYWVrYwrwv5OAfzt4MlMn63ndRvIbJw9nMxjBOLIYrj9J0Ue0THmbgip6yl2J1l7kos37aZbwE5ojGME8OwOBmLHNdHTodCV3Y4kRyGRTcTgcIYkgycDBXW9nwapYF+ZQSomelNefpGuIBGj9OncbOtZObPwdVQn7DOXOCijksoNevs0qVjO1drWq386Mp4m3FWEsOA9NLILmIgWjJyYGF7UhhtR4TIzBGIuFMek5o/wvIEhscwDMNwxAiBRowUYqRIwTUpa6YZIpNIZBKFHENYRc4WeAzDiCQSmUQikclYpGChkCm70rbFXPN93Y3g+VslnrrJDKHaGb0HQuYZVzz0XTw8gdDimt2pDte47Pu9tkFWy0IHdNBgDa7BN4T/RNJ9d9dUAp77mqsbAO1Uutp8mkwGAEQkAB5hjzmyCO1G5UC/utxmFG6cvO1QBXFAJNe9FtrEab7GQfrf7FXFj0wgE6VNntcUX73wBhLYxPGopQfCu4upiBGZ3MGY3MYYz+Be3EQYxoiYYbi4mXz0G5E0c500cZW0cEU0tYdb79oMEfAShzbSum7h8k04rOCQ6C/NwxOLqerdMeZGYAKwo4MH1D/dLB2hJQIAeMVHSi6xthf7coG6yu8khkLVeBfI/e3AKgDo06kGKE+B7rbBgUOC8I7/uarK48m6m2qXPQ446rgzwnQR93YnBEKpEA1iQmpomxfxPQwor6cdVnDhG7m2R0JkiPKns37XUC/2Qot6tmea14Od0M5fF+y03WYbzOL8ejoi9ViDYpiPo7KLcgDC2Yu73pH0ff81R/q+3tupBQcOAr+LkyS9/YfF7VuM+0+R6xO2r/lI5XcvUOv/W6EXyoXNnffgT+C1jQeQwBwaCKizowYKLcXPW7D0adhGh5PFBGMRPZqlnc/Rm3fljxf88sZH1au7S/dL71+TqmVzv2RLqkKXpHPj3Ar9nKIjlc/5Azl6Hhm13nAm0i26DeakCQfxGDUw1laXC7xBgyaCWb8UOrciugYMDc77BMkaGMyb17LqRZCWkfW52tmNewW9NaPN/Mzpp0r993X0et7uYWk75i3X76RoySeh7qMEnSdP3VR66sDkrQGUJWRoJiVMwC3uocWR0UsfRZ95y4Samepy8Y+FwusQS2Xp7kgey81ZGMxh4CTc9LwjO78bfA5CjLjlNgazrElpcy25CqPkcwX1CYohajVb9I3//pq4y4boDgCK7iLO/pnKgztoLqJ35tNNL1keKm0s+O+G5oYFvCZYnG+WdXdJDQlPgV+DZ2/wIcT9kaV/LJSlzY9otFrxNNFZZJUE3u7Fyqpxury+obYfmhzN345vd49CznscvnGACp/7mh8zIXnA93DNgFqo/Bq8bMi+Cc221rB7zg6zUD5frDI287bHM/M5E6Lump+mJjhneHBnChzTUynaG7cCoY0hBM8HEuOzG0CIYxV0sRfxNWiCqwFHIVlQhuS/5dZxrIfrUP75H3Qm/u8nl1JDhIrwVkOMSj6hRKIolTSUSQzlko4KyUClZKJKstBSsufuYJBXxcje7kVTC/n0DlqW73tqEsfP1FPN4Pg9XK9wjLXLBmtYQQ0CGxBoQKAFgQ4EehAYQGAEgS1I6wHqbBTNGRmZaURfjPSokYFxcNOsI5ideWZffQZpVtyALdavWTQsfdBwkqNz9fH6yT5ns6rHvUm8m4QTF6CU1td6CT3iVb/ashYuKFgQp1y8a0wkvwAAb57ZWr2MsWCHyjXUacZsFLx2D6OGG7TnuobbcUFI1r02+w6Vhv0raq0FWp9Y/Lp8XmlI9opzF1WzNQy3keydvsnp9wAJAiFmb3xMZWzeWpWjSl25n5/GQ0Tto6RgGiZZ4p+Ika1u4096cbJ2MZlOFimg6BKLKu3EoE2rQRlD0chIpuSMdVDmpaGxX1YabXX3NDKKFZw+qd4kWLJpv+YMi1OoMd9grVmtz/BSY1emgb3XrUcnaMGSNMIYcFpWcDJnGy1d/Y8Q6MrM0FMTtW5tuuZJBGtIm4JRZIbzP+3mgqjgZuO3sVVn3o28T4YIXf0hw3oDXmd2RXNFbVo1kqFuXf6MCz/1ZOT0X1Bcj26Tz2FqAaT1yIJxy+2kqC619RijWwtNX3z2jttavVpW8uR9/RLcO7Wur8CDl/qic63vsNyPS4Ox5cjodQSJW+KkWG/C1MmZawRT3qBaLau+p0ie/E3MXJZJwPBpz52tOe8cM3ziD72di/tbEOjvevQ0w9tNlcIrMLz3xd4dHhDG2qmc83r2gXxY/BEV5CXEjTR/AnctOm0KycTUalraHKTwF7DfEKdH2pcYsBT4LCQlQqk6AEoilCaChpCRCGXrAOQkSs97TghQz0ABEyrWAyhhQuWtBAQVTKhaD6CGyahvBw2kBrugZh2AlkSoTQR+6EiEunUAehIJnyeojwN2Rf16AANMYtiwBkaY0LgewATTiqknTzK1J2Y/hH6KlY4Q4sZc4fwCCW0xaTKMljJ4JYPWsySLIGwcWbB1ZIldw1/CXn2JDjLoKKOfrjU6nB06XBw6RA4drmqDbjLoLqM/UJMNT0c2vBzZ8HZkw0dt0FcG/WQ6/A8nXJ4Vqpqh6uj0eZdzXzEsB6/MA6GG7xLBg9/+oNcAV8D0FthPAuBfAPYYxP0MBQAArGHCETAkOloVmxmcLSVWB68I5oapiJTZB0bAcm4E4SrygyUgRofwGFJOwZFKB+ZUou1a2HUwMuaDwojCZIkMephTZEmkJlPZ4AZzDM6Yy3jFetNkXNMyl3lekKE+OwiMol10mWhD3Jfri1Hz14umCceuXZc7A2c+NzwnCDweBdKdrdj0uONYzDJYKSJeJ4vCTiaRcL5PgiDiiRBzFK24yGpnZGPO2fCiEKISwnM557XQHnjhuhG/PS7sh1FwNl+NVcEY2B5jRt48gxUJXvNrjP8vXj27nAMBAjFkxHipc+/RxImNEgafvQCQqWa+8IQFsYBczIQYhUkqiFQAQk7FCCGu6suoljjTUfPXF/p1sYMU6wBkZ/ldpSXJdekXL3dxJPQwgjucwZzjuyF708duX6M3Ao74fminFnx3i6M7krpB6hoObeFoE+J1pDbID7jQvrH3nDgmDTHP40hwOyagd0jQUazPj1kWKY4jgcUxZzAaKpazG72qoMuaZo07kdIudmwUvFQ4ZbZDXJTMQkCeEGn2drq4Yyr2OhpQUz+V5zGLBMFncxwCxbJwqerqruiUATSVW8UE5nE2Cwwmr81Nu6X5Wk3n13NQrHeOdzN564vBmU9SgjC/2zOl22AmcDYShiTXoYY1+jV2E8dW2m8C8kNnwyoU1PTOPSRpR79r5M00j0IOqr0JA4P9ehYaOPuvYdIkkdp+xq/NGRbsNXee79/6CUf6HpQzB16mU/hy0qRs4Hb9VOFYnisiVXprS7a2t57QQ2Bw7YEH1uvyCEpDG17G2Jl3qV2WgJ5GohbGSANIuom2bJCU4L7l3Ojc0JGSx+PoMMsJn89amq5eGuO6f+NklsExGNmMju8GsoWtC5TnAEoBZzvgfdkhgl6HPjZPmpLOpj+kplkI7mWVhVgwU21YFGgECCYYeSZ809Hmk2maCwvYvbjq192eQGYA5lmaqVM7frumWIjtKoaksEQW8u6MkLiHs752TixKoO6ir5mQJw+G2hKyltY8i5z2I98/YzPW6Baf5zwI9q6TdsR47ufupVj7lWm10Vn9jKtRpJ/BsFmUsUkqLbunb04DXd9bwZ4zC7VPQ22cvD5x/K7QjgnMQ2byO1taLhytWCfvcWoTJq1muagN+a5P8yR50jQVpW/ZssH1BCArgh4ZFlhG6Ce/obMDgnGJ8YABNaM9MW8Co3wMHd5H2LZZbHxrDBCvKu0pxqzYzIE50mctISwcJRAGpCU99Kp6Ngg9zp94Nu+gZS7AO9WYU+aM66iEIQevZFQGvndGM9PN6SwSfwTlWH6h6vV/WgcQoIY6Mop7mZS8CKFzgbE51sqM186xqyooMCylLB9TnCdxpsOD97IwtzTULT1pnmfviYTSplb5pGVJMpLa1cOBNAgB/p+4qHBujX6n72/J1C0bcj37hN+5KYGQZANu9BMdC4KMGpvW/LCuMNGoRLTRt+z1tRZ8dZMOPTHeSWqTL7Ks2sNVOHNpg+gG3dk2V18snm5GtOTJxt6calA9etF35jUKtY2ggJux62EWMUvVTPJkqKFzmOZ8rFuaUar4Qxd9y5PzXGd0+FnCRoejcNxS0RBqyhBSdDDMlqImg3IAs/ZOmEWbND43lYw1rkcMQVxGoNbNiNlBoCpSUaYIQGDlY0aqChada5hFexa8d5MmXYVYrAyT1AoC1XiOCusIFIhDa6MoxTDnxFOqvs6JRbq4iKFl6y9EXdIkyftmncs6a7DurmH2rqeWqu/YcHzW7vn5qPiiweKasNIDYHR0VpPCMK3a+TZSDZuCAG5xxKBkKZtgKGYhxpYs/olQNyA1geo9GiVM/V9MqBp8VblcEcgODbFZd+32YLXYyiy8WzatSyM6I/dVkDI/hgEIKNbFZ5zS0HckRqVEnlp62koeqZdfLW/7YMxEZYi1fVrCW1OqOG7H9Q0x5Nhuwmzd/eapUSxfVyUukDqXxZtSS3DFLtvC0eoLaIvmj8rC7ubwHsLpaYvuoVE9eNGD0T5idIf7E72/C77NWPCtffaRVJHnKyIXlZreCTl3o0jVrYEIUhWqsoEQ809p1UZErvqmWsVRPC6rTeEIiRYhDWchD+NiF54g8Le5BKdwatj/Sy0Yw/RfV8PUAXeqUqFYg7Pxki0Ovasf2QHeNe2JM6RxxI/zUnG1v3ygHimZ9oJDn+NXjr7zdPeD3ASjKPXfUOnr7e/sLbt1tpbnHDx92ZPPB06ayJ3TGgtifYfnfkvDecZnY3LkCDnZ2M8Z8kbZAupclWt6DuYXnuXPQRlJ04k/rFuY0j3Z1y5Oit48mcms5Kaap2kVygqrqAysLUrfEiGII/PDCPAjBPSJNtEW2giuw3YeN4wytrBStrM0iw3fBEP+b8veBXNVoBqqDC3Dp5Js7xp9C+Ilm/hAWMSb+L8JSE0zMtpodVkamLP6NgcBriYmXUHGjk1CywSDIooj5nwpwKbzFve7l9oBA03PMFA3Uo0MI21DT93GDGM21UylU/WVVMPkjc+fbaSmGCbQNvr9I+Q0EhXx51NbN7Zu2Na2sY2a70f844PUbDOftpFWk82HqKCjIi3kUlLowu9G45vR9Co66nU04+QU5FG3pRuaD0Lz+2+iwy3Dh7RJjEibCVrRLxOjLAv7xzeyfgs/YedSbpbdbQ+1gJY/jBx1asBhMreHn1zjzZTk206bQdMJtzUYqLAqMQNLOuyZ/NjzmnFxsV4vFOpk9z/nnkHITQgY5hMxGELxRiLGxsKU5IaUwuRdk0J0/PE66X15ke45xS2gpOoMheoSAeKV5FbUubHV+1PAt/9sGZNmc01Y9ShLNyNM6oCZVi4/057LlWpxo+eE/J6EnxAuOVYdlJ+SFDjFTskh/7ngKkf4kSZ4zv9CB9RoBdMTDFZLjokLwu/uHKl53G4LnQZip3XYHvOJHKm712nHTgdDp3fYHzM2vVi1Fdy6inTz2G2CUazbBRl3wwdHHbAcIOdjGF0Mfp4Xc+xaIf4KpkQpHVaUXORotyOZbC7rvzwx0uhKdlEiVyQQiCpo5o6LwvMFQpDsDiWnjyCRtaTbUbhf6IhJwxPd+SX4/xytkj7QxGRDhvKzn9DrnlhxHpqZCyO8vDw+CltYl53DljnMskwji2liZ7JNRiaLyBp35GoqSU3afVrathTpBXtDG+an1Iz480XPM4RNLspDePkIn5e/9PvaWI+cNYcdpizEnDibA52lr8RHRpHfxX5XsTM1i1HvRlG3UMhBt8DR5/km8AjZoA22ISZVUUGyrMRau/G9juuzcjNtXDjTauHwYCuHY4X7bnPapPnIOYRynBROTm/lKb1CmOVwoRqFm89x8oQ4+XO0M5iyPJtOl2eTMWdoD5mNKonUoObxy4oX1+T5VDRIZ+XI5TXFQ4TGpButmWJpsrQR5cKG7pDrg3K4cSNKcQQl+DHa8vzrk6+xIuF5pHcttv/r/MokjpvKSqQj/kD6KKbCZlXLLKbC9jGeXJ3V6zXxYZPLtHE4KYGFn9byf+ezBPlPANzDvLCMJpo82JjOEFhl7KBJxQzmqEUEf2+VqscFYKSwxjR31iygNVBRunxNSbC4t6xsXbC+fM2yohIdUEUburmzgWGo2FQe3NHa4P9pQ3VFw/Zy/3pMMLzx1tWxocazDM6/tBLZYHu95lLrBAxnAtjH0/choHD50OHDhnOrES/WYXZb9cLkXUvkdrmlzGM9tA3JUmaLxTaVRGcNeboqUZ1rUUg0JtXOL+pnWL9aO6qYWNzQbgJyTZlql2plgUQuKJbKW91EFyiuW6i8QDLDvnawSs2vRtblahqk2aNrtq5oKBszBgyOGDahSNVRJZHbXN/QkaSwO+Q7f5LJKIqSkVGk8JPkk59AFCFnPsfWqNU/lkWUgWJSWnO9K67rfplVLS+Vytq9EV5ZW3H5Cj0iQbUZd4L8gOqQN5dnySV9CAp+onwCke40ShprDoj2EAehEzyWH6zom/GbeV1rgF7rkpDIwIxNR/JntADMTVu85+xwCs1HIv+LdJPTS3h88OP9GcT+WZ9B3qNBYqtS/xlOJD8CB/KPOzAY+nNsQK0dWUIsaWi3I4VirgK7RCpvcRPd8laERCJIrc6WYg3252W9a0iWMD+XzRp5Khk1hmaH+5hGOtsi8Hgc5vTEPjWa+ExRq9aPKo4pbiibCjlSWfboFeP3lEkVLe4Yt6IVIZEIqBW50A/jsVZLNYWYmqtp1ecG4iadQf3fxNJQUNO8rNCVW+DJMUOJrYqhgv1YG6c5LZBnz1abLEYxo2DmHwl9i7mMbRYarCuy1QSqnEpR5q9vQXre6JuME1tgVYHHDbtIC8kgeQHZlPIY65OgFZrQwa0hFbJMj4OPOkqCngoQ6K5BKnySrMz1yGGEfBjp2QEca6UUMhUB5z9f8BycinSP/jr/Z3D+49FfnD8dGnR4UNqFtGNxN/q+7KYbJxMvpnLuDLwD323Su3shTC/UnVqbmGSniD6Lkmzpgg9wz1oPuPr+atBDi19DRvLy5rVY91OSvXfUyJGdxJmTZswIb43cJtsG/Wh+xAPZV2c1GyHmQ+ixd169qO0pBN5GJdfmhhOAn9s8GJ4sy0KPCG1Kpl9lzgzYpGh0foZOIAULu/sNSnfOOntdeRa91CS49c5ixNkVMs8JrFcqqtIQNaIqr1SocBnf5/RZlSI4B4W9cqIM9uUgXJFNcULx2G1Q8Ed7CslxUU5DGr0xB9EfVF+dG0Li71bNEaxXjgQMemHQJxcjblRUpIzHlQIR7UrqcmAbvK1mV6FUsvyjkJNn4XFhhwAugNV7DK+oefXk+ungdBVZlcf9GU7d3CWjjLu4aHjEVnGlOpNsK2WbMsRIvocnl/pYUwZ8uRlCJIfNzuakf/pz8ecMoVcmqlSrRZVemTCm4nSUeB7ss6Ncrh2FfVIp7M15AnyZeqWNpUddPjMNTNWabfIIAsMkGGsDXT3//OXicnk43Bt7+7iZIDK2+58wqGduL51Cm/k0C/h8BvBlatgrBaSkVS37W+P23pGFKVyQqVYYhTEhW9XZQD64rwowhWj0GwmDODrmwO+5rExxSX3HbUTH5oD7W4Gcf/M4MO8UtqglaBeUiGtDPAfiEcXnnQjPKyfKeT4Hwuc7CsmHvIPy4NZG8Rv/OGd8T6RRITJsdtf5d57IbEOUQYTNGLt3RM/3ZSr9/+l43j7kYutXXd/9ifpubyi2Ba+T8nlzrWxmTP4gtx7iGFSAM/ZgC8YWkboSexKf3bWrQ5R1h04Je7/1SLGdhubplOxf8mQTdToRyoKHEekL1v0yoplBweqoCP8VGaRInmYBMRnhvJ3eM7OYXAyQUx/x8tfu2w9isn8vYPJ1eT4zpQfUGm1Srpt3BhjkTd63al+6qdy9aPnC5dTCfT37oI4F0KCU0j10eec8iGj7G+583b+iP3XOuXnnUlf1r3m0etGlhRdXk9bu+9kxuDSP46AmDvxhSmPoPA5Twx9uFv7/jR7kbo7K0fvfuDdkAuX9uNdkAnNuQP1bsvIpmzNAuwshFNxbbnlcQhKhn0vpD7tIZfyaEJpIaAm9EaVo3Dw2GcQrgjdCWwiJoQm/MqgXw/op3H5CUkLc7NC3hgQEuksb4LCfKpN/U2sVrK+jj5KTelbOfBQH73fQj6cn5O2YGUsg3GuQ5C3PnYtjRNhL8WyJCHnxNtItm47OpSlCCmRohYqoami3OERJg+lTq7kVoTd37SzSGAWJMm1E0X4Cy/h4nSIAU+OdJH1nQQbMtdjYsLzQcCtwyCZHGG8dzORBMc8WkKbczODzf9gDWBII/bZ6BYkEpjn+iBySNBRTPCxp2Hhw/PSk6cWYaUljeulrs+ysEdU7gsEdtbU1TdTmzrLKU9aUl6+pqGDKlHNllmRZoVhYLJUw5ZHFTCNlKfCtj2fnwbkIAucVI/J0X4D1p5IZg9exfSKRT4xUr08oFnqFoolums+mCzc6YNjBZ+QAfoMD5jP4ufIv4cRrkH7035Rf4pEk2HT8TGzyu4LoSJ2pdlzvQHq4PGJgDdenCmdjJVJGDotNH8JUWLLVMrOxcP7mjcyNsd0ROhcfIe/XT4Fg1qWcmSAV0ZDRloajQyzF8QODn/ehYfmRnJQMtopBv67JHBKWkqKjJGlReizTZ5B0ujYvhHMFyhU7Wvz104zl36v8g5XEt5c55mDfvDFxmeD1FYLOABl9lWNDfJlPzIRd5k066/pcJre/3sCMIVq9fZuHxxfncoGsYLD4L+uMg/qlDUR72p9kiL8cbpm1eKtMKqjuA5rm2JQauxJN+1GxbfagSEHjn3OfskSw3pTKoJ0vv30nS2BX6Pj/HXq8hYibdzNDISUxL4vEO7R9ZDRi9sN0f3S1ZdnqblA92DA03ETnm4PZ4PjccpuqrziwJydfz/sWuJdRIpzpvYTPlDEWft/Yx2emNcLwfqifzcnilGb1bxQaTi9j4mUMbUrzOgcLjsAS3QrEr9GLgkVyCeJCpIU1KKtcs6zLov/DpDm/4eT5j9rfUw8Y11ZP3MArcQh5fKd/5xKFglfqEPL5NO1ZIY54Wh1kB76utJhcvGRFZZlyXl2dfd3em22Flg+j9nqdaZ+rvQmNwB9c1IgXGak+VFBQQb2SBwxJcwfD/Zf476P415AesOeGPsu4e3JuWfQxRuFfTGL13p4DIBGHCyNuoB7klBRTg1U74MvSNFpTTFNQsq7u/aBPCZ/BHNfa8/6YKz14S1x2TaFRkr82Yaz1xlnwFr9Xf7q2MThQvNnR8hvtajlCLmf9iRQ0fekpMyv0CGPzGPbC1hPhm5lxnexl9eHEGI/H5YGCet6F3xJ2zUyKqk/5Cx/7ylX7jvPbtE9U7v8HGVeNk+zPPkA6ALHJ32LM30wOzBWSCmNMYLIxGcwo3pgOPpHE4aUVvfi4Qrx8MOb7rBlN1mqxkjEdO0k7yanLMx4UpD8Mp/UmP5zjHrf8zOaE+E0JxM3E+C3EtL8C20EHvxtbf+vtyQlbS5EwQWeLqI6fpU9aV5x6tJinL4s0aEBFCp6YgMsCVTiLruoHgSA5nG5uPkdRFKE7Cp7AJRDxKcfBw1sVBU5WZl4epphcHI5TREjhZH43m2+cMy72rMWk4TMABXtAMEB5BVsyYIeDmgkhgN2hjGYiJiEcsMJpYwKXUbGjXyY/ngYcBCkBpyzpS8jHYmv6R2qzh9/5PIOTEveK47EZLz4zL1M+Mz8dX3AiXd7Itg+4H7cbK+67bIK58XSqmiouiTdTVs35UgEzCApS42AzyT2zsIcct8sDn5kX25R8pYrrG/nR+K2icS0NnNx4Mu3M6sTxLFMjVe5TpuQlTwVzCSgu8nKFojnJY/zKTEci2YJyunlQUcCcC4prY7cg+VMfU7fGbVGDiG3pDD8kBy9w8AIHD4hdIMNPZg4AMwcXW+UcPFnOwR3MHCTZhS8pwUSOW+ZRPjPPhyn5StTO0B6DQe2pv8wAVTzazKWBo+VcPFvONXtIxUXurZCSS/AtR/tFqdj/xWfmZdmU/AxS+W8M9H/ytK8Cna1FSHjMcghe4qpL7kdfs8EOV5ADtKASK7AkoTH+URoLza8r/L3VbjeojRGNsc4H3KjxYETrVFbhc81WC9CicPQqetzE41pz7IWb+ofczmxtdjx2Tj81dZA9W5Ls2QQOMPrrbJkpAmAgfVvFDgY8Ay5KL2TnluQnC8CKrRxg8hF4EJ8AIAZw4UR424k6v6YH87Z/AYBed2t6tG2ZRdlF62qz0knAqhxMX20AS6ZGQ/VaM3VkKTEisUgF+nixl8+ZMvk782sTYQju3DNLPDjkF83PfftG2LXY9a2lLeO5AKXzTRzgx/nFJv7VHIPOP83v/H0/4ciH57Ay+buGr3X/WvltvsrP0i9yAD2eO3hpLcuFWQLyRLlODsJU6322y3yQ566rb38ALJvJWhXwAZRXl0wdMf54bD5ob/e5rTjkmlfKc+UB31xfnVqWdbNUngSdwStPEo2wJ3PDoLoDHZ58sen1wwxH+lLfzjBNeX0H1aABPT1dAH5QuprptgL7aEG96TXBb+Ol1Ts1o9W2p3J1NkjI64xwWVQTpBE6cI85GVVfoytkUtHtEvuxWxdZIoUdQn87qQYgeAbFZ0ieGXvrA8vYxuZjKfR6Pak3fFPb7DxXtPqH34W0KPDk6rrNEyNtdQB+//cMd0SJssizP2syIF9f1ubbkzpdjF29DrxaciQomnISn5HUIxx+BsFXyIwZEVcnUymYKSDFFwfVLk2VtllWZSFlbDF0M/oNhEjF4sqeLukFBa0rbfF0K1Z2dQGweAK55WG7rSohWHx2tb08HqqxGppalKJIIjGlxZl/mqehrizJCUIW5YIIH2FvngD4TGVzBnlNDplmN9kmkzJuQkZvTMoD4QHA/wJSL6fvVsnbCOVCVY0U/mrou1aLxTXICSB4BXJHDllE69V0+npSf1QxDKdYoEXQOCFiZIdSLcEczz3NgPZDW904UjBe/EnZx+suwqhvTN+Z21WNAUL8AIAcl1gvpKDRXSUAyEyBUgGAi/4jrV5OmsIV2FN1mm0HKswgMlp0j4ONGQRA0AZNmUNCjMZcvaJ2OmokoAysnKEjR8nWqTov1jJNWNMk+wzp6sQE8I615cj7UVpd8Kq86DbVpw0JPgLQBGsDZW3mTEkPURkOatRip6ne7RU7kM6UBzHTtoFAqJ4fibqty4IPSXEyJMSUpiOkxCJlaF0tGhkNw2DWvZseE9IVBIf8EqQsNESMHi3LgGzMhnqFFEl+YNtdweK8yheGONm0ATUjdLg6GTKJaoP2uB6utt049Wxgr4shQAQXtGjWqZSRL3it6/Ie34D/059fX32WPmkmXztlyXdJ3v7uOeEDOAheSd0KIsiMgP5KApSg2BKzIV6Mf6hroJ7q/dBhjXU/iX1hh1lKm+7eJmZ07fMLmvB0+jpWf1QX0FGy/IaIOqPW3QmtuYRtf3J0nfjLt0+wW63cBWPvM5gI1Vhm9+/5LDVPPpQN6MarVB7+9CcVvNaUX77+xX7oTXIautZFsCVbmyG38qF1SkhjjWap1hvFtdBN66PFvPYSMpQn2DhFO1MEj1ROSFlIsVkXTdlkschlvj+31NU2VSUfTga9BMEJeKMzuk4FsMZqPPGmywxiXBCFlCova2ZKG1Tj41y6l/yy3+iEWw8A0Ju5lS2OiNhcmN2L7dO4iyGScAfzD2N3oAsNNd7HYSPmcHFfdekyeJQIWOET2+GcKYWv9aatRycjxwk3dGBOhGU0ET3YFOCDAbsfEh7QHRYk0tQeTFshqInxtTBea1tgc9a2Ckpf24UG8a0pPoCk0xJEgTYoqt8w//x4OGYWbleMXPYC8Lk+kNU2lgVxYiF7EGTAAw1dBj0HR6dOPoBrY2bUg/1hHcPZE7/GXUwgDb2bxQ04+rEPr7IOLYboKe61SO191G3TsTbO0iMlE+1cRPKUo3JNcrdSFu8vZBM203e5TJ44y1Elzwbf4oCpn4dERgkqPz5hDw22ZXxgVLupTQKgM8ji2oKWRAjDnYIjtT4KNETLGSdbDJQxQfX6aWg2TPwQoajGxtNVlbNn4QQsx42/Bry/Tf2T8grAg/NMcmVkjE4NBj0BAqwZykL2p50pl6y1MAzXyePJDHUPO6fJEd5Aq6a0YjbgX/vSSpCtH7xurvwCqCIpmM1AtBZCQKgDpoL1XSBu76ry+5uUT/MIY1xnKQ2/lxhGaNI9zHven4ymekArNXNf7rpm6AIP3XSx30ryCAAOY7UUmncnAPkJEXJmsc7PDT8ztWuX2tfRSkaDaIrEtw8072PfWcQiY/P40uBtRgR2CzNHeozPh74Q+flE/UlFSQIkbdIsS8SIh07WlC2PSUzZMczgcCiPL4eRUhRA0YTU9RI5snYvf2hzTlLyvLBVLNNYlooo45m7DNEeRwaQkZPlMchtJSNMZ8gdq/Y3qxx6ZhiyLGN4N8tPnf0CxIhaqWr5GX7MSjh5JinFASzTOrAYT6KaOY5S4AhskdIowTo6DQyIRcvYvBFn9U/K+Vo5bPvZrG9Oah94AjlJQf0AUm/+fRxRGLPiNtRej2/I/8MvEX2GP4pE42mORumHq3moVPGn1S+WFWV+sso1UHixWeZsdmXuT6z6b48dtmPUpi00tr0UlOaZViWzm4/WH2Ru1cuqun/jQnBazGX3APJnviF8q9zEoOI+C7UM0WGihPuY6tujhWPWEm3XJ91x6KPOm/ldmsghF5fppjmIqciZA5/f375+OLT7fuilB7ecmzFWo/6xwPRETvdExyBTPP1WucAiGEK0MIhNamjdB47L8xaXHzbjbu31MT52dji2qGeu4rpe7cCx5dk171IzSeMHNH6AY+/I7Wpx4mGQTnENdH9YJb4drXqHLSXxoHs4uO0RCv6gdaRv15vb6kiEPMUZY+Opr0Iy+A3YhJNz55P4MBdGpvgRsTxFe7z4f0K4qvJXAAb0c3toCx4dT5a6Swj13jp2lSBpeEoBePH/pGU/iJB2bpVLtT0fZNwQUdRfpBF+ESUqO68E9VWnRsMwzwtdz0Fpyn9ZesN/ACcOpALBr/gO8G2IbNa7RckIPY23Hss+0xQZmgzk4+HF/7K+CCw7ZxN1X3SUaeDNJfVxvaLOLy4p24odB6KLyeBKNeuEBnaNyz2B5bsTuq6yS336OMq0H2qra5yy/FW3CUG3zILKwtZS8nAWOTn3KAQOJxl5Fkdyc7UCKep5DpPtN/d3054d+d8EoAGdWGSJXFB6Vpe62Ez6JxsFkHXmza/qWgigflI/3l4fD9tBrMUqS+Bj84lbLxXKCS/520BKl0+Mcpei/C/yx9S6aAvXoWRXTu4D7GKnbp6D8124jzdXh2m/245NvUUTz5hXBft0ElgHphrOdc2vAqEuaQFff47ESfuvFqtMrCaMTYSgsPwbk5gFyUQ7C0Y7NtByZGitV3m6tqQfhuLr8Vx9QhYTfsSy1BtpPu4xqIVOTjyWUIuTrdZyRCkHlYjuxqAJiiA44fvG1nAz09n6dJg0RS3vEtSLkDo8gQgzFqTYdlcnS63O5A3+E/MmPQC4x12/6/ruMrbrm/tgmFnaJyRpFuIHPN4vOfO7tkaY2H68rulxHMahKvMs9VZDP7hEz9v5tux20+Dh6lG+xE9I5X1+jKhjxQeOCB+VNqjhOWhQ5lKAKPWcW5RdaLQsaFlDITwu75Sm+831xdmqypLGOZCBJnz62v76j0pcdButH27lotXsqqYyV+M2bav3phYZp/1JlZXHeISzYu36ekLmeMaAwhnxqoVhKD1K2Z88XXcgWb59AsCuykLg9eJ5i6HHnBD/KXcFYAN57SWCNPW2fXqMbPM8aH/SXzpU/fTp8Qg8ffP0tXpxfHJ8vLnCjLmNhzbsWz94PjR7ZExKDVj6ZxB836IuQuJKGW2zqVfLU+W5Dh8Oubwa97h3ytXFtBveuMAVleXqHjDilEAOeBNEZvzULWdTRn6FG/wOsOf/8MCjFlhhdZkxeVi55dv7zhoI+8n73zPO4f+SP4OkV0AIRVQbXluyeNmojvXMhpeLlA/3QiBQhiUzQBJsH1OC2pK/97g5o7WotwogqQ5hqZW7UuY1O+y3nazaqApxPScfl6SVTatGakLrmWh5cleVUj+HTfbloCf44QF4ePmgnj29uTrsMWDoxq5vecq3GkJhh1uLXNnjN1/MMXyonl+rH5yBramgeWHftaXvhj1D5WWdg6nnRHwbzKylbbp1duUroh+ctlMPlb9Zn2b0Bgki/tLVizMMe/1Btj6lbVxN5Yn4YlnRKJYGajJF4z28+2BTTw7iKWcO54bhHtu6r3B5dpwPMuxbGUebV9+eiOsuzWCr1wLb+OMz1tVTaPmUed60Zydv5vHTg/JOeLIfAFgAeXl5igfuTataHqf6raUvLQA8efklAHy22fdS2FNtqVoggIwBAAJuezXgvhD0w84g2ot/DQ/yn64A0B7AX4AT/AkD2OWUXNZ0FNRB6epTfBDwgZrZ9HwUsJOWNp2cVS9s+kRCTyjUbKfngoysp+aWuvmZngA1z+j5mea5tvbSMo6eTwLl5POBO0bNn1InCsGh8g9DMGdvaF5oDH1IasNhfGq2vPqLYLr0YwT2Ngd/rgGV1uZP/S5fflWsU0f3HOSY9WLzWGzmcWQSV5hmRuUIUyAL6DPd0PwhLb8I5nzS/2T46+IJh5ZP0iYWQd9p4+eGckLQR90XvODEIJgBF3isc+jELqaHIm0i0Cl91BlNzTGpqj4ln04W8L+hdAJTs4kqX93sViknaRnDsfg71v/ExiVgjKw8EuCk6FXLjOvfPDGO8kUDLvy2Fn3BNSRuGFAQGLY7GUk85UkO9r+Mz2tBXooJ28Kg57zIhxf5rj/UagXKcnEMSIWCwMLInQwvNwXl9JwXab4TTAuq1eq+5PMvfvW6YQGE2wFo4IEcuBGbk7PHEOYiyM6WmcRlrEqJQWwiEGs9V95rmnxg50LZmcctEwqti1OWBFpece3Q3nmftEnQdjDM1r2N1WNdQ9FzruVS+PCYirwWAeZlHR4BohIbb1BLmbmIRS0XI/G5OLGa6vyyHHQJzEaWizqXgck0MMmLXDayDcduJ9iBQysMAAbbK1wkIUQXY0kVF0eLSudJbnIJ4jK1XBQug5i8ZAG4vO4S8Pm+JynSz28VEt6sr9PP3hDWcoRVX2pR0zfKu5R6Pl90FX0QbK6p7GiGHCfqR6LNEPBRVKx85Va/0oR5BRT1TdL4onmrYe8RYzbUOLPRX4LvXoiAUbMWw7WpU6NWB8hmIoQSkIBUGQ5iNp7YahCHZlX8Aho04IPoJ+WQu2hX9ECCgN7F6X58esGQ3qxGpQ5iOB7rdJeAGp1nvRJtAnxoeODFlArZ+eRSuk7FK10vvAT09v6emjWBkEvzSAwdaXwU8nNnGwVqyd2PcDZTfN3wLBr/g3eO8ryF1I+dzEBhZGJmYWVjFyGSg1OU6DcnufUlcimnvAoqqsTtE0mSqSpL8SmPVFVUVU11Gq8aaqolTboMmbLostVWR1311OfTkP8l6g9+U8001+KF6s32B/92ddZFV91010NPu8w2x1qLLDTLFTsdccsNR/XS23JBd/Rx020P3HXPfb/o64mHHjmmn7+s8NxTz/T3m98tMNAAgwwx2FDbDTPCcCONMsZoY43zq/EmmmCSKSY7a4dppppuhlJ/KPAiIcThuLzwJJBIEslkIIWMyHciJpx2xkmnzHMoZrLgTxddShzZQggx8UlIYpIyGAlDxjr8zR3YhuaoB3U21aFCkQz3pUwHBr4h6BJcZXVnx4TrNZGL4jrq1uVVTHEpyyQ9i3oFLJEJ+9F4LFwd/0Wwu3hc9ohgeS3/RbPd3Zb1jg6ztTIg4XeY8pV/FRL23kP8aOpEnjqUxXJ/IKm5lY3l7170tH0G2wONdYuaUQ09CfzKhg7Avh+42QpKUR/R0huP08seVnmoD9Lp92MJSBkv/cAkk7xXHyV2lk9/ztVFDA4ZZFTW4XvPTZOv7PBT3fkdHApKSSkH5eloxdDq3abobv1GHWmXRSZTyqeE57zLlrxHJzI/EIKrAN9ZAA==)\r\n    format('woff2');\r\n  font-weight: 300;\r\n  font-style: normal;\r\n}\r\n", "",{"version":3,"sources":["webpack://styles/fonts/font-woff2.css"],"names":[],"mappings":"AAAA;EACE,uBAAuB;EACvB;mBACiB;EACjB,gBAAgB;EAChB,kBAAkB;AACpB;;AAEA;EACE,uBAAuB;EACvB;mBACiB;EACjB,gBAAgB;EAChB,kBAAkB;AACpB;;AAEA;EACE,uBAAuB;EACvB;mBACiB;EACjB,iBAAiB;EACjB,kBAAkB;AACpB;;AAEA;EACE,uBAAuB;EACvB;mBACiB;EACjB,mBAAmB;EACnB,kBAAkB;AACpB;;AAEA;EACE,uBAAuB;EACvB;mBACiB;EACjB,gBAAgB;EAChB,kBAAkB;AACpB","sourcesContent":["@font-face {\r\n  font-family: 'Affogato';\r\n  src: url(data:application/font-woff2;charset=utf-8;base64,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)\r\n    format('woff2');\r\n  font-weight: 900;\r\n  font-style: normal;\r\n}\r\n\r\n@font-face {\r\n  font-family: 'Affogato';\r\n  src: url(data:application/font-woff2;charset=utf-8;base64,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)\r\n    format('woff2');\r\n  font-weight: 500;\r\n  font-style: normal;\r\n}\r\n\r\n@font-face {\r\n  font-family: 'Affogato';\r\n  src: url(data:application/font-woff2;charset=utf-8;base64,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)\r\n    format('woff2');\r\n  font-weight: bold;\r\n  font-style: normal;\r\n}\r\n\r\n@font-face {\r\n  font-family: 'Affogato';\r\n  src: url(data:application/font-woff2;charset=utf-8;base64,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)\r\n    format('woff2');\r\n  font-weight: normal;\r\n  font-style: normal;\r\n}\r\n\r\n@font-face {\r\n  font-family: 'Affogato';\r\n  src: url(data:application/font-woff2;charset=utf-8;base64,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)\r\n    format('woff2');\r\n  font-weight: 300;\r\n  font-style: normal;\r\n}\r\n"],"sourceRoot":""}]);
// Exports
/* harmony default export */ __webpack_exports__["default"] = (___CSS_LOADER_EXPORT___);


/***/ }),

/***/ "./node_modules/next/dist/compiled/css-loader/cjs.js?!./node_modules/next/dist/compiled/postcss-loader/cjs.js?!./styles/grid.css":
/*!*************************************************************************************************************************!*\
  !*** (webpack)/css-loader/cjs.js??ref--5-oneOf-6-1!(webpack)/postcss-loader/cjs.js??ref--5-oneOf-6-2!./styles/grid.css ***!
  \*************************************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _node_modules_next_dist_compiled_css_loader_api_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../node_modules/next/dist/compiled/css-loader/api.js */ "./node_modules/next/dist/compiled/css-loader/api.js");
/* harmony import */ var _node_modules_next_dist_compiled_css_loader_api_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_next_dist_compiled_css_loader_api_js__WEBPACK_IMPORTED_MODULE_0__);
// Imports

var ___CSS_LOADER_EXPORT___ = _node_modules_next_dist_compiled_css_loader_api_js__WEBPACK_IMPORTED_MODULE_0___default()(true);
// Module
___CSS_LOADER_EXPORT___.push([module.i, ":root {\r\n  --space: 1rem;\r\n  --space-grid: 1.5rem;\r\n  --space-s: 0.8rem;\r\n  --space-xs: 0.5rem;\r\n  --space-l: 1.5rem;\r\n  --space-xl: 3rem;\r\n  --menu-width: 400px;\r\n}\r\n\r\n@media (max-width: 800px) {\r\n  :root {\r\n    --space-grid: 0.5rem;\r\n  }\r\n}\r\n", "",{"version":3,"sources":["webpack://styles/grid.css"],"names":[],"mappings":"AAAA;EACE,aAAa;EACb,oBAAoB;EACpB,iBAAiB;EACjB,kBAAkB;EAClB,iBAAiB;EACjB,gBAAgB;EAChB,mBAAmB;AACrB;;AAEA;EACE;IACE,oBAAoB;EACtB;AACF","sourcesContent":[":root {\r\n  --space: 1rem;\r\n  --space-grid: 1.5rem;\r\n  --space-s: 0.8rem;\r\n  --space-xs: 0.5rem;\r\n  --space-l: 1.5rem;\r\n  --space-xl: 3rem;\r\n  --menu-width: 400px;\r\n}\r\n\r\n@media (max-width: 800px) {\r\n  :root {\r\n    --space-grid: 0.5rem;\r\n  }\r\n}\r\n"],"sourceRoot":""}]);
// Exports
/* harmony default export */ __webpack_exports__["default"] = (___CSS_LOADER_EXPORT___);


/***/ }),

/***/ "./node_modules/next/dist/compiled/css-loader/cjs.js?!./node_modules/next/dist/compiled/postcss-loader/cjs.js?!./styles/keyframes/spinner.css":
/*!**************************************************************************************************************************************!*\
  !*** (webpack)/css-loader/cjs.js??ref--5-oneOf-6-1!(webpack)/postcss-loader/cjs.js??ref--5-oneOf-6-2!./styles/keyframes/spinner.css ***!
  \**************************************************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _node_modules_next_dist_compiled_css_loader_api_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../node_modules/next/dist/compiled/css-loader/api.js */ "./node_modules/next/dist/compiled/css-loader/api.js");
/* harmony import */ var _node_modules_next_dist_compiled_css_loader_api_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_next_dist_compiled_css_loader_api_js__WEBPACK_IMPORTED_MODULE_0__);
// Imports

var ___CSS_LOADER_EXPORT___ = _node_modules_next_dist_compiled_css_loader_api_js__WEBPACK_IMPORTED_MODULE_0___default()(true);
// Module
___CSS_LOADER_EXPORT___.push([module.i, "@-webkit-keyframes spinner {\r\n  0% {\r\n    transform: rotate(0deg);\r\n  }\r\n\r\n  100% {\r\n    transform: rotate(360deg);\r\n  }\r\n}\r\n@keyframes spinner {\r\n  0% {\r\n    transform: rotate(0deg);\r\n  }\r\n\r\n  100% {\r\n    transform: rotate(360deg);\r\n  }\r\n}\r\n", "",{"version":3,"sources":["webpack://styles/keyframes/spinner.css"],"names":[],"mappings":"AAAA;EACE;IACE,uBAAuB;EACzB;;EAEA;IACE,yBAAyB;EAC3B;AACF;AARA;EACE;IACE,uBAAuB;EACzB;;EAEA;IACE,yBAAyB;EAC3B;AACF","sourcesContent":["@keyframes spinner {\r\n  0% {\r\n    transform: rotate(0deg);\r\n  }\r\n\r\n  100% {\r\n    transform: rotate(360deg);\r\n  }\r\n}\r\n"],"sourceRoot":""}]);
// Exports
/* harmony default export */ __webpack_exports__["default"] = (___CSS_LOADER_EXPORT___);


/***/ }),

/***/ "./node_modules/next/dist/compiled/css-loader/cjs.js?!./node_modules/next/dist/compiled/postcss-loader/cjs.js?!./styles/reset.css":
/*!**************************************************************************************************************************!*\
  !*** (webpack)/css-loader/cjs.js??ref--5-oneOf-6-1!(webpack)/postcss-loader/cjs.js??ref--5-oneOf-6-2!./styles/reset.css ***!
  \**************************************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _node_modules_next_dist_compiled_css_loader_api_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../node_modules/next/dist/compiled/css-loader/api.js */ "./node_modules/next/dist/compiled/css-loader/api.js");
/* harmony import */ var _node_modules_next_dist_compiled_css_loader_api_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_next_dist_compiled_css_loader_api_js__WEBPACK_IMPORTED_MODULE_0__);
// Imports

var ___CSS_LOADER_EXPORT___ = _node_modules_next_dist_compiled_css_loader_api_js__WEBPACK_IMPORTED_MODULE_0___default()(true);
// Module
___CSS_LOADER_EXPORT___.push([module.i, "/* Box sizing rules */\r\n*,\r\n*::before,\r\n*::after {\r\n  box-sizing: border-box;\r\n}\r\n\r\n/* Remove default padding */\r\nul[class],\r\nol[class] {\r\n  padding: 0;\r\n}\r\n\r\n/* Remove default margin */\r\nbody,\r\nh1,\r\nh2,\r\nh3,\r\nh4,\r\np,\r\nul[class],\r\nol[class],\r\nli,\r\nfigure,\r\nfigcaption,\r\nblockquote,\r\ndl,\r\ndd {\r\n  margin: 0;\r\n}\r\n\r\n/* Set core body defaults */\r\nbody {\r\n  min-height: 100vh;\r\n  scroll-behavior: smooth;\r\n  text-rendering: optimizeSpeed;\r\n  line-height: 1.5;\r\n}\r\n\r\n/* Remove list styles on ul, ol elements with a class attribute */\r\nul[class],\r\nol[class] {\r\n  list-style: none;\r\n}\r\n\r\n/* A elements that don't have a class get default styles */\r\na:not([class]) {\r\n  -webkit-text-decoration-skip: ink;\r\n          text-decoration-skip-ink: auto;\r\n}\r\n\r\n/* Make images easier to work with */\r\nimg {\r\n  max-width: 100%;\r\n  display: block;\r\n}\r\n\r\n/* Natural flow and rhythm in articles by default */\r\n/*article > * + * {\r\n  margin-top: 1em;\r\n}*/\r\n\r\n/* Inherit fonts for inputs and buttons */\r\ninput,\r\nbutton,\r\ntextarea,\r\nselect {\r\n  font: inherit;\r\n}\r\n\r\ninput[type='number'] {\r\n  -moz-appearance: textfield;\r\n}\r\n\r\n/* Remove all animations and transitions for people that prefer not to see them */\r\n@media (prefers-reduced-motion: reduce) {\r\n  * {\r\n    -webkit-animation-duration: 0.01ms !important;\r\n            animation-duration: 0.01ms !important;\r\n    -webkit-animation-iteration-count: 1 !important;\r\n            animation-iteration-count: 1 !important;\r\n    transition-duration: 0.01ms !important;\r\n    scroll-behavior: auto !important;\r\n  }\r\n}\r\n", "",{"version":3,"sources":["webpack://styles/reset.css"],"names":[],"mappings":"AAAA,qBAAqB;AACrB;;;EAGE,sBAAsB;AACxB;;AAEA,2BAA2B;AAC3B;;EAEE,UAAU;AACZ;;AAEA,0BAA0B;AAC1B;;;;;;;;;;;;;;EAcE,SAAS;AACX;;AAEA,2BAA2B;AAC3B;EACE,iBAAiB;EACjB,uBAAuB;EACvB,6BAA6B;EAC7B,gBAAgB;AAClB;;AAEA,iEAAiE;AACjE;;EAEE,gBAAgB;AAClB;;AAEA,0DAA0D;AAC1D;EACE,iCAA8B;UAA9B,8BAA8B;AAChC;;AAEA,oCAAoC;AACpC;EACE,eAAe;EACf,cAAc;AAChB;;AAEA,mDAAmD;AACnD;;EAEE;;AAEF,yCAAyC;AACzC;;;;EAIE,aAAa;AACf;;AAEA;EACE,0BAA0B;AAC5B;;AAEA,iFAAiF;AACjF;EACE;IACE,6CAAqC;YAArC,qCAAqC;IACrC,+CAAuC;YAAvC,uCAAuC;IACvC,sCAAsC;IACtC,gCAAgC;EAClC;AACF","sourcesContent":["/* Box sizing rules */\r\n*,\r\n*::before,\r\n*::after {\r\n  box-sizing: border-box;\r\n}\r\n\r\n/* Remove default padding */\r\nul[class],\r\nol[class] {\r\n  padding: 0;\r\n}\r\n\r\n/* Remove default margin */\r\nbody,\r\nh1,\r\nh2,\r\nh3,\r\nh4,\r\np,\r\nul[class],\r\nol[class],\r\nli,\r\nfigure,\r\nfigcaption,\r\nblockquote,\r\ndl,\r\ndd {\r\n  margin: 0;\r\n}\r\n\r\n/* Set core body defaults */\r\nbody {\r\n  min-height: 100vh;\r\n  scroll-behavior: smooth;\r\n  text-rendering: optimizeSpeed;\r\n  line-height: 1.5;\r\n}\r\n\r\n/* Remove list styles on ul, ol elements with a class attribute */\r\nul[class],\r\nol[class] {\r\n  list-style: none;\r\n}\r\n\r\n/* A elements that don't have a class get default styles */\r\na:not([class]) {\r\n  text-decoration-skip-ink: auto;\r\n}\r\n\r\n/* Make images easier to work with */\r\nimg {\r\n  max-width: 100%;\r\n  display: block;\r\n}\r\n\r\n/* Natural flow and rhythm in articles by default */\r\n/*article > * + * {\r\n  margin-top: 1em;\r\n}*/\r\n\r\n/* Inherit fonts for inputs and buttons */\r\ninput,\r\nbutton,\r\ntextarea,\r\nselect {\r\n  font: inherit;\r\n}\r\n\r\ninput[type='number'] {\r\n  -moz-appearance: textfield;\r\n}\r\n\r\n/* Remove all animations and transitions for people that prefer not to see them */\r\n@media (prefers-reduced-motion: reduce) {\r\n  * {\r\n    animation-duration: 0.01ms !important;\r\n    animation-iteration-count: 1 !important;\r\n    transition-duration: 0.01ms !important;\r\n    scroll-behavior: auto !important;\r\n  }\r\n}\r\n"],"sourceRoot":""}]);
// Exports
/* harmony default export */ __webpack_exports__["default"] = (___CSS_LOADER_EXPORT___);


/***/ }),

/***/ "./node_modules/next/dist/compiled/css-loader/cjs.js?!./node_modules/next/dist/compiled/postcss-loader/cjs.js?!./styles/typography.css":
/*!*******************************************************************************************************************************!*\
  !*** (webpack)/css-loader/cjs.js??ref--5-oneOf-6-1!(webpack)/postcss-loader/cjs.js??ref--5-oneOf-6-2!./styles/typography.css ***!
  \*******************************************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _node_modules_next_dist_compiled_css_loader_api_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../node_modules/next/dist/compiled/css-loader/api.js */ "./node_modules/next/dist/compiled/css-loader/api.js");
/* harmony import */ var _node_modules_next_dist_compiled_css_loader_api_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_next_dist_compiled_css_loader_api_js__WEBPACK_IMPORTED_MODULE_0__);
// Imports

var ___CSS_LOADER_EXPORT___ = _node_modules_next_dist_compiled_css_loader_api_js__WEBPACK_IMPORTED_MODULE_0___default()(true);
// Module
___CSS_LOADER_EXPORT___.push([module.i, ":root {\n  --fs: 1rem;\n  --fs-small: 0.9rem;\n  --fs-xsmall: 0.7rem;\n  --fs-big: 1.2rem;\n}\n\nhtml {\n  //font-size: 2vmin;\n}\n\nbody {\n  font-family: Affogato, sans-serif;\n  font-weight: 400;\n  font-size: 100%;\n  line-height: 1.4;\n  color: var(--c-p);\n}\n\nb {\n  font-weight: 700;\n}\n\nh1,\nh2,\nh3 {\n  font-family: Affogato, sans-serif;\n  font-weight: 700;\n  line-height: 1.1;\n  font-size: 1.8em;\n}\n\nh2 {\n  font-size: 1.5em;\n}\n\nh3 {\n  font-size: 1.2em;\n}\n\n/* button reset */\nbutton {\n  background-color: transparent;\n  border: none;\n  padding: 0;\n}\n\na {\n  color: var(--c-primary);\n}\n\n.fs--small {\n  font-size: 0.9rem;\n  font-size: var(--fs-small);\n}\n\n.fs--xsmall {\n  font-size: 0.7rem;\n  font-size: var(--fs-xsmall);\n}\n", "",{"version":3,"sources":["webpack://styles/typography.css"],"names":[],"mappings":"AAAA;EACE,UAAU;EACV,kBAAkB;EAClB,mBAAmB;EACnB,gBAAgB;AAClB;;AAEA;EACE,kBAAkB;AACpB;;AAEA;EACE,iCAAiC;EACjC,gBAAgB;EAChB,eAAe;EACf,gBAAgB;EAChB,iBAAiB;AACnB;;AAEA;EACE,gBAAgB;AAClB;;AAEA;;;EAGE,iCAAiC;EACjC,gBAAgB;EAChB,gBAAgB;EAChB,gBAAgB;AAClB;;AAEA;EACE,gBAAgB;AAClB;;AAEA;EACE,gBAAgB;AAClB;;AAEA,iBAAiB;AACjB;EACE,6BAA6B;EAC7B,YAAY;EACZ,UAAU;AACZ;;AAEA;EACE,uBAAuB;AACzB;;AAEA;EACE,iBAA0B;EAA1B,0BAA0B;AAC5B;;AAEA;EACE,iBAA2B;EAA3B,2BAA2B;AAC7B","sourcesContent":[":root {\n  --fs: 1rem;\n  --fs-small: 0.9rem;\n  --fs-xsmall: 0.7rem;\n  --fs-big: 1.2rem;\n}\n\nhtml {\n  //font-size: 2vmin;\n}\n\nbody {\n  font-family: Affogato, sans-serif;\n  font-weight: 400;\n  font-size: 100%;\n  line-height: 1.4;\n  color: var(--c-p);\n}\n\nb {\n  font-weight: 700;\n}\n\nh1,\nh2,\nh3 {\n  font-family: Affogato, sans-serif;\n  font-weight: 700;\n  line-height: 1.1;\n  font-size: 1.8em;\n}\n\nh2 {\n  font-size: 1.5em;\n}\n\nh3 {\n  font-size: 1.2em;\n}\n\n/* button reset */\nbutton {\n  background-color: transparent;\n  border: none;\n  padding: 0;\n}\n\na {\n  color: var(--c-primary);\n}\n\n.fs--small {\n  font-size: var(--fs-small);\n}\n\n.fs--xsmall {\n  font-size: var(--fs-xsmall);\n}\n"],"sourceRoot":""}]);
// Exports
/* harmony default export */ __webpack_exports__["default"] = (___CSS_LOADER_EXPORT___);


/***/ }),

/***/ "./node_modules/next/dist/compiled/css-loader/cjs.js?!./node_modules/next/dist/compiled/postcss-loader/cjs.js?!./styles/vars.css":
/*!*************************************************************************************************************************!*\
  !*** (webpack)/css-loader/cjs.js??ref--5-oneOf-6-1!(webpack)/postcss-loader/cjs.js??ref--5-oneOf-6-2!./styles/vars.css ***!
  \*************************************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _node_modules_next_dist_compiled_css_loader_api_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../node_modules/next/dist/compiled/css-loader/api.js */ "./node_modules/next/dist/compiled/css-loader/api.js");
/* harmony import */ var _node_modules_next_dist_compiled_css_loader_api_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_next_dist_compiled_css_loader_api_js__WEBPACK_IMPORTED_MODULE_0__);
// Imports

var ___CSS_LOADER_EXPORT___ = _node_modules_next_dist_compiled_css_loader_api_js__WEBPACK_IMPORTED_MODULE_0___default()(true);
// Module
___CSS_LOADER_EXPORT___.push([module.i, ":root {\r\n    --s-near: 10s;\r\n    --s-mid: calc(var(--s-near) * 2);\r\n    --s-far: calc(var(--s-near) * 3);\r\n    --ease-out-quad: cubic-bezier(.25, .46, .450, .94);\r\n    --form-input-border-radius: 4px;\r\n}", "",{"version":3,"sources":["webpack://styles/vars.css"],"names":[],"mappings":"AAAA;IACI,aAAa;IACb,gCAAgC;IAChC,gCAAgC;IAChC,kDAAkD;IAClD,+BAA+B;AACnC","sourcesContent":[":root {\r\n    --s-near: 10s;\r\n    --s-mid: calc(var(--s-near) * 2);\r\n    --s-far: calc(var(--s-near) * 3);\r\n    --ease-out-quad: cubic-bezier(.25, .46, .450, .94);\r\n    --form-input-border-radius: 4px;\r\n}"],"sourceRoot":""}]);
// Exports
/* harmony default export */ __webpack_exports__["default"] = (___CSS_LOADER_EXPORT___);


/***/ }),

/***/ "./node_modules/next/dist/compiled/css-loader/cjs.js?!./node_modules/next/dist/compiled/postcss-loader/cjs.js?!./theme/Button/Button.module.css":
/*!****************************************************************************************************************************************!*\
  !*** (webpack)/css-loader/cjs.js??ref--5-oneOf-2-1!(webpack)/postcss-loader/cjs.js??ref--5-oneOf-2-2!./theme/Button/Button.module.css ***!
  \****************************************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// Imports
var ___CSS_LOADER_API_IMPORT___ = __webpack_require__(/*! ../../node_modules/next/dist/compiled/css-loader/api.js */ "./node_modules/next/dist/compiled/css-loader/api.js");
var ___CSS_LOADER_EXPORT___ = ___CSS_LOADER_API_IMPORT___(true);
// Module
___CSS_LOADER_EXPORT___.push([module.i, ".Button_root__9utAh {\n    cursor: pointer;\n    font-weight: 700;\n    padding: 0.5em 1em;\n    position: relative;\n    color: var(--c-p);\n    background-color: currentColor;\n    border: 1px solid currentColor;\n    display: flex;\n    align-items: center;\n    transition: all 200ms ease-in-out\n}\n\n\n.Button_root__9utAh:hover {\n    //background-color: var(--c-hellgrau);\n    }\n\n\n.Button_root__9utAh:focus {\n        outline: none;\n        box-shadow: 0 0 0 3px rgba(66, 153, 225, 0.5);\n    }\n\n\n.Button_fontWeight-normal__qmFKZ {\n    font-weight: normal;\n}\n\n.Button_zeropadding__203Wk {\n    padding: 0 0;\n}\n\n.Button_icon__15X15 {\n    color: #fff;\n    will-change: opacity;\n    transition: opacity 200ms ease-in-out;\n    transform: scale(1.3);\n}\n\n.Button_iconLeft__3cxwT {\n    margin-right: 0.6em;\n}\n\n.Button_iconRight__r_5vx {\n    margin-left: 0.6em;\n}\n\n.Button_type-ghost__2pgX-,\n.Button_type-empty__3ZJFx {\n    background-color: transparent;\n\n    .Button_content__3GYla, .Button_icon__15X15, .Button_loader__2ig6q {\n        color: currentColor;\n    }\n}\n\n.Button_type-empty__3ZJFx {\n    border: none;\n}\n\n.Button_size-small__3pZna {\n    font-size: 0.8rem;\n}\n\n.Button_size-large__3XvGz {\n    font-size: 1.2rem;\n}\n\n\n.Button_isRound__12GAE {\n    border-radius: 5rem;\n}\n\n.Button_isDisabled__3ezCB {\n    pointer-events: none;\n    opacity: 0.8;\n}\n\n\n.Button_loader__2ig6q {\n    position: absolute;\n    left: 50%;\n    top: 50%;\n    transform: translateX(-50%) translateY(-50%);\n    width: 1em;\n    height: 1em;\n    color: #fff;\n    opacity: 0;\n    will-change: opacity;\n    transition: opacity 200ms ease-in-out;\n    pointer-events: none;\n}\n\n.Button_content__3GYla {\n    position: relative;\n    z-index: 1;\n    color: #fff;\n    opacity: 1;\n    will-change: opacity;\n    transition: opacity 200ms ease-in-out;\n}\n\n.Button_isLoading__1Jnsk {\n    .Button_loader__2ig6q {\n        opacity: 1;\n    }\n\n    .Button_content__3GYla,\n    .Button_icon__15X15 {\n        opacity: 0;\n    }\n}\n\n.Button_color-red__2F1q7 {\n    color: var(--c-primary);\n}\n", "",{"version":3,"sources":["webpack://theme/Button/Button.module.css","webpack://styles/mixins/a11y-focus.css"],"names":[],"mappings":"AAAA;IACI,eAAe;IACf,gBAAgB;IAChB,kBAAkB;IAClB,kBAAkB;IAClB,iBAAiB;IACjB,8BAA8B;IAC9B,8BAA8B;IAC9B,aAAa;IACb,mBAAmB;IACnB;AASJ;;;AAPI;IACA,qCAAqC;IACrC;;;AAEA;QCfF,aAAa;QACb,6CAA6C;IDgB3C;;;AAIJ;IACI,mBAAmB;AACvB;;AAEA;IACI,YAAY;AAChB;;AAEA;IACI,WAAW;IACX,oBAAoB;IACpB,qCAAqC;IACrC,qBAAqB;AACzB;;AAEA;IACI,mBAAmB;AACvB;;AAEA;IACI,kBAAkB;AACtB;;AAEA;;IAEI,6BAA6B;;IAE7B;QACI,mBAAmB;IACvB;AACJ;;AAEA;IACI,YAAY;AAChB;;AAEA;IACI,iBAAiB;AACrB;;AAEA;IACI,iBAAiB;AACrB;;;AAGA;IACI,mBAAmB;AACvB;;AAEA;IACI,oBAAoB;IACpB,YAAY;AAChB;;;AAGA;IACI,kBAAkB;IAClB,SAAS;IACT,QAAQ;IACR,4CAA4C;IAC5C,UAAU;IACV,WAAW;IACX,WAAW;IACX,UAAU;IACV,oBAAoB;IACpB,qCAAqC;IACrC,oBAAoB;AACxB;;AAEA;IACI,kBAAkB;IAClB,UAAU;IACV,WAAW;IACX,UAAU;IACV,oBAAoB;IACpB,qCAAqC;AACzC;;AAEA;IACI;QACI,UAAU;IACd;;IAEA;;QAEI,UAAU;IACd;AACJ;;AAEA;IACI,uBAAuB;AAC3B","sourcesContent":[".root {\n    cursor: pointer;\n    font-weight: 700;\n    padding: 0.5em 1em;\n    position: relative;\n    color: var(--c-p);\n    background-color: currentColor;\n    border: 1px solid currentColor;\n    display: flex;\n    align-items: center;\n    transition: all 200ms ease-in-out;\n\n    &:hover {\n    //background-color: var(--c-hellgrau);\n    }\n\n    &:focus {\n        @mixin a11y-focus;\n    }\n}\n\n\n.fontWeight-normal {\n    font-weight: normal;\n}\n\n.zeropadding {\n    padding: 0 0;\n}\n\n.icon {\n    color: #fff;\n    will-change: opacity;\n    transition: opacity 200ms ease-in-out;\n    transform: scale(1.3);\n}\n\n.iconLeft {\n    margin-right: 0.6em;\n}\n\n.iconRight {\n    margin-left: 0.6em;\n}\n\n.type-ghost,\n.type-empty {\n    background-color: transparent;\n\n    .content, .icon, .loader {\n        color: currentColor;\n    }\n}\n\n.type-empty {\n    border: none;\n}\n\n.size-small {\n    font-size: 0.8rem;\n}\n\n.size-large {\n    font-size: 1.2rem;\n}\n\n\n.isRound {\n    border-radius: 5rem;\n}\n\n.isDisabled {\n    pointer-events: none;\n    opacity: 0.8;\n}\n\n\n.loader {\n    position: absolute;\n    left: 50%;\n    top: 50%;\n    transform: translateX(-50%) translateY(-50%);\n    width: 1em;\n    height: 1em;\n    color: #fff;\n    opacity: 0;\n    will-change: opacity;\n    transition: opacity 200ms ease-in-out;\n    pointer-events: none;\n}\n\n.content {\n    position: relative;\n    z-index: 1;\n    color: #fff;\n    opacity: 1;\n    will-change: opacity;\n    transition: opacity 200ms ease-in-out;\n}\n\n.isLoading {\n    .loader {\n        opacity: 1;\n    }\n\n    .content,\n    .icon {\n        opacity: 0;\n    }\n}\n\n.color-red {\n    color: var(--c-primary);\n}\n","@define-mixin a11y-focus {\n  outline: none;\n  box-shadow: 0 0 0 3px rgba(66, 153, 225, 0.5);\n}\n"],"sourceRoot":""}]);
// Exports
___CSS_LOADER_EXPORT___.locals = {
	"root": "Button_root__9utAh",
	"fontWeight-normal": "Button_fontWeight-normal__qmFKZ",
	"zeropadding": "Button_zeropadding__203Wk",
	"icon": "Button_icon__15X15",
	"iconLeft": "Button_iconLeft__3cxwT",
	"iconRight": "Button_iconRight__r_5vx",
	"type-ghost": "Button_type-ghost__2pgX-",
	"type-empty": "Button_type-empty__3ZJFx",
	"content": "Button_content__3GYla",
	"loader": "Button_loader__2ig6q",
	"size-small": "Button_size-small__3pZna",
	"size-large": "Button_size-large__3XvGz",
	"isRound": "Button_isRound__12GAE",
	"isDisabled": "Button_isDisabled__3ezCB",
	"isLoading": "Button_isLoading__1Jnsk",
	"color-red": "Button_color-red__2F1q7"
};
module.exports = ___CSS_LOADER_EXPORT___;


/***/ }),

/***/ "./node_modules/next/dist/compiled/css-loader/cjs.js?!./node_modules/next/dist/compiled/postcss-loader/cjs.js?!./theme/CloseButton/CloseButton.module.css":
/*!**************************************************************************************************************************************************!*\
  !*** (webpack)/css-loader/cjs.js??ref--5-oneOf-2-1!(webpack)/postcss-loader/cjs.js??ref--5-oneOf-2-2!./theme/CloseButton/CloseButton.module.css ***!
  \**************************************************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// Imports
var ___CSS_LOADER_API_IMPORT___ = __webpack_require__(/*! ../../node_modules/next/dist/compiled/css-loader/api.js */ "./node_modules/next/dist/compiled/css-loader/api.js");
var ___CSS_LOADER_EXPORT___ = ___CSS_LOADER_API_IMPORT___(true);
// Module
___CSS_LOADER_EXPORT___.push([module.i, ".CloseButton_root__2t_pS {\r\n  position: relative;\r\n  width: 1.5em;\r\n  height: 1.5em;\r\n  text-indent: -9999px;\r\n  cursor: pointer;\r\n  border-radius: 50%\r\n}\n.CloseButton_root__2t_pS::after,\r\n  .CloseButton_root__2t_pS::before {\r\n    content: '';\r\n    position: absolute;\r\n    top: 50%;\r\n    left: 50%;\r\n    transform: translateY(-50%) translateX(-50%) rotate(45deg);\r\n    width: 60%;\r\n    height: 1px;\r\n    background-color: currentColor;\r\n  }\n.CloseButton_root__2t_pS::before {\r\n    transform: translateY(-50%) translateX(-50%) rotate(-45deg);\r\n  }\n.CloseButton_root__2t_pS:hover {\r\n    background-color: #e2e2e2;\r\n    opacity: 1;\r\n  }\n.CloseButton_root__2t_pS:focus {\r\n    outline: none;\r\n    box-shadow: 0 0 0 3px rgba(66, 153, 225, 0.5);\r\n  }\r\n", "",{"version":3,"sources":["webpack://theme/CloseButton/CloseButton.module.css","webpack://styles/mixins/a11y-focus.css"],"names":[],"mappings":"AAAA;EACE,kBAAkB;EAClB,YAAY;EACZ,aAAa;EACb,oBAAoB;EACpB,eAAe;EACf;AA0BF;AAxBE;;IAEE,WAAW;IACX,kBAAkB;IAClB,QAAQ;IACR,SAAS;IACT,0DAA0D;IAC1D,UAAU;IACV,WAAW;IACX,8BAA8B;EAChC;AAEA;IACE,2DAA2D;EAC7D;AAEA;IACE,yBAAyB;IACzB,UAAU;EACZ;AAEA;IC5BA,aAAa;IACb,6CAA6C;ED6B7C","sourcesContent":[".root {\r\n  position: relative;\r\n  width: 1.5em;\r\n  height: 1.5em;\r\n  text-indent: -9999px;\r\n  cursor: pointer;\r\n  border-radius: 50%;\r\n\r\n  &::after,\r\n  &::before {\r\n    content: '';\r\n    position: absolute;\r\n    top: 50%;\r\n    left: 50%;\r\n    transform: translateY(-50%) translateX(-50%) rotate(45deg);\r\n    width: 60%;\r\n    height: 1px;\r\n    background-color: currentColor;\r\n  }\r\n\r\n  &::before {\r\n    transform: translateY(-50%) translateX(-50%) rotate(-45deg);\r\n  }\r\n\r\n  &:hover {\r\n    background-color: #e2e2e2;\r\n    opacity: 1;\r\n  }\r\n\r\n  &:focus {\r\n    @mixin a11y-focus;\r\n  }\r\n}\r\n","@define-mixin a11y-focus {\n  outline: none;\n  box-shadow: 0 0 0 3px rgba(66, 153, 225, 0.5);\n}\n"],"sourceRoot":""}]);
// Exports
___CSS_LOADER_EXPORT___.locals = {
	"root": "CloseButton_root__2t_pS"
};
module.exports = ___CSS_LOADER_EXPORT___;


/***/ }),

/***/ "./node_modules/next/dist/compiled/css-loader/cjs.js?!./node_modules/next/dist/compiled/postcss-loader/cjs.js?!./theme/ContentModal/ContentModal.module.css":
/*!****************************************************************************************************************************************************!*\
  !*** (webpack)/css-loader/cjs.js??ref--5-oneOf-2-1!(webpack)/postcss-loader/cjs.js??ref--5-oneOf-2-2!./theme/ContentModal/ContentModal.module.css ***!
  \****************************************************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// Imports
var ___CSS_LOADER_API_IMPORT___ = __webpack_require__(/*! ../../node_modules/next/dist/compiled/css-loader/api.js */ "./node_modules/next/dist/compiled/css-loader/api.js");
var ___CSS_LOADER_EXPORT___ = ___CSS_LOADER_API_IMPORT___(true);
// Module
___CSS_LOADER_EXPORT___.push([module.i, ".ContentModal_loader__3o3jr {\n    font-size: 1.8rem\n}\n\n.ContentModal_loader__3o3jr:after {\n        margin: 0 auto;\n    }\n\n.ContentModal_content__1Xjx4 {\n}", "",{"version":3,"sources":["webpack://theme/ContentModal/ContentModal.module.css"],"names":[],"mappings":"AAAA;IACI;AAKJ;;AAHI;QACI,cAAc;IAClB;;AAGJ;AACA","sourcesContent":[".loader {\n    font-size: 1.8rem;\n\n    &:after {\n        margin: 0 auto;\n    }\n}\n\n.content {\n}"],"sourceRoot":""}]);
// Exports
___CSS_LOADER_EXPORT___.locals = {
	"loader": "ContentModal_loader__3o3jr",
	"content": "ContentModal_content__1Xjx4"
};
module.exports = ___CSS_LOADER_EXPORT___;


/***/ }),

/***/ "./node_modules/next/dist/compiled/css-loader/cjs.js?!./node_modules/next/dist/compiled/postcss-loader/cjs.js?!./theme/Form/FormControls.module.css":
/*!********************************************************************************************************************************************!*\
  !*** (webpack)/css-loader/cjs.js??ref--5-oneOf-2-1!(webpack)/postcss-loader/cjs.js??ref--5-oneOf-2-2!./theme/Form/FormControls.module.css ***!
  \********************************************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// Imports
var ___CSS_LOADER_API_IMPORT___ = __webpack_require__(/*! ../../node_modules/next/dist/compiled/css-loader/api.js */ "./node_modules/next/dist/compiled/css-loader/api.js");
var ___CSS_LOADER_EXPORT___ = ___CSS_LOADER_API_IMPORT___(true);
// Module
___CSS_LOADER_EXPORT___.push([module.i, ".FormControls_root__36D7E {\r\n  margin-top: var(--space);\r\n  display: flex;\r\n  justify-content: flex-end\r\n}\n.FormControls_root__36D7E > * + * {\r\n    margin-left: var(--space);\r\n  }\r\n", "",{"version":3,"sources":["webpack://theme/Form/FormControls.module.css"],"names":[],"mappings":"AAAA;EACE,wBAAwB;EACxB,aAAa;EACb;AAKF;AAHE;IACE,yBAAyB;EAC3B","sourcesContent":[".root {\r\n  margin-top: var(--space);\r\n  display: flex;\r\n  justify-content: flex-end;\r\n\r\n  & > * + * {\r\n    margin-left: var(--space);\r\n  }\r\n}\r\n"],"sourceRoot":""}]);
// Exports
___CSS_LOADER_EXPORT___.locals = {
	"root": "FormControls_root__36D7E"
};
module.exports = ___CSS_LOADER_EXPORT___;


/***/ }),

/***/ "./node_modules/next/dist/compiled/css-loader/cjs.js?!./node_modules/next/dist/compiled/postcss-loader/cjs.js?!./theme/Form/FormFieldset.module.css":
/*!********************************************************************************************************************************************!*\
  !*** (webpack)/css-loader/cjs.js??ref--5-oneOf-2-1!(webpack)/postcss-loader/cjs.js??ref--5-oneOf-2-2!./theme/Form/FormFieldset.module.css ***!
  \********************************************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// Imports
var ___CSS_LOADER_API_IMPORT___ = __webpack_require__(/*! ../../node_modules/next/dist/compiled/css-loader/api.js */ "./node_modules/next/dist/compiled/css-loader/api.js");
var ___CSS_LOADER_EXPORT___ = ___CSS_LOADER_API_IMPORT___(true);
// Module
___CSS_LOADER_EXPORT___.push([module.i, ".FormFieldset_root__ua4eo {\r\n}\r\n\r\n.FormFieldset_label__3UK8u {\r\n    margin-bottom: var(--space);\r\n}\r\n\r\n.FormFieldset_fields__16Uwy {\r\n    width: 100%;\r\n    display: grid;\r\n    grid-gap: var(--space) var(--space);\r\n    grid-template-columns: 1fr 1fr;\r\n}\r\n\r\n.FormFieldset_isStacked__XunQq {\r\n    .FormFieldset_fields__16Uwy {\r\n        grid-template-columns: 1fr;\r\n    }\r\n}\r\n", "",{"version":3,"sources":["webpack://theme/Form/FormFieldset.module.css"],"names":[],"mappings":"AAAA;AACA;;AAEA;IACI,2BAA2B;AAC/B;;AAEA;IACI,WAAW;IACX,aAAa;IACb,mCAAmC;IACnC,8BAA8B;AAClC;;AAEA;IACI;QACI,0BAA0B;IAC9B;AACJ","sourcesContent":[".root {\r\n}\r\n\r\n.label {\r\n    margin-bottom: var(--space);\r\n}\r\n\r\n.fields {\r\n    width: 100%;\r\n    display: grid;\r\n    grid-gap: var(--space) var(--space);\r\n    grid-template-columns: 1fr 1fr;\r\n}\r\n\r\n.isStacked {\r\n    .fields {\r\n        grid-template-columns: 1fr;\r\n    }\r\n}\r\n"],"sourceRoot":""}]);
// Exports
___CSS_LOADER_EXPORT___.locals = {
	"root": "FormFieldset_root__ua4eo",
	"label": "FormFieldset_label__3UK8u",
	"fields": "FormFieldset_fields__16Uwy",
	"isStacked": "FormFieldset_isStacked__XunQq"
};
module.exports = ___CSS_LOADER_EXPORT___;


/***/ }),

/***/ "./node_modules/next/dist/compiled/css-loader/cjs.js?!./node_modules/next/dist/compiled/postcss-loader/cjs.js?!./theme/Form/Input.module.css":
/*!*************************************************************************************************************************************!*\
  !*** (webpack)/css-loader/cjs.js??ref--5-oneOf-2-1!(webpack)/postcss-loader/cjs.js??ref--5-oneOf-2-2!./theme/Form/Input.module.css ***!
  \*************************************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// Imports
var ___CSS_LOADER_API_IMPORT___ = __webpack_require__(/*! ../../node_modules/next/dist/compiled/css-loader/api.js */ "./node_modules/next/dist/compiled/css-loader/api.js");
var ___CSS_LOADER_EXPORT___ = ___CSS_LOADER_API_IMPORT___(true);
// Module
___CSS_LOADER_EXPORT___.push([module.i, ".Input_root__1Td0X {\r\n    width: 100%;\r\n    position: relative;\r\n    display: flex;\r\n    flex-direction: column;\r\n}\r\n\r\n.Input_label__ErkuA {\r\n    font-weight: bold;\r\n    color: var(--c-p);\r\n    font-size: var(--fs-small);\r\n    margin-bottom: 0.6em;\r\n}\r\n\r\n.Input_element__3XBnZ {\r\n    display: block;\r\n    width: 100%;\r\n    border-radius: var(--form-input-border-radius);\r\n    border: 1px solid var(--c-border);\r\n    color: var(--c-p);\r\n    line-height: 1.25;\r\n    padding: 0.8em 1em;\r\n    outline: none;\r\n//box-shadow: 0 1px 3px 0 rgba(0, 0, 0, 0.1), 0 1px 2px 0 rgba(0, 0, 0, 0.06)\r\n}\r\n\r\n.Input_element__3XBnZ:focus {\r\n        outline: none;\r\n        box-shadow: 0 0 0 3px rgba(66, 153, 225, 0.5);\r\n    }\r\n\r\n.Input_isError__-4H5f {\r\n    .Input_element__3XBnZ {\r\n        border-color: var(--c-feedback-error) !important;\r\n    }\r\n}\r\n\r\n.Input_error__ZQdhk {\r\n    color: var(--c-feedback-error);\r\n    font-size: var(--fs-xsmall);\r\n    margin-top: 0.5em;\r\n    text-align: right;\r\n    width: 100%;\r\n    position: absolute;\r\n    right: 0;\r\n    bottom: -0.5em;\r\n    transform: translateY(100%);\r\n}\r\n", "",{"version":3,"sources":["webpack://theme/Form/Input.module.css","webpack://styles/mixins/a11y-focus.css"],"names":[],"mappings":"AAAA;IACI,WAAW;IACX,kBAAkB;IAClB,aAAa;IACb,sBAAsB;AAC1B;;AAEA;IACI,iBAAiB;IACjB,iBAAiB;IACjB,0BAA0B;IAC1B,oBAAoB;AACxB;;AAEA;IACI,cAAc;IACd,WAAW;IACX,8CAA8C;IAC9C,iCAAiC;IACjC,iBAAiB;IACjB,iBAAiB;IACjB,kBAAkB;IAClB,aAAa;AACjB;AAKA;;AAHI;QCxBF,aAAa;QACb,6CAA6C;IDyB3C;;AAGJ;IACI;QACI,gDAAgD;IACpD;AACJ;;AAEA;IACI,8BAA8B;IAC9B,2BAA2B;IAC3B,iBAAiB;IACjB,iBAAiB;IACjB,WAAW;IACX,kBAAkB;IAClB,QAAQ;IACR,cAAc;IACd,2BAA2B;AAC/B","sourcesContent":[".root {\r\n    width: 100%;\r\n    position: relative;\r\n    display: flex;\r\n    flex-direction: column;\r\n}\r\n\r\n.label {\r\n    font-weight: bold;\r\n    color: var(--c-p);\r\n    font-size: var(--fs-small);\r\n    margin-bottom: 0.6em;\r\n}\r\n\r\n.element {\r\n    display: block;\r\n    width: 100%;\r\n    border-radius: var(--form-input-border-radius);\r\n    border: 1px solid var(--c-border);\r\n    color: var(--c-p);\r\n    line-height: 1.25;\r\n    padding: 0.8em 1em;\r\n    outline: none;\r\n//box-shadow: 0 1px 3px 0 rgba(0, 0, 0, 0.1), 0 1px 2px 0 rgba(0, 0, 0, 0.06);\r\n\r\n    &:focus {\r\n        @mixin a11y-focus;\r\n    }\r\n}\r\n\r\n.isError {\r\n    .element {\r\n        border-color: var(--c-feedback-error) !important;\r\n    }\r\n}\r\n\r\n.error {\r\n    color: var(--c-feedback-error);\r\n    font-size: var(--fs-xsmall);\r\n    margin-top: 0.5em;\r\n    text-align: right;\r\n    width: 100%;\r\n    position: absolute;\r\n    right: 0;\r\n    bottom: -0.5em;\r\n    transform: translateY(100%);\r\n}\r\n","@define-mixin a11y-focus {\n  outline: none;\n  box-shadow: 0 0 0 3px rgba(66, 153, 225, 0.5);\n}\n"],"sourceRoot":""}]);
// Exports
___CSS_LOADER_EXPORT___.locals = {
	"root": "Input_root__1Td0X",
	"label": "Input_label__ErkuA",
	"element": "Input_element__3XBnZ",
	"isError": "Input_isError__-4H5f",
	"error": "Input_error__ZQdhk"
};
module.exports = ___CSS_LOADER_EXPORT___;


/***/ }),

/***/ "./node_modules/next/dist/compiled/css-loader/cjs.js?!./node_modules/next/dist/compiled/postcss-loader/cjs.js?!./theme/Image/LazyImage.module.css":
/*!******************************************************************************************************************************************!*\
  !*** (webpack)/css-loader/cjs.js??ref--5-oneOf-2-1!(webpack)/postcss-loader/cjs.js??ref--5-oneOf-2-2!./theme/Image/LazyImage.module.css ***!
  \******************************************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// Imports
var ___CSS_LOADER_API_IMPORT___ = __webpack_require__(/*! ../../node_modules/next/dist/compiled/css-loader/api.js */ "./node_modules/next/dist/compiled/css-loader/api.js");
var ___CSS_LOADER_EXPORT___ = ___CSS_LOADER_API_IMPORT___(true);
// Module
___CSS_LOADER_EXPORT___.push([module.i, ".LazyImage_root__1LfAK {\r\n    display: inline-block;\r\n    position: relative;\r\n}\r\n\r\n.LazyImage_image__3nOAm {\r\n    display: block;\r\n    position: relative;\r\n    opacity: 0;\r\n    height: auto;\r\n    transition: opacity 200ms;\r\n    will-change: opacity;\r\n}\r\n\r\n.LazyImage_imageLazyload__MlFRV {\r\n}\r\n\r\n.LazyImage_imageLazyloading__3Jki_ {\r\n}\r\n\r\n.LazyImage_imageLazyloaded__1nPet {\r\n    opacity: 1;\r\n}\r\n\r\n.LazyImage_preview__3gqXR {\r\n//filter: url(#ls-sharp-blur); position: absolute; left: 0; top: 0;\r\n    width: 100%;\r\n    transition: opacity 200ms;\r\n    will-change: opacity;\r\n}\r\n\r\n.LazyImage_background__2L4ax {\r\n    position: absolute;\r\n    bottom: 0;\r\n    right: 0;\r\n    left: 0;\r\n    top: 0;\r\n\r\n    .LazyImage_image__3nOAm,\r\n    .LazyImage_preview__3gqXR {\r\n        position: absolute;\r\n        bottom: 0;\r\n        right: 0;\r\n        left: 0;\r\n        top: 0;\r\n        background: center center no-repeat;\r\n        background-size: cover;\r\n    }\r\n}\r\n\r\n.LazyImage_isLoaded__2ebks {\r\n    .LazyImage_preview__3gqXR[src$='.png'] {\r\n        opacity: 0;\r\n    }\r\n}\r\n\r\n.LazyImage_lazysizes-svgfilter__Legu1 {\r\n    border: 0;\r\n    clip: rect(0 0 0 0);\r\n    height: 1px;\r\n    margin: -1px;\r\n    overflow: hidden;\r\n    padding: 0;\r\n    position: absolute;\r\n    width: 1px;\r\n}\r\n", "",{"version":3,"sources":["webpack://theme/Image/LazyImage.module.css"],"names":[],"mappings":"AAAA;IACI,qBAAqB;IACrB,kBAAkB;AACtB;;AAEA;IACI,cAAc;IACd,kBAAkB;IAClB,UAAU;IACV,YAAY;IACZ,yBAAyB;IACzB,oBAAoB;AACxB;;AAEA;AACA;;AAEA;AACA;;AAEA;IACI,UAAU;AACd;;AAEA;AACA,6BAA6B,EAAE,kBAAkB,EAAE,OAAO,EAAE,MAAM;IAC9D,WAAW;IACX,yBAAyB;IACzB,oBAAoB;AACxB;;AAEA;IACI,kBAAkB;IAClB,SAAS;IACT,QAAQ;IACR,OAAO;IACP,MAAM;;IAEN;;QAEI,kBAAkB;QAClB,SAAS;QACT,QAAQ;QACR,OAAO;QACP,MAAM;QACN,mCAAmC;QACnC,sBAAsB;IAC1B;AACJ;;AAEA;IACI;QACI,UAAU;IACd;AACJ;;AAEA;IACI,SAAS;IACT,mBAAmB;IACnB,WAAW;IACX,YAAY;IACZ,gBAAgB;IAChB,UAAU;IACV,kBAAkB;IAClB,UAAU;AACd","sourcesContent":[".root {\r\n    display: inline-block;\r\n    position: relative;\r\n}\r\n\r\n.image {\r\n    display: block;\r\n    position: relative;\r\n    opacity: 0;\r\n    height: auto;\r\n    transition: opacity 200ms;\r\n    will-change: opacity;\r\n}\r\n\r\n.imageLazyload {\r\n}\r\n\r\n.imageLazyloading {\r\n}\r\n\r\n.imageLazyloaded {\r\n    opacity: 1;\r\n}\r\n\r\n.preview {\r\n//filter: url(#ls-sharp-blur); position: absolute; left: 0; top: 0;\r\n    width: 100%;\r\n    transition: opacity 200ms;\r\n    will-change: opacity;\r\n}\r\n\r\n.background {\r\n    position: absolute;\r\n    bottom: 0;\r\n    right: 0;\r\n    left: 0;\r\n    top: 0;\r\n\r\n    .image,\r\n    .preview {\r\n        position: absolute;\r\n        bottom: 0;\r\n        right: 0;\r\n        left: 0;\r\n        top: 0;\r\n        background: center center no-repeat;\r\n        background-size: cover;\r\n    }\r\n}\r\n\r\n.isLoaded {\r\n    .preview[src$='.png'] {\r\n        opacity: 0;\r\n    }\r\n}\r\n\r\n.lazysizes-svgfilter {\r\n    border: 0;\r\n    clip: rect(0 0 0 0);\r\n    height: 1px;\r\n    margin: -1px;\r\n    overflow: hidden;\r\n    padding: 0;\r\n    position: absolute;\r\n    width: 1px;\r\n}\r\n"],"sourceRoot":""}]);
// Exports
___CSS_LOADER_EXPORT___.locals = {
	"root": "LazyImage_root__1LfAK",
	"image": "LazyImage_image__3nOAm",
	"imageLazyload": "LazyImage_imageLazyload__MlFRV",
	"imageLazyloading": "LazyImage_imageLazyloading__3Jki_",
	"imageLazyloaded": "LazyImage_imageLazyloaded__1nPet",
	"preview": "LazyImage_preview__3gqXR",
	"background": "LazyImage_background__2L4ax",
	"isLoaded": "LazyImage_isLoaded__2ebks",
	"lazysizes-svgfilter": "LazyImage_lazysizes-svgfilter__Legu1"
};
module.exports = ___CSS_LOADER_EXPORT___;


/***/ }),

/***/ "./node_modules/next/dist/compiled/css-loader/cjs.js?!./node_modules/next/dist/compiled/postcss-loader/cjs.js?!./theme/Loader/Loader.module.css":
/*!****************************************************************************************************************************************!*\
  !*** (webpack)/css-loader/cjs.js??ref--5-oneOf-2-1!(webpack)/postcss-loader/cjs.js??ref--5-oneOf-2-2!./theme/Loader/Loader.module.css ***!
  \****************************************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// Imports
var ___CSS_LOADER_API_IMPORT___ = __webpack_require__(/*! ../../node_modules/next/dist/compiled/css-loader/api.js */ "./node_modules/next/dist/compiled/css-loader/api.js");
var ___CSS_LOADER_EXPORT___ = ___CSS_LOADER_API_IMPORT___(true);
// Module
___CSS_LOADER_EXPORT___.push([module.i, ".Loader_root__3xCP2 {\r\n    text-align: center\r\n}\n.Loader_root__3xCP2::after {\r\n        content: '';\r\n        background-color: transparent;\r\n        border: 0.08em solid currentColor;\r\n        border-radius: 50%;\r\n        border-top-color: transparent;\r\n        border-right-color: transparent;\r\n        font-size: 1em;\r\n        width: 1em;\r\n        height: 1em;\r\n        display: block;\r\n        vertical-align: middle;\r\n        box-sizing: border-box;\r\n        -webkit-animation: Loader_spinner__spCe8 0.65s infinite linear;\r\n                animation: Loader_spinner__spCe8 0.65s infinite linear;\r\n    }\r\n", "",{"version":3,"sources":["webpack://theme/Loader/Loader.module.css","webpack://styles/mixins/spinner.css"],"names":[],"mappings":"AAAA;IACI;AAMJ;AAJI;QACI,WAAW;QCFjB,6BAA6B;QAC7B,iCAAe;QACf,kBAAkB;QAClB,6BAA6B;QAC7B,+BAA+B;QAC/B,cAAgB;QAChB,UAAY;QACZ,WAAa;QACb,cAAc;QACd,sBAAsB;QACtB,sBAAsB;QACtB,8DAA4C;gBAA5C,sDAA4C;IDP1C","sourcesContent":[".root {\r\n    text-align: center;\r\n\r\n    &::after {\r\n        content: '';\r\n        @mixin spinner;\r\n    }\r\n}\r\n","@define-mixin spinner $size: 1em, $border: 0.08em solid currentColor,\r\n  $duration: 0.65s, $background: transparent {\r\n  background-color: transparent;\r\n  border: $border;\r\n  border-radius: 50%;\r\n  border-top-color: $background;\r\n  border-right-color: $background;\r\n  font-size: $size;\r\n  width: $size;\r\n  height: $size;\r\n  display: block;\r\n  vertical-align: middle;\r\n  box-sizing: border-box;\r\n  animation: spinner $duration infinite linear;\r\n}\r\n"],"sourceRoot":""}]);
// Exports
___CSS_LOADER_EXPORT___.locals = {
	"root": "Loader_root__3xCP2",
	"spinner": "Loader_spinner__spCe8"
};
module.exports = ___CSS_LOADER_EXPORT___;


/***/ }),

/***/ "./node_modules/next/dist/compiled/css-loader/cjs.js?!./node_modules/next/dist/compiled/postcss-loader/cjs.js?!./theme/Logo/Logo.module.css":
/*!************************************************************************************************************************************!*\
  !*** (webpack)/css-loader/cjs.js??ref--5-oneOf-2-1!(webpack)/postcss-loader/cjs.js??ref--5-oneOf-2-2!./theme/Logo/Logo.module.css ***!
  \************************************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// Imports
var ___CSS_LOADER_API_IMPORT___ = __webpack_require__(/*! ../../node_modules/next/dist/compiled/css-loader/api.js */ "./node_modules/next/dist/compiled/css-loader/api.js");
var ___CSS_LOADER_EXPORT___ = ___CSS_LOADER_API_IMPORT___(true);
// Module
___CSS_LOADER_EXPORT___.push([module.i, ".Logo_root__3rjtE {\r\n  #Logo_p__2-UEd,\r\n  #Logo_a__2b6ZQ {\r\n    fill: var(--c-primary);\r\n  }\r\n\r\n  #Logo_w__1hZAn {\r\n    fill: var(--c-secondary);\r\n  }\r\n}\r\n", "",{"version":3,"sources":["webpack://theme/Logo/Logo.module.css"],"names":[],"mappings":"AAAA;EACE;;IAEE,sBAAsB;EACxB;;EAEA;IACE,wBAAwB;EAC1B;AACF","sourcesContent":[".root {\r\n  #p,\r\n  #a {\r\n    fill: var(--c-primary);\r\n  }\r\n\r\n  #w {\r\n    fill: var(--c-secondary);\r\n  }\r\n}\r\n"],"sourceRoot":""}]);
// Exports
___CSS_LOADER_EXPORT___.locals = {
	"root": "Logo_root__3rjtE",
	"p": "Logo_p__2-UEd",
	"a": "Logo_a__2b6ZQ",
	"w": "Logo_w__1hZAn"
};
module.exports = ___CSS_LOADER_EXPORT___;


/***/ }),

/***/ "./node_modules/next/dist/compiled/css-loader/cjs.js?!./node_modules/next/dist/compiled/postcss-loader/cjs.js?!./theme/Misc/Notification.module.css":
/*!********************************************************************************************************************************************!*\
  !*** (webpack)/css-loader/cjs.js??ref--5-oneOf-2-1!(webpack)/postcss-loader/cjs.js??ref--5-oneOf-2-2!./theme/Misc/Notification.module.css ***!
  \********************************************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// Imports
var ___CSS_LOADER_API_IMPORT___ = __webpack_require__(/*! ../../node_modules/next/dist/compiled/css-loader/api.js */ "./node_modules/next/dist/compiled/css-loader/api.js");
var ___CSS_LOADER_EXPORT___ = ___CSS_LOADER_API_IMPORT___(true);
// Module
___CSS_LOADER_EXPORT___.push([module.i, ".Notification_root__2p0d3 {\n    padding: 0.8em 1em;\n    border: 1px solid var(--c-feedback);\n    border-radius: 4px;\n    position: relative\n}\n\n.Notification_root__2p0d3:after {\n        content: '';\n        position: absolute;\n        bottom: 0;\n        right: 0;\n        left: 0;\n        top: 0;\n        background-color: var(--c-feedback);\n        opacity: 0.05;\n        z-index: 1;\n    }\n\n.Notification_root__2p0d3 a {\n    color: var(--c-feedback);\n}\n\n.Notification_text__3xstF {\n    position: relative;\n    z-index: 2;\n}\n\n.Notification_type-error__hm_Gs {\n    border-color: var(--c-feedback-error);\n    color: var(--c-feedback-error)\n}\n\n.Notification_type-error__hm_Gs:after {\n        background-color: var(--c-feedback-error);\n    }\n\n.Notification_type-error__hm_Gs a {\n    color: var(--c-feedback-error);\n}\n\n.Notification_type-success__3PzZO {\n    border-color: var(--c-feedback-success);\n    color: var(--c-feedback-success)\n}\n\n.Notification_type-success__3PzZO:after {\n        background-color: var(--c-feedback-success);\n    }\n\n.Notification_type-success__3PzZO a {\n    color: var(--c-feedback-success);\n}\n", "",{"version":3,"sources":["webpack://theme/Misc/Notification.module.css"],"names":[],"mappings":"AAAA;IACI,kBAAkB;IAClB,mCAAmC;IACnC,kBAAkB;IAClB;AAaJ;;AAXI;QACI,WAAW;QACX,kBAAkB;QAClB,SAAS;QACT,QAAQ;QACR,OAAO;QACP,MAAM;QACN,mCAAmC;QACnC,aAAa;QACb,UAAU;IACd;;AAGJ;IACI,wBAAwB;AAC5B;;AAEA;IACI,kBAAkB;IAClB,UAAU;AACd;;AAEA;IACI,qCAAqC;IACrC;AAKJ;;AAHI;QACI,yCAAyC;IAC7C;;AAGJ;IACI,8BAA8B;AAClC;;AAEA;IACI,uCAAuC;IACvC;AAKJ;;AAHI;QACI,2CAA2C;IAC/C;;AAGJ;IACI,gCAAgC;AACpC","sourcesContent":[".root {\n    padding: 0.8em 1em;\n    border: 1px solid var(--c-feedback);\n    border-radius: 4px;\n    position: relative;\n\n    &:after {\n        content: '';\n        position: absolute;\n        bottom: 0;\n        right: 0;\n        left: 0;\n        top: 0;\n        background-color: var(--c-feedback);\n        opacity: 0.05;\n        z-index: 1;\n    }\n}\n\n.root a {\n    color: var(--c-feedback);\n}\n\n.text {\n    position: relative;\n    z-index: 2;\n}\n\n.type-error {\n    border-color: var(--c-feedback-error);\n    color: var(--c-feedback-error);\n\n    &:after {\n        background-color: var(--c-feedback-error);\n    }\n}\n\n.type-error a {\n    color: var(--c-feedback-error);\n}\n\n.type-success {\n    border-color: var(--c-feedback-success);\n    color: var(--c-feedback-success);\n\n    &:after {\n        background-color: var(--c-feedback-success);\n    }\n}\n\n.type-success a {\n    color: var(--c-feedback-success);\n}\n"],"sourceRoot":""}]);
// Exports
___CSS_LOADER_EXPORT___.locals = {
	"root": "Notification_root__2p0d3",
	"text": "Notification_text__3xstF",
	"type-error": "Notification_type-error__hm_Gs",
	"type-success": "Notification_type-success__3PzZO"
};
module.exports = ___CSS_LOADER_EXPORT___;


/***/ }),

/***/ "./node_modules/next/dist/compiled/css-loader/cjs.js?!./node_modules/next/dist/compiled/postcss-loader/cjs.js?!./theme/Misc/Snow.module.css":
/*!************************************************************************************************************************************!*\
  !*** (webpack)/css-loader/cjs.js??ref--5-oneOf-2-1!(webpack)/postcss-loader/cjs.js??ref--5-oneOf-2-2!./theme/Misc/Snow.module.css ***!
  \************************************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// Imports
var ___CSS_LOADER_API_IMPORT___ = __webpack_require__(/*! ../../node_modules/next/dist/compiled/css-loader/api.js */ "./node_modules/next/dist/compiled/css-loader/api.js");
var ___CSS_LOADER_EXPORT___ = ___CSS_LOADER_API_IMPORT___(true);
// Module
___CSS_LOADER_EXPORT___.push([module.i, ".Snow_root__sRHs0 {\n}\n\n.Snow_level__A7P1Q {\n    position: absolute;\n    top: 0;\n    right: 0;\n    bottom: 0;\n    left: 0;\n    -webkit-animation: Snow_falling__KfwK8 linear infinite both;\n            animation: Snow_falling__KfwK8 linear infinite both;\n    transform: translate3D(0, -100%, 0);\n}\n\n.Snow_position-near__2UUm0 {\n    -webkit-animation-duration: var(--s-near);\n            animation-duration: var(--s-near);\n    background-image: url('/assets/static/snow/near.png');\n    background-size: contain;\n}\n\n.Snow_position-near__2UUm0.Snow_levelAlt__3EuxJ {\n    -webkit-animation-delay: calc(var(--s-near) / 2);\n            animation-delay: calc(var(--s-near) / 2);\n}\n\n.Snow_position-mid__tbB4c {\n    -webkit-animation-duration: var(--s-mid);\n            animation-duration: var(--s-mid);\n    background-image: url('/assets/static/snow/mid.png');\n    background-size: contain;\n}\n\n.Snow_position-mid__tbB4c.Snow_levelAlt__3EuxJ {\n    -webkit-animation-delay: calc(var(--s-mid) / 2);\n            animation-delay: calc(var(--s-mid) / 2);\n}\n\n.Snow_position-far__31-bX {\n    -webkit-animation-duration: var(--s-far);\n            animation-duration: var(--s-far);\n    background-image: url('/assets/static/snow/far.png');\n    background-size: contain;\n}\n\n.Snow_position-far__31-bX.Snow_levelAlt__3EuxJ {\n    -webkit-animation-delay: calc(var(--s-far) / 2);\n            animation-delay: calc(var(--s-far) / 2);\n}\n\n@-webkit-keyframes Snow_falling__KfwK8 {\n    0% {\n        transform: translate3D(-7.5%, -100%, 0);\n    }\n\n    100% {\n        transform: translate3D(7.5%, 100%, 0);\n    }\n}\n\n@keyframes Snow_falling__KfwK8 {\n    0% {\n        transform: translate3D(-7.5%, -100%, 0);\n    }\n\n    100% {\n        transform: translate3D(7.5%, 100%, 0);\n    }\n}\n", "",{"version":3,"sources":["webpack://theme/Misc/Snow.module.css"],"names":[],"mappings":"AAAA;AACA;;AAEA;IACI,kBAAkB;IAClB,MAAM;IACN,QAAQ;IACR,SAAS;IACT,OAAO;IACP,2DAAuC;YAAvC,mDAAuC;IACvC,mCAAmC;AACvC;;AAEA;IACI,yCAAiC;YAAjC,iCAAiC;IACjC,qDAAqD;IACrD,wBAAwB;AAC5B;;AAEA;IACI,gDAAwC;YAAxC,wCAAwC;AAC5C;;AAEA;IACI,wCAAgC;YAAhC,gCAAgC;IAChC,oDAAoD;IACpD,wBAAwB;AAC5B;;AAEA;IACI,+CAAuC;YAAvC,uCAAuC;AAC3C;;AAEA;IACI,wCAAgC;YAAhC,gCAAgC;IAChC,oDAAoD;IACpD,wBAAwB;AAC5B;;AAEA;IACI,+CAAuC;YAAvC,uCAAuC;AAC3C;;AAEA;IACI;QACI,uCAAuC;IAC3C;;IAEA;QACI,qCAAqC;IACzC;AACJ;;AARA;IACI;QACI,uCAAuC;IAC3C;;IAEA;QACI,qCAAqC;IACzC;AACJ","sourcesContent":[".root {\n}\n\n.level {\n    position: absolute;\n    top: 0;\n    right: 0;\n    bottom: 0;\n    left: 0;\n    animation: falling linear infinite both;\n    transform: translate3D(0, -100%, 0);\n}\n\n.position-near {\n    animation-duration: var(--s-near);\n    background-image: url('/assets/static/snow/near.png');\n    background-size: contain;\n}\n\n.position-near.levelAlt {\n    animation-delay: calc(var(--s-near) / 2);\n}\n\n.position-mid {\n    animation-duration: var(--s-mid);\n    background-image: url('/assets/static/snow/mid.png');\n    background-size: contain;\n}\n\n.position-mid.levelAlt {\n    animation-delay: calc(var(--s-mid) / 2);\n}\n\n.position-far {\n    animation-duration: var(--s-far);\n    background-image: url('/assets/static/snow/far.png');\n    background-size: contain;\n}\n\n.position-far.levelAlt {\n    animation-delay: calc(var(--s-far) / 2);\n}\n\n@keyframes falling {\n    0% {\n        transform: translate3D(-7.5%, -100%, 0);\n    }\n\n    100% {\n        transform: translate3D(7.5%, 100%, 0);\n    }\n}\n"],"sourceRoot":""}]);
// Exports
___CSS_LOADER_EXPORT___.locals = {
	"root": "Snow_root__sRHs0",
	"level": "Snow_level__A7P1Q",
	"falling": "Snow_falling__KfwK8",
	"position-near": "Snow_position-near__2UUm0",
	"levelAlt": "Snow_levelAlt__3EuxJ",
	"position-mid": "Snow_position-mid__tbB4c",
	"position-far": "Snow_position-far__31-bX"
};
module.exports = ___CSS_LOADER_EXPORT___;


/***/ }),

/***/ "./node_modules/next/dist/compiled/css-loader/cjs.js?!./node_modules/next/dist/compiled/postcss-loader/cjs.js?!./theme/SVG/Icon.module.css":
/*!***********************************************************************************************************************************!*\
  !*** (webpack)/css-loader/cjs.js??ref--5-oneOf-2-1!(webpack)/postcss-loader/cjs.js??ref--5-oneOf-2-2!./theme/SVG/Icon.module.css ***!
  \***********************************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// Imports
var ___CSS_LOADER_API_IMPORT___ = __webpack_require__(/*! ../../node_modules/next/dist/compiled/css-loader/api.js */ "./node_modules/next/dist/compiled/css-loader/api.js");
var ___CSS_LOADER_EXPORT___ = ___CSS_LOADER_API_IMPORT___(true);
// Module
___CSS_LOADER_EXPORT___.push([module.i, ".Icon_root__2KQzV {\r\n    display: inline-block;\r\n    line-height: 1;\r\n}\r\n\r\n.Icon_root__2KQzV svg {\r\n    text-align: center;\r\n    vertical-align: middle;\r\n    fill: currentColor;\r\n    height: 1em;\r\n    width: 1em;\r\n    display: block;\r\n}\r\n\r\n.Icon_isRound__2Tjje {\r\n    border-radius: 9999px;\r\n}\r\n\r\n.Icon_animationSpin__Zg000 {\r\n    -webkit-animation: Icon_spinner__MGSts 2s infinite linear;\r\n            animation: Icon_spinner__MGSts 2s infinite linear;\r\n}\r\n\r\n.Icon_rotate-90__1zk2t {\r\n    transform: rotate(90deg);\r\n}\r\n\r\n.Icon_rotate-180__3XgMt {\r\n    transform: rotate(180deg);\r\n}\r\n\r\n.Icon_rotate-270__YzpTZ {\r\n    transform: rotate(270deg);\r\n}\r\n\r\n.Icon_circle__3AGLi {\r\n    border: 1px solid currentColor;\r\n    border-radius: 50%;\r\n}\r\n\r\n.Icon_circle__3AGLi svg {\r\n    transform: scale(0.7);\r\n}", "",{"version":3,"sources":["webpack://theme/SVG/Icon.module.css"],"names":[],"mappings":"AAAA;IACI,qBAAqB;IACrB,cAAc;AAClB;;AAEA;IACI,kBAAkB;IAClB,sBAAsB;IACtB,kBAAkB;IAClB,WAAW;IACX,UAAU;IACV,cAAc;AAClB;;AAEA;IACI,qBAAqB;AACzB;;AAEA;IACI,yDAAqC;YAArC,iDAAqC;AACzC;;AAEA;IACI,wBAAwB;AAC5B;;AAEA;IACI,yBAAyB;AAC7B;;AAEA;IACI,yBAAyB;AAC7B;;AAEA;IACI,8BAA8B;IAC9B,kBAAkB;AACtB;;AAEA;IACI,qBAAqB;AACzB","sourcesContent":[".root {\r\n    display: inline-block;\r\n    line-height: 1;\r\n}\r\n\r\n.root svg {\r\n    text-align: center;\r\n    vertical-align: middle;\r\n    fill: currentColor;\r\n    height: 1em;\r\n    width: 1em;\r\n    display: block;\r\n}\r\n\r\n.isRound {\r\n    border-radius: 9999px;\r\n}\r\n\r\n.animationSpin {\r\n    animation: spinner 2s infinite linear;\r\n}\r\n\r\n.rotate-90 {\r\n    transform: rotate(90deg);\r\n}\r\n\r\n.rotate-180 {\r\n    transform: rotate(180deg);\r\n}\r\n\r\n.rotate-270 {\r\n    transform: rotate(270deg);\r\n}\r\n\r\n.circle {\r\n    border: 1px solid currentColor;\r\n    border-radius: 50%;\r\n}\r\n\r\n.circle svg {\r\n    transform: scale(0.7);\r\n}"],"sourceRoot":""}]);
// Exports
___CSS_LOADER_EXPORT___.locals = {
	"root": "Icon_root__2KQzV",
	"isRound": "Icon_isRound__2Tjje",
	"animationSpin": "Icon_animationSpin__Zg000",
	"spinner": "Icon_spinner__MGSts",
	"rotate-90": "Icon_rotate-90__1zk2t",
	"rotate-180": "Icon_rotate-180__3XgMt",
	"rotate-270": "Icon_rotate-270__YzpTZ",
	"circle": "Icon_circle__3AGLi"
};
module.exports = ___CSS_LOADER_EXPORT___;


/***/ }),

/***/ "./node_modules/next/dist/compiled/css-loader/cjs.js?!./node_modules/next/dist/compiled/postcss-loader/cjs.js?!./theme/SVG/SVG.module.css":
/*!**********************************************************************************************************************************!*\
  !*** (webpack)/css-loader/cjs.js??ref--5-oneOf-2-1!(webpack)/postcss-loader/cjs.js??ref--5-oneOf-2-2!./theme/SVG/SVG.module.css ***!
  \**********************************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// Imports
var ___CSS_LOADER_API_IMPORT___ = __webpack_require__(/*! ../../node_modules/next/dist/compiled/css-loader/api.js */ "./node_modules/next/dist/compiled/css-loader/api.js");
var ___CSS_LOADER_EXPORT___ = ___CSS_LOADER_API_IMPORT___(true);
// Module
___CSS_LOADER_EXPORT___.push([module.i, ".SVG_root__xlZ0r svg {\n    width: 100%;\n    height: auto;\n    display: block;\n}\n\n.SVG_isInline__35vCN {\n    width: 1em;\n    height: 1em;\n    display: inline-block;\n}\n", "",{"version":3,"sources":["webpack://theme/SVG/SVG.module.css"],"names":[],"mappings":"AAAA;IACI,WAAW;IACX,YAAY;IACZ,cAAc;AAClB;;AAEA;IACI,UAAU;IACV,WAAW;IACX,qBAAqB;AACzB","sourcesContent":[".root svg {\n    width: 100%;\n    height: auto;\n    display: block;\n}\n\n.isInline {\n    width: 1em;\n    height: 1em;\n    display: inline-block;\n}\n"],"sourceRoot":""}]);
// Exports
___CSS_LOADER_EXPORT___.locals = {
	"root": "SVG_root__xlZ0r",
	"isInline": "SVG_isInline__35vCN"
};
module.exports = ___CSS_LOADER_EXPORT___;


/***/ }),

/***/ "./node_modules/next/dist/compiled/css-loader/cjs.js?!./node_modules/next/dist/compiled/postcss-loader/cjs.js?!./theme/ShadowBox/ShadowBox.module.css":
/*!**********************************************************************************************************************************************!*\
  !*** (webpack)/css-loader/cjs.js??ref--5-oneOf-2-1!(webpack)/postcss-loader/cjs.js??ref--5-oneOf-2-2!./theme/ShadowBox/ShadowBox.module.css ***!
  \**********************************************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// Imports
var ___CSS_LOADER_API_IMPORT___ = __webpack_require__(/*! ../../node_modules/next/dist/compiled/css-loader/api.js */ "./node_modules/next/dist/compiled/css-loader/api.js");
var ___CSS_LOADER_EXPORT___ = ___CSS_LOADER_API_IMPORT___(true);
// Module
___CSS_LOADER_EXPORT___.push([module.i, ".ShadowBox_root__FzXHc {\n    position: fixed;\n    bottom: 0;\n    right: 0;\n    left: 0;\n    top: 0;\n    z-index: 9999;\n    transition: opacity 0.2s ease-in;\n    will-change: opacity;\n}\n\n.ShadowBox_shadow__2odoG {\n    position: absolute;\n    bottom: 0;\n    right: 0;\n    left: 0;\n    top: 0;\n    background-color: #000;\n    cursor: pointer;\n}\n\n.ShadowBox_header__1qO9f {\n    display: flex;\n    justify-content: space-between;\n    align-items: center;\n    position: sticky;\n    top: 0;\n    background-color: var(--c-bkg-light);\n    padding: var(--space-l);\n    z-index: 10\n}\n\n.ShadowBox_header__1qO9f::before {\n        content: '';\n        position: absolute;\n        top: 0;\n        left: 0;\n        right: 0;\n        bottom: 0;\n        background-color: var(--c-bkg-light);\n        z-index: -1;\n    }\n\n.ShadowBox_header__1qO9f::after {\n        content: '';\n        position: absolute;\n        left: 0;\n        bottom: 0;\n        width: 100%;\n        height: 2rem;\n        background: linear-gradient(\n                180deg,\n                rgba(189, 189, 189, 1) 0%,\n                rgba(0, 0, 0, 0) 100%\n        );\n        transition: transform 100ms ease-in;\n        will-change: transform;\n        transform: translateY(0);\n        z-index: -2;\n    }\n\n.ShadowBox_headerShadow__1_lKr::after {\n    transform: translateY(30%);\n}\n\n.ShadowBox_headerIos__ZUmEh ::after {\n    display: none;\n}\n\n.ShadowBox_title__3jEAl {\n    display: flex;\n    vertical-align: center;\n}\n\n.ShadowBox_close__3QSwh {\n    font-size: 1.5rem;\n}\n\n.ShadowBox_box__wg7mr {\n    position: absolute;\n    left: 50%;\n    top: 50%;\n    transform: translateX(-50%) translateY(-50%);\n    max-height: calc(100vh - (var(--space-l) * 2));\n    width: 900px;\n    max-width: calc(100vw - (var(--space-l) * 2));\n    background-color: var(--c-bkg-light);\n    transition: opacity 0.2s ease-in;\n    will-change: transform;\n    overflow: auto;\n}\n\n.ShadowBox_size-small__e2QeM .ShadowBox_box__wg7mr {\n    width: 500px;\n}\n\n.ShadowBox_content__3ZzgR {\n    padding: var(--space) var(--space-l) calc(var(--space-l) * 2) var(--space-l);\n}\n\n.ShadowBox_loader__2kPXS {\n    margin: 6vh auto 10vh auto;\n    font-size: 2rem;\n    width: 2rem;\n}\n\n.ShadowBox_box__wg7mr,\n.ShadowBox_shadow__2odoG {\n    opacity: 0;\n    will-change: opacity;\n    transition: all 200ms ease-in-out;\n}\n\n.ShadowBox_box__wg7mr {\n    transform: translateX(-50%) translateY(-30%) scale(0.9);\n}\n\n[data-visible='true'] .ShadowBox_box__wg7mr {\n    opacity: 1;\n    transform: translateX(-50%) translateY(-50%) scale(1);\n}\n\n[data-visible='true'] .ShadowBox_shadow__2odoG {\n    opacity: 0.7;\n}\n\n.ShadowBox_size-large__1iD5U {\n        @media (max-width: 700px) {\n    .ShadowBox_box__wg7mr {\n            width: 100%;\n            max-width: 100%;\n            bottom: 0;\n            top: 0;\n            max-height: 100vh;\n            height: auto;\n            transform: translateX(-50%) translateY(10%) scale(0.9)\n    }\n        }\n}\n\n.ShadowBox_size-large__1iD5U[data-visible='true'] {\n            @media (max-width: 700px) {\n        .ShadowBox_box__wg7mr {\n                transform: translateX(-50%) translateY(0) scale(1)\n        }\n            }\n    }\n", "",{"version":3,"sources":["webpack://theme/ShadowBox/ShadowBox.module.css"],"names":[],"mappings":"AAAA;IACI,eAAe;IACf,SAAS;IACT,QAAQ;IACR,OAAO;IACP,MAAM;IACN,aAAa;IACb,gCAAgC;IAChC,oBAAoB;AACxB;;AAEA;IACI,kBAAkB;IAClB,SAAS;IACT,QAAQ;IACR,OAAO;IACP,MAAM;IACN,sBAAsB;IACtB,eAAe;AACnB;;AAEA;IACI,aAAa;IACb,8BAA8B;IAC9B,mBAAmB;IACnB,gBAAgB;IAChB,MAAM;IACN,oCAAoC;IACpC,uBAAuB;IACvB;AA8BJ;;AA5BI;QACI,WAAW;QACX,kBAAkB;QAClB,MAAM;QACN,OAAO;QACP,QAAQ;QACR,SAAS;QACT,oCAAoC;QACpC,WAAW;IACf;;AAEA;QACI,WAAW;QACX,kBAAkB;QAClB,OAAO;QACP,SAAS;QACT,WAAW;QACX,YAAY;QACZ;;;;SAIC;QACD,mCAAmC;QACnC,sBAAsB;QACtB,wBAAwB;QACxB,WAAW;IACf;;AAGJ;IACI,0BAA0B;AAC9B;;AAEA;IACI,aAAa;AACjB;;AAEA;IACI,aAAa;IACb,sBAAsB;AAC1B;;AAEA;IACI,iBAAiB;AACrB;;AAEA;IACI,kBAAkB;IAClB,SAAS;IACT,QAAQ;IACR,4CAA4C;IAC5C,8CAA8C;IAC9C,YAAY;IACZ,6CAA6C;IAC7C,oCAAoC;IACpC,gCAAgC;IAChC,sBAAsB;IACtB,cAAc;AAClB;;AAEA;IACI,YAAY;AAChB;;AAEA;IACI,4EAA4E;AAChF;;AAEA;IACI,0BAA0B;IAC1B,eAAe;IACf,WAAW;AACf;;AAEA;;IAEI,UAAU;IACV,oBAAoB;IACpB,iCAAiC;AACrC;;AAEA;IACI,uDAAuD;AAC3D;;AAEA;IACI,UAAU;IACV,qDAAqD;AACzD;;AAEA;IACI,YAAY;AAChB;;AAEA;QAEQ;IADJ;YAEQ,WAAW;YACX,eAAe;YACf,SAAS;YACT,MAAM;YACN,iBAAiB;YACjB,YAAY;YACZ;IAER;QADI;AAUR;;AAPI;YAEQ;QADJ;gBAEQ;QAER;YADI;IAER","sourcesContent":[".root {\n    position: fixed;\n    bottom: 0;\n    right: 0;\n    left: 0;\n    top: 0;\n    z-index: 9999;\n    transition: opacity 0.2s ease-in;\n    will-change: opacity;\n}\n\n.shadow {\n    position: absolute;\n    bottom: 0;\n    right: 0;\n    left: 0;\n    top: 0;\n    background-color: #000;\n    cursor: pointer;\n}\n\n.header {\n    display: flex;\n    justify-content: space-between;\n    align-items: center;\n    position: sticky;\n    top: 0;\n    background-color: var(--c-bkg-light);\n    padding: var(--space-l);\n    z-index: 10;\n\n    &::before {\n        content: '';\n        position: absolute;\n        top: 0;\n        left: 0;\n        right: 0;\n        bottom: 0;\n        background-color: var(--c-bkg-light);\n        z-index: -1;\n    }\n\n    &::after {\n        content: '';\n        position: absolute;\n        left: 0;\n        bottom: 0;\n        width: 100%;\n        height: 2rem;\n        background: linear-gradient(\n                180deg,\n                rgba(189, 189, 189, 1) 0%,\n                rgba(0, 0, 0, 0) 100%\n        );\n        transition: transform 100ms ease-in;\n        will-change: transform;\n        transform: translateY(0);\n        z-index: -2;\n    }\n}\n\n.headerShadow::after {\n    transform: translateY(30%);\n}\n\n.headerIos ::after {\n    display: none;\n}\n\n.title {\n    display: flex;\n    vertical-align: center;\n}\n\n.close {\n    font-size: 1.5rem;\n}\n\n.box {\n    position: absolute;\n    left: 50%;\n    top: 50%;\n    transform: translateX(-50%) translateY(-50%);\n    max-height: calc(100vh - (var(--space-l) * 2));\n    width: 900px;\n    max-width: calc(100vw - (var(--space-l) * 2));\n    background-color: var(--c-bkg-light);\n    transition: opacity 0.2s ease-in;\n    will-change: transform;\n    overflow: auto;\n}\n\n.size-small .box {\n    width: 500px;\n}\n\n.content {\n    padding: var(--space) var(--space-l) calc(var(--space-l) * 2) var(--space-l);\n}\n\n.loader {\n    margin: 6vh auto 10vh auto;\n    font-size: 2rem;\n    width: 2rem;\n}\n\n.box,\n.shadow {\n    opacity: 0;\n    will-change: opacity;\n    transition: all 200ms ease-in-out;\n}\n\n.box {\n    transform: translateX(-50%) translateY(-30%) scale(0.9);\n}\n\n[data-visible='true'] .box {\n    opacity: 1;\n    transform: translateX(-50%) translateY(-50%) scale(1);\n}\n\n[data-visible='true'] .shadow {\n    opacity: 0.7;\n}\n\n.size-large {\n    .box {\n        @media (max-width: 700px) {\n            width: 100%;\n            max-width: 100%;\n            bottom: 0;\n            top: 0;\n            max-height: 100vh;\n            height: auto;\n            transform: translateX(-50%) translateY(10%) scale(0.9);\n        }\n    }\n\n    &[data-visible='true'] {\n        .box {\n            @media (max-width: 700px) {\n                transform: translateX(-50%) translateY(0) scale(1);\n            }\n        }\n    }\n}\n"],"sourceRoot":""}]);
// Exports
___CSS_LOADER_EXPORT___.locals = {
	"root": "ShadowBox_root__FzXHc",
	"shadow": "ShadowBox_shadow__2odoG",
	"header": "ShadowBox_header__1qO9f",
	"headerShadow": "ShadowBox_headerShadow__1_lKr",
	"headerIos": "ShadowBox_headerIos__ZUmEh",
	"title": "ShadowBox_title__3jEAl",
	"close": "ShadowBox_close__3QSwh",
	"box": "ShadowBox_box__wg7mr",
	"size-small": "ShadowBox_size-small__e2QeM",
	"content": "ShadowBox_content__3ZzgR",
	"loader": "ShadowBox_loader__2kPXS",
	"size-large": "ShadowBox_size-large__1iD5U"
};
module.exports = ___CSS_LOADER_EXPORT___;


/***/ }),

/***/ "./node_modules/next/dist/compiled/webpack/global.js":
/*!***********************************!*\
  !*** (webpack)/webpack/global.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports) {

/* WEBPACK VAR INJECTION */(function(__dirname) {module.exports =
/******/ (function() { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ 149:
/***/ (function(module) {

var g;

// This works in non-strict mode
g = (function() {
	return this;
})();

try {
	// This works if eval is allowed (see CSP)
	g = g || new Function("return this")();
} catch (e) {
	// This works if the window reference is available
	if (typeof window === "object") g = window;
}

// g can still be undefined, but nothing to do about it...
// We return undefined, instead of nothing here, so it's
// easier to handle this case. if(!global) { ...}

module.exports = g;


/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __nccwpck_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		if(__webpack_module_cache__[moduleId]) {
/******/ 			return __webpack_module_cache__[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		var threw = true;
/******/ 		try {
/******/ 			__webpack_modules__[moduleId](module, module.exports, __nccwpck_require__);
/******/ 			threw = false;
/******/ 		} finally {
/******/ 			if(threw) delete __webpack_module_cache__[moduleId];
/******/ 		}
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/compat */
/******/ 	
/******/ 	__nccwpck_require__.ab = __dirname + "/";/************************************************************************/
/******/ 	// module exports must be returned from runtime so entry inlining is disabled
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	return __nccwpck_require__(149);
/******/ })()
;
/* WEBPACK VAR INJECTION */}.call(this, "/"))

/***/ }),

/***/ "./node_modules/next/dist/compiled/webpack/harmony-module.js":
/*!*******************************************!*\
  !*** (webpack)/webpack/harmony-module.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/* WEBPACK VAR INJECTION */(function(__dirname) {module.exports =
/******/ (function() { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ 931:
/***/ (function(module) {

module.exports = function(originalModule) {
	if (!originalModule.webpackPolyfill) {
		var module = Object.create(originalModule);
		// module.parent = undefined by default
		if (!module.children) module.children = [];
		Object.defineProperty(module, "loaded", {
			enumerable: true,
			get: function() {
				return module.l;
			}
		});
		Object.defineProperty(module, "id", {
			enumerable: true,
			get: function() {
				return module.i;
			}
		});
		Object.defineProperty(module, "exports", {
			enumerable: true
		});
		module.webpackPolyfill = 1;
	}
	return module;
};


/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __nccwpck_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		if(__webpack_module_cache__[moduleId]) {
/******/ 			return __webpack_module_cache__[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		var threw = true;
/******/ 		try {
/******/ 			__webpack_modules__[moduleId](module, module.exports, __nccwpck_require__);
/******/ 			threw = false;
/******/ 		} finally {
/******/ 			if(threw) delete __webpack_module_cache__[moduleId];
/******/ 		}
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/compat */
/******/ 	
/******/ 	__nccwpck_require__.ab = __dirname + "/";/************************************************************************/
/******/ 	// module exports must be returned from runtime so entry inlining is disabled
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	return __nccwpck_require__(931);
/******/ })()
;
/* WEBPACK VAR INJECTION */}.call(this, "/"))

/***/ }),

/***/ "./node_modules/next/dist/compiled/webpack/module.js":
/*!***********************************!*\
  !*** (webpack)/webpack/module.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports) {

/* WEBPACK VAR INJECTION */(function(__dirname) {module.exports =
/******/ (function() { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ 880:
/***/ (function(module) {

module.exports = function(module) {
	if (!module.webpackPolyfill) {
		module.deprecate = function() {};
		module.paths = [];
		// module.parent = undefined by default
		if (!module.children) module.children = [];
		Object.defineProperty(module, "loaded", {
			enumerable: true,
			get: function() {
				return module.l;
			}
		});
		Object.defineProperty(module, "id", {
			enumerable: true,
			get: function() {
				return module.i;
			}
		});
		module.webpackPolyfill = 1;
	}
	return module;
};


/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __nccwpck_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		if(__webpack_module_cache__[moduleId]) {
/******/ 			return __webpack_module_cache__[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		var threw = true;
/******/ 		try {
/******/ 			__webpack_modules__[moduleId](module, module.exports, __nccwpck_require__);
/******/ 			threw = false;
/******/ 		} finally {
/******/ 			if(threw) delete __webpack_module_cache__[moduleId];
/******/ 		}
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/compat */
/******/ 	
/******/ 	__nccwpck_require__.ab = __dirname + "/";/************************************************************************/
/******/ 	// module exports must be returned from runtime so entry inlining is disabled
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	return __nccwpck_require__(880);
/******/ })()
;
/* WEBPACK VAR INJECTION */}.call(this, "/"))

/***/ }),

/***/ "./node_modules/next/dist/next-server/lib/amp-context.js":
/*!***************************************************************!*\
  !*** ./node_modules/next/dist/next-server/lib/amp-context.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(module) {

exports.__esModule = true;
exports.AmpStateContext = void 0;

var _react = _interopRequireDefault(__webpack_require__(/*! react */ "./node_modules/preact/compat/dist/compat.module.js"));

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    "default": obj
  };
}

var AmpStateContext = /*#__PURE__*/_react["default"].createContext({});

exports.AmpStateContext = AmpStateContext;

if (true) {
  AmpStateContext.displayName = 'AmpStateContext';
}

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.i);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../compiled/webpack/module.js */ "./node_modules/next/dist/compiled/webpack/module.js")(module)))

/***/ }),

/***/ "./node_modules/next/dist/next-server/lib/amp.js":
/*!*******************************************************!*\
  !*** ./node_modules/next/dist/next-server/lib/amp.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(module) {

var _s = $RefreshSig$();

exports.__esModule = true;
exports.isInAmpMode = isInAmpMode;
exports.useAmp = useAmp;

var _react = _interopRequireDefault(__webpack_require__(/*! react */ "./node_modules/preact/compat/dist/compat.module.js"));

var _ampContext = __webpack_require__(/*! ./amp-context */ "./node_modules/next/dist/next-server/lib/amp-context.js");

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    "default": obj
  };
}

function isInAmpMode() {
  var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
      _ref$ampFirst = _ref.ampFirst,
      ampFirst = _ref$ampFirst === void 0 ? false : _ref$ampFirst,
      _ref$hybrid = _ref.hybrid,
      hybrid = _ref$hybrid === void 0 ? false : _ref$hybrid,
      _ref$hasQuery = _ref.hasQuery,
      hasQuery = _ref$hasQuery === void 0 ? false : _ref$hasQuery;

  return ampFirst || hybrid && hasQuery;
}

function useAmp() {
  _s();

  // Don't assign the context value to a variable to save bytes
  return isInAmpMode(_react["default"].useContext(_ampContext.AmpStateContext));
}

_s(useAmp, "gDsCjeeItUuvgOWf1v4qoK9RF6k=");

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.i);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../compiled/webpack/module.js */ "./node_modules/next/dist/compiled/webpack/module.js")(module)))

/***/ }),

/***/ "./node_modules/next/dist/next-server/lib/head-manager-context.js":
/*!************************************************************************!*\
  !*** ./node_modules/next/dist/next-server/lib/head-manager-context.js ***!
  \************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(module) {

exports.__esModule = true;
exports.HeadManagerContext = void 0;

var _react = _interopRequireDefault(__webpack_require__(/*! react */ "./node_modules/preact/compat/dist/compat.module.js"));

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    "default": obj
  };
}

var HeadManagerContext = /*#__PURE__*/_react["default"].createContext({});

exports.HeadManagerContext = HeadManagerContext;

if (true) {
  HeadManagerContext.displayName = 'HeadManagerContext';
}

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.i);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../compiled/webpack/module.js */ "./node_modules/next/dist/compiled/webpack/module.js")(module)))

/***/ }),

/***/ "./node_modules/next/dist/next-server/lib/head.js":
/*!********************************************************!*\
  !*** ./node_modules/next/dist/next-server/lib/head.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(module) {

var _defineProperty = __webpack_require__(/*! ./node_modules/@babel/runtime/helpers/defineProperty */ "./node_modules/@babel/runtime/helpers/defineProperty.js");

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

exports.__esModule = true;
exports.defaultHead = defaultHead;
exports["default"] = void 0;

var _react = _interopRequireWildcard(__webpack_require__(/*! react */ "./node_modules/preact/compat/dist/compat.module.js"));

var _sideEffect = _interopRequireDefault(__webpack_require__(/*! ./side-effect */ "./node_modules/next/dist/next-server/lib/side-effect.js"));

var _ampContext = __webpack_require__(/*! ./amp-context */ "./node_modules/next/dist/next-server/lib/amp-context.js");

var _headManagerContext = __webpack_require__(/*! ./head-manager-context */ "./node_modules/next/dist/next-server/lib/head-manager-context.js");

var _amp = __webpack_require__(/*! ./amp */ "./node_modules/next/dist/next-server/lib/amp.js");

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    "default": obj
  };
}

function _getRequireWildcardCache() {
  if (typeof WeakMap !== "function") return null;
  var cache = new WeakMap();

  _getRequireWildcardCache = function _getRequireWildcardCache() {
    return cache;
  };

  return cache;
}

function _interopRequireWildcard(obj) {
  if (obj && obj.__esModule) {
    return obj;
  }

  if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
    return {
      "default": obj
    };
  }

  var cache = _getRequireWildcardCache();

  if (cache && cache.has(obj)) {
    return cache.get(obj);
  }

  var newObj = {};
  var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;

  for (var key in obj) {
    if (Object.prototype.hasOwnProperty.call(obj, key)) {
      var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;

      if (desc && (desc.get || desc.set)) {
        Object.defineProperty(newObj, key, desc);
      } else {
        newObj[key] = obj[key];
      }
    }
  }

  newObj["default"] = obj;

  if (cache) {
    cache.set(obj, newObj);
  }

  return newObj;
}

function defaultHead() {
  var inAmpMode = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
  var head = [/*#__PURE__*/_react["default"].createElement("meta", {
    charSet: "utf-8"
  })];

  if (!inAmpMode) {
    head.push( /*#__PURE__*/_react["default"].createElement("meta", {
      name: "viewport",
      content: "width=device-width"
    }));
  }

  return head;
}

function onlyReactElement(list, child) {
  // React children can be "string" or "number" in this case we ignore them for backwards compat
  if (typeof child === 'string' || typeof child === 'number') {
    return list;
  } // Adds support for React.Fragment


  if (child.type === _react["default"].Fragment) {
    return list.concat(_react["default"].Children.toArray(child.props.children).reduce(function (fragmentList, fragmentChild) {
      if (typeof fragmentChild === 'string' || typeof fragmentChild === 'number') {
        return fragmentList;
      }

      return fragmentList.concat(fragmentChild);
    }, []));
  }

  return list.concat(child);
}

var METATYPES = ['name', 'httpEquiv', 'charSet', 'itemProp'];
/*
returns a function for filtering head child elements
which shouldn't be duplicated, like <title/>
Also adds support for deduplicated `key` properties
*/

function unique() {
  var keys = new Set();
  var tags = new Set();
  var metaTypes = new Set();
  var metaCategories = {};
  return function (h) {
    var isUnique = true;
    var hasKey = false;

    if (h.key && typeof h.key !== 'number' && h.key.indexOf('$') > 0) {
      hasKey = true;
      var key = h.key.slice(h.key.indexOf('$') + 1);

      if (keys.has(key)) {
        isUnique = false;
      } else {
        keys.add(key);
      }
    } // eslint-disable-next-line default-case


    switch (h.type) {
      case 'title':
      case 'base':
        if (tags.has(h.type)) {
          isUnique = false;
        } else {
          tags.add(h.type);
        }

        break;

      case 'meta':
        for (var i = 0, len = METATYPES.length; i < len; i++) {
          var metatype = METATYPES[i];
          if (!h.props.hasOwnProperty(metatype)) continue;

          if (metatype === 'charSet') {
            if (metaTypes.has(metatype)) {
              isUnique = false;
            } else {
              metaTypes.add(metatype);
            }
          } else {
            var category = h.props[metatype];
            var categories = metaCategories[metatype] || new Set();

            if ((metatype !== 'name' || !hasKey) && categories.has(category)) {
              isUnique = false;
            } else {
              categories.add(category);
              metaCategories[metatype] = categories;
            }
          }
        }

        break;
    }

    return isUnique;
  };
}
/**
*
* @param headElements List of multiple <Head> instances
*/


function reduceComponents(headElements, props) {
  return headElements.reduce(function (list, headElement) {
    var headElementChildren = _react["default"].Children.toArray(headElement.props.children);

    return list.concat(headElementChildren);
  }, []).reduce(onlyReactElement, []).reverse().concat(defaultHead(props.inAmpMode)).filter(unique()).reverse().map(function (c, i) {
    var key = c.key || i;

    if (false) { var newProps; }

    return /*#__PURE__*/_react["default"].cloneElement(c, {
      key: key
    });
  });
}
/**
* This component injects elements to `<head>` of your page.
* To avoid duplicated `tags` in `<head>` you can use the `key` property, which will make sure every tag is only rendered once.
*/


function Head(_ref) {
  var children = _ref.children;
  var ampState = (0, _react.useContext)(_ampContext.AmpStateContext);
  var headManager = (0, _react.useContext)(_headManagerContext.HeadManagerContext);
  return /*#__PURE__*/_react["default"].createElement(_sideEffect["default"], {
    reduceComponentsToState: reduceComponents,
    headManager: headManager,
    inAmpMode: (0, _amp.isInAmpMode)(ampState)
  }, children);
} // TODO: Remove in the next major release


_c = Head;

Head.rewind = function () {};

var _default = Head;
exports["default"] = _default;

var _c;

$RefreshReg$(_c, "Head");

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.i);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../compiled/webpack/module.js */ "./node_modules/next/dist/compiled/webpack/module.js")(module)))

/***/ }),

/***/ "./node_modules/next/dist/next-server/lib/i18n/normalize-locale-path.js":
/*!******************************************************************************!*\
  !*** ./node_modules/next/dist/next-server/lib/i18n/normalize-locale-path.js ***!
  \******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(module) {

exports.__esModule = true;
exports.normalizeLocalePath = normalizeLocalePath;

function normalizeLocalePath(pathname, locales) {
  var detectedLocale; // first item will be empty string from splitting at first char

  var pathnameParts = pathname.split('/');
  (locales || []).some(function (locale) {
    if (pathnameParts[1].toLowerCase() === locale.toLowerCase()) {
      detectedLocale = locale;
      pathnameParts.splice(1, 1);
      pathname = pathnameParts.join('/') || '/';
      return true;
    }

    return false;
  });
  return {
    pathname: pathname,
    detectedLocale: detectedLocale
  };
}

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.i);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../compiled/webpack/module.js */ "./node_modules/next/dist/compiled/webpack/module.js")(module)))

/***/ }),

/***/ "./node_modules/next/dist/next-server/lib/mitt.js":
/*!********************************************************!*\
  !*** ./node_modules/next/dist/next-server/lib/mitt.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(module) {

exports.__esModule = true;
exports["default"] = mitt;
/*
MIT License
Copyright (c) Jason Miller (https://jasonformat.com/)
Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:
The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.
THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
*/
// This file is based on https://github.com/developit/mitt/blob/v1.1.3/src/index.js
// It's been edited for the needs of this script
// See the LICENSE at the top of the file

function mitt() {
  var all = Object.create(null);
  return {
    on: function on(type, handler) {
      ;
      (all[type] || (all[type] = [])).push(handler);
    },
    off: function off(type, handler) {
      if (all[type]) {
        all[type].splice(all[type].indexOf(handler) >>> 0, 1);
      }
    },
    emit: function emit(type) {
      for (var _len = arguments.length, evts = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        evts[_key - 1] = arguments[_key];
      }

      // eslint-disable-next-line array-callback-return
      ;
      (all[type] || []).slice().map(function (handler) {
        handler.apply(void 0, evts);
      });
    }
  };
}

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.i);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../compiled/webpack/module.js */ "./node_modules/next/dist/compiled/webpack/module.js")(module)))

/***/ }),

/***/ "./node_modules/next/dist/next-server/lib/router-context.js":
/*!******************************************************************!*\
  !*** ./node_modules/next/dist/next-server/lib/router-context.js ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(module) {

exports.__esModule = true;
exports.RouterContext = void 0;

var _react = _interopRequireDefault(__webpack_require__(/*! react */ "./node_modules/preact/compat/dist/compat.module.js"));

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    "default": obj
  };
}

var RouterContext = /*#__PURE__*/_react["default"].createContext(null);

exports.RouterContext = RouterContext;

if (true) {
  RouterContext.displayName = 'RouterContext';
}

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.i);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../compiled/webpack/module.js */ "./node_modules/next/dist/compiled/webpack/module.js")(module)))

/***/ }),

/***/ "./node_modules/next/dist/next-server/lib/router/router.js":
/*!*****************************************************************!*\
  !*** ./node_modules/next/dist/next-server/lib/router/router.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(module) {

var _regeneratorRuntime = __webpack_require__(/*! ./node_modules/@babel/runtime/regenerator */ "./node_modules/@babel/runtime/regenerator/index.js");

var _asyncToGenerator = __webpack_require__(/*! ./node_modules/@babel/runtime/helpers/asyncToGenerator */ "./node_modules/@babel/runtime/helpers/asyncToGenerator.js");

var _classCallCheck = __webpack_require__(/*! ./node_modules/@babel/runtime/helpers/classCallCheck */ "./node_modules/@babel/runtime/helpers/classCallCheck.js");

var _createClass = __webpack_require__(/*! ./node_modules/@babel/runtime/helpers/createClass */ "./node_modules/@babel/runtime/helpers/createClass.js");

var _slicedToArray = __webpack_require__(/*! ./node_modules/@babel/runtime/helpers/slicedToArray */ "./node_modules/@babel/runtime/helpers/slicedToArray.js");

exports.__esModule = true;
exports.getDomainLocale = getDomainLocale;
exports.addLocale = addLocale;
exports.delLocale = delLocale;
exports.hasBasePath = hasBasePath;
exports.addBasePath = addBasePath;
exports.delBasePath = delBasePath;
exports.isLocalURL = isLocalURL;
exports.interpolateAs = interpolateAs;
exports.resolveHref = resolveHref;
exports["default"] = void 0;

var _normalizeTrailingSlash = __webpack_require__(/*! ../../../client/normalize-trailing-slash */ "./node_modules/next/dist/client/normalize-trailing-slash.js");

var _routeLoader = __webpack_require__(/*! ../../../client/route-loader */ "./node_modules/next/dist/client/route-loader.js");

var _denormalizePagePath = __webpack_require__(/*! ../../server/denormalize-page-path */ "./node_modules/next/dist/next-server/server/denormalize-page-path.js");

var _normalizeLocalePath = __webpack_require__(/*! ../i18n/normalize-locale-path */ "./node_modules/next/dist/next-server/lib/i18n/normalize-locale-path.js");

var _mitt = _interopRequireDefault(__webpack_require__(/*! ../mitt */ "./node_modules/next/dist/next-server/lib/mitt.js"));

var _utils = __webpack_require__(/*! ../utils */ "./node_modules/next/dist/next-server/lib/utils.js");

var _isDynamic = __webpack_require__(/*! ./utils/is-dynamic */ "./node_modules/next/dist/next-server/lib/router/utils/is-dynamic.js");

var _parseRelativeUrl = __webpack_require__(/*! ./utils/parse-relative-url */ "./node_modules/next/dist/next-server/lib/router/utils/parse-relative-url.js");

var _querystring = __webpack_require__(/*! ./utils/querystring */ "./node_modules/next/dist/next-server/lib/router/utils/querystring.js");

var _resolveRewrites = _interopRequireDefault(__webpack_require__(/*! ./utils/resolve-rewrites */ "./node_modules/next/dist/next-server/lib/router/utils/resolve-rewrites-noop.js"));

var _routeMatcher = __webpack_require__(/*! ./utils/route-matcher */ "./node_modules/next/dist/next-server/lib/router/utils/route-matcher.js");

var _routeRegex = __webpack_require__(/*! ./utils/route-regex */ "./node_modules/next/dist/next-server/lib/router/utils/route-regex.js");

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    "default": obj
  };
} // tslint:disable:no-console


var detectDomainLocale;

if (false) {}

var basePath =  false || '';

function buildCancellationError() {
  return Object.assign(new Error('Route Cancelled'), {
    cancelled: true
  });
}

function addPathPrefix(path, prefix) {
  return prefix && path.startsWith('/') ? path === '/' ? (0, _normalizeTrailingSlash.normalizePathTrailingSlash)(prefix) : "".concat(prefix).concat(pathNoQueryHash(path) === '/' ? path.substring(1) : path) : path;
}

function getDomainLocale(path, locale, locales, domainLocales) {
  if (false) { var detectedDomain; }

  return false;
}

function addLocale(path, locale, defaultLocale) {
  if (false) { var localeLower, pathLower, pathname; }

  return path;
}

function delLocale(path, locale) {
  if (false) { var localeLower, pathLower, pathname; }

  return path;
}

function pathNoQueryHash(path) {
  var queryIndex = path.indexOf('?');
  var hashIndex = path.indexOf('#');

  if (queryIndex > -1 || hashIndex > -1) {
    path = path.substring(0, queryIndex > -1 ? queryIndex : hashIndex);
  }

  return path;
}

function hasBasePath(path) {
  path = pathNoQueryHash(path);
  return path === basePath || path.startsWith(basePath + '/');
}

function addBasePath(path) {
  // we only add the basepath on relative urls
  return addPathPrefix(path, basePath);
}

function delBasePath(path) {
  path = path.slice(basePath.length);
  if (!path.startsWith('/')) path = "/".concat(path);
  return path;
}
/**
* Detects whether a given url is routable by the Next.js router (browser only).
*/


function isLocalURL(url) {
  // prevent a hydration mismatch on href for url with anchor refs
  if (url.startsWith('/') || url.startsWith('#')) return true;

  try {
    // absolute urls can be local if they are on the same origin
    var locationOrigin = (0, _utils.getLocationOrigin)();
    var resolved = new URL(url, locationOrigin);
    return resolved.origin === locationOrigin && hasBasePath(resolved.pathname);
  } catch (_) {
    return false;
  }
}

function interpolateAs(route, asPathname, query) {
  var interpolatedRoute = '';
  var dynamicRegex = (0, _routeRegex.getRouteRegex)(route);
  var dynamicGroups = dynamicRegex.groups;
  var dynamicMatches = // Try to match the dynamic route against the asPath
  (asPathname !== route ? (0, _routeMatcher.getRouteMatcher)(dynamicRegex)(asPathname) : '') || // Fall back to reading the values from the href
  // TODO: should this take priority; also need to change in the router.
  query;
  interpolatedRoute = route;
  var params = Object.keys(dynamicGroups);

  if (!params.every(function (param) {
    var value = dynamicMatches[param] || '';
    var _dynamicGroups$param = dynamicGroups[param],
        repeat = _dynamicGroups$param.repeat,
        optional = _dynamicGroups$param.optional; // support single-level catch-all
    // TODO: more robust handling for user-error (passing `/`)

    var replaced = "[".concat(repeat ? '...' : '').concat(param, "]");

    if (optional) {
      replaced = "".concat(!value ? '/' : '', "[").concat(replaced, "]");
    }

    if (repeat && !Array.isArray(value)) value = [value];
    return (optional || param in dynamicMatches) && ( // Interpolate group into data URL if present
    interpolatedRoute = interpolatedRoute.replace(replaced, repeat ? value.map( // these values should be fully encoded instead of just
    // path delimiter escaped since they are being inserted
    // into the URL and we expect URL encoded segments
    // when parsing dynamic route params
    function (segment) {
      return encodeURIComponent(segment);
    }).join('/') : encodeURIComponent(value)) || '/');
  })) {
    interpolatedRoute = ''; // did not satisfy all requirements
    // n.b. We ignore this error because we handle warning for this case in
    // development in the `<Link>` component directly.
  }

  return {
    params: params,
    result: interpolatedRoute
  };
}

function omitParmsFromQuery(query, params) {
  var filteredQuery = {};
  Object.keys(query).forEach(function (key) {
    if (!params.includes(key)) {
      filteredQuery[key] = query[key];
    }
  });
  return filteredQuery;
}
/**
* Resolves a given hyperlink with a certain router state (basePath not included).
* Preserves absolute urls.
*/


function resolveHref(currentPath, href, resolveAs) {
  // we use a dummy base url for relative urls
  var base;

  try {
    base = new URL(currentPath, 'http://n');
  } catch (_) {
    // fallback to / for invalid asPath values e.g. //
    base = new URL('/', 'http://n');
  }

  var urlAsString = typeof href === 'string' ? href : (0, _utils.formatWithValidation)(href); // Return because it cannot be routed by the Next.js router

  if (!isLocalURL(urlAsString)) {
    return resolveAs ? [urlAsString] : urlAsString;
  }

  try {
    var finalUrl = new URL(urlAsString, base);
    finalUrl.pathname = (0, _normalizeTrailingSlash.normalizePathTrailingSlash)(finalUrl.pathname);
    var interpolatedAs = '';

    if ((0, _isDynamic.isDynamicRoute)(finalUrl.pathname) && finalUrl.searchParams && resolveAs) {
      var query = (0, _querystring.searchParamsToUrlQuery)(finalUrl.searchParams);

      var _interpolateAs = interpolateAs(finalUrl.pathname, finalUrl.pathname, query),
          result = _interpolateAs.result,
          params = _interpolateAs.params;

      if (result) {
        interpolatedAs = (0, _utils.formatWithValidation)({
          pathname: result,
          hash: finalUrl.hash,
          query: omitParmsFromQuery(query, params)
        });
      }
    } // if the origin didn't change, it means we received a relative href


    var resolvedHref = finalUrl.origin === base.origin ? finalUrl.href.slice(finalUrl.origin.length) : finalUrl.href;
    return resolveAs ? [resolvedHref, interpolatedAs || resolvedHref] : resolvedHref;
  } catch (_) {
    return resolveAs ? [urlAsString] : urlAsString;
  }
}

function stripOrigin(url) {
  var origin = (0, _utils.getLocationOrigin)();
  return url.startsWith(origin) ? url.substring(origin.length) : url;
}

function prepareUrlAs(router, url, as) {
  // If url and as provided as an object representation,
  // we'll format them into the string version here.
  var _resolveHref = resolveHref(router.asPath, url, true),
      _resolveHref2 = _slicedToArray(_resolveHref, 2),
      resolvedHref = _resolveHref2[0],
      resolvedAs = _resolveHref2[1];

  var origin = (0, _utils.getLocationOrigin)();
  var hrefHadOrigin = resolvedHref.startsWith(origin);
  var asHadOrigin = resolvedAs && resolvedAs.startsWith(origin);
  resolvedHref = stripOrigin(resolvedHref);
  resolvedAs = resolvedAs ? stripOrigin(resolvedAs) : resolvedAs;
  var preparedUrl = hrefHadOrigin ? resolvedHref : addBasePath(resolvedHref);
  var preparedAs = as ? stripOrigin(resolveHref(router.asPath, as)) : resolvedAs || resolvedHref;
  return {
    url: preparedUrl,
    as: asHadOrigin ? preparedAs : addBasePath(preparedAs)
  };
}

function resolveDynamicRoute(pathname, pages) {
  var cleanPathname = (0, _normalizeTrailingSlash.removePathTrailingSlash)((0, _denormalizePagePath.denormalizePagePath)(pathname));

  if (cleanPathname === '/404' || cleanPathname === '/_error') {
    return pathname;
  } // handle resolving href for dynamic routes


  if (!pages.includes(cleanPathname)) {
    // eslint-disable-next-line array-callback-return
    pages.some(function (page) {
      if ((0, _isDynamic.isDynamicRoute)(page) && (0, _routeRegex.getRouteRegex)(page).re.test(cleanPathname)) {
        pathname = page;
        return true;
      }
    });
  }

  return (0, _normalizeTrailingSlash.removePathTrailingSlash)(pathname);
}

var manualScrollRestoration =  false && false;
var SSG_DATA_NOT_FOUND = Symbol('SSG_DATA_NOT_FOUND');

function fetchRetry(url, attempts) {
  return fetch(url, {
    // Cookies are required to be present for Next.js' SSG "Preview Mode".
    // Cookies may also be required for `getServerSideProps`.
    //
    // > `fetch` wont send cookies, unless you set the credentials init
    // > option.
    // https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API/Using_Fetch
    //
    // > For maximum browser compatibility when it comes to sending &
    // > receiving cookies, always supply the `credentials: 'same-origin'`
    // > option instead of relying on the default.
    // https://github.com/github/fetch#caveats
    credentials: 'same-origin'
  }).then(function (res) {
    if (!res.ok) {
      if (attempts > 1 && res.status >= 500) {
        return fetchRetry(url, attempts - 1);
      }

      if (res.status === 404) {
        return res.json().then(function (data) {
          if (data.notFound) {
            return {
              notFound: SSG_DATA_NOT_FOUND
            };
          }

          throw new Error("Failed to load static props");
        });
      }

      throw new Error("Failed to load static props");
    }

    return res.json();
  });
}

function fetchNextData(dataHref, isServerRender) {
  return fetchRetry(dataHref, isServerRender ? 3 : 1)["catch"](function (err) {
    // We should only trigger a server-side transition if this was caused
    // on a client-side transition. Otherwise, we'd get into an infinite
    // loop.
    if (!isServerRender) {
      (0, _routeLoader.markAssetError)(err);
    }

    throw err;
  });
}

var Router = /*#__PURE__*/function () {
  /**
  * Map of all components loaded in `Router`
  */
  // Static Data Cache
  // In-flight Server Data Requests, for deduping
  function Router(_pathname, _query, _as, _ref) {
    var _this = this;

    var initialProps = _ref.initialProps,
        pageLoader = _ref.pageLoader,
        App = _ref.App,
        wrapApp = _ref.wrapApp,
        Component = _ref.Component,
        err = _ref.err,
        subscription = _ref.subscription,
        isFallback = _ref.isFallback,
        locale = _ref.locale,
        locales = _ref.locales,
        defaultLocale = _ref.defaultLocale,
        domainLocales = _ref.domainLocales,
        isPreview = _ref.isPreview;

    _classCallCheck(this, Router);

    this.route = void 0;
    this.pathname = void 0;
    this.query = void 0;
    this.asPath = void 0;
    this.basePath = void 0;
    this.components = void 0;
    this.sdc = {};
    this.sdr = {};
    this.sub = void 0;
    this.clc = void 0;
    this.pageLoader = void 0;
    this._bps = void 0;
    this.events = void 0;
    this._wrapApp = void 0;
    this.isSsr = void 0;
    this.isFallback = void 0;
    this._inFlightRoute = void 0;
    this._shallow = void 0;
    this.locale = void 0;
    this.locales = void 0;
    this.defaultLocale = void 0;
    this.domainLocales = void 0;
    this.isReady = void 0;
    this.isPreview = void 0;
    this.isLocaleDomain = void 0;
    this._idx = 0;

    this.onPopState = function (e) {
      var state = e.state;

      if (!state) {
        // We get state as undefined for two reasons.
        //  1. With older safari (< 8) and older chrome (< 34)
        //  2. When the URL changed with #
        //
        // In the both cases, we don't need to proceed and change the route.
        // (as it's already changed)
        // But we can simply replace the state with the new changes.
        // Actually, for (1) we don't need to nothing. But it's hard to detect that event.
        // So, doing the following for (1) does no harm.
        var _pathname2 = _this.pathname,
            query = _this.query;

        _this.changeState('replaceState', (0, _utils.formatWithValidation)({
          pathname: addBasePath(_pathname2),
          query: query
        }), (0, _utils.getURL)());

        return;
      }

      if (!state.__N) {
        return;
      }

      var forcedScroll;
      var url = state.url,
          as = state.as,
          options = state.options,
          idx = state.idx;

      if (false) { var v; }

      _this._idx = idx;

      var _ref2 = (0, _parseRelativeUrl.parseRelativeUrl)(url),
          pathname = _ref2.pathname; // Make sure we don't re-render on initial load,
      // can be caused by navigating back from an external site


      if (_this.isSsr && as === _this.asPath && pathname === _this.pathname) {
        return;
      } // If the downstream application returns falsy, return.
      // They will then be responsible for handling the event.


      if (_this._bps && !_this._bps(state)) {
        return;
      }

      _this.change('replaceState', url, as, Object.assign({}, options, {
        shallow: options.shallow && _this._shallow,
        locale: options.locale || _this.defaultLocale
      }), forcedScroll);
    }; // represents the current component key


    this.route = (0, _normalizeTrailingSlash.removePathTrailingSlash)(_pathname); // set up the component cache (by route keys)

    this.components = {}; // We should not keep the cache, if there's an error
    // Otherwise, this cause issues when when going back and
    // come again to the errored page.

    if (_pathname !== '/_error') {
      this.components[this.route] = {
        Component: Component,
        initial: true,
        props: initialProps,
        err: err,
        __N_SSG: initialProps && initialProps.__N_SSG,
        __N_SSP: initialProps && initialProps.__N_SSP
      };
    }

    this.components['/_app'] = {
      Component: App,
      styleSheets: [
        /* /_app does not need its stylesheets managed */
      ]
    }; // Backwards compat for Router.router.events
    // TODO: Should be remove the following major version as it was never documented

    this.events = Router.events;
    this.pageLoader = pageLoader;
    this.pathname = _pathname;
    this.query = _query; // if auto prerendered and dynamic route wait to update asPath
    // until after mount to prevent hydration mismatch

    var autoExportDynamic = (0, _isDynamic.isDynamicRoute)(_pathname) && self.__NEXT_DATA__.autoExport;

    this.asPath = autoExportDynamic ? _pathname : _as;
    this.basePath = basePath;
    this.sub = subscription;
    this.clc = null;
    this._wrapApp = wrapApp; // make sure to ignore extra popState in safari on navigating
    // back from external site

    this.isSsr = true;
    this.isFallback = isFallback;
    this.isReady = !!(self.__NEXT_DATA__.gssp || self.__NEXT_DATA__.gip || !autoExportDynamic && !self.location.search && !false);
    this.isPreview = !!isPreview;
    this.isLocaleDomain = false;

    if (false) {}

    if (true) {
      // make sure "as" doesn't start with double slashes or else it can
      // throw an error as it's considered invalid
      if (_as.substr(0, 2) !== '//') {
        // in order for `e.state` to work on the `onpopstate` event
        // we have to register the initial route upon initialization
        this.changeState('replaceState', (0, _utils.formatWithValidation)({
          pathname: addBasePath(_pathname),
          query: _query
        }), (0, _utils.getURL)(), {
          locale: locale
        });
      }

      window.addEventListener('popstate', this.onPopState); // enable custom scroll restoration handling when available
      // otherwise fallback to browser's default handling

      if (false) {}
    }
  }

  _createClass(Router, [{
    key: "reload",
    value: function reload() {
      window.location.reload();
    }
    /**
    * Go back in history
    */

  }, {
    key: "back",
    value: function back() {
      window.history.back();
    }
    /**
    * Performs a `pushState` with arguments
    * @param url of the route
    * @param as masks `url` for the browser
    * @param options object you can define `shallow` and other options
    */

  }, {
    key: "push",
    value: function push(url, as) {
      var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

      if (false) {}

      ;

      var _prepareUrlAs = prepareUrlAs(this, url, as);

      url = _prepareUrlAs.url;
      as = _prepareUrlAs.as;
      return this.change('pushState', url, as, options);
    }
    /**
    * Performs a `replaceState` with arguments
    * @param url of the route
    * @param as masks `url` for the browser
    * @param options object you can define `shallow` and other options
    */

  }, {
    key: "replace",
    value: function replace(url, as) {
      var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
      ;

      var _prepareUrlAs2 = prepareUrlAs(this, url, as);

      url = _prepareUrlAs2.url;
      as = _prepareUrlAs2.as;
      return this.change('replaceState', url, as, options);
    }
  }, {
    key: "change",
    value: function () {
      var _change = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(method, url, as, options, forcedScroll) {
        var _options$scroll, shouldResolveHref, localeChange, parsedAs, localePathResult, didNavigate, _this$locales, detectedDomain, asNoBasePath, _options$shallow, shallow, routeProps, cleanedAs, parsed, pathname, query, pages, rewrites, _yield, resolvedAs, rewritesResult, route, _parsedAs, asPathname, routeRegex, routeMatch, shouldInterpolate, interpolatedAs, missingParams, _self$__NEXT_DATA__$p, _self$__NEXT_DATA__$p2, routeInfo, _routeInfo, error, props, __N_SSG, __N_SSP, destination, parsedHref, _prepareUrlAs3, newUrl, newAs, notFoundRoute, appComp, isValidShallowRoute;

        return _regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                if (isLocalURL(url)) {
                  _context.next = 3;
                  break;
                }

                window.location.href = url;
                return _context.abrupt("return", false);

              case 3:
                shouldResolveHref = url === as || options._h; // for static pages with query params in the URL we delay
                // marking the router ready until after the query is updated

                if (options._h) {
                  this.isReady = true;
                } // Default to scroll reset behavior unless explicitly specified to be
                // `false`! This makes the behavior between using `Router#push` and a
                // `<Link />` consistent.


                options.scroll = !!((_options$scroll = options.scroll) != null ? _options$scroll : true);
                localeChange = options.locale !== this.locale;

                if (true) {
                  _context.next = 19;
                  break;
                }

                this.locale = options.locale === false ? this.defaultLocale : options.locale || this.locale;

                if (typeof options.locale === 'undefined') {
                  options.locale = this.locale;
                }

                parsedAs = (0, _parseRelativeUrl.parseRelativeUrl)(hasBasePath(as) ? delBasePath(as) : as);
                localePathResult = (0, _normalizeLocalePath.normalizeLocalePath)(parsedAs.pathname, this.locales);

                if (localePathResult.detectedLocale) {
                  this.locale = localePathResult.detectedLocale;
                  parsedAs.pathname = addBasePath(parsedAs.pathname);
                  as = (0, _utils.formatWithValidation)(parsedAs);
                  url = addBasePath((0, _normalizeLocalePath.normalizeLocalePath)(hasBasePath(url) ? delBasePath(url) : url, this.locales).pathname);
                }

                didNavigate = false; // we need to wrap this in the env check again since regenerator runtime
                // moves this on its own due to the return

                if (false) {}

                detectedDomain = detectDomainLocale(this.domainLocales, undefined, this.locale); // we need to wrap this in the env check again since regenerator runtime
                // moves this on its own due to the return

                if (false) {}

                if (!didNavigate) {
                  _context.next = 19;
                  break;
                }

                return _context.abrupt("return", new Promise(function () {}));

              case 19:
                if (!options._h) {
                  this.isSsr = false;
                } // marking route changes as a navigation start entry


                if (_utils.ST) {
                  performance.mark('routeChange');
                }

                _options$shallow = options.shallow, shallow = _options$shallow === void 0 ? false : _options$shallow;
                routeProps = {
                  shallow: shallow
                };

                if (this._inFlightRoute) {
                  this.abortComponentLoad(this._inFlightRoute, routeProps);
                }

                as = addBasePath(addLocale(hasBasePath(as) ? delBasePath(as) : as, options.locale, this.defaultLocale));
                cleanedAs = delLocale(hasBasePath(as) ? delBasePath(as) : as, this.locale);
                this._inFlightRoute = as; // If the url change is only related to a hash change
                // We should not proceed. We should only change the state.
                // WARNING: `_h` is an internal option for handing Next.js client-side
                // hydration. Your app should _never_ use this property. It may change at
                // any time without notice.

                if (!(!options._h && this.onlyAHashChange(cleanedAs))) {
                  _context.next = 35;
                  break;
                }

                this.asPath = cleanedAs;
                Router.events.emit('hashChangeStart', as, routeProps); // TODO: do we need the resolved href when only a hash change?

                this.changeState(method, url, as, options);
                this.scrollToHash(cleanedAs);
                this.notify(this.components[this.route], null);
                Router.events.emit('hashChangeComplete', as, routeProps);
                return _context.abrupt("return", true);

              case 35:
                parsed = (0, _parseRelativeUrl.parseRelativeUrl)(url);
                pathname = parsed.pathname, query = parsed.query; // The build manifest needs to be loaded before auto-static dynamic pages
                // get their query parameters to allow ensuring they can be parsed properly
                // when rewritten to

                _context.prev = 37;
                _context.next = 40;
                return this.pageLoader.getPageList();

              case 40:
                pages = _context.sent;
                _context.next = 43;
                return (0, _routeLoader.getClientBuildManifest)();

              case 43:
                _yield = _context.sent;
                rewrites = _yield.__rewrites;
                _context.next = 51;
                break;

              case 47:
                _context.prev = 47;
                _context.t0 = _context["catch"](37);
                // If we fail to resolve the page list or client-build manifest, we must
                // do a server-side transition:
                window.location.href = as;
                return _context.abrupt("return", false);

              case 51:
                // If asked to change the current URL we should reload the current page
                // (not location.reload() but reload getInitialProps and other Next.js stuffs)
                // We also need to set the method = replaceState always
                // as this should not go into the history (That's how browsers work)
                // We should compare the new asPath to the current asPath, not the url
                if (!this.urlIsNew(cleanedAs) && !localeChange) {
                  method = 'replaceState';
                } // we need to resolve the as value using rewrites for dynamic SSG
                // pages to allow building the data URL correctly


                resolvedAs = as; // url and as should always be prefixed with basePath by this
                // point by either next/link or router.push/replace so strip the
                // basePath from the pathname to match the pages dir 1-to-1

                pathname = pathname ? (0, _normalizeTrailingSlash.removePathTrailingSlash)(delBasePath(pathname)) : pathname;

                if (shouldResolveHref && pathname !== '/_error') {
                  if (false) {} else {
                    parsed.pathname = resolveDynamicRoute(pathname, pages);

                    if (parsed.pathname !== pathname) {
                      pathname = parsed.pathname;
                      url = (0, _utils.formatWithValidation)(parsed);
                    }
                  }
                }

                route = (0, _normalizeTrailingSlash.removePathTrailingSlash)(pathname);

                if (isLocalURL(as)) {
                  _context.next = 61;
                  break;
                }

                if (false) {}

                throw new Error("Invalid href: \"".concat(url, "\" and as: \"").concat(as, "\", received relative href and external as") + "\nSee more info: https://nextjs.org/docs/messages/invalid-relative-url-external-as");

              case 59:
                window.location.href = as;
                return _context.abrupt("return", false);

              case 61:
                resolvedAs = delLocale(delBasePath(resolvedAs), this.locale);

                if (!(0, _isDynamic.isDynamicRoute)(route)) {
                  _context.next = 77;
                  break;
                }

                _parsedAs = (0, _parseRelativeUrl.parseRelativeUrl)(resolvedAs);
                asPathname = _parsedAs.pathname;
                routeRegex = (0, _routeRegex.getRouteRegex)(route);
                routeMatch = (0, _routeMatcher.getRouteMatcher)(routeRegex)(asPathname);
                shouldInterpolate = route === asPathname;
                interpolatedAs = shouldInterpolate ? interpolateAs(route, asPathname, query) : {};

                if (!(!routeMatch || shouldInterpolate && !interpolatedAs.result)) {
                  _context.next = 76;
                  break;
                }

                missingParams = Object.keys(routeRegex.groups).filter(function (param) {
                  return !query[param];
                });

                if (!(missingParams.length > 0)) {
                  _context.next = 74;
                  break;
                }

                if (true) {
                  console.warn("".concat(shouldInterpolate ? "Interpolating href" : "Mismatching `as` and `href`", " failed to manually provide ") + "the params: ".concat(missingParams.join(', '), " in the `href`'s `query`"));
                }

                throw new Error((shouldInterpolate ? "The provided `href` (".concat(url, ") value is missing query values (").concat(missingParams.join(', '), ") to be interpolated properly. ") : "The provided `as` value (".concat(asPathname, ") is incompatible with the `href` value (").concat(route, "). ")) + "Read more: https://nextjs.org/docs/messages/".concat(shouldInterpolate ? 'href-interpolation-failed' : 'incompatible-href-as'));

              case 74:
                _context.next = 77;
                break;

              case 76:
                if (shouldInterpolate) {
                  as = (0, _utils.formatWithValidation)(Object.assign({}, _parsedAs, {
                    pathname: interpolatedAs.result,
                    query: omitParmsFromQuery(query, interpolatedAs.params)
                  }));
                } else {
                  // Merge params into `query`, overwriting any specified in search
                  Object.assign(query, routeMatch);
                }

              case 77:
                Router.events.emit('routeChangeStart', as, routeProps);
                _context.prev = 78;
                _context.next = 81;
                return this.getRouteInfo(route, pathname, query, as, resolvedAs, routeProps);

              case 81:
                routeInfo = _context.sent;
                _routeInfo = routeInfo, error = _routeInfo.error, props = _routeInfo.props, __N_SSG = _routeInfo.__N_SSG, __N_SSP = _routeInfo.__N_SSP; // handle redirect on client-transition

                if (!((__N_SSG || __N_SSP) && props)) {
                  _context.next = 108;
                  break;
                }

                if (!(props.pageProps && props.pageProps.__N_REDIRECT)) {
                  _context.next = 94;
                  break;
                }

                destination = props.pageProps.__N_REDIRECT; // check if destination is internal (resolves to a page) and attempt
                // client-navigation if it is falling back to hard navigation if
                // it's not

                if (!destination.startsWith('/')) {
                  _context.next = 92;
                  break;
                }

                parsedHref = (0, _parseRelativeUrl.parseRelativeUrl)(destination);
                parsedHref.pathname = resolveDynamicRoute(parsedHref.pathname, pages);

                if (!pages.includes(parsedHref.pathname)) {
                  _context.next = 92;
                  break;
                }

                _prepareUrlAs3 = prepareUrlAs(this, destination, destination), newUrl = _prepareUrlAs3.url, newAs = _prepareUrlAs3.as;
                return _context.abrupt("return", this.change(method, newUrl, newAs, options));

              case 92:
                window.location.href = destination;
                return _context.abrupt("return", new Promise(function () {}));

              case 94:
                this.isPreview = !!props.__N_PREVIEW; // handle SSG data 404

                if (!(props.notFound === SSG_DATA_NOT_FOUND)) {
                  _context.next = 108;
                  break;
                }

                _context.prev = 96;
                _context.next = 99;
                return this.fetchComponent('/404');

              case 99:
                notFoundRoute = '/404';
                _context.next = 105;
                break;

              case 102:
                _context.prev = 102;
                _context.t1 = _context["catch"](96);
                notFoundRoute = '/_error';

              case 105:
                _context.next = 107;
                return this.getRouteInfo(notFoundRoute, notFoundRoute, query, as, resolvedAs, {
                  shallow: false
                });

              case 107:
                routeInfo = _context.sent;

              case 108:
                Router.events.emit('beforeHistoryChange', as, routeProps);
                this.changeState(method, url, as, options);

                if (true) {
                  appComp = this.components['/_app'].Component;
                  window.next.isPrerendered = appComp.getInitialProps === appComp.origGetInitialProps && !routeInfo.Component.getInitialProps;
                } // shallow routing is only allowed for same page URL changes.


                isValidShallowRoute = options.shallow && this.route === route;

                if (options._h && pathname === '/_error' && ((_self$__NEXT_DATA__$p = self.__NEXT_DATA__.props) == null ? void 0 : (_self$__NEXT_DATA__$p2 = _self$__NEXT_DATA__$p.pageProps) == null ? void 0 : _self$__NEXT_DATA__$p2.statusCode) === 500 && props != null && props.pageProps) {
                  // ensure statusCode is still correct for static 500 page
                  // when updating query information
                  props.pageProps.statusCode = 500;
                }

                _context.next = 115;
                return this.set(route, pathname, query, cleanedAs, routeInfo, forcedScroll || (isValidShallowRoute || !options.scroll ? null : {
                  x: 0,
                  y: 0
                }))["catch"](function (e) {
                  if (e.cancelled) error = error || e;else throw e;
                });

              case 115:
                if (!error) {
                  _context.next = 118;
                  break;
                }

                Router.events.emit('routeChangeError', error, cleanedAs, routeProps);
                throw error;

              case 118:
                if (false) {}

                Router.events.emit('routeChangeComplete', as, routeProps);
                return _context.abrupt("return", true);

              case 123:
                _context.prev = 123;
                _context.t2 = _context["catch"](78);

                if (!_context.t2.cancelled) {
                  _context.next = 127;
                  break;
                }

                return _context.abrupt("return", false);

              case 127:
                throw _context.t2;

              case 128:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this, [[37, 47], [78, 123], [96, 102]]);
      }));

      function change(_x, _x2, _x3, _x4, _x5) {
        return _change.apply(this, arguments);
      }

      return change;
    }()
  }, {
    key: "changeState",
    value: function changeState(method, url, as) {
      var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};

      if (true) {
        if (typeof window.history === 'undefined') {
          console.error("Warning: window.history is not available.");
          return;
        }

        if (typeof window.history[method] === 'undefined') {
          console.error("Warning: window.history.".concat(method, " is not available"));
          return;
        }
      }

      if (method !== 'pushState' || (0, _utils.getURL)() !== as) {
        this._shallow = options.shallow;
        window.history[method]({
          url: url,
          as: as,
          options: options,
          __N: true,
          idx: this._idx = method !== 'pushState' ? this._idx : this._idx + 1
        }, // Most browsers currently ignores this parameter, although they may use it in the future.
        // Passing the empty string here should be safe against future changes to the method.
        // https://developer.mozilla.org/en-US/docs/Web/API/History/replaceState
        '', as);
      }
    }
  }, {
    key: "handleRouteInfoError",
    value: function () {
      var _handleRouteInfoError = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(err, pathname, query, as, routeProps, loadErrorFail) {
        var Component, styleSheets, props, _yield$this$fetchComp, routeInfo;

        return _regeneratorRuntime.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                if (!err.cancelled) {
                  _context2.next = 2;
                  break;
                }

                throw err;

              case 2:
                if (!((0, _routeLoader.isAssetError)(err) || loadErrorFail)) {
                  _context2.next = 6;
                  break;
                }

                Router.events.emit('routeChangeError', err, as, routeProps); // If we can't load the page it could be one of following reasons
                //  1. Page doesn't exists
                //  2. Page does exist in a different zone
                //  3. Internal error while loading the page
                // So, doing a hard reload is the proper way to deal with this.

                window.location.href = as; // Changing the URL doesn't block executing the current code path.
                // So let's throw a cancellation error stop the routing logic.

                throw buildCancellationError();

              case 6:
                _context2.prev = 6;

                if (!(typeof Component === 'undefined' || typeof styleSheets === 'undefined')) {
                  _context2.next = 14;
                  break;
                }

                ;
                _context2.next = 11;
                return this.fetchComponent('/_error');

              case 11:
                _yield$this$fetchComp = _context2.sent;
                Component = _yield$this$fetchComp.page;
                styleSheets = _yield$this$fetchComp.styleSheets;

              case 14:
                routeInfo = {
                  props: props,
                  Component: Component,
                  styleSheets: styleSheets,
                  err: err,
                  error: err
                };

                if (routeInfo.props) {
                  _context2.next = 26;
                  break;
                }

                _context2.prev = 16;
                _context2.next = 19;
                return this.getInitialProps(Component, {
                  err: err,
                  pathname: pathname,
                  query: query
                });

              case 19:
                routeInfo.props = _context2.sent;
                _context2.next = 26;
                break;

              case 22:
                _context2.prev = 22;
                _context2.t0 = _context2["catch"](16);
                console.error('Error in error page `getInitialProps`: ', _context2.t0);
                routeInfo.props = {};

              case 26:
                return _context2.abrupt("return", routeInfo);

              case 29:
                _context2.prev = 29;
                _context2.t1 = _context2["catch"](6);
                return _context2.abrupt("return", this.handleRouteInfoError(_context2.t1, pathname, query, as, routeProps, true));

              case 32:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2, this, [[6, 29], [16, 22]]);
      }));

      function handleRouteInfoError(_x6, _x7, _x8, _x9, _x10, _x11) {
        return _handleRouteInfoError.apply(this, arguments);
      }

      return handleRouteInfoError;
    }()
  }, {
    key: "getRouteInfo",
    value: function () {
      var _getRouteInfo = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee3(route, pathname, query, as, resolvedAs, routeProps) {
        var _this2 = this;

        var existingRouteInfo, cachedRouteInfo, routeInfo, Component, __N_SSG, __N_SSP, _require, isValidElementType, dataHref, props;

        return _regeneratorRuntime.wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                _context3.prev = 0;
                existingRouteInfo = this.components[route];

                if (!(routeProps.shallow && existingRouteInfo && this.route === route)) {
                  _context3.next = 4;
                  break;
                }

                return _context3.abrupt("return", existingRouteInfo);

              case 4:
                cachedRouteInfo = existingRouteInfo && 'initial' in existingRouteInfo ? undefined : existingRouteInfo;

                if (!cachedRouteInfo) {
                  _context3.next = 9;
                  break;
                }

                _context3.t0 = cachedRouteInfo;
                _context3.next = 12;
                break;

              case 9:
                _context3.next = 11;
                return this.fetchComponent(route).then(function (res) {
                  return {
                    Component: res.page,
                    styleSheets: res.styleSheets,
                    __N_SSG: res.mod.__N_SSG,
                    __N_SSP: res.mod.__N_SSP
                  };
                });

              case 11:
                _context3.t0 = _context3.sent;

              case 12:
                routeInfo = _context3.t0;
                Component = routeInfo.Component, __N_SSG = routeInfo.__N_SSG, __N_SSP = routeInfo.__N_SSP;

                if (false) {}

                _require = __webpack_require__(/*! react-is */ "./node_modules/react-is/index.js"), isValidElementType = _require.isValidElementType;

                if (isValidElementType(Component)) {
                  _context3.next = 18;
                  break;
                }

                throw new Error("The default export is not a React Component in page: \"".concat(pathname, "\""));

              case 18:
                if (__N_SSG || __N_SSP) {
                  dataHref = this.pageLoader.getDataHref((0, _utils.formatWithValidation)({
                    pathname: pathname,
                    query: query
                  }), resolvedAs, __N_SSG, this.locale);
                }

                _context3.next = 21;
                return this._getData(function () {
                  return __N_SSG ? _this2._getStaticData(dataHref) : __N_SSP ? _this2._getServerData(dataHref) : _this2.getInitialProps(Component, // we provide AppTree later so this needs to be `any`
                  {
                    pathname: pathname,
                    query: query,
                    asPath: as,
                    locale: _this2.locale,
                    locales: _this2.locales,
                    defaultLocale: _this2.defaultLocale
                  });
                });

              case 21:
                props = _context3.sent;
                routeInfo.props = props;
                this.components[route] = routeInfo;
                return _context3.abrupt("return", routeInfo);

              case 27:
                _context3.prev = 27;
                _context3.t1 = _context3["catch"](0);
                return _context3.abrupt("return", this.handleRouteInfoError(_context3.t1, pathname, query, as, routeProps));

              case 30:
              case "end":
                return _context3.stop();
            }
          }
        }, _callee3, this, [[0, 27]]);
      }));

      function getRouteInfo(_x12, _x13, _x14, _x15, _x16, _x17) {
        return _getRouteInfo.apply(this, arguments);
      }

      return getRouteInfo;
    }()
  }, {
    key: "set",
    value: function set(route, pathname, query, as, data, resetScroll) {
      this.isFallback = false;
      this.route = route;
      this.pathname = pathname;
      this.query = query;
      this.asPath = as;
      return this.notify(data, resetScroll);
    }
    /**
    * Callback to execute before replacing router state
    * @param cb callback to be executed
    */

  }, {
    key: "beforePopState",
    value: function beforePopState(cb) {
      this._bps = cb;
    }
  }, {
    key: "onlyAHashChange",
    value: function onlyAHashChange(as) {
      if (!this.asPath) return false;

      var _this$asPath$split = this.asPath.split('#'),
          _this$asPath$split2 = _slicedToArray(_this$asPath$split, 2),
          oldUrlNoHash = _this$asPath$split2[0],
          oldHash = _this$asPath$split2[1];

      var _as$split = as.split('#'),
          _as$split2 = _slicedToArray(_as$split, 2),
          newUrlNoHash = _as$split2[0],
          newHash = _as$split2[1]; // Makes sure we scroll to the provided hash if the url/hash are the same


      if (newHash && oldUrlNoHash === newUrlNoHash && oldHash === newHash) {
        return true;
      } // If the urls are change, there's more than a hash change


      if (oldUrlNoHash !== newUrlNoHash) {
        return false;
      } // If the hash has changed, then it's a hash only change.
      // This check is necessary to handle both the enter and
      // leave hash === '' cases. The identity case falls through
      // and is treated as a next reload.


      return oldHash !== newHash;
    }
  }, {
    key: "scrollToHash",
    value: function scrollToHash(as) {
      var _as$split3 = as.split('#'),
          _as$split4 = _slicedToArray(_as$split3, 2),
          hash = _as$split4[1]; // Scroll to top if the hash is just `#` with no value or `#top`
      // To mirror browsers


      if (hash === '' || hash === 'top') {
        window.scrollTo(0, 0);
        return;
      } // First we check if the element by id is found


      var idEl = document.getElementById(hash);

      if (idEl) {
        idEl.scrollIntoView();
        return;
      } // If there's no element with the id, we check the `name` property
      // To mirror browsers


      var nameEl = document.getElementsByName(hash)[0];

      if (nameEl) {
        nameEl.scrollIntoView();
      }
    }
  }, {
    key: "urlIsNew",
    value: function urlIsNew(asPath) {
      return this.asPath !== asPath;
    }
    /**
    * Prefetch page code, you may wait for the data during page rendering.
    * This feature only works in production!
    * @param url the href of prefetched page
    * @param asPath the as path of the prefetched page
    */

  }, {
    key: "prefetch",
    value: function () {
      var _prefetch = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee4(url) {
        var _this3 = this;

        var asPath,
            options,
            parsed,
            pathname,
            parsedAs,
            localePathResult,
            pages,
            resolvedAs,
            rewrites,
            _yield2,
            rewritesResult,
            route,
            _args4 = arguments;

        return _regeneratorRuntime.wrap(function _callee4$(_context4) {
          while (1) {
            switch (_context4.prev = _context4.next) {
              case 0:
                asPath = _args4.length > 1 && _args4[1] !== undefined ? _args4[1] : url;
                options = _args4.length > 2 && _args4[2] !== undefined ? _args4[2] : {};
                parsed = (0, _parseRelativeUrl.parseRelativeUrl)(url);
                pathname = parsed.pathname;

                if (false) {}

                _context4.next = 7;
                return this.pageLoader.getPageList();

              case 7:
                pages = _context4.sent;
                resolvedAs = asPath;

                if (true) {
                  _context4.next = 19;
                  break;
                }

                _context4.next = 12;
                return (0, _routeLoader.getClientBuildManifest)();

              case 12:
                _yield2 = _context4.sent;
                rewrites = _yield2.__rewrites;
                rewritesResult = (0, _resolveRewrites["default"])(addBasePath(addLocale(asPath, this.locale)), pages, rewrites, parsed.query, function (p) {
                  return resolveDynamicRoute(p, pages);
                }, this.locales);
                resolvedAs = delLocale(delBasePath(rewritesResult.asPath), this.locale);

                if (rewritesResult.matchedPage && rewritesResult.resolvedHref) {
                  // if this directly matches a page we need to update the href to
                  // allow the correct page chunk to be loaded
                  pathname = rewritesResult.resolvedHref;
                  parsed.pathname = pathname;
                  url = (0, _utils.formatWithValidation)(parsed);
                }

                _context4.next = 21;
                break;

              case 19:
                parsed.pathname = resolveDynamicRoute(parsed.pathname, pages);

                if (parsed.pathname !== pathname) {
                  pathname = parsed.pathname;
                  url = (0, _utils.formatWithValidation)(parsed);
                }

              case 21:
                route = (0, _normalizeTrailingSlash.removePathTrailingSlash)(pathname); // Prefetch is not supported in development mode because it would trigger on-demand-entries

                if (false) {}

                return _context4.abrupt("return");

              case 24:
                _context4.next = 26;
                return Promise.all([this.pageLoader._isSsg(route).then(function (isSsg) {
                  return isSsg ? _this3._getStaticData(_this3.pageLoader.getDataHref(url, resolvedAs, true, typeof options.locale !== 'undefined' ? options.locale : _this3.locale)) : false;
                }), this.pageLoader[options.priority ? 'loadPage' : 'prefetch'](route)]);

              case 26:
              case "end":
                return _context4.stop();
            }
          }
        }, _callee4, this);
      }));

      function prefetch(_x18) {
        return _prefetch.apply(this, arguments);
      }

      return prefetch;
    }()
  }, {
    key: "fetchComponent",
    value: function () {
      var _fetchComponent = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee5(route) {
        var cancelled, cancel, componentResult, error;
        return _regeneratorRuntime.wrap(function _callee5$(_context5) {
          while (1) {
            switch (_context5.prev = _context5.next) {
              case 0:
                cancelled = false;

                cancel = this.clc = function () {
                  cancelled = true;
                };

                _context5.next = 4;
                return this.pageLoader.loadPage(route);

              case 4:
                componentResult = _context5.sent;

                if (!cancelled) {
                  _context5.next = 9;
                  break;
                }

                error = new Error("Abort fetching component for route: \"".concat(route, "\""));
                error.cancelled = true;
                throw error;

              case 9:
                if (cancel === this.clc) {
                  this.clc = null;
                }

                return _context5.abrupt("return", componentResult);

              case 11:
              case "end":
                return _context5.stop();
            }
          }
        }, _callee5, this);
      }));

      function fetchComponent(_x19) {
        return _fetchComponent.apply(this, arguments);
      }

      return fetchComponent;
    }()
  }, {
    key: "_getData",
    value: function _getData(fn) {
      var _this4 = this;

      var cancelled = false;

      var cancel = function cancel() {
        cancelled = true;
      };

      this.clc = cancel;
      return fn().then(function (data) {
        if (cancel === _this4.clc) {
          _this4.clc = null;
        }

        if (cancelled) {
          var err = new Error('Loading initial props cancelled');
          err.cancelled = true;
          throw err;
        }

        return data;
      });
    }
  }, {
    key: "_getStaticData",
    value: function _getStaticData(dataHref) {
      var _this5 = this;

      var _URL = new URL(dataHref, window.location.href),
          cacheKey = _URL.href;

      if (false) {}

      return fetchNextData(dataHref, this.isSsr).then(function (data) {
        _this5.sdc[cacheKey] = data;
        return data;
      });
    }
  }, {
    key: "_getServerData",
    value: function _getServerData(dataHref) {
      var _this6 = this;

      var _URL2 = new URL(dataHref, window.location.href),
          resourceKey = _URL2.href;

      if (this.sdr[resourceKey]) {
        return this.sdr[resourceKey];
      }

      return this.sdr[resourceKey] = fetchNextData(dataHref, this.isSsr).then(function (data) {
        delete _this6.sdr[resourceKey];
        return data;
      })["catch"](function (err) {
        delete _this6.sdr[resourceKey];
        throw err;
      });
    }
  }, {
    key: "getInitialProps",
    value: function getInitialProps(Component, ctx) {
      var App = this.components['/_app'].Component;

      var AppTree = this._wrapApp(App);

      ctx.AppTree = AppTree;
      return (0, _utils.loadGetInitialProps)(App, {
        AppTree: AppTree,
        Component: Component,
        router: this,
        ctx: ctx
      });
    }
  }, {
    key: "abortComponentLoad",
    value: function abortComponentLoad(as, routeProps) {
      if (this.clc) {
        Router.events.emit('routeChangeError', buildCancellationError(), as, routeProps);
        this.clc();
        this.clc = null;
      }
    }
  }, {
    key: "notify",
    value: function notify(data, resetScroll) {
      return this.sub(data, this.components['/_app'].Component, resetScroll);
    }
  }]);

  return Router;
}();

_c = Router;
exports["default"] = Router;
Router.events = (0, _mitt["default"])();

var _c;

$RefreshReg$(_c, "Router");

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.i);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../compiled/webpack/module.js */ "./node_modules/next/dist/compiled/webpack/module.js")(module)))

/***/ }),

/***/ "./node_modules/next/dist/next-server/lib/router/utils/format-url.js":
/*!***************************************************************************!*\
  !*** ./node_modules/next/dist/next-server/lib/router/utils/format-url.js ***!
  \***************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(module) {

exports.__esModule = true;
exports.formatUrl = formatUrl;

var querystring = _interopRequireWildcard(__webpack_require__(/*! ./querystring */ "./node_modules/next/dist/next-server/lib/router/utils/querystring.js"));

function _getRequireWildcardCache() {
  if (typeof WeakMap !== "function") return null;
  var cache = new WeakMap();

  _getRequireWildcardCache = function _getRequireWildcardCache() {
    return cache;
  };

  return cache;
}

function _interopRequireWildcard(obj) {
  if (obj && obj.__esModule) {
    return obj;
  }

  if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
    return {
      "default": obj
    };
  }

  var cache = _getRequireWildcardCache();

  if (cache && cache.has(obj)) {
    return cache.get(obj);
  }

  var newObj = {};
  var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;

  for (var key in obj) {
    if (Object.prototype.hasOwnProperty.call(obj, key)) {
      var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;

      if (desc && (desc.get || desc.set)) {
        Object.defineProperty(newObj, key, desc);
      } else {
        newObj[key] = obj[key];
      }
    }
  }

  newObj["default"] = obj;

  if (cache) {
    cache.set(obj, newObj);
  }

  return newObj;
} // Format function modified from nodejs
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.


var slashedProtocols = /https?|ftp|gopher|file/;

function formatUrl(urlObj) {
  var auth = urlObj.auth,
      hostname = urlObj.hostname;
  var protocol = urlObj.protocol || '';
  var pathname = urlObj.pathname || '';
  var hash = urlObj.hash || '';
  var query = urlObj.query || '';
  var host = false;
  auth = auth ? encodeURIComponent(auth).replace(/%3A/i, ':') + '@' : '';

  if (urlObj.host) {
    host = auth + urlObj.host;
  } else if (hostname) {
    host = auth + (~hostname.indexOf(':') ? "[".concat(hostname, "]") : hostname);

    if (urlObj.port) {
      host += ':' + urlObj.port;
    }
  }

  if (query && typeof query === 'object') {
    query = String(querystring.urlQueryToSearchParams(query));
  }

  var search = urlObj.search || query && "?".concat(query) || '';
  if (protocol && protocol.substr(-1) !== ':') protocol += ':';

  if (urlObj.slashes || (!protocol || slashedProtocols.test(protocol)) && host !== false) {
    host = '//' + (host || '');
    if (pathname && pathname[0] !== '/') pathname = '/' + pathname;
  } else if (!host) {
    host = '';
  }

  if (hash && hash[0] !== '#') hash = '#' + hash;
  if (search && search[0] !== '?') search = '?' + search;
  pathname = pathname.replace(/[?#]/g, encodeURIComponent);
  search = search.replace('#', '%23');
  return "".concat(protocol).concat(host).concat(pathname).concat(search).concat(hash);
}

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.i);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../compiled/webpack/module.js */ "./node_modules/next/dist/compiled/webpack/module.js")(module)))

/***/ }),

/***/ "./node_modules/next/dist/next-server/lib/router/utils/get-asset-path-from-route.js":
/*!******************************************************************************************!*\
  !*** ./node_modules/next/dist/next-server/lib/router/utils/get-asset-path-from-route.js ***!
  \******************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(module) {

exports.__esModule = true;
exports["default"] = getAssetPathFromRoute; // Translates a logical route into its pages asset path (relative from a common prefix)
// "asset path" being its javascript file, data file, prerendered html,...

function getAssetPathFromRoute(route) {
  var ext = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';
  var path = route === '/' ? '/index' : /^\/index(\/|$)/.test(route) ? "/index".concat(route) : "".concat(route);
  return path + ext;
}

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.i);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../compiled/webpack/module.js */ "./node_modules/next/dist/compiled/webpack/module.js")(module)))

/***/ }),

/***/ "./node_modules/next/dist/next-server/lib/router/utils/is-dynamic.js":
/*!***************************************************************************!*\
  !*** ./node_modules/next/dist/next-server/lib/router/utils/is-dynamic.js ***!
  \***************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(module) {

exports.__esModule = true;
exports.isDynamicRoute = isDynamicRoute; // Identify /[param]/ in route string

var TEST_ROUTE = /\/\[[^/]+?\](?=\/|$)/;

function isDynamicRoute(route) {
  return TEST_ROUTE.test(route);
}

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.i);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../compiled/webpack/module.js */ "./node_modules/next/dist/compiled/webpack/module.js")(module)))

/***/ }),

/***/ "./node_modules/next/dist/next-server/lib/router/utils/parse-relative-url.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/next/dist/next-server/lib/router/utils/parse-relative-url.js ***!
  \***********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(module) {

exports.__esModule = true;
exports.parseRelativeUrl = parseRelativeUrl;

var _utils = __webpack_require__(/*! ../../utils */ "./node_modules/next/dist/next-server/lib/utils.js");

var _querystring = __webpack_require__(/*! ./querystring */ "./node_modules/next/dist/next-server/lib/router/utils/querystring.js");
/**
* Parses path-relative urls (e.g. `/hello/world?foo=bar`). If url isn't path-relative
* (e.g. `./hello`) then at least base must be.
* Absolute urls are rejected with one exception, in the browser, absolute urls that are on
* the current origin will be parsed as relative
*/


function parseRelativeUrl(url, base) {
  var globalBase = new URL(false ? undefined : (0, _utils.getLocationOrigin)());
  var resolvedBase = base ? new URL(base, globalBase) : globalBase;

  var _URL = new URL(url, resolvedBase),
      pathname = _URL.pathname,
      searchParams = _URL.searchParams,
      search = _URL.search,
      hash = _URL.hash,
      href = _URL.href,
      origin = _URL.origin;

  if (origin !== globalBase.origin) {
    throw new Error("invariant: invalid relative URL, router received ".concat(url));
  }

  return {
    pathname: pathname,
    query: (0, _querystring.searchParamsToUrlQuery)(searchParams),
    search: search,
    hash: hash,
    href: href.slice(globalBase.origin.length)
  };
}

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.i);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../compiled/webpack/module.js */ "./node_modules/next/dist/compiled/webpack/module.js")(module)))

/***/ }),

/***/ "./node_modules/next/dist/next-server/lib/router/utils/querystring.js":
/*!****************************************************************************!*\
  !*** ./node_modules/next/dist/next-server/lib/router/utils/querystring.js ***!
  \****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(module) {

var _slicedToArray = __webpack_require__(/*! ./node_modules/@babel/runtime/helpers/slicedToArray */ "./node_modules/@babel/runtime/helpers/slicedToArray.js");

exports.__esModule = true;
exports.searchParamsToUrlQuery = searchParamsToUrlQuery;
exports.urlQueryToSearchParams = urlQueryToSearchParams;
exports.assign = assign;

function searchParamsToUrlQuery(searchParams) {
  var query = {};
  searchParams.forEach(function (value, key) {
    if (typeof query[key] === 'undefined') {
      query[key] = value;
    } else if (Array.isArray(query[key])) {
      ;
      query[key].push(value);
    } else {
      query[key] = [query[key], value];
    }
  });
  return query;
}

function stringifyUrlQueryParam(param) {
  if (typeof param === 'string' || typeof param === 'number' && !isNaN(param) || typeof param === 'boolean') {
    return String(param);
  } else {
    return '';
  }
}

function urlQueryToSearchParams(urlQuery) {
  var result = new URLSearchParams();
  Object.entries(urlQuery).forEach(function (_ref) {
    var _ref2 = _slicedToArray(_ref, 2),
        key = _ref2[0],
        value = _ref2[1];

    if (Array.isArray(value)) {
      value.forEach(function (item) {
        return result.append(key, stringifyUrlQueryParam(item));
      });
    } else {
      result.set(key, stringifyUrlQueryParam(value));
    }
  });
  return result;
}

function assign(target) {
  for (var _len = arguments.length, searchParamsList = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    searchParamsList[_key - 1] = arguments[_key];
  }

  searchParamsList.forEach(function (searchParams) {
    Array.from(searchParams.keys()).forEach(function (key) {
      return target["delete"](key);
    });
    searchParams.forEach(function (value, key) {
      return target.append(key, value);
    });
  });
  return target;
}

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.i);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../compiled/webpack/module.js */ "./node_modules/next/dist/compiled/webpack/module.js")(module)))

/***/ }),

/***/ "./node_modules/next/dist/next-server/lib/router/utils/resolve-rewrites-noop.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/next/dist/next-server/lib/router/utils/resolve-rewrites-noop.js ***!
  \**************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(module) {

exports.__esModule = true;
exports["default"] = resolveRewrites;

function resolveRewrites() {}

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.i);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../compiled/webpack/module.js */ "./node_modules/next/dist/compiled/webpack/module.js")(module)))

/***/ }),

/***/ "./node_modules/next/dist/next-server/lib/router/utils/route-matcher.js":
/*!******************************************************************************!*\
  !*** ./node_modules/next/dist/next-server/lib/router/utils/route-matcher.js ***!
  \******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(module) {

exports.__esModule = true;
exports.getRouteMatcher = getRouteMatcher;

function getRouteMatcher(routeRegex) {
  var re = routeRegex.re,
      groups = routeRegex.groups;
  return function (pathname) {
    var routeMatch = re.exec(pathname);

    if (!routeMatch) {
      return false;
    }

    var decode = function decode(param) {
      try {
        return decodeURIComponent(param);
      } catch (_) {
        var err = new Error('failed to decode param');
        err.code = 'DECODE_FAILED';
        throw err;
      }
    };

    var params = {};
    Object.keys(groups).forEach(function (slugName) {
      var g = groups[slugName];
      var m = routeMatch[g.pos];

      if (m !== undefined) {
        params[slugName] = ~m.indexOf('/') ? m.split('/').map(function (entry) {
          return decode(entry);
        }) : g.repeat ? [decode(m)] : decode(m);
      }
    });
    return params;
  };
}

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.i);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../compiled/webpack/module.js */ "./node_modules/next/dist/compiled/webpack/module.js")(module)))

/***/ }),

/***/ "./node_modules/next/dist/next-server/lib/router/utils/route-regex.js":
/*!****************************************************************************!*\
  !*** ./node_modules/next/dist/next-server/lib/router/utils/route-regex.js ***!
  \****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(module) {

exports.__esModule = true;
exports.getRouteRegex = getRouteRegex; // this isn't importing the escape-string-regex module
// to reduce bytes

function escapeRegex(str) {
  return str.replace(/[|\\{}()[\]^$+*?.-]/g, '\\$&');
}

function parseParameter(param) {
  var optional = param.startsWith('[') && param.endsWith(']');

  if (optional) {
    param = param.slice(1, -1);
  }

  var repeat = param.startsWith('...');

  if (repeat) {
    param = param.slice(3);
  }

  return {
    key: param,
    repeat: repeat,
    optional: optional
  };
}

function getRouteRegex(normalizedRoute) {
  var segments = (normalizedRoute.replace(/\/$/, '') || '/').slice(1).split('/');
  var groups = {};
  var groupIndex = 1;
  var parameterizedRoute = segments.map(function (segment) {
    if (segment.startsWith('[') && segment.endsWith(']')) {
      var _parseParameter = parseParameter(segment.slice(1, -1)),
          key = _parseParameter.key,
          optional = _parseParameter.optional,
          repeat = _parseParameter.repeat;

      groups[key] = {
        pos: groupIndex++,
        repeat: repeat,
        optional: optional
      };
      return repeat ? optional ? '(?:/(.+?))?' : '/(.+?)' : '/([^/]+?)';
    } else {
      return "/".concat(escapeRegex(segment));
    }
  }).join(''); // dead code eliminate for browser since it's only needed
  // while generating routes-manifest

  if (false) { var namedParameterizedRoute, routeKeys, getSafeRouteKey, routeKeyCharLength, routeKeyCharCode; }

  return {
    re: new RegExp("^".concat(parameterizedRoute, "(?:/)?$")),
    groups: groups
  };
}

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.i);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../compiled/webpack/module.js */ "./node_modules/next/dist/compiled/webpack/module.js")(module)))

/***/ }),

/***/ "./node_modules/next/dist/next-server/lib/side-effect.js":
/*!***************************************************************!*\
  !*** ./node_modules/next/dist/next-server/lib/side-effect.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(module) {

var _toConsumableArray = __webpack_require__(/*! ./node_modules/@babel/runtime/helpers/toConsumableArray */ "./node_modules/@babel/runtime/helpers/toConsumableArray.js");

var _classCallCheck = __webpack_require__(/*! ./node_modules/@babel/runtime/helpers/classCallCheck */ "./node_modules/@babel/runtime/helpers/classCallCheck.js");

var _createClass = __webpack_require__(/*! ./node_modules/@babel/runtime/helpers/createClass */ "./node_modules/@babel/runtime/helpers/createClass.js");

var _assertThisInitialized = __webpack_require__(/*! ./node_modules/@babel/runtime/helpers/assertThisInitialized */ "./node_modules/@babel/runtime/helpers/assertThisInitialized.js");

var _inherits = __webpack_require__(/*! ./node_modules/@babel/runtime/helpers/inherits */ "./node_modules/@babel/runtime/helpers/inherits.js");

var _possibleConstructorReturn = __webpack_require__(/*! ./node_modules/@babel/runtime/helpers/possibleConstructorReturn */ "./node_modules/@babel/runtime/helpers/possibleConstructorReturn.js");

var _getPrototypeOf = __webpack_require__(/*! ./node_modules/@babel/runtime/helpers/getPrototypeOf */ "./node_modules/@babel/runtime/helpers/getPrototypeOf.js");

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

exports.__esModule = true;
exports["default"] = void 0;

var _react = __webpack_require__(/*! react */ "./node_modules/preact/compat/dist/compat.module.js");

var isServer = false;

var _default = /*#__PURE__*/function (_react$Component) {
  _inherits(_default, _react$Component);

  var _super = _createSuper(_default);

  function _default(props) {
    var _this;

    _classCallCheck(this, _default);

    _this = _super.call(this, props);
    _this._hasHeadManager = void 0;

    _this.emitChange = function () {
      if (_this._hasHeadManager) {
        _this.props.headManager.updateHead(_this.props.reduceComponentsToState(_toConsumableArray(_this.props.headManager.mountedInstances), _this.props));
      }
    };

    _this._hasHeadManager = _this.props.headManager && _this.props.headManager.mountedInstances;

    if (isServer && _this._hasHeadManager) {
      _this.props.headManager.mountedInstances.add(_assertThisInitialized(_this));

      _this.emitChange();
    }

    return _this;
  }

  _createClass(_default, [{
    key: "componentDidMount",
    value: function componentDidMount() {
      if (this._hasHeadManager) {
        this.props.headManager.mountedInstances.add(this);
      }

      this.emitChange();
    }
  }, {
    key: "componentDidUpdate",
    value: function componentDidUpdate() {
      this.emitChange();
    }
  }, {
    key: "componentWillUnmount",
    value: function componentWillUnmount() {
      if (this._hasHeadManager) {
        this.props.headManager.mountedInstances["delete"](this);
      }

      this.emitChange();
    }
  }, {
    key: "render",
    value: function render() {
      return null;
    }
  }]);

  return _default;
}(_react.Component);

exports["default"] = _default;

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.i);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../compiled/webpack/module.js */ "./node_modules/next/dist/compiled/webpack/module.js")(module)))

/***/ }),

/***/ "./node_modules/next/dist/next-server/lib/utils.js":
/*!*********************************************************!*\
  !*** ./node_modules/next/dist/next-server/lib/utils.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(module) {

var _regeneratorRuntime = __webpack_require__(/*! ./node_modules/@babel/runtime/regenerator */ "./node_modules/@babel/runtime/regenerator/index.js");

var _asyncToGenerator = __webpack_require__(/*! ./node_modules/@babel/runtime/helpers/asyncToGenerator */ "./node_modules/@babel/runtime/helpers/asyncToGenerator.js");

exports.__esModule = true;
exports.execOnce = execOnce;
exports.getLocationOrigin = getLocationOrigin;
exports.getURL = getURL;
exports.getDisplayName = getDisplayName;
exports.isResSent = isResSent;
exports.loadGetInitialProps = loadGetInitialProps;
exports.formatWithValidation = formatWithValidation;
exports.ST = exports.SP = exports.urlObjectKeys = void 0;

var _formatUrl = __webpack_require__(/*! ./router/utils/format-url */ "./node_modules/next/dist/next-server/lib/router/utils/format-url.js");
/**
* Utils
*/


function execOnce(fn) {
  var used = false;
  var result;
  return function () {
    if (!used) {
      used = true;
      result = fn.apply(void 0, arguments);
    }

    return result;
  };
}

function getLocationOrigin() {
  var _window$location = window.location,
      protocol = _window$location.protocol,
      hostname = _window$location.hostname,
      port = _window$location.port;
  return "".concat(protocol, "//").concat(hostname).concat(port ? ':' + port : '');
}

function getURL() {
  var href = window.location.href;
  var origin = getLocationOrigin();
  return href.substring(origin.length);
}

function getDisplayName(Component) {
  return typeof Component === 'string' ? Component : Component.displayName || Component.name || 'Unknown';
}

function isResSent(res) {
  return res.finished || res.headersSent;
}

function loadGetInitialProps(_x, _x2) {
  return _loadGetInitialProps.apply(this, arguments);
}

function _loadGetInitialProps() {
  _loadGetInitialProps = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(App, ctx) {
    var _App$prototype, message, res, props, _message;

    return _regeneratorRuntime.wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            if (false) {}

            if (!((_App$prototype = App.prototype) != null && _App$prototype.getInitialProps)) {
              _context.next = 4;
              break;
            }

            message = "\"".concat(getDisplayName(App), ".getInitialProps()\" is defined as an instance method - visit https://nextjs.org/docs/messages/get-initial-props-as-an-instance-method for more information.");
            throw new Error(message);

          case 4:
            // when called from _app `ctx` is nested in `ctx`
            res = ctx.res || ctx.ctx && ctx.ctx.res;

            if (App.getInitialProps) {
              _context.next = 12;
              break;
            }

            if (!(ctx.ctx && ctx.Component)) {
              _context.next = 11;
              break;
            }

            _context.next = 9;
            return loadGetInitialProps(ctx.Component, ctx.ctx);

          case 9:
            _context.t0 = _context.sent;
            return _context.abrupt("return", {
              pageProps: _context.t0
            });

          case 11:
            return _context.abrupt("return", {});

          case 12:
            _context.next = 14;
            return App.getInitialProps(ctx);

          case 14:
            props = _context.sent;

            if (!(res && isResSent(res))) {
              _context.next = 17;
              break;
            }

            return _context.abrupt("return", props);

          case 17:
            if (props) {
              _context.next = 20;
              break;
            }

            _message = "\"".concat(getDisplayName(App), ".getInitialProps()\" should resolve to an object. But found \"").concat(props, "\" instead.");
            throw new Error(_message);

          case 20:
            if (true) {
              if (Object.keys(props).length === 0 && !ctx.ctx) {
                console.warn("".concat(getDisplayName(App), " returned an empty object from `getInitialProps`. This de-optimizes and prevents automatic static optimization. https://nextjs.org/docs/messages/empty-object-getInitialProps"));
              }
            }

            return _context.abrupt("return", props);

          case 22:
          case "end":
            return _context.stop();
        }
      }
    }, _callee);
  }));
  return _loadGetInitialProps.apply(this, arguments);
}

var urlObjectKeys = ['auth', 'hash', 'host', 'hostname', 'href', 'path', 'pathname', 'port', 'protocol', 'query', 'search', 'slashes'];
exports.urlObjectKeys = urlObjectKeys;

function formatWithValidation(url) {
  if (true) {
    if (url !== null && typeof url === 'object') {
      Object.keys(url).forEach(function (key) {
        if (urlObjectKeys.indexOf(key) === -1) {
          console.warn("Unknown key passed via urlObject into url.format: ".concat(key));
        }
      });
    }
  }

  return (0, _formatUrl.formatUrl)(url);
}

var SP = typeof performance !== 'undefined';
exports.SP = SP;
var ST = SP && typeof performance.mark === 'function' && typeof performance.measure === 'function';
exports.ST = ST;

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.i);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../compiled/webpack/module.js */ "./node_modules/next/dist/compiled/webpack/module.js")(module)))

/***/ }),

/***/ "./node_modules/next/dist/next-server/server/denormalize-page-path.js":
/*!****************************************************************************!*\
  !*** ./node_modules/next/dist/next-server/server/denormalize-page-path.js ***!
  \****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
exports.__esModule=true;exports.normalizePathSep=normalizePathSep;exports.denormalizePagePath=denormalizePagePath;function normalizePathSep(path){return path.replace(/\\/g,'/');}function denormalizePagePath(page){page=normalizePathSep(page);if(page.startsWith('/index/')){page=page.slice(6);}else if(page==='/index'){page='/';}return page;}
//# sourceMappingURL=denormalize-page-path.js.map

/***/ }),

/***/ "./node_modules/next/head.js":
/*!***********************************!*\
  !*** ./node_modules/next/head.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(/*! ./dist/next-server/lib/head */ "./node_modules/next/dist/next-server/lib/head.js")


/***/ }),

/***/ "./node_modules/next/link.js":
/*!***********************************!*\
  !*** ./node_modules/next/link.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(/*! ./dist/client/link */ "./node_modules/next/dist/client/link.js")


/***/ }),

/***/ "./node_modules/preact/compat/dist/compat.module.js":
/*!**********************************************************!*\
  !*** ./node_modules/preact/compat/dist/compat.module.js ***!
  \**********************************************************/
/*! exports provided: useState, useReducer, useEffect, useLayoutEffect, useRef, useImperativeHandle, useMemo, useCallback, useContext, useDebugValue, useErrorBoundary, createElement, createContext, createRef, Fragment, Component, default, version, Children, render, hydrate, unmountComponentAtNode, createPortal, createFactory, cloneElement, isValidElement, findDOMNode, PureComponent, memo, forwardRef, unstable_batchedUpdates, StrictMode, Suspense, SuspenseList, lazy, __SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED, unstable_ImmediatePriority, unstable_UserBlockingPriority, unstable_NormalPriority, unstable_LowPriority, unstable_IdlePriority, unstable_runWithPriority, unstable_now */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "version", function() { return ln; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Children", function() { return k; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "render", function() { return z; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "hydrate", function() { return B; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "unmountComponentAtNode", function() { return sn; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createPortal", function() { return I; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createFactory", function() { return fn; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "cloneElement", function() { return an; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isValidElement", function() { return cn; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "findDOMNode", function() { return hn; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PureComponent", function() { return E; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "memo", function() { return g; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "forwardRef", function() { return x; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "unstable_batchedUpdates", function() { return pn; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "StrictMode", function() { return vn; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Suspense", function() { return L; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SuspenseList", function() { return F; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "lazy", function() { return D; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED", function() { return Q; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "unstable_ImmediatePriority", function() { return X; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "unstable_UserBlockingPriority", function() { return nn; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "unstable_NormalPriority", function() { return tn; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "unstable_LowPriority", function() { return en; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "unstable_IdlePriority", function() { return rn; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "unstable_runWithPriority", function() { return un; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "unstable_now", function() { return on; });
/* harmony import */ var preact_hooks__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! preact/hooks */ "./node_modules/preact/hooks/dist/hooks.module.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "useState", function() { return preact_hooks__WEBPACK_IMPORTED_MODULE_0__["useState"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "useReducer", function() { return preact_hooks__WEBPACK_IMPORTED_MODULE_0__["useReducer"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "useEffect", function() { return preact_hooks__WEBPACK_IMPORTED_MODULE_0__["useEffect"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "useLayoutEffect", function() { return preact_hooks__WEBPACK_IMPORTED_MODULE_0__["useLayoutEffect"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "useRef", function() { return preact_hooks__WEBPACK_IMPORTED_MODULE_0__["useRef"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "useImperativeHandle", function() { return preact_hooks__WEBPACK_IMPORTED_MODULE_0__["useImperativeHandle"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "useMemo", function() { return preact_hooks__WEBPACK_IMPORTED_MODULE_0__["useMemo"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "useCallback", function() { return preact_hooks__WEBPACK_IMPORTED_MODULE_0__["useCallback"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "useContext", function() { return preact_hooks__WEBPACK_IMPORTED_MODULE_0__["useContext"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "useDebugValue", function() { return preact_hooks__WEBPACK_IMPORTED_MODULE_0__["useDebugValue"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "useErrorBoundary", function() { return preact_hooks__WEBPACK_IMPORTED_MODULE_0__["useErrorBoundary"]; });

/* harmony import */ var preact__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! preact */ "./node_modules/preact/dist/preact.module.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "createElement", function() { return preact__WEBPACK_IMPORTED_MODULE_1__["createElement"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "createContext", function() { return preact__WEBPACK_IMPORTED_MODULE_1__["createContext"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "createRef", function() { return preact__WEBPACK_IMPORTED_MODULE_1__["createRef"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Fragment", function() { return preact__WEBPACK_IMPORTED_MODULE_1__["Fragment"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Component", function() { return preact__WEBPACK_IMPORTED_MODULE_1__["Component"]; });

function C(n,t){for(var e in t)n[e]=t[e];return n}function S(n,t){for(var e in n)if("__source"!==e&&!(e in t))return!0;for(var r in t)if("__source"!==r&&n[r]!==t[r])return!0;return!1}function E(n){this.props=n}function g(n,t){function e(n){var e=this.props.ref,r=e==n.ref;return!r&&e&&(e.call?e(null):e.current=null),t?!t(this.props,n)||!r:S(this.props,n)}function r(t){return this.shouldComponentUpdate=e,Object(preact__WEBPACK_IMPORTED_MODULE_1__["createElement"])(n,t)}return r.displayName="Memo("+(n.displayName||n.name)+")",r.prototype.isReactComponent=!0,r.__f=!0,r}(E.prototype=new preact__WEBPACK_IMPORTED_MODULE_1__["Component"]).isPureReactComponent=!0,E.prototype.shouldComponentUpdate=function(n,t){return S(this.props,n)||S(this.state,t)};var w=preact__WEBPACK_IMPORTED_MODULE_1__["options"].__b;preact__WEBPACK_IMPORTED_MODULE_1__["options"].__b=function(n){n.type&&n.type.__f&&n.ref&&(n.props.ref=n.ref,n.ref=null),w&&w(n)};var R="undefined"!=typeof Symbol&&Symbol.for&&Symbol.for("react.forward_ref")||3911;function x(n){function t(t,e){var r=C({},t);return delete r.ref,n(r,(e=t.ref||e)&&("object"!=typeof e||"current"in e)?e:null)}return t.$$typeof=R,t.render=t,t.prototype.isReactComponent=t.__f=!0,t.displayName="ForwardRef("+(n.displayName||n.name)+")",t}var N=function(n,t){return null==n?null:Object(preact__WEBPACK_IMPORTED_MODULE_1__["toChildArray"])(Object(preact__WEBPACK_IMPORTED_MODULE_1__["toChildArray"])(n).map(t))},k={map:N,forEach:N,count:function(n){return n?Object(preact__WEBPACK_IMPORTED_MODULE_1__["toChildArray"])(n).length:0},only:function(n){var t=Object(preact__WEBPACK_IMPORTED_MODULE_1__["toChildArray"])(n);if(1!==t.length)throw"Children.only";return t[0]},toArray:preact__WEBPACK_IMPORTED_MODULE_1__["toChildArray"]},A=preact__WEBPACK_IMPORTED_MODULE_1__["options"].__e;preact__WEBPACK_IMPORTED_MODULE_1__["options"].__e=function(n,t,e){if(n.then)for(var r,u=t;u=u.__;)if((r=u.__c)&&r.__c)return null==t.__e&&(t.__e=e.__e,t.__k=e.__k),r.__c(n,t);A(n,t,e)};var O=preact__WEBPACK_IMPORTED_MODULE_1__["options"].unmount;function L(){this.__u=0,this.t=null,this.__b=null}function U(n){var t=n.__.__c;return t&&t.__e&&t.__e(n)}function D(n){var t,e,r;function u(u){if(t||(t=n()).then(function(n){e=n.default||n},function(n){r=n}),r)throw r;if(!e)throw t;return Object(preact__WEBPACK_IMPORTED_MODULE_1__["createElement"])(e,u)}return u.displayName="Lazy",u.__f=!0,u}function F(){this.u=null,this.o=null}preact__WEBPACK_IMPORTED_MODULE_1__["options"].unmount=function(n){var t=n.__c;t&&t.__R&&t.__R(),t&&!0===n.__h&&(n.type=null),O&&O(n)},(L.prototype=new preact__WEBPACK_IMPORTED_MODULE_1__["Component"]).__c=function(n,t){var e=t.__c,r=this;null==r.t&&(r.t=[]),r.t.push(e);var u=U(r.__v),o=!1,i=function(){o||(o=!0,e.__R=null,u?u(l):l())};e.__R=i;var l=function(){if(!--r.__u){if(r.state.__e){var n=r.state.__e;r.__v.__k[0]=function n(t,e,r){return t&&(t.__v=null,t.__k=t.__k&&t.__k.map(function(t){return n(t,e,r)}),t.__c&&t.__c.__P===e&&(t.__e&&r.insertBefore(t.__e,t.__d),t.__c.__e=!0,t.__c.__P=r)),t}(n,n.__c.__P,n.__c.__O)}var t;for(r.setState({__e:r.__b=null});t=r.t.pop();)t.forceUpdate()}},f=!0===t.__h;r.__u++||f||r.setState({__e:r.__b=r.__v.__k[0]}),n.then(i,i)},L.prototype.componentWillUnmount=function(){this.t=[]},L.prototype.render=function(n,t){if(this.__b){if(this.__v.__k){var e=document.createElement("div"),r=this.__v.__k[0].__c;this.__v.__k[0]=function n(t,e,r){return t&&(t.__c&&t.__c.__H&&(t.__c.__H.__.forEach(function(n){"function"==typeof n.__c&&n.__c()}),t.__c.__H=null),null!=(t=C({},t)).__c&&(t.__c.__P===r&&(t.__c.__P=e),t.__c=null),t.__k=t.__k&&t.__k.map(function(t){return n(t,e,r)})),t}(this.__b,e,r.__O=r.__P)}this.__b=null}var u=t.__e&&Object(preact__WEBPACK_IMPORTED_MODULE_1__["createElement"])(preact__WEBPACK_IMPORTED_MODULE_1__["Fragment"],null,n.fallback);return u&&(u.__h=null),[Object(preact__WEBPACK_IMPORTED_MODULE_1__["createElement"])(preact__WEBPACK_IMPORTED_MODULE_1__["Fragment"],null,t.__e?null:n.children),u]};var M=function(n,t,e){if(++e[1]===e[0]&&n.o.delete(t),n.props.revealOrder&&("t"!==n.props.revealOrder[0]||!n.o.size))for(e=n.u;e;){for(;e.length>3;)e.pop()();if(e[1]<e[0])break;n.u=e=e[2]}};function T(n){return this.getChildContext=function(){return n.context},n.children}function j(n){var t=this,e=n.i;t.componentWillUnmount=function(){Object(preact__WEBPACK_IMPORTED_MODULE_1__["render"])(null,t.l),t.l=null,t.i=null},t.i&&t.i!==e&&t.componentWillUnmount(),n.__v?(t.l||(t.i=e,t.l={nodeType:1,parentNode:e,childNodes:[],appendChild:function(n){this.childNodes.push(n),t.i.appendChild(n)},insertBefore:function(n,e){this.childNodes.push(n),t.i.appendChild(n)},removeChild:function(n){this.childNodes.splice(this.childNodes.indexOf(n)>>>1,1),t.i.removeChild(n)}}),Object(preact__WEBPACK_IMPORTED_MODULE_1__["render"])(Object(preact__WEBPACK_IMPORTED_MODULE_1__["createElement"])(T,{context:t.context},n.__v),t.l)):t.l&&t.componentWillUnmount()}function I(n,t){return Object(preact__WEBPACK_IMPORTED_MODULE_1__["createElement"])(j,{__v:n,i:t})}(F.prototype=new preact__WEBPACK_IMPORTED_MODULE_1__["Component"]).__e=function(n){var t=this,e=U(t.__v),r=t.o.get(n);return r[0]++,function(u){var o=function(){t.props.revealOrder?(r.push(u),M(t,n,r)):u()};e?e(o):o()}},F.prototype.render=function(n){this.u=null,this.o=new Map;var t=Object(preact__WEBPACK_IMPORTED_MODULE_1__["toChildArray"])(n.children);n.revealOrder&&"b"===n.revealOrder[0]&&t.reverse();for(var e=t.length;e--;)this.o.set(t[e],this.u=[1,0,this.u]);return n.children},F.prototype.componentDidUpdate=F.prototype.componentDidMount=function(){var n=this;this.o.forEach(function(t,e){M(n,e,t)})};var W="undefined"!=typeof Symbol&&Symbol.for&&Symbol.for("react.element")||60103,P=/^(?:accent|alignment|arabic|baseline|cap|clip(?!PathU)|color|fill|flood|font|glyph(?!R)|horiz|marker(?!H|W|U)|overline|paint|stop|strikethrough|stroke|text(?!L)|underline|unicode|units|v|vector|vert|word|writing|x(?!C))[A-Z]/,V=function(n){return("undefined"!=typeof Symbol&&"symbol"==typeof Symbol()?/fil|che|rad/i:/fil|che|ra/i).test(n)};function z(n,t,e){return null==t.__k&&(t.textContent=""),Object(preact__WEBPACK_IMPORTED_MODULE_1__["render"])(n,t),"function"==typeof e&&e(),n?n.__c:null}function B(n,t,e){return Object(preact__WEBPACK_IMPORTED_MODULE_1__["hydrate"])(n,t),"function"==typeof e&&e(),n?n.__c:null}preact__WEBPACK_IMPORTED_MODULE_1__["Component"].prototype.isReactComponent={},["componentWillMount","componentWillReceiveProps","componentWillUpdate"].forEach(function(n){Object.defineProperty(preact__WEBPACK_IMPORTED_MODULE_1__["Component"].prototype,n,{configurable:!0,get:function(){return this["UNSAFE_"+n]},set:function(t){Object.defineProperty(this,n,{configurable:!0,writable:!0,value:t})}})});var H=preact__WEBPACK_IMPORTED_MODULE_1__["options"].event;function Z(){}function Y(){return this.cancelBubble}function $(){return this.defaultPrevented}preact__WEBPACK_IMPORTED_MODULE_1__["options"].event=function(n){return H&&(n=H(n)),n.persist=Z,n.isPropagationStopped=Y,n.isDefaultPrevented=$,n.nativeEvent=n};var q,G={configurable:!0,get:function(){return this.class}},J=preact__WEBPACK_IMPORTED_MODULE_1__["options"].vnode;preact__WEBPACK_IMPORTED_MODULE_1__["options"].vnode=function(n){var t=n.type,e=n.props,r=e;if("string"==typeof t){for(var u in r={},e){var o=e[u];"value"===u&&"defaultValue"in e&&null==o||("defaultValue"===u&&"value"in e&&null==e.value?u="value":"download"===u&&!0===o?o="":/ondoubleclick/i.test(u)?u="ondblclick":/^onchange(textarea|input)/i.test(u+t)&&!V(e.type)?u="oninput":/^on(Ani|Tra|Tou|BeforeInp)/.test(u)?u=u.toLowerCase():P.test(u)?u=u.replace(/[A-Z0-9]/,"-$&").toLowerCase():null===o&&(o=void 0),r[u]=o)}"select"==t&&r.multiple&&Array.isArray(r.value)&&(r.value=Object(preact__WEBPACK_IMPORTED_MODULE_1__["toChildArray"])(e.children).forEach(function(n){n.props.selected=-1!=r.value.indexOf(n.props.value)})),"select"==t&&null!=r.defaultValue&&(r.value=Object(preact__WEBPACK_IMPORTED_MODULE_1__["toChildArray"])(e.children).forEach(function(n){n.props.selected=r.multiple?-1!=r.defaultValue.indexOf(n.props.value):r.defaultValue==n.props.value})),n.props=r}t&&e.class!=e.className&&(G.enumerable="className"in e,null!=e.className&&(r.class=e.className),Object.defineProperty(r,"className",G)),n.$$typeof=W,J&&J(n)};var K=preact__WEBPACK_IMPORTED_MODULE_1__["options"].__r;preact__WEBPACK_IMPORTED_MODULE_1__["options"].__r=function(n){K&&K(n),q=n.__c};var Q={ReactCurrentDispatcher:{current:{readContext:function(n){return q.__n[n.__c].props.value}}}},X=1,nn=2,tn=3,en=4,rn=5;function un(n,t){return t()}var on="object"==typeof performance&&"function"==typeof performance.now?performance.now.bind(performance):function(){return Date.now()},ln="16.8.0";function fn(n){return preact__WEBPACK_IMPORTED_MODULE_1__["createElement"].bind(null,n)}function cn(n){return!!n&&n.$$typeof===W}function an(n){return cn(n)?preact__WEBPACK_IMPORTED_MODULE_1__["cloneElement"].apply(null,arguments):n}function sn(n){return!!n.__k&&(Object(preact__WEBPACK_IMPORTED_MODULE_1__["render"])(null,n),!0)}function hn(n){return n&&(n.base||1===n.nodeType&&n)||null}var pn=function(n,t){return n(t)},vn=preact__WEBPACK_IMPORTED_MODULE_1__["Fragment"];/* harmony default export */ __webpack_exports__["default"] = ({useState:preact_hooks__WEBPACK_IMPORTED_MODULE_0__["useState"],useReducer:preact_hooks__WEBPACK_IMPORTED_MODULE_0__["useReducer"],useEffect:preact_hooks__WEBPACK_IMPORTED_MODULE_0__["useEffect"],useLayoutEffect:preact_hooks__WEBPACK_IMPORTED_MODULE_0__["useLayoutEffect"],useRef:preact_hooks__WEBPACK_IMPORTED_MODULE_0__["useRef"],useImperativeHandle:preact_hooks__WEBPACK_IMPORTED_MODULE_0__["useImperativeHandle"],useMemo:preact_hooks__WEBPACK_IMPORTED_MODULE_0__["useMemo"],useCallback:preact_hooks__WEBPACK_IMPORTED_MODULE_0__["useCallback"],useContext:preact_hooks__WEBPACK_IMPORTED_MODULE_0__["useContext"],useDebugValue:preact_hooks__WEBPACK_IMPORTED_MODULE_0__["useDebugValue"],version:"16.8.0",Children:k,render:z,hydrate:B,unmountComponentAtNode:sn,createPortal:I,createElement:preact__WEBPACK_IMPORTED_MODULE_1__["createElement"],createContext:preact__WEBPACK_IMPORTED_MODULE_1__["createContext"],createFactory:fn,cloneElement:an,createRef:preact__WEBPACK_IMPORTED_MODULE_1__["createRef"],Fragment:preact__WEBPACK_IMPORTED_MODULE_1__["Fragment"],isValidElement:cn,findDOMNode:hn,Component:preact__WEBPACK_IMPORTED_MODULE_1__["Component"],PureComponent:E,memo:g,forwardRef:x,unstable_batchedUpdates:pn,StrictMode:preact__WEBPACK_IMPORTED_MODULE_1__["Fragment"],Suspense:L,SuspenseList:F,lazy:D,__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED:Q});
//# sourceMappingURL=compat.module.js.map


/***/ }),

/***/ "./node_modules/preact/dist/preact.module.js":
/*!***************************************************!*\
  !*** ./node_modules/preact/dist/preact.module.js ***!
  \***************************************************/
/*! exports provided: render, hydrate, createElement, h, Fragment, createRef, isValidElement, Component, cloneElement, createContext, toChildArray, options */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "render", function() { return N; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "hydrate", function() { return O; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createElement", function() { return a; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "h", function() { return a; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Fragment", function() { return y; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createRef", function() { return h; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isValidElement", function() { return l; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Component", function() { return p; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "cloneElement", function() { return S; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createContext", function() { return q; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "toChildArray", function() { return w; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "options", function() { return n; });
var n,l,u,i,t,o,r={},f=[],e=/acit|ex(?:s|g|n|p|$)|rph|grid|ows|mnc|ntw|ine[ch]|zoo|^ord|itera/i;function c(n,l){for(var u in l)n[u]=l[u];return n}function s(n){var l=n.parentNode;l&&l.removeChild(n)}function a(n,l,u){var i,t,o,r=arguments,f={};for(o in l)"key"==o?i=l[o]:"ref"==o?t=l[o]:f[o]=l[o];if(arguments.length>3)for(u=[u],o=3;o<arguments.length;o++)u.push(r[o]);if(null!=u&&(f.children=u),"function"==typeof n&&null!=n.defaultProps)for(o in n.defaultProps)void 0===f[o]&&(f[o]=n.defaultProps[o]);return v(n,f,i,t,null)}function v(l,u,i,t,o){var r={type:l,props:u,key:i,ref:t,__k:null,__:null,__b:0,__e:null,__d:void 0,__c:null,__h:null,constructor:void 0,__v:null==o?++n.__v:o};return null!=n.vnode&&n.vnode(r),r}function h(){return{current:null}}function y(n){return n.children}function p(n,l){this.props=n,this.context=l}function d(n,l){if(null==l)return n.__?d(n.__,n.__.__k.indexOf(n)+1):null;for(var u;l<n.__k.length;l++)if(null!=(u=n.__k[l])&&null!=u.__e)return u.__e;return"function"==typeof n.type?d(n):null}function _(n){var l,u;if(null!=(n=n.__)&&null!=n.__c){for(n.__e=n.__c.base=null,l=0;l<n.__k.length;l++)if(null!=(u=n.__k[l])&&null!=u.__e){n.__e=n.__c.base=u.__e;break}return _(n)}}function k(l){(!l.__d&&(l.__d=!0)&&u.push(l)&&!b.__r++||t!==n.debounceRendering)&&((t=n.debounceRendering)||i)(b)}function b(){for(var n;b.__r=u.length;)n=u.sort(function(n,l){return n.__v.__b-l.__v.__b}),u=[],n.some(function(n){var l,u,i,t,o,r;n.__d&&(o=(t=(l=n).__v).__e,(r=l.__P)&&(u=[],(i=c({},t)).__v=t.__v+1,I(r,t,i,l.__n,void 0!==r.ownerSVGElement,null!=t.__h?[o]:null,u,null==o?d(t):o,t.__h),T(u,t),t.__e!=o&&_(t)))})}function m(n,l,u,i,t,o,e,c,s,a){var h,p,_,k,b,m,w,A=i&&i.__k||f,P=A.length;for(u.__k=[],h=0;h<l.length;h++)if(null!=(k=u.__k[h]=null==(k=l[h])||"boolean"==typeof k?null:"string"==typeof k||"number"==typeof k||"bigint"==typeof k?v(null,k,null,null,k):Array.isArray(k)?v(y,{children:k},null,null,null):k.__b>0?v(k.type,k.props,k.key,null,k.__v):k)){if(k.__=u,k.__b=u.__b+1,null===(_=A[h])||_&&k.key==_.key&&k.type===_.type)A[h]=void 0;else for(p=0;p<P;p++){if((_=A[p])&&k.key==_.key&&k.type===_.type){A[p]=void 0;break}_=null}I(n,k,_=_||r,t,o,e,c,s,a),b=k.__e,(p=k.ref)&&_.ref!=p&&(w||(w=[]),_.ref&&w.push(_.ref,null,k),w.push(p,k.__c||b,k)),null!=b?(null==m&&(m=b),"function"==typeof k.type&&null!=k.__k&&k.__k===_.__k?k.__d=s=g(k,s,n):s=x(n,k,_,A,b,s),a||"option"!==u.type?"function"==typeof u.type&&(u.__d=s):n.value=""):s&&_.__e==s&&s.parentNode!=n&&(s=d(_))}for(u.__e=m,h=P;h--;)null!=A[h]&&("function"==typeof u.type&&null!=A[h].__e&&A[h].__e==u.__d&&(u.__d=d(i,h+1)),L(A[h],A[h]));if(w)for(h=0;h<w.length;h++)z(w[h],w[++h],w[++h])}function g(n,l,u){var i,t;for(i=0;i<n.__k.length;i++)(t=n.__k[i])&&(t.__=n,l="function"==typeof t.type?g(t,l,u):x(u,t,t,n.__k,t.__e,l));return l}function w(n,l){return l=l||[],null==n||"boolean"==typeof n||(Array.isArray(n)?n.some(function(n){w(n,l)}):l.push(n)),l}function x(n,l,u,i,t,o){var r,f,e;if(void 0!==l.__d)r=l.__d,l.__d=void 0;else if(null==u||t!=o||null==t.parentNode)n:if(null==o||o.parentNode!==n)n.appendChild(t),r=null;else{for(f=o,e=0;(f=f.nextSibling)&&e<i.length;e+=2)if(f==t)break n;n.insertBefore(t,o),r=o}return void 0!==r?r:t.nextSibling}function A(n,l,u,i,t){var o;for(o in u)"children"===o||"key"===o||o in l||C(n,o,null,u[o],i);for(o in l)t&&"function"!=typeof l[o]||"children"===o||"key"===o||"value"===o||"checked"===o||u[o]===l[o]||C(n,o,l[o],u[o],i)}function P(n,l,u){"-"===l[0]?n.setProperty(l,u):n[l]=null==u?"":"number"!=typeof u||e.test(l)?u:u+"px"}function C(n,l,u,i,t){var o;n:if("style"===l)if("string"==typeof u)n.style.cssText=u;else{if("string"==typeof i&&(n.style.cssText=i=""),i)for(l in i)u&&l in u||P(n.style,l,"");if(u)for(l in u)i&&u[l]===i[l]||P(n.style,l,u[l])}else if("o"===l[0]&&"n"===l[1])o=l!==(l=l.replace(/Capture$/,"")),l=l.toLowerCase()in n?l.toLowerCase().slice(2):l.slice(2),n.l||(n.l={}),n.l[l+o]=u,u?i||n.addEventListener(l,o?H:$,o):n.removeEventListener(l,o?H:$,o);else if("dangerouslySetInnerHTML"!==l){if(t)l=l.replace(/xlink[H:h]/,"h").replace(/sName$/,"s");else if("href"!==l&&"list"!==l&&"form"!==l&&"tabIndex"!==l&&"download"!==l&&l in n)try{n[l]=null==u?"":u;break n}catch(n){}"function"==typeof u||(null!=u&&(!1!==u||"a"===l[0]&&"r"===l[1])?n.setAttribute(l,u):n.removeAttribute(l))}}function $(l){this.l[l.type+!1](n.event?n.event(l):l)}function H(l){this.l[l.type+!0](n.event?n.event(l):l)}function I(l,u,i,t,o,r,f,e,s){var a,v,h,d,_,k,b,g,w,x,A,P=u.type;if(void 0!==u.constructor)return null;null!=i.__h&&(s=i.__h,e=u.__e=i.__e,u.__h=null,r=[e]),(a=n.__b)&&a(u);try{n:if("function"==typeof P){if(g=u.props,w=(a=P.contextType)&&t[a.__c],x=a?w?w.props.value:a.__:t,i.__c?b=(v=u.__c=i.__c).__=v.__E:("prototype"in P&&P.prototype.render?u.__c=v=new P(g,x):(u.__c=v=new p(g,x),v.constructor=P,v.render=M),w&&w.sub(v),v.props=g,v.state||(v.state={}),v.context=x,v.__n=t,h=v.__d=!0,v.__h=[]),null==v.__s&&(v.__s=v.state),null!=P.getDerivedStateFromProps&&(v.__s==v.state&&(v.__s=c({},v.__s)),c(v.__s,P.getDerivedStateFromProps(g,v.__s))),d=v.props,_=v.state,h)null==P.getDerivedStateFromProps&&null!=v.componentWillMount&&v.componentWillMount(),null!=v.componentDidMount&&v.__h.push(v.componentDidMount);else{if(null==P.getDerivedStateFromProps&&g!==d&&null!=v.componentWillReceiveProps&&v.componentWillReceiveProps(g,x),!v.__e&&null!=v.shouldComponentUpdate&&!1===v.shouldComponentUpdate(g,v.__s,x)||u.__v===i.__v){v.props=g,v.state=v.__s,u.__v!==i.__v&&(v.__d=!1),v.__v=u,u.__e=i.__e,u.__k=i.__k,u.__k.forEach(function(n){n&&(n.__=u)}),v.__h.length&&f.push(v);break n}null!=v.componentWillUpdate&&v.componentWillUpdate(g,v.__s,x),null!=v.componentDidUpdate&&v.__h.push(function(){v.componentDidUpdate(d,_,k)})}v.context=x,v.props=g,v.state=v.__s,(a=n.__r)&&a(u),v.__d=!1,v.__v=u,v.__P=l,a=v.render(v.props,v.state,v.context),v.state=v.__s,null!=v.getChildContext&&(t=c(c({},t),v.getChildContext())),h||null==v.getSnapshotBeforeUpdate||(k=v.getSnapshotBeforeUpdate(d,_)),A=null!=a&&a.type===y&&null==a.key?a.props.children:a,m(l,Array.isArray(A)?A:[A],u,i,t,o,r,f,e,s),v.base=u.__e,u.__h=null,v.__h.length&&f.push(v),b&&(v.__E=v.__=null),v.__e=!1}else null==r&&u.__v===i.__v?(u.__k=i.__k,u.__e=i.__e):u.__e=j(i.__e,u,i,t,o,r,f,s);(a=n.diffed)&&a(u)}catch(l){u.__v=null,(s||null!=r)&&(u.__e=e,u.__h=!!s,r[r.indexOf(e)]=null),n.__e(l,u,i)}}function T(l,u){n.__c&&n.__c(u,l),l.some(function(u){try{l=u.__h,u.__h=[],l.some(function(n){n.call(u)})}catch(l){n.__e(l,u.__v)}})}function j(n,l,u,i,t,o,e,c){var a,v,h,y,p=u.props,d=l.props,_=l.type,k=0;if("svg"===_&&(t=!0),null!=o)for(;k<o.length;k++)if((a=o[k])&&(a===n||(_?a.localName==_:3==a.nodeType))){n=a,o[k]=null;break}if(null==n){if(null===_)return document.createTextNode(d);n=t?document.createElementNS("http://www.w3.org/2000/svg",_):document.createElement(_,d.is&&d),o=null,c=!1}if(null===_)p===d||c&&n.data===d||(n.data=d);else{if(o=o&&f.slice.call(n.childNodes),v=(p=u.props||r).dangerouslySetInnerHTML,h=d.dangerouslySetInnerHTML,!c){if(null!=o)for(p={},y=0;y<n.attributes.length;y++)p[n.attributes[y].name]=n.attributes[y].value;(h||v)&&(h&&(v&&h.__html==v.__html||h.__html===n.innerHTML)||(n.innerHTML=h&&h.__html||""))}if(A(n,d,p,t,c),h)l.__k=[];else if(k=l.props.children,m(n,Array.isArray(k)?k:[k],l,u,i,t&&"foreignObject"!==_,o,e,n.firstChild,c),null!=o)for(k=o.length;k--;)null!=o[k]&&s(o[k]);c||("value"in d&&void 0!==(k=d.value)&&(k!==n.value||"progress"===_&&!k)&&C(n,"value",k,p.value,!1),"checked"in d&&void 0!==(k=d.checked)&&k!==n.checked&&C(n,"checked",k,p.checked,!1))}return n}function z(l,u,i){try{"function"==typeof l?l(u):l.current=u}catch(l){n.__e(l,i)}}function L(l,u,i){var t,o,r;if(n.unmount&&n.unmount(l),(t=l.ref)&&(t.current&&t.current!==l.__e||z(t,null,u)),i||"function"==typeof l.type||(i=null!=(o=l.__e)),l.__e=l.__d=void 0,null!=(t=l.__c)){if(t.componentWillUnmount)try{t.componentWillUnmount()}catch(l){n.__e(l,u)}t.base=t.__P=null}if(t=l.__k)for(r=0;r<t.length;r++)t[r]&&L(t[r],u,i);null!=o&&s(o)}function M(n,l,u){return this.constructor(n,u)}function N(l,u,i){var t,o,e;n.__&&n.__(l,u),o=(t="function"==typeof i)?null:i&&i.__k||u.__k,e=[],I(u,l=(!t&&i||u).__k=a(y,null,[l]),o||r,r,void 0!==u.ownerSVGElement,!t&&i?[i]:o?null:u.firstChild?f.slice.call(u.childNodes):null,e,!t&&i?i:o?o.__e:u.firstChild,t),T(e,l)}function O(n,l){N(n,l,O)}function S(n,l,u){var i,t,o,r=arguments,f=c({},n.props);for(o in l)"key"==o?i=l[o]:"ref"==o?t=l[o]:f[o]=l[o];if(arguments.length>3)for(u=[u],o=3;o<arguments.length;o++)u.push(r[o]);return null!=u&&(f.children=u),v(n.type,f,i||n.key,t||n.ref,null)}function q(n,l){var u={__c:l="__cC"+o++,__:n,Consumer:function(n,l){return n.children(l)},Provider:function(n){var u,i;return this.getChildContext||(u=[],(i={})[l]=this,this.getChildContext=function(){return i},this.shouldComponentUpdate=function(n){this.props.value!==n.value&&u.some(k)},this.sub=function(n){u.push(n);var l=n.componentWillUnmount;n.componentWillUnmount=function(){u.splice(u.indexOf(n),1),l&&l.call(n)}}),n.children}};return u.Provider.__=u.Consumer.contextType=u}n={__e:function(n,l){for(var u,i,t;l=l.__;)if((u=l.__c)&&!u.__)try{if((i=u.constructor)&&null!=i.getDerivedStateFromError&&(u.setState(i.getDerivedStateFromError(n)),t=u.__d),null!=u.componentDidCatch&&(u.componentDidCatch(n),t=u.__d),t)return u.__E=u}catch(l){n=l}throw n},__v:0},l=function(n){return null!=n&&void 0===n.constructor},p.prototype.setState=function(n,l){var u;u=null!=this.__s&&this.__s!==this.state?this.__s:this.__s=c({},this.state),"function"==typeof n&&(n=n(c({},u),this.props)),n&&c(u,n),null!=n&&this.__v&&(l&&this.__h.push(l),k(this))},p.prototype.forceUpdate=function(n){this.__v&&(this.__e=!0,n&&this.__h.push(n),k(this))},p.prototype.render=y,u=[],i="function"==typeof Promise?Promise.prototype.then.bind(Promise.resolve()):setTimeout,b.__r=0,o=0;
//# sourceMappingURL=preact.module.js.map


/***/ }),

/***/ "./node_modules/preact/hooks/dist/hooks.module.js":
/*!********************************************************!*\
  !*** ./node_modules/preact/hooks/dist/hooks.module.js ***!
  \********************************************************/
/*! exports provided: useState, useReducer, useEffect, useLayoutEffect, useRef, useImperativeHandle, useMemo, useCallback, useContext, useDebugValue, useErrorBoundary */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "useState", function() { return l; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "useReducer", function() { return p; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "useEffect", function() { return y; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "useLayoutEffect", function() { return h; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "useRef", function() { return s; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "useImperativeHandle", function() { return _; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "useMemo", function() { return d; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "useCallback", function() { return A; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "useContext", function() { return F; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "useDebugValue", function() { return T; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "useErrorBoundary", function() { return q; });
/* harmony import */ var preact__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! preact */ "./node_modules/preact/dist/preact.module.js");
var t,u,r,o=0,i=[],c=preact__WEBPACK_IMPORTED_MODULE_0__["options"].__b,f=preact__WEBPACK_IMPORTED_MODULE_0__["options"].__r,e=preact__WEBPACK_IMPORTED_MODULE_0__["options"].diffed,a=preact__WEBPACK_IMPORTED_MODULE_0__["options"].__c,v=preact__WEBPACK_IMPORTED_MODULE_0__["options"].unmount;function m(t,r){preact__WEBPACK_IMPORTED_MODULE_0__["options"].__h&&preact__WEBPACK_IMPORTED_MODULE_0__["options"].__h(u,t,o||r),o=0;var i=u.__H||(u.__H={__:[],__h:[]});return t>=i.__.length&&i.__.push({}),i.__[t]}function l(n){return o=1,p(w,n)}function p(n,r,o){var i=m(t++,2);return i.t=n,i.__c||(i.__=[o?o(r):w(void 0,r),function(n){var t=i.t(i.__[0],n);i.__[0]!==t&&(i.__=[t,i.__[1]],i.__c.setState({}))}],i.__c=u),i.__}function y(r,o){var i=m(t++,3);!preact__WEBPACK_IMPORTED_MODULE_0__["options"].__s&&k(i.__H,o)&&(i.__=r,i.__H=o,u.__H.__h.push(i))}function h(r,o){var i=m(t++,4);!preact__WEBPACK_IMPORTED_MODULE_0__["options"].__s&&k(i.__H,o)&&(i.__=r,i.__H=o,u.__h.push(i))}function s(n){return o=5,d(function(){return{current:n}},[])}function _(n,t,u){o=6,h(function(){"function"==typeof n?n(t()):n&&(n.current=t())},null==u?u:u.concat(n))}function d(n,u){var r=m(t++,7);return k(r.__H,u)&&(r.__=n(),r.__H=u,r.__h=n),r.__}function A(n,t){return o=8,d(function(){return n},t)}function F(n){var r=u.context[n.__c],o=m(t++,9);return o.__c=n,r?(null==o.__&&(o.__=!0,r.sub(u)),r.props.value):n.__}function T(t,u){preact__WEBPACK_IMPORTED_MODULE_0__["options"].useDebugValue&&preact__WEBPACK_IMPORTED_MODULE_0__["options"].useDebugValue(u?u(t):t)}function q(n){var r=m(t++,10),o=l();return r.__=n,u.componentDidCatch||(u.componentDidCatch=function(n){r.__&&r.__(n),o[1](n)}),[o[0],function(){o[1](void 0)}]}function x(){i.forEach(function(t){if(t.__P)try{t.__H.__h.forEach(g),t.__H.__h.forEach(j),t.__H.__h=[]}catch(u){t.__H.__h=[],preact__WEBPACK_IMPORTED_MODULE_0__["options"].__e(u,t.__v)}}),i=[]}preact__WEBPACK_IMPORTED_MODULE_0__["options"].__b=function(n){u=null,c&&c(n)},preact__WEBPACK_IMPORTED_MODULE_0__["options"].__r=function(n){f&&f(n),t=0;var r=(u=n.__c).__H;r&&(r.__h.forEach(g),r.__h.forEach(j),r.__h=[])},preact__WEBPACK_IMPORTED_MODULE_0__["options"].diffed=function(t){e&&e(t);var o=t.__c;o&&o.__H&&o.__H.__h.length&&(1!==i.push(o)&&r===preact__WEBPACK_IMPORTED_MODULE_0__["options"].requestAnimationFrame||((r=preact__WEBPACK_IMPORTED_MODULE_0__["options"].requestAnimationFrame)||function(n){var t,u=function(){clearTimeout(r),b&&cancelAnimationFrame(t),setTimeout(n)},r=setTimeout(u,100);b&&(t=requestAnimationFrame(u))})(x)),u=void 0},preact__WEBPACK_IMPORTED_MODULE_0__["options"].__c=function(t,u){u.some(function(t){try{t.__h.forEach(g),t.__h=t.__h.filter(function(n){return!n.__||j(n)})}catch(r){u.some(function(n){n.__h&&(n.__h=[])}),u=[],preact__WEBPACK_IMPORTED_MODULE_0__["options"].__e(r,t.__v)}}),a&&a(t,u)},preact__WEBPACK_IMPORTED_MODULE_0__["options"].unmount=function(t){v&&v(t);var u=t.__c;if(u&&u.__H)try{u.__H.__.forEach(g)}catch(t){preact__WEBPACK_IMPORTED_MODULE_0__["options"].__e(t,u.__v)}};var b="function"==typeof requestAnimationFrame;function g(n){var t=u;"function"==typeof n.__c&&n.__c(),u=t}function j(n){var t=u;n.__c=n.__(),u=t}function k(n,t){return!n||n.length!==t.length||t.some(function(t,u){return t!==n[u]})}function w(n,t){return"function"==typeof t?t(n):t}
//# sourceMappingURL=hooks.module.js.map


/***/ }),

/***/ "./node_modules/process/browser.js":
/*!*****************************************!*\
  !*** ./node_modules/process/browser.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports) {

// shim for using process in browser
var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout () {
    throw new Error('clearTimeout has not been defined');
}
(function () {
    try {
        if (typeof setTimeout === 'function') {
            cachedSetTimeout = setTimeout;
        } else {
            cachedSetTimeout = defaultSetTimout;
        }
    } catch (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === 'function') {
            cachedClearTimeout = clearTimeout;
        } else {
            cachedClearTimeout = defaultClearTimeout;
        }
    } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
    }
} ())
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
        //normal enviroments in sane situations
        return setTimeout(fun, 0);
    }
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch(e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch(e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }


}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
        //normal enviroments in sane situations
        return clearTimeout(marker);
    }
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }



}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;

process.listeners = function (name) { return [] }

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };


/***/ }),

/***/ "./node_modules/react-hook-form/dist/react-hook-form.es.js":
/*!*****************************************************************!*\
  !*** ./node_modules/react-hook-form/dist/react-hook-form.es.js ***!
  \*****************************************************************/
/*! exports provided: Controller, ErrorMessage, FormContext, useFieldArray, useForm, useFormContext */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Controller", function() { return Controller; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ErrorMessage", function() { return ErrorMessage; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "FormContext", function() { return FormContext; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "useFieldArray", function() { return useFieldArray; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "useForm", function() { return useForm; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "useFormContext", function() { return useFormContext; });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ "./node_modules/preact/compat/dist/compat.module.js");


var isNullOrUndefined = (value) => value == null;

var isArray = (value) => Array.isArray(value);

const isObjectType = (value) => typeof value === 'object';
var isObject = (value) => !isNullOrUndefined(value) && !isArray(value) && isObjectType(value);

var isHTMLElement = (value) => isObject(value) && value.nodeType === Node.ELEMENT_NODE;

const VALIDATION_MODE = {
    onBlur: 'onBlur',
    onChange: 'onChange',
    onSubmit: 'onSubmit',
};
const VALUE = 'value';
const UNDEFINED = 'undefined';
const EVENTS = {
    BLUR: 'blur',
    CHANGE: 'change',
    INPUT: 'input',
};
const SELECT = 'select';
const INPUT_VALIDATION_RULES = {
    max: 'max',
    min: 'min',
    maxLength: 'maxLength',
    minLength: 'minLength',
    pattern: 'pattern',
    required: 'required',
    validate: 'validate',
};
const REGEX_IS_DEEP_PROP = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/;
const REGEX_IS_PLAIN_PROP = /^\w*$/;
const REGEX_PROP_NAME = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;
const REGEX_ESCAPE_CHAR = /\\(\\)?/g;
const REGEX_ARRAY_FIELD_INDEX = /[\d+]/g;

function attachEventListeners({ field: { ref }, handleChange, isRadioOrCheckbox, }) {
    if (isHTMLElement(ref) && handleChange) {
        ref.addEventListener(isRadioOrCheckbox ? EVENTS.CHANGE : EVENTS.INPUT, handleChange);
        ref.addEventListener(EVENTS.BLUR, handleChange);
    }
}

var isKey = (value) => !isArray(value) &&
    (REGEX_IS_PLAIN_PROP.test(value) || !REGEX_IS_DEEP_PROP.test(value));

var stringToPath = (string) => {
    const result = [];
    string.replace(REGEX_PROP_NAME, (match, number, quote, string) => {
        result.push(quote ? string.replace(REGEX_ESCAPE_CHAR, '$1') : number || match);
    });
    return result;
};

function set(object, path, value) {
    let index = -1;
    const tempPath = isKey(path) ? [path] : stringToPath(path);
    const length = tempPath.length;
    const lastIndex = length - 1;
    while (++index < length) {
        const key = tempPath[index];
        let newValue = value;
        if (index !== lastIndex) {
            const objValue = object[key];
            newValue =
                isObject(objValue) || isArray(objValue)
                    ? objValue
                    : !isNaN(+tempPath[index + 1])
                        ? []
                        : {};
        }
        object[key] = newValue;
        object = object[key];
    }
    return object;
}

var transformToNestObject = (data) => Object.entries(data).reduce((previous, [key, value]) => {
    if (!isKey(key)) {
        set(previous, key, value);
        return previous;
    }
    return Object.assign(Object.assign({}, previous), { [key]: value });
}, {});

var isUndefined = (val) => val === undefined;

var get = (obj, path, defaultValue) => {
    const result = path
        .split(/[,[\].]+?/)
        .filter(Boolean)
        .reduce((result, key) => (isNullOrUndefined(result) ? result : result[key]), obj);
    return isUndefined(result) || result === obj
        ? isUndefined(obj[path])
            ? defaultValue
            : obj[path]
        : result;
};

var focusOnErrorField = (fields, fieldErrors) => {
    for (const key in fields) {
        if (get(fieldErrors, key)) {
            const field = fields[key];
            if (field) {
                if (field.ref.focus) {
                    field.ref.focus();
                    break;
                }
                else if (field.options) {
                    field.options[0].ref.focus();
                    break;
                }
            }
        }
    }
};

var removeAllEventListeners = (ref, validateWithStateUpdate) => {
    if (isHTMLElement(ref) && ref.removeEventListener) {
        ref.removeEventListener(EVENTS.INPUT, validateWithStateUpdate);
        ref.removeEventListener(EVENTS.CHANGE, validateWithStateUpdate);
        ref.removeEventListener(EVENTS.BLUR, validateWithStateUpdate);
    }
};

var isRadioInput = (element) => element.type === 'radio';

var isCheckBoxInput = (element) => element.type === 'checkbox';

function isDetached(element) {
    if (!element) {
        return true;
    }
    if (!(element instanceof HTMLElement) ||
        element.nodeType === Node.DOCUMENT_NODE) {
        return false;
    }
    return isDetached(element.parentNode);
}

var isEmptyObject = (value) => isObject(value) && !Object.keys(value).length;

function castPath(value) {
    return isArray(value) ? value : stringToPath(value);
}
function baseGet(object, path) {
    const updatePath = isKey(path) ? [path] : castPath(path);
    const length = path.length;
    let index = 0;
    while (index < length) {
        object = isUndefined(object) ? index++ : object[updatePath[index++]];
    }
    return index == length ? object : undefined;
}
function baseSlice(array, start, end) {
    let index = -1;
    let length = array.length;
    if (start < 0) {
        start = -start > length ? 0 : length + start;
    }
    end = end > length ? length : end;
    if (end < 0) {
        end += length;
    }
    length = start > end ? 0 : end - start;
    const result = Array(length);
    while (++index < length) {
        result[index] = array[index + start];
    }
    return result;
}
function parent(object, path) {
    return path.length == 1 ? object : baseGet(object, baseSlice(path, 0, -1));
}
function baseUnset(object, path) {
    const updatePath = isKey(path) ? [path] : castPath(path);
    const childObject = parent(object, updatePath);
    const key = updatePath[updatePath.length - 1];
    const result = !(childObject != null) || delete childObject[key];
    let previousObjRef = undefined;
    for (let k = 0; k < updatePath.slice(0, -1).length; k++) {
        let index = -1;
        let objectRef = undefined;
        const currentPaths = updatePath.slice(0, -(k + 1));
        const currentPathsLength = currentPaths.length - 1;
        if (k > 0) {
            previousObjRef = object;
        }
        while (++index < currentPaths.length) {
            const item = currentPaths[index];
            objectRef = objectRef ? objectRef[item] : object[item];
            if (currentPathsLength === index) {
                if ((isObject(objectRef) && isEmptyObject(objectRef)) ||
                    (isArray(objectRef) &&
                        !objectRef.filter((data) => isObject(data) && !isEmptyObject(data))
                            .length)) {
                    previousObjRef ? delete previousObjRef[item] : delete object[item];
                }
            }
            previousObjRef = objectRef;
        }
    }
    return result;
}
function unset(object, paths) {
    paths.forEach((path) => {
        baseUnset(object, path);
    });
    return object;
}

const isSameRef = (fieldValue, ref) => fieldValue && fieldValue.ref === ref;
function findRemovedFieldAndRemoveListener(fields, handleChange, field, forceDelete) {
    const { ref, ref: { name, type }, mutationWatcher, } = field;
    const fieldValue = fields[name];
    if (!type) {
        delete fields[name];
        return;
    }
    if ((isRadioInput(ref) || isCheckBoxInput(ref)) && fieldValue) {
        const { options } = fieldValue;
        if (isArray(options) && options.length) {
            options.filter(Boolean).forEach((option, index) => {
                const { ref, mutationWatcher } = option;
                if ((ref && isDetached(ref) && isSameRef(option, ref)) || forceDelete) {
                    removeAllEventListeners(ref, handleChange);
                    if (mutationWatcher) {
                        mutationWatcher.disconnect();
                    }
                    unset(options, [`[${index}]`]);
                }
            });
            if (options && !options.filter(Boolean).length) {
                delete fields[name];
            }
        }
        else {
            delete fields[name];
        }
    }
    else if ((isDetached(ref) && isSameRef(fieldValue, ref)) || forceDelete) {
        removeAllEventListeners(ref, handleChange);
        if (mutationWatcher) {
            mutationWatcher.disconnect();
        }
        delete fields[name];
    }
}

const defaultReturn = {
    isValid: false,
    value: '',
};
var getRadioValue = (options) => isArray(options)
    ? options.reduce((previous, option) => option && option.ref.checked
        ? {
            isValid: true,
            value: option.ref.value,
        }
        : previous, defaultReturn)
    : defaultReturn;

var getMultipleSelectValue = (options) => [...options]
    .filter(({ selected }) => selected)
    .map(({ value }) => value);

var isFileInput = (element) => element.type === 'file';

var isMultipleSelect = (element) => element.type === `${SELECT}-multiple`;

var isEmptyString = (value) => value === '';

const defaultResult = {
    value: false,
    isValid: false,
};
const validResult = { value: true, isValid: true };
var getCheckboxValue = (options) => {
    if (isArray(options)) {
        if (options.length > 1) {
            const values = options
                .filter((option) => option && option.ref.checked)
                .map(({ ref: { value } }) => value);
            return { value: values, isValid: !!values.length };
        }
        const { checked, value, attributes } = options[0].ref;
        return checked
            ? attributes && !isUndefined(attributes.value)
                ? isUndefined(value) || isEmptyString(value)
                    ? validResult
                    : { value: value, isValid: true }
                : validResult
            : defaultResult;
    }
    return defaultResult;
};

function getFieldValue(fields, ref) {
    const { name, value } = ref;
    const field = fields[name];
    if (isFileInput(ref)) {
        return ref.files;
    }
    if (isRadioInput(ref)) {
        return field ? getRadioValue(field.options).value : '';
    }
    if (isMultipleSelect(ref)) {
        return getMultipleSelectValue(ref.options);
    }
    if (isCheckBoxInput(ref)) {
        return field ? getCheckboxValue(field.options).value : false;
    }
    return value;
}

var isString = (value) => typeof value === 'string';

var getFieldsValues = (fields, search) => {
    const output = {};
    for (const name in fields) {
        if (isUndefined(search) ||
            (isString(search)
                ? name.startsWith(search)
                : isArray(search)
                    ? search.find((data) => name.startsWith(data))
                    : search && search.nest)) {
            output[name] = getFieldValue(fields, fields[name].ref);
        }
    }
    return output;
};

var compareObject = (objectA = {}, objectB = {}) => {
    const objectAKeys = Object.keys(objectA);
    const objectBKeys = Object.keys(objectB);
    return (objectAKeys.length === objectBKeys.length &&
        objectAKeys.every((key) => objectB[key] && objectB[key] === objectA[key]));
};

var isSameError = (error, { type, types, message }) => isObject(error) &&
    error.type === type &&
    error.message === message &&
    compareObject(error.types, types);

function shouldRenderBasedOnError({ errors, name, error, validFields, fieldsWithValidation, }) {
    const isFieldValid = isEmptyObject(error);
    const isFormValid = isEmptyObject(errors);
    const currentFieldError = get(error, name);
    const existFieldError = get(errors, name);
    if ((isFieldValid && validFields.has(name)) ||
        (existFieldError && existFieldError.isManual)) {
        return false;
    }
    if (isFormValid !== isFieldValid ||
        (!isFormValid && !existFieldError) ||
        (isFieldValid && fieldsWithValidation.has(name) && !validFields.has(name))) {
        return true;
    }
    return currentFieldError && !isSameError(existFieldError, currentFieldError);
}

var isRegex = (value) => value instanceof RegExp;

var getValueAndMessage = (validationData) => {
    const isValueMessage = (value) => isObject(value) && !isRegex(value);
    return isValueMessage(validationData)
        ? validationData
        : {
            value: validationData,
            message: '',
        };
};

var isFunction = (value) => typeof value === 'function';

var isBoolean = (value) => typeof value === 'boolean';

var isMessage = (value) => isString(value) || (isObject(value) && Object(react__WEBPACK_IMPORTED_MODULE_0__["isValidElement"])(value));

function getValidateError(result, ref, type = 'validate') {
    if (isMessage(result) || (isBoolean(result) && !result)) {
        return {
            type,
            message: isMessage(result) ? result : '',
            ref,
        };
    }
}

var appendErrors = (name, validateAllFieldCriteria, errors, type, message) => {
    if (validateAllFieldCriteria) {
        const error = errors[name];
        return Object.assign(Object.assign({}, error), { types: Object.assign(Object.assign({}, (error && error.types ? error.types : {})), { [type]: message || true }) });
    }
    return {};
};

var validateField = async (fieldsRef, validateAllFieldCriteria, { ref, ref: { type, value, name }, options, required, maxLength, minLength, min, max, pattern, validate, }) => {
    var _a;
    const fields = fieldsRef.current;
    const error = {};
    const isRadio = isRadioInput(ref);
    const isCheckBox = isCheckBoxInput(ref);
    const isRadioOrCheckbox = isRadio || isCheckBox;
    const isEmpty = isEmptyString(value);
    const appendErrorsCurry = appendErrors.bind(null, name, validateAllFieldCriteria, error);
    const getMinMaxMessage = (exceedMax, maxLengthMessage, minLengthMessage, maxType = INPUT_VALIDATION_RULES.maxLength, minType = INPUT_VALIDATION_RULES.minLength) => {
        const message = exceedMax ? maxLengthMessage : minLengthMessage;
        error[name] = Object.assign({ type: exceedMax ? maxType : minType, message,
            ref }, (exceedMax
            ? appendErrorsCurry(maxType, message)
            : appendErrorsCurry(minType, message)));
        if (!validateAllFieldCriteria) {
            return error;
        }
    };
    if (required &&
        ((!isRadio && !isCheckBox && (isEmpty || isNullOrUndefined(value))) ||
            (isBoolean(value) && !value) ||
            (isCheckBox && !getCheckboxValue(options).isValid) ||
            (isRadio && !getRadioValue(options).isValid))) {
        const { value: requiredValue, message: requiredMessage } = isMessage(required)
            ? { value: !!required, message: required }
            : getValueAndMessage(required);
        if (requiredValue) {
            error[name] = Object.assign({ type: INPUT_VALIDATION_RULES.required, message: requiredMessage, ref: isRadioOrCheckbox ? (_a = fields[name].options) === null || _a === void 0 ? void 0 : _a[0].ref : ref }, appendErrorsCurry(INPUT_VALIDATION_RULES.required, requiredMessage));
            if (!validateAllFieldCriteria) {
                return error;
            }
        }
    }
    if (!isNullOrUndefined(min) || !isNullOrUndefined(max)) {
        let exceedMax;
        let exceedMin;
        const { value: maxValue, message: maxMessage } = getValueAndMessage(max);
        const { value: minValue, message: minMessage } = getValueAndMessage(min);
        if (type === 'number' || (!type && !isNaN(value))) {
            const valueNumber = ref.valueAsNumber || parseFloat(value);
            if (!isNullOrUndefined(maxValue)) {
                exceedMax = valueNumber > maxValue;
            }
            if (!isNullOrUndefined(minValue)) {
                exceedMin = valueNumber < minValue;
            }
        }
        else {
            const valueDate = ref.valueAsDate || new Date(value);
            if (isString(maxValue)) {
                exceedMax = valueDate > new Date(maxValue);
            }
            if (isString(minValue)) {
                exceedMin = valueDate < new Date(minValue);
            }
        }
        if (exceedMax || exceedMin) {
            getMinMaxMessage(!!exceedMax, maxMessage, minMessage, INPUT_VALIDATION_RULES.max, INPUT_VALIDATION_RULES.min);
            if (!validateAllFieldCriteria) {
                return error;
            }
        }
    }
    if (isString(value) && !isEmpty && (maxLength || minLength)) {
        const { value: maxLengthValue, message: maxLengthMessage, } = getValueAndMessage(maxLength);
        const { value: minLengthValue, message: minLengthMessage, } = getValueAndMessage(minLength);
        const inputLength = value.toString().length;
        const exceedMax = !isNullOrUndefined(maxLengthValue) && inputLength > maxLengthValue;
        const exceedMin = !isNullOrUndefined(minLengthValue) && inputLength < minLengthValue;
        if (exceedMax || exceedMin) {
            getMinMaxMessage(!!exceedMax, maxLengthMessage, minLengthMessage);
            if (!validateAllFieldCriteria) {
                return error;
            }
        }
    }
    if (pattern && !isEmpty) {
        const { value: patternValue, message: patternMessage } = getValueAndMessage(pattern);
        if (isRegex(patternValue) && !patternValue.test(value)) {
            error[name] = Object.assign({ type: INPUT_VALIDATION_RULES.pattern, message: patternMessage, ref }, appendErrorsCurry(INPUT_VALIDATION_RULES.pattern, patternMessage));
            if (!validateAllFieldCriteria) {
                return error;
            }
        }
    }
    if (validate) {
        const fieldValue = getFieldValue(fields, ref);
        const validateRef = isRadioOrCheckbox && options ? options[0].ref : ref;
        if (isFunction(validate)) {
            const result = await validate(fieldValue);
            const validateError = getValidateError(result, validateRef);
            if (validateError) {
                error[name] = Object.assign(Object.assign({}, validateError), appendErrorsCurry(INPUT_VALIDATION_RULES.validate, validateError.message));
                if (!validateAllFieldCriteria) {
                    return error;
                }
            }
        }
        else if (isObject(validate)) {
            let validationResult = {};
            for (const [key, validateFunction] of Object.entries(validate)) {
                if (!isEmptyObject(validationResult) && !validateAllFieldCriteria) {
                    break;
                }
                const validateResult = await validateFunction(fieldValue);
                const validateError = getValidateError(validateResult, validateRef, key);
                if (validateError) {
                    validationResult = Object.assign(Object.assign({}, validateError), appendErrorsCurry(key, validateError.message));
                    if (validateAllFieldCriteria) {
                        error[name] = validationResult;
                    }
                }
            }
            if (!isEmptyObject(validationResult)) {
                error[name] = Object.assign({ ref: validateRef }, validationResult);
                if (!validateAllFieldCriteria) {
                    return error;
                }
            }
        }
    }
    return error;
};

const parseErrorSchema = (error, validateAllFieldCriteria) => isArray(error.inner)
    ? error.inner.reduce((previous, { path, message, type }) => (Object.assign(Object.assign({}, previous), (path
        ? previous[path] && validateAllFieldCriteria
            ? {
                [path]: appendErrors(path, validateAllFieldCriteria, previous, type, message),
            }
            : {
                [path]: previous[path] || Object.assign({ message,
                    type }, (validateAllFieldCriteria
                    ? {
                        types: { [type]: message || true },
                    }
                    : {})),
            }
        : {}))), {})
    : {
        [error.path]: { message: error.message, type: error.type },
    };
async function validateWithSchema(validationSchema, validateAllFieldCriteria, data, validationResolver, context) {
    if (validationResolver) {
        return validationResolver(data, context);
    }
    try {
        return {
            values: await validationSchema.validate(data, {
                abortEarly: false,
                context,
            }),
            errors: {},
        };
    }
    catch (e) {
        return {
            values: {},
            errors: transformToNestObject(parseErrorSchema(e, validateAllFieldCriteria)),
        };
    }
}

var isPrimitive = (value) => isNullOrUndefined(value) || !isObjectType(value);

const getPath = (path, values) => {
    const getInnerPath = (value, key, isObject) => {
        const pathWithIndex = isObject ? `${path}.${key}` : `${path}[${key}]`;
        return isPrimitive(value) ? pathWithIndex : getPath(pathWithIndex, value);
    };
    return isArray(values)
        ? values.map((value, key) => getInnerPath(value, key))
        : Object.entries(values).map(([key, value]) => getInnerPath(value, key, true));
};
var getPath$1 = (parentPath, value) => getPath(parentPath, value).flat(Infinity);

var assignWatchFields = (fieldValues, fieldName, watchFields, inputValue, isSingleField) => {
    let value;
    watchFields.add(fieldName);
    if (isEmptyObject(fieldValues)) {
        value = undefined;
    }
    else if (!isUndefined(fieldValues[fieldName])) {
        value = fieldValues[fieldName];
        watchFields.add(fieldName);
    }
    else {
        value = get(transformToNestObject(fieldValues), fieldName);
        if (!isUndefined(value)) {
            getPath$1(fieldName, value).forEach((name) => watchFields.add(name));
        }
    }
    return isUndefined(value)
        ? isSingleField
            ? inputValue
            : get(inputValue, fieldName)
        : value;
};

var skipValidation = ({ isOnChange, hasError, isBlurEvent, isOnSubmit, isReValidateOnSubmit, isOnBlur, isReValidateOnBlur, isSubmitted, }) => (isOnChange && isBlurEvent) ||
    (isOnSubmit && isReValidateOnSubmit) ||
    (isOnSubmit && !isSubmitted) ||
    (isOnBlur && !isBlurEvent && !hasError) ||
    (isReValidateOnBlur && !isBlurEvent && hasError) ||
    (isReValidateOnSubmit && isSubmitted);

var getFieldArrayParentName = (name) => name.substring(0, name.indexOf('['));

var getFieldValueByName = (fields, name) => {
    const results = transformToNestObject(getFieldsValues(fields));
    return name ? get(results, name, results) : results;
};

function getIsFieldsDifferent(referenceArray, differenceArray) {
    let isMatch = false;
    if (!isArray(referenceArray) ||
        !isArray(differenceArray) ||
        referenceArray.length !== differenceArray.length) {
        return true;
    }
    for (let i = 0; i < referenceArray.length; i++) {
        if (isMatch) {
            break;
        }
        const dataA = referenceArray[i];
        const dataB = differenceArray[i];
        if (isUndefined(dataB) ||
            Object.keys(dataA).length !== Object.keys(dataB).length) {
            isMatch = true;
            break;
        }
        for (const key in dataA) {
            if (dataA[key] !== dataB[key]) {
                isMatch = true;
                break;
            }
        }
    }
    return isMatch;
}

const isMatchFieldArrayName = (name, searchName) => RegExp(`^${searchName}[\\d+]`.replace(/\[/g, '\\[').replace(/\]/g, '\\]')).test(name);
var isNameInFieldArray = (names, name) => [...names].some((current) => isMatchFieldArrayName(name, current));

var isSelectInput = (element) => element.type === `${SELECT}-one`;

function onDomRemove(element, onDetachCallback) {
    const observer = new MutationObserver(() => {
        if (isDetached(element)) {
            observer.disconnect();
            onDetachCallback();
        }
    });
    observer.observe(window.document, {
        childList: true,
        subtree: true,
    });
    return observer;
}

var modeChecker = (mode) => ({
    isOnSubmit: !mode || mode === VALIDATION_MODE.onSubmit,
    isOnBlur: mode === VALIDATION_MODE.onBlur,
    isOnChange: mode === VALIDATION_MODE.onChange,
});

var isRadioOrCheckboxFunction = (ref) => isRadioInput(ref) || isCheckBoxInput(ref);

function useForm({ mode = VALIDATION_MODE.onSubmit, reValidateMode = VALIDATION_MODE.onChange, validationSchema, validationResolver, validationContext, defaultValues = {}, submitFocusError = true, validateCriteriaMode, } = {}) {
    const fieldsRef = Object(react__WEBPACK_IMPORTED_MODULE_0__["useRef"])({});
    const errorsRef = Object(react__WEBPACK_IMPORTED_MODULE_0__["useRef"])({});
    const touchedFieldsRef = Object(react__WEBPACK_IMPORTED_MODULE_0__["useRef"])({});
    const fieldArrayDefaultValues = Object(react__WEBPACK_IMPORTED_MODULE_0__["useRef"])({});
    const watchFieldsRef = Object(react__WEBPACK_IMPORTED_MODULE_0__["useRef"])(new Set());
    const dirtyFieldsRef = Object(react__WEBPACK_IMPORTED_MODULE_0__["useRef"])(new Set());
    const fieldsWithValidationRef = Object(react__WEBPACK_IMPORTED_MODULE_0__["useRef"])(new Set());
    const validFieldsRef = Object(react__WEBPACK_IMPORTED_MODULE_0__["useRef"])(new Set());
    const isValidRef = Object(react__WEBPACK_IMPORTED_MODULE_0__["useRef"])(true);
    const defaultValuesRef = Object(react__WEBPACK_IMPORTED_MODULE_0__["useRef"])(defaultValues);
    const defaultValuesAtRenderRef = Object(react__WEBPACK_IMPORTED_MODULE_0__["useRef"])({});
    const isUnMount = Object(react__WEBPACK_IMPORTED_MODULE_0__["useRef"])(false);
    const isWatchAllRef = Object(react__WEBPACK_IMPORTED_MODULE_0__["useRef"])(false);
    const isSubmittedRef = Object(react__WEBPACK_IMPORTED_MODULE_0__["useRef"])(false);
    const isDirtyRef = Object(react__WEBPACK_IMPORTED_MODULE_0__["useRef"])(false);
    const submitCountRef = Object(react__WEBPACK_IMPORTED_MODULE_0__["useRef"])(0);
    const isSubmittingRef = Object(react__WEBPACK_IMPORTED_MODULE_0__["useRef"])(false);
    const handleChangeRef = Object(react__WEBPACK_IMPORTED_MODULE_0__["useRef"])();
    const resetFieldArrayFunctionRef = Object(react__WEBPACK_IMPORTED_MODULE_0__["useRef"])({});
    const validationContextRef = Object(react__WEBPACK_IMPORTED_MODULE_0__["useRef"])(validationContext);
    const fieldArrayNamesRef = Object(react__WEBPACK_IMPORTED_MODULE_0__["useRef"])(new Set());
    const [, render] = Object(react__WEBPACK_IMPORTED_MODULE_0__["useState"])();
    const { isOnBlur, isOnSubmit, isOnChange } = Object(react__WEBPACK_IMPORTED_MODULE_0__["useRef"])(modeChecker(mode)).current;
    const validateAllFieldCriteria = validateCriteriaMode === 'all';
    const isWindowUndefined = typeof window === UNDEFINED;
    const shouldValidateSchemaOrResolver = !!(validationSchema || validationResolver);
    const isWeb = typeof document !== UNDEFINED &&
        !isWindowUndefined &&
        !isUndefined(window.HTMLElement);
    const isProxyEnabled = isWeb ? 'Proxy' in window : typeof Proxy !== UNDEFINED;
    const readFormStateRef = Object(react__WEBPACK_IMPORTED_MODULE_0__["useRef"])({
        dirty: !isProxyEnabled,
        dirtyFields: !isProxyEnabled,
        isSubmitted: isOnSubmit,
        submitCount: !isProxyEnabled,
        touched: !isProxyEnabled,
        isSubmitting: !isProxyEnabled,
        isValid: !isProxyEnabled,
    });
    const { isOnBlur: isReValidateOnBlur, isOnSubmit: isReValidateOnSubmit, } = Object(react__WEBPACK_IMPORTED_MODULE_0__["useRef"])(modeChecker(reValidateMode)).current;
    validationContextRef.current = validationContext;
    const reRender = Object(react__WEBPACK_IMPORTED_MODULE_0__["useCallback"])(() => {
        if (!isUnMount.current) {
            render({});
        }
    }, []);
    const shouldRenderBaseOnError = Object(react__WEBPACK_IMPORTED_MODULE_0__["useCallback"])((name, error, shouldRender = false) => {
        let shouldReRender = shouldRender ||
            shouldRenderBasedOnError({
                errors: errorsRef.current,
                error,
                name,
                validFields: validFieldsRef.current,
                fieldsWithValidation: fieldsWithValidationRef.current,
            });
        if (isEmptyObject(error)) {
            if (fieldsWithValidationRef.current.has(name) ||
                shouldValidateSchemaOrResolver) {
                validFieldsRef.current.add(name);
                shouldReRender = shouldReRender || get(errorsRef.current, name);
            }
            errorsRef.current = unset(errorsRef.current, [name]);
        }
        else {
            const previousError = get(errorsRef.current, name);
            validFieldsRef.current.delete(name);
            shouldReRender =
                shouldReRender ||
                    (previousError
                        ? !isSameError(previousError, error[name])
                        : true);
            set(errorsRef.current, name, error[name]);
        }
        if (shouldReRender && !isNullOrUndefined(shouldRender)) {
            reRender();
            return true;
        }
    }, [reRender, shouldValidateSchemaOrResolver]);
    const setFieldValue = Object(react__WEBPACK_IMPORTED_MODULE_0__["useCallback"])((field, rawValue) => {
        const { ref, options } = field;
        const value = isWeb && isHTMLElement(ref) && isNullOrUndefined(rawValue)
            ? ''
            : rawValue;
        if (isRadioInput(ref) && options) {
            options.forEach(({ ref: radioRef }) => (radioRef.checked = radioRef.value === value));
        }
        else if (isFileInput(ref)) {
            if (isString(value)) {
                ref.value = value;
            }
            else {
                ref.files = value;
            }
        }
        else if (isMultipleSelect(ref)) {
            [...ref.options].forEach((selectRef) => (selectRef.selected = value.includes(selectRef.value)));
        }
        else if (isCheckBoxInput(ref) && options) {
            options.length > 1
                ? options.forEach(({ ref: checkboxRef }) => (checkboxRef.checked = value.includes(checkboxRef.value)))
                : (options[0].ref.checked = !!value);
        }
        else {
            ref.value = value;
        }
    }, [isWeb]);
    const setDirty = Object(react__WEBPACK_IMPORTED_MODULE_0__["useCallback"])((name) => {
        if (!fieldsRef.current[name] ||
            (!readFormStateRef.current.dirty && !readFormStateRef.current.dirtyFields)) {
            return false;
        }
        let isFieldDirty = defaultValuesAtRenderRef.current[name] !==
            getFieldValue(fieldsRef.current, fieldsRef.current[name].ref);
        const isFieldArray = isNameInFieldArray(fieldArrayNamesRef.current, name);
        const previousDirtyFieldsLength = dirtyFieldsRef.current.size;
        if (isFieldArray) {
            const fieldArrayName = getFieldArrayParentName(name);
            isFieldDirty = getIsFieldsDifferent(getFieldValueByName(fieldsRef.current, fieldArrayName), get(defaultValuesRef.current, fieldArrayName));
        }
        const isDirtyChanged = (isFieldArray ? isDirtyRef.current : dirtyFieldsRef.current.has(name)) !==
            isFieldDirty;
        if (isFieldDirty) {
            dirtyFieldsRef.current.add(name);
        }
        else {
            dirtyFieldsRef.current.delete(name);
        }
        isDirtyRef.current = isFieldArray
            ? isFieldDirty
            : !!dirtyFieldsRef.current.size;
        return readFormStateRef.current.dirty
            ? isDirtyChanged
            : previousDirtyFieldsLength !== dirtyFieldsRef.current.size;
    }, []);
    const setInternalValues = Object(react__WEBPACK_IMPORTED_MODULE_0__["useCallback"])((name, value, parentFieldName) => {
        const isValueArray = isArray(value);
        for (const key in value) {
            const fieldName = `${parentFieldName || name}${isValueArray ? `[${key}]` : `.${key}`}`;
            const field = fieldsRef.current[fieldName];
            if (isObject(value[key])) {
                setInternalValues(name, value[key], fieldName);
            }
            if (field) {
                setFieldValue(field, value[key]);
                setDirty(fieldName);
            }
        }
    }, [setFieldValue, setDirty]);
    const setInternalValue = Object(react__WEBPACK_IMPORTED_MODULE_0__["useCallback"])((name, value) => {
        const field = fieldsRef.current[name];
        if (field) {
            setFieldValue(field, value);
            const output = setDirty(name);
            if (isBoolean(output)) {
                return output;
            }
        }
        else if (!isPrimitive(value)) {
            setInternalValues(name, value);
        }
    }, [setDirty, setFieldValue, setInternalValues]);
    const executeValidation = Object(react__WEBPACK_IMPORTED_MODULE_0__["useCallback"])(async (name, skipReRender) => {
        const field = fieldsRef.current[name];
        if (field) {
            const error = await validateField(fieldsRef, validateAllFieldCriteria, field);
            shouldRenderBaseOnError(name, error, skipReRender ? null : false);
            return isEmptyObject(error);
        }
        return false;
    }, [shouldRenderBaseOnError, validateAllFieldCriteria]);
    const executeSchemaOrResolverValidation = Object(react__WEBPACK_IMPORTED_MODULE_0__["useCallback"])(async (payload) => {
        const { errors } = await validateWithSchema(validationSchema, validateAllFieldCriteria, getFieldValueByName(fieldsRef.current), validationResolver, validationContextRef.current);
        const previousFormIsValid = isValidRef.current;
        isValidRef.current = isEmptyObject(errors);
        if (isArray(payload)) {
            payload.forEach((name) => {
                const error = get(errors, name);
                if (error) {
                    set(errorsRef.current, name, error);
                }
                else {
                    unset(errorsRef.current, [name]);
                }
            });
            reRender();
        }
        else {
            const error = get(errors, payload);
            shouldRenderBaseOnError(payload, (error ? { [payload]: error } : {}), previousFormIsValid !== isValidRef.current);
        }
        return isEmptyObject(errorsRef.current);
    }, [
        reRender,
        shouldRenderBaseOnError,
        validateAllFieldCriteria,
        validationResolver,
        validationSchema,
    ]);
    const triggerValidation = Object(react__WEBPACK_IMPORTED_MODULE_0__["useCallback"])(async (payload) => {
        const fields = payload || Object.keys(fieldsRef.current);
        if (shouldValidateSchemaOrResolver) {
            return executeSchemaOrResolverValidation(fields);
        }
        if (isArray(fields)) {
            const result = await Promise.all(fields.map(async (data) => await executeValidation(data, true)));
            reRender();
            return result.every(Boolean);
        }
        return await executeValidation(fields);
    }, [
        executeSchemaOrResolverValidation,
        executeValidation,
        reRender,
        shouldValidateSchemaOrResolver,
    ]);
    const isFieldWatched = (name) => isWatchAllRef.current ||
        watchFieldsRef.current.has(name) ||
        watchFieldsRef.current.has((name.match(/\w+/) || [])[0]);
    function setValue(names, valueOrShouldValidate, shouldValidate) {
        let shouldRender = false;
        const isArrayValue = isArray(names);
        (isArrayValue
            ? names
            : [names]).forEach((name) => {
            const isStringFieldName = isString(name);
            shouldRender =
                setInternalValue(isStringFieldName ? name : Object.keys(name)[0], isStringFieldName
                    ? valueOrShouldValidate
                    : Object.values(name)[0]) || isArrayValue
                    ? true
                    : isFieldWatched(name);
        });
        if (shouldRender || isArrayValue) {
            reRender();
        }
        if (shouldValidate || (isArrayValue && valueOrShouldValidate)) {
            triggerValidation(isArrayValue ? undefined : names);
        }
    }
    handleChangeRef.current = handleChangeRef.current
        ? handleChangeRef.current
        : async ({ type, target }) => {
            const name = target ? target.name : '';
            const fields = fieldsRef.current;
            const errors = errorsRef.current;
            const field = fields[name];
            const currentError = get(errors, name);
            let error;
            if (!field) {
                return;
            }
            const isBlurEvent = type === EVENTS.BLUR;
            const shouldSkipValidation = skipValidation({
                hasError: !!currentError,
                isOnChange,
                isBlurEvent,
                isOnSubmit,
                isReValidateOnSubmit,
                isOnBlur,
                isReValidateOnBlur,
                isSubmitted: isSubmittedRef.current,
            });
            const shouldUpdateDirty = setDirty(name);
            let shouldRender = isFieldWatched(name) || shouldUpdateDirty;
            if (isBlurEvent &&
                !get(touchedFieldsRef.current, name) &&
                readFormStateRef.current.touched) {
                set(touchedFieldsRef.current, name, true);
                shouldRender = true;
            }
            if (shouldSkipValidation) {
                return shouldRender && reRender();
            }
            if (shouldValidateSchemaOrResolver) {
                const { errors } = await validateWithSchema(validationSchema, validateAllFieldCriteria, getFieldValueByName(fields), validationResolver, validationContextRef.current);
                const previousFormIsValid = isValidRef.current;
                isValidRef.current = isEmptyObject(errors);
                error = (get(errors, name)
                    ? { [name]: get(errors, name) }
                    : {});
                if (previousFormIsValid !== isValidRef.current) {
                    shouldRender = true;
                }
            }
            else {
                error = await validateField(fieldsRef, validateAllFieldCriteria, field);
            }
            if (!shouldRenderBaseOnError(name, error) && shouldRender) {
                reRender();
            }
        };
    const validateSchemaOrResolver = Object(react__WEBPACK_IMPORTED_MODULE_0__["useCallback"])((values = {}) => {
        const fieldValues = isEmptyObject(defaultValuesRef.current)
            ? getFieldsValues(fieldsRef.current)
            : defaultValuesRef.current;
        validateWithSchema(validationSchema, validateAllFieldCriteria, transformToNestObject(Object.assign(Object.assign({}, fieldValues), values)), validationResolver, validationContextRef.current).then(({ errors }) => {
            const previousFormIsValid = isValidRef.current;
            isValidRef.current = isEmptyObject(errors);
            if (previousFormIsValid !== isValidRef.current) {
                reRender();
            }
        });
    }, 
    // eslint-disable-next-line react-hooks/exhaustive-deps
    [reRender, validateAllFieldCriteria, validationResolver]);
    const removeFieldEventListener = Object(react__WEBPACK_IMPORTED_MODULE_0__["useCallback"])((field, forceDelete) => {
        if (handleChangeRef.current && field) {
            findRemovedFieldAndRemoveListener(fieldsRef.current, handleChangeRef.current, field, forceDelete);
        }
    }, []);
    const removeFieldEventListenerAndRef = Object(react__WEBPACK_IMPORTED_MODULE_0__["useCallback"])((field, forceDelete) => {
        if (!field ||
            (field &&
                isNameInFieldArray(fieldArrayNamesRef.current, field.ref.name) &&
                !forceDelete)) {
            return;
        }
        removeFieldEventListener(field, forceDelete);
        const { name } = field.ref;
        errorsRef.current = unset(errorsRef.current, [name]);
        touchedFieldsRef.current = unset(touchedFieldsRef.current, [name]);
        defaultValuesAtRenderRef.current = unset(defaultValuesAtRenderRef.current, [name]);
        [
            dirtyFieldsRef,
            fieldsWithValidationRef,
            validFieldsRef,
            watchFieldsRef,
        ].forEach((data) => data.current.delete(name));
        if (readFormStateRef.current.isValid ||
            readFormStateRef.current.touched) {
            reRender();
            if (shouldValidateSchemaOrResolver) {
                validateSchemaOrResolver();
            }
        }
    }, [
        reRender,
        shouldValidateSchemaOrResolver,
        validateSchemaOrResolver,
        removeFieldEventListener,
    ]);
    function clearError(name) {
        if (name) {
            unset(errorsRef.current, isArray(name) ? name : [name]);
        }
        else {
            errorsRef.current = {};
        }
        reRender();
    }
    const setInternalError = ({ name, type, types, message, shouldRender, }) => {
        const field = fieldsRef.current[name];
        if (!isSameError(get(errorsRef.current, name), {
            type,
            message,
            types,
        })) {
            set(errorsRef.current, name, {
                type,
                types,
                message,
                ref: field ? field.ref : {},
                isManual: true,
            });
            if (shouldRender) {
                reRender();
            }
        }
    };
    function setError(name, type = '', message) {
        if (isString(name)) {
            setInternalError(Object.assign(Object.assign({ name }, (isObject(type)
                ? {
                    types: type,
                    type: '',
                }
                : {
                    type,
                    message,
                })), { shouldRender: true }));
        }
        else if (isArray(name)) {
            name.forEach((error) => setInternalError(Object.assign({}, error)));
            reRender();
        }
    }
    function watch(fieldNames, defaultValue) {
        const watchFields = watchFieldsRef.current;
        const isDefaultValueUndefined = isUndefined(defaultValue);
        const combinedDefaultValues = isDefaultValueUndefined
            ? defaultValuesRef.current
            : defaultValue;
        const fieldValues = getFieldsValues(fieldsRef.current, fieldNames);
        if (isString(fieldNames)) {
            return assignWatchFields(fieldValues, fieldNames, watchFields, isDefaultValueUndefined
                ? get(combinedDefaultValues, fieldNames)
                : defaultValue, true);
        }
        if (isArray(fieldNames)) {
            return fieldNames.reduce((previous, name) => (Object.assign(Object.assign({}, previous), { [name]: assignWatchFields(fieldValues, name, watchFields, combinedDefaultValues) })), {});
        }
        isWatchAllRef.current = true;
        const result = (!isEmptyObject(fieldValues) && fieldValues) || combinedDefaultValues;
        return fieldNames && fieldNames.nest
            ? transformToNestObject(result)
            : result;
    }
    function unregister(name) {
        if (fieldsRef.current) {
            (isArray(name) ? name : [name]).forEach((fieldName) => removeFieldEventListenerAndRef(fieldsRef.current[fieldName], true));
        }
    }
    function registerFieldsRef(ref, validateOptions = {}) {
        if (!ref.name) {
            // eslint-disable-next-line no-console
            return console.warn('Missing name @', ref);
        }
        const { name, type, value } = ref;
        const fieldRefAndValidationOptions = Object.assign({ ref }, validateOptions);
        const fields = fieldsRef.current;
        const isRadioOrCheckbox = isRadioOrCheckboxFunction(ref);
        let field = fields[name];
        let isEmptyDefaultValue = true;
        let isFieldArray;
        let defaultValue;
        if (isRadioOrCheckbox
            ? field &&
                isArray(field.options) &&
                field.options.filter(Boolean).find((option) => {
                    return value === option.ref.value && option.ref === ref;
                })
            : field && ref === field.ref) {
            fields[name] = Object.assign(Object.assign({}, field), validateOptions);
            return;
        }
        if (type) {
            const mutationWatcher = onDomRemove(ref, () => removeFieldEventListenerAndRef(field));
            field = isRadioOrCheckbox
                ? Object.assign({ options: [
                        ...((field && field.options) || []),
                        {
                            ref,
                            mutationWatcher,
                        },
                    ], ref: { type, name } }, validateOptions) : Object.assign(Object.assign({}, fieldRefAndValidationOptions), { mutationWatcher });
        }
        else {
            field = fieldRefAndValidationOptions;
        }
        fields[name] = field;
        if (!isEmptyObject(defaultValuesRef.current)) {
            defaultValue = get(defaultValuesRef.current, name);
            isEmptyDefaultValue = isUndefined(defaultValue);
            isFieldArray = isNameInFieldArray(fieldArrayNamesRef.current, name);
            if (!isEmptyDefaultValue && !isFieldArray) {
                setFieldValue(field, defaultValue);
            }
        }
        if (shouldValidateSchemaOrResolver &&
            !isFieldArray &&
            readFormStateRef.current.isValid) {
            validateSchemaOrResolver();
        }
        else if (!isEmptyObject(validateOptions)) {
            fieldsWithValidationRef.current.add(name);
            if (!isOnSubmit && readFormStateRef.current.isValid) {
                validateField(fieldsRef, validateAllFieldCriteria, field).then((error) => {
                    const previousFormIsValid = isValidRef.current;
                    isEmptyObject(error)
                        ? validFieldsRef.current.add(name)
                        : (isValidRef.current = false);
                    if (previousFormIsValid !== isValidRef.current) {
                        reRender();
                    }
                });
            }
        }
        if (!defaultValuesAtRenderRef.current[name] &&
            !(isFieldArray && isEmptyDefaultValue)) {
            defaultValuesAtRenderRef.current[name] = isEmptyDefaultValue ? getFieldValue(fields, field.ref) : defaultValue;
        }
        if (type) {
            attachEventListeners({
                field: isRadioOrCheckbox && field.options
                    ? field.options[field.options.length - 1]
                    : field,
                isRadioOrCheckbox: isRadioOrCheckbox || isSelectInput(ref),
                handleChange: handleChangeRef.current,
            });
        }
    }
    function register(refOrValidationOptions, validationOptions) {
        if (isWindowUndefined) {
            return;
        }
        if (isString(refOrValidationOptions)) {
            registerFieldsRef({ name: refOrValidationOptions }, validationOptions);
            return;
        }
        if (isObject(refOrValidationOptions) && 'name' in refOrValidationOptions) {
            registerFieldsRef(refOrValidationOptions, validationOptions);
            return;
        }
        return (ref) => ref && registerFieldsRef(ref, refOrValidationOptions);
    }
    const handleSubmit = Object(react__WEBPACK_IMPORTED_MODULE_0__["useCallback"])((callback) => async (e) => {
        if (e) {
            e.preventDefault();
            e.persist();
        }
        let fieldErrors = {};
        const fields = fieldsRef.current;
        let fieldValues = getFieldsValues(fields);
        if (readFormStateRef.current.isSubmitting) {
            isSubmittingRef.current = true;
            reRender();
        }
        try {
            if (shouldValidateSchemaOrResolver) {
                const { errors, values } = await validateWithSchema(validationSchema, validateAllFieldCriteria, transformToNestObject(fieldValues), validationResolver, validationContextRef.current);
                errorsRef.current = errors;
                fieldErrors = errors;
                fieldValues = values;
            }
            else {
                for (const field of Object.values(fields)) {
                    if (field) {
                        const { ref: { name }, } = field;
                        const fieldError = await validateField(fieldsRef, validateAllFieldCriteria, field);
                        if (fieldError[name]) {
                            set(fieldErrors, name, fieldError[name]);
                            validFieldsRef.current.delete(name);
                        }
                        else {
                            if (fieldsWithValidationRef.current.has(name)) {
                                validFieldsRef.current.add(name);
                            }
                        }
                    }
                }
            }
            if (isEmptyObject(fieldErrors)) {
                errorsRef.current = {};
                reRender();
                await callback(transformToNestObject(fieldValues), e);
            }
            else {
                errorsRef.current = fieldErrors;
                if (submitFocusError && isWeb) {
                    focusOnErrorField(fields, fieldErrors);
                }
            }
        }
        finally {
            isSubmittedRef.current = true;
            isSubmittingRef.current = false;
            submitCountRef.current = submitCountRef.current + 1;
            reRender();
        }
    }, [
        isWeb,
        reRender,
        shouldValidateSchemaOrResolver,
        submitFocusError,
        validateAllFieldCriteria,
        validationResolver,
        validationSchema,
    ]);
    const resetRefs = ({ errors, dirty, isSubmitted, touched, isValid, submitCount, dirtyFields, }) => {
        fieldsRef.current = {};
        if (!errors) {
            errorsRef.current = {};
        }
        if (!touched) {
            touchedFieldsRef.current = {};
        }
        if (!isValid) {
            validFieldsRef.current = new Set();
            fieldsWithValidationRef.current = new Set();
            isValidRef.current = true;
        }
        if (!dirty) {
            isDirtyRef.current = false;
        }
        if (!dirtyFields) {
            dirtyFieldsRef.current = new Set();
        }
        if (!isSubmitted) {
            isSubmittedRef.current = false;
        }
        if (!submitCount) {
            submitCountRef.current = 0;
        }
        defaultValuesAtRenderRef.current = {};
        fieldArrayDefaultValues.current = {};
        watchFieldsRef.current = new Set();
        isWatchAllRef.current = false;
    };
    const reset = (values, omitResetState = {}) => {
        if (isWeb) {
            for (const field of Object.values(fieldsRef.current)) {
                if (field) {
                    const { ref, options } = field;
                    const inputRef = isRadioOrCheckboxFunction(ref) && isArray(options)
                        ? options[0].ref
                        : ref;
                    if (isHTMLElement(inputRef)) {
                        try {
                            inputRef.closest('form').reset();
                            break;
                        }
                        catch (_a) { }
                    }
                }
            }
        }
        if (values) {
            defaultValuesRef.current = values;
        }
        Object.values(resetFieldArrayFunctionRef.current).forEach((resetFieldArray) => isFunction(resetFieldArray) && resetFieldArray());
        resetRefs(omitResetState);
        reRender();
    };
    function getValues(payload) {
        if (isString(payload)) {
            return fieldsRef.current[payload]
                ? getFieldValue(fieldsRef.current, fieldsRef.current[payload].ref)
                : get(defaultValuesRef.current, payload);
        }
        const fieldValues = getFieldsValues(fieldsRef.current);
        const outputValues = isEmptyObject(fieldValues)
            ? defaultValuesRef.current
            : fieldValues;
        return payload && payload.nest
            ? transformToNestObject(outputValues)
            : outputValues;
    }
    Object(react__WEBPACK_IMPORTED_MODULE_0__["useEffect"])(() => () => {
        isUnMount.current = true;
        fieldsRef.current &&
            "development" === 'production' &&
            Object.values(fieldsRef.current).forEach((field) => removeFieldEventListenerAndRef(field, true));
    }, [removeFieldEventListenerAndRef]);
    if (!shouldValidateSchemaOrResolver) {
        isValidRef.current =
            validFieldsRef.current.size >= fieldsWithValidationRef.current.size &&
                isEmptyObject(errorsRef.current);
    }
    const formState = {
        dirty: isDirtyRef.current,
        dirtyFields: dirtyFieldsRef.current,
        isSubmitted: isSubmittedRef.current,
        submitCount: submitCountRef.current,
        touched: touchedFieldsRef.current,
        isSubmitting: isSubmittingRef.current,
        isValid: isOnSubmit
            ? isSubmittedRef.current && isEmptyObject(errorsRef.current)
            : isValidRef.current,
    };
    const commonProps = {
        triggerValidation,
        setValue: Object(react__WEBPACK_IMPORTED_MODULE_0__["useCallback"])(setValue, [
            reRender,
            setInternalValue,
            triggerValidation,
        ]),
        register: Object(react__WEBPACK_IMPORTED_MODULE_0__["useCallback"])(register, [
            defaultValuesRef.current,
            defaultValuesAtRenderRef.current,
        ]),
        unregister: Object(react__WEBPACK_IMPORTED_MODULE_0__["useCallback"])(unregister, []),
        getValues: Object(react__WEBPACK_IMPORTED_MODULE_0__["useCallback"])(getValues, []),
        formState: isProxyEnabled
            ? new Proxy(formState, {
                get: (obj, prop) => {
                    if (prop in obj) {
                        readFormStateRef.current[prop] = true;
                        return obj[prop];
                    }
                    return undefined;
                },
            })
            : formState,
    };
    const control = Object.assign(Object.assign(Object.assign({ removeFieldEventListener,
        reRender }, (shouldValidateSchemaOrResolver
        ? { validateSchemaIsValid: validateSchemaOrResolver }
        : {})), { mode: {
            isOnBlur,
            isOnSubmit,
            isOnChange,
        }, reValidateMode: {
            isReValidateOnBlur,
            isReValidateOnSubmit,
        }, errorsRef,
        touchedFieldsRef,
        fieldsRef,
        isWatchAllRef,
        watchFieldsRef,
        resetFieldArrayFunctionRef,
        fieldArrayDefaultValues,
        validFieldsRef,
        dirtyFieldsRef,
        fieldsWithValidationRef,
        fieldArrayNamesRef,
        isDirtyRef,
        readFormStateRef,
        defaultValuesRef }), commonProps);
    return Object.assign({ watch,
        control,
        handleSubmit, reset: Object(react__WEBPACK_IMPORTED_MODULE_0__["useCallback"])(reset, []), clearError: Object(react__WEBPACK_IMPORTED_MODULE_0__["useCallback"])(clearError, []), setError: Object(react__WEBPACK_IMPORTED_MODULE_0__["useCallback"])(setError, []), errors: errorsRef.current }, commonProps);
}

/*! *****************************************************************************
Copyright (c) Microsoft Corporation. All rights reserved.
Licensed under the Apache License, Version 2.0 (the "License"); you may not use
this file except in compliance with the License. You may obtain a copy of the
License at http://www.apache.org/licenses/LICENSE-2.0

THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
MERCHANTABLITY OR NON-INFRINGEMENT.

See the Apache Version 2.0 License for specific language governing permissions
and limitations under the License.
***************************************************************************** */

function __rest(s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
}

const FormGlobalContext = Object(react__WEBPACK_IMPORTED_MODULE_0__["createContext"])(null);
function useFormContext() {
    return Object(react__WEBPACK_IMPORTED_MODULE_0__["useContext"])(FormGlobalContext);
}
function FormContext(_a) {
    var { children, formState, errors } = _a, restMethods = __rest(_a, ["children", "formState", "errors"]);
    return (Object(react__WEBPACK_IMPORTED_MODULE_0__["createElement"])(FormGlobalContext.Provider, { value: Object.assign(Object.assign({}, restMethods), { formState, errors }) }, children));
}

var generateId = () => {
    const d = typeof performance === UNDEFINED ? Date.now() : performance.now() * 1000;
    return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function (c) {
        const r = (Math.random() * 16 + d) % 16 | 0;
        return (c == 'x' ? r : (r & 0x3) | 0x8).toString(16);
    });
};

const appendId = (value, keyName) => (Object.assign({ [keyName]: generateId() }, (isObject(value) ? value : { value })));
const mapIds = (data, keyName) => (isArray(data) ? data : []).map((value) => appendId(value, keyName));

var getSortRemovedItems = (indexes, removeIndexes, updatedIndexes = [], count = 0, notFoundIndexes = []) => {
    for (const removeIndex of removeIndexes) {
        if (indexes.indexOf(removeIndex) < 0) {
            notFoundIndexes.push(removeIndex);
        }
    }
    for (const index of indexes.sort()) {
        if (removeIndexes.indexOf(index) > -1) {
            updatedIndexes.push(-1);
            count++;
        }
        else {
            updatedIndexes.push(index -
                count -
                (notFoundIndexes.length
                    ? notFoundIndexes
                        .map((notFoundIndex) => notFoundIndex < index)
                        .filter(Boolean).length
                    : 0));
        }
    }
    return updatedIndexes;
};

const removeAt = (data, index) => [
    ...data.slice(0, index),
    ...data.slice(index + 1),
];
function removeAtIndexes(data, index) {
    let k = -1;
    while (++k < data.length) {
        if (index.indexOf(k) >= 0) {
            delete data[k];
        }
    }
    return data.filter(Boolean);
}
var removeArrayAt = (data, index) => isUndefined(index)
    ? []
    : isArray(index)
        ? removeAtIndexes(data, index)
        : removeAt(data, index);

var moveArrayAt = (data, from, to) => isArray(data) ? data.splice(to, 0, data.splice(from, 1)[0]) : [];

var swapArrayAt = (data, indexA, indexB) => {
    const temp = [data[indexB], data[indexA]];
    data[indexA] = temp[0];
    data[indexB] = temp[1];
};

function prepend(data, value) {
    return [...(isArray(value) ? value : [value || null]), ...data];
}

function insert(data, index, value) {
    return [
        ...data.slice(0, index),
        ...(isArray(value) ? value : [value || null]),
        ...data.slice(index),
    ];
}

var fillEmptyArray = (value) => isArray(value) ? Array(value.length).fill(null) : null;

const useFieldArray = ({ control, name, keyName = 'id', }) => {
    const methods = useFormContext();
    const { isWatchAllRef, resetFieldArrayFunctionRef, fieldArrayNamesRef, reRender, fieldsRef, getValues, defaultValuesRef, removeFieldEventListener, errorsRef, dirtyFieldsRef, isDirtyRef, touchedFieldsRef, readFormStateRef, watchFieldsRef, validFieldsRef, fieldsWithValidationRef, fieldArrayDefaultValues, validateSchemaIsValid, } = control || methods.control;
    const getDefaultValues = () => [
        ...get(fieldArrayDefaultValues.current[getFieldArrayParentName(name)]
            ? fieldArrayDefaultValues.current
            : defaultValuesRef.current, name, []),
    ];
    const memoizedDefaultValues = Object(react__WEBPACK_IMPORTED_MODULE_0__["useRef"])(getDefaultValues());
    const [fields, setField] = Object(react__WEBPACK_IMPORTED_MODULE_0__["useState"])(mapIds(memoizedDefaultValues.current, keyName));
    const [isDeleted, setIsDeleted] = Object(react__WEBPACK_IMPORTED_MODULE_0__["useState"])(false);
    const allFields = Object(react__WEBPACK_IMPORTED_MODULE_0__["useRef"])(fields);
    const isNameKey = isKey(name);
    allFields.current = fields;
    if (isNameKey) {
        fieldArrayDefaultValues.current[name] = memoizedDefaultValues.current;
    }
    const appendValueWithKey = (values) => values.map((value) => appendId(value, keyName));
    const setFieldAndValidState = (fieldsValues) => {
        setField(fieldsValues);
        if (readFormStateRef.current.isValid && validateSchemaIsValid) {
            validateSchemaIsValid({
                [name]: fieldsValues,
            });
        }
    };
    const modifyDirtyFields = ({ shouldRender, isRemove, isPrePend, index, value = {}, } = {}) => {
        let render = shouldRender;
        const values = isArray(value) ? value : [value];
        if (readFormStateRef.current.dirty) {
            const dirtyFieldIndexesAndValues = {};
            if (isPrePend || isRemove) {
                for (const dirtyField of [...dirtyFieldsRef.current].sort()) {
                    if (isMatchFieldArrayName(dirtyField, name)) {
                        const matchedIndexes = dirtyField.match(REGEX_ARRAY_FIELD_INDEX);
                        if (matchedIndexes) {
                            const matchIndex = +matchedIndexes[matchedIndexes.length - 1];
                            if (dirtyFieldIndexesAndValues[matchIndex]) {
                                dirtyFieldIndexesAndValues[matchIndex].push(dirtyField);
                            }
                            else {
                                dirtyFieldIndexesAndValues[matchIndex] = [dirtyField];
                            }
                        }
                        dirtyFieldsRef.current.delete(dirtyField);
                    }
                }
            }
            if (!isUndefined(index) || isPrePend) {
                const updatedDirtyFieldIndexes = isUndefined(index)
                    ? []
                    : getSortRemovedItems(Object.keys(dirtyFieldIndexesAndValues).map((i) => +i), isArray(index) ? index : [index]);
                Object.values(dirtyFieldIndexesAndValues).forEach((values, index) => {
                    const updateIndex = isPrePend ? 0 : updatedDirtyFieldIndexes[index];
                    if (updateIndex > -1) {
                        for (const value of values) {
                            const matchedIndexes = value.match(REGEX_ARRAY_FIELD_INDEX);
                            if (matchedIndexes) {
                                dirtyFieldsRef.current.add(value.replace(/[\d+]([^[\d+]+)$/, `${isPrePend
                                    ? +matchedIndexes[matchedIndexes.length - 1] +
                                        values.length
                                    : updateIndex}$1`));
                            }
                        }
                    }
                });
            }
            if (!isRemove) {
                values.forEach((fieldValue, index) => Object.keys(fieldValue).forEach((key) => dirtyFieldsRef.current.add(`${name}[${isPrePend ? index : allFields.current.length + index}].${key}`)));
                isDirtyRef.current = true;
            }
            render = true;
        }
        if (render && !isWatchAllRef.current) {
            reRender();
        }
    };
    const resetFields = (flagOrFields) => {
        if (readFormStateRef.current.dirty) {
            isDirtyRef.current = isUndefined(flagOrFields)
                ? true
                : getIsFieldsDifferent(flagOrFields, defaultValuesRef.current[name] || []);
        }
        for (const key in fieldsRef.current) {
            if (isMatchFieldArrayName(key, name) && fieldsRef.current[key]) {
                removeFieldEventListener(fieldsRef.current[key], true);
            }
        }
    };
    const mapCurrentFieldsValueWithState = () => {
        const currentFieldsValue = get(getValues({ nest: true }), name);
        if (isArray(currentFieldsValue)) {
            for (let i = 0; i < currentFieldsValue.length; i++) {
                allFields.current[i] = Object.assign(Object.assign({}, allFields.current[i]), currentFieldsValue[i]);
            }
        }
    };
    const append = (value) => {
        setFieldAndValidState([
            ...allFields.current,
            ...(isArray(value)
                ? appendValueWithKey(value)
                : [appendId(value, keyName)]),
        ]);
        modifyDirtyFields({ value });
    };
    const prepend$1 = (value) => {
        let shouldRender = false;
        resetFields();
        setFieldAndValidState(prepend(allFields.current, isArray(value) ? appendValueWithKey(value) : [appendId(value, keyName)]));
        if (errorsRef.current[name]) {
            errorsRef.current[name] = prepend(errorsRef.current[name], fillEmptyArray(value));
        }
        if (readFormStateRef.current.touched && touchedFieldsRef.current[name]) {
            touchedFieldsRef.current[name] = prepend(touchedFieldsRef.current[name], fillEmptyArray(value));
            shouldRender = true;
        }
        modifyDirtyFields({
            shouldRender,
            isPrePend: true,
            value,
        });
    };
    const remove = (index) => {
        let shouldRender = false;
        const isIndexUndefined = isUndefined(index);
        if (!isIndexUndefined) {
            mapCurrentFieldsValueWithState();
        }
        resetFields(removeArrayAt(getFieldValueByName(fieldsRef.current, name), index));
        setFieldAndValidState(removeArrayAt(allFields.current, index));
        setIsDeleted(true);
        if (errorsRef.current[name]) {
            errorsRef.current[name] = removeArrayAt(errorsRef.current[name], index);
            if (!errorsRef.current[name].filter(Boolean).length) {
                delete errorsRef.current[name];
            }
        }
        if (readFormStateRef.current.touched && touchedFieldsRef.current[name]) {
            touchedFieldsRef.current[name] = removeArrayAt(touchedFieldsRef.current[name], index);
            shouldRender = true;
        }
        if (readFormStateRef.current.isValid && !validateSchemaIsValid) {
            let fieldIndex = -1;
            let isFound = false;
            const isIndexUndefined = isUndefined(index);
            while (fieldIndex++ < fields.length) {
                const isLast = fieldIndex === fields.length - 1;
                const isCurrentIndex = (isArray(index) ? index : [index]).indexOf(fieldIndex) >= 0;
                if (isCurrentIndex || isIndexUndefined) {
                    isFound = true;
                }
                if (!isFound) {
                    continue;
                }
                for (const key in fields[fieldIndex]) {
                    const currentFieldName = `${name}[${fieldIndex}].${key}`;
                    if (isCurrentIndex || isLast || isIndexUndefined) {
                        validFieldsRef.current.delete(currentFieldName);
                        fieldsWithValidationRef.current.delete(currentFieldName);
                    }
                    else {
                        const previousFieldName = `${name}[${fieldIndex - 1}].${key}`;
                        if (validFieldsRef.current.has(currentFieldName)) {
                            validFieldsRef.current.add(previousFieldName);
                        }
                        if (fieldsWithValidationRef.current.has(currentFieldName)) {
                            fieldsWithValidationRef.current.add(previousFieldName);
                        }
                    }
                }
            }
        }
        modifyDirtyFields({
            shouldRender,
            isRemove: true,
            index,
        });
    };
    const insert$1 = (index, value) => {
        mapCurrentFieldsValueWithState();
        resetFields(insert(getFieldValueByName(fieldsRef.current, name), index));
        setFieldAndValidState(insert(allFields.current, index, isArray(value) ? appendValueWithKey(value) : [appendId(value, keyName)]));
        if (errorsRef.current[name]) {
            errorsRef.current[name] = insert(errorsRef.current[name], index, fillEmptyArray(value));
        }
        if (readFormStateRef.current.touched && touchedFieldsRef.current[name]) {
            touchedFieldsRef.current[name] = insert(touchedFieldsRef.current[name], index, fillEmptyArray(value));
            reRender();
        }
    };
    const swap = (indexA, indexB) => {
        mapCurrentFieldsValueWithState();
        const fieldValues = getFieldValueByName(fieldsRef.current, name);
        swapArrayAt(fieldValues, indexA, indexB);
        resetFields(fieldValues);
        swapArrayAt(allFields.current, indexA, indexB);
        setFieldAndValidState([...allFields.current]);
        if (errorsRef.current[name]) {
            swapArrayAt(errorsRef.current[name], indexA, indexB);
        }
        if (readFormStateRef.current.touched && touchedFieldsRef.current[name]) {
            swapArrayAt(touchedFieldsRef.current[name], indexA, indexB);
            reRender();
        }
    };
    const move = (from, to) => {
        mapCurrentFieldsValueWithState();
        const fieldValues = getFieldValueByName(fieldsRef.current, name);
        moveArrayAt(fieldValues, from, to);
        resetFields(fieldValues);
        moveArrayAt(allFields.current, from, to);
        setFieldAndValidState([...allFields.current]);
        if (errorsRef.current[name]) {
            moveArrayAt(errorsRef.current[name], from, to);
        }
        if (readFormStateRef.current.touched && touchedFieldsRef.current[name]) {
            moveArrayAt(touchedFieldsRef.current[name], from, to);
            reRender();
        }
    };
    const reset = () => {
        resetFields();
        memoizedDefaultValues.current = getDefaultValues();
        setField(mapIds(memoizedDefaultValues.current, keyName));
    };
    Object(react__WEBPACK_IMPORTED_MODULE_0__["useEffect"])(() => {
        if (isNameKey &&
            isDeleted &&
            fieldArrayDefaultValues.current[name] &&
            fields.length < fieldArrayDefaultValues.current[name].length) {
            fieldArrayDefaultValues.current[name].pop();
        }
    }, [fields, name, fieldArrayDefaultValues, isDeleted, isNameKey]);
    Object(react__WEBPACK_IMPORTED_MODULE_0__["useEffect"])(() => {
        if (isWatchAllRef && isWatchAllRef.current) {
            reRender();
        }
        else if (watchFieldsRef) {
            for (const watchField of watchFieldsRef.current) {
                if (watchField.startsWith(name)) {
                    reRender();
                    break;
                }
            }
        }
    }, [fields, name, reRender, watchFieldsRef, isWatchAllRef]);
    Object(react__WEBPACK_IMPORTED_MODULE_0__["useEffect"])(() => {
        const resetFunctions = resetFieldArrayFunctionRef.current;
        const fieldArrayNames = fieldArrayNamesRef.current;
        fieldArrayNames.add(name);
        resetFunctions[name] = reset;
        return () => {
            resetFields();
            delete resetFunctions[name];
            fieldArrayNames.delete(name);
        };
        // eslint-disable-next-line react-hooks/exhaustive-deps
    }, []);
    return {
        swap: Object(react__WEBPACK_IMPORTED_MODULE_0__["useCallback"])(swap, [name]),
        move: Object(react__WEBPACK_IMPORTED_MODULE_0__["useCallback"])(move, [name]),
        prepend: Object(react__WEBPACK_IMPORTED_MODULE_0__["useCallback"])(prepend$1, [name]),
        append: Object(react__WEBPACK_IMPORTED_MODULE_0__["useCallback"])(append, [name]),
        remove: Object(react__WEBPACK_IMPORTED_MODULE_0__["useCallback"])(remove, [fields, name]),
        insert: Object(react__WEBPACK_IMPORTED_MODULE_0__["useCallback"])(insert$1, [name]),
        fields,
    };
};

var getInputValue = (event, isCheckboxInput) => isPrimitive(event) ||
    !isObject(event.target) ||
    (isObject(event.target) && !event.type)
    ? event
    : isCheckboxInput || isUndefined(event.target.value)
        ? event.target.checked
        : event.target.value;

const Controller = (_a) => {
    var { name, rules, as: InnerComponent, onBlur, onChange, onChangeName = VALIDATION_MODE.onChange, onBlurName = VALIDATION_MODE.onBlur, valueName, defaultValue, control, onFocus } = _a, rest = __rest(_a, ["name", "rules", "as", "onBlur", "onChange", "onChangeName", "onBlurName", "valueName", "defaultValue", "control", "onFocus"]);
    const methods = useFormContext();
    const { defaultValuesRef, setValue, register, unregister, errorsRef, removeFieldEventListener, triggerValidation, mode: { isOnSubmit, isOnBlur, isOnChange }, reValidateMode: { isReValidateOnBlur, isReValidateOnSubmit }, formState: { isSubmitted }, touchedFieldsRef, readFormStateRef, reRender, fieldsRef, fieldArrayNamesRef, } = control || methods.control;
    const [value, setInputStateValue] = Object(react__WEBPACK_IMPORTED_MODULE_0__["useState"])(isUndefined(defaultValue)
        ? get(defaultValuesRef.current, name)
        : defaultValue);
    const valueRef = Object(react__WEBPACK_IMPORTED_MODULE_0__["useRef"])(value);
    const isCheckboxInput = isBoolean(value);
    const shouldReValidateOnBlur = isOnBlur || isReValidateOnBlur;
    const rulesRef = Object(react__WEBPACK_IMPORTED_MODULE_0__["useRef"])(rules);
    const onFocusRef = Object(react__WEBPACK_IMPORTED_MODULE_0__["useRef"])(onFocus);
    const isNotFieldArray = !isNameInFieldArray(fieldArrayNamesRef.current, name);
    rulesRef.current = rules;
    const shouldValidate = () => !skipValidation({
        hasError: !!get(errorsRef.current, name),
        isOnBlur,
        isOnSubmit,
        isOnChange,
        isReValidateOnBlur,
        isReValidateOnSubmit,
        isSubmitted,
    });
    const commonTask = (event) => {
        const data = getInputValue(event, isCheckboxInput);
        setInputStateValue(data);
        valueRef.current = data;
        return data;
    };
    const eventWrapper = (event) => (...arg) => setValue(name, commonTask(event(arg)), shouldValidate());
    const handleChange = (event) => {
        const data = commonTask(event);
        setValue(name, data, shouldValidate());
    };
    const registerField = Object(react__WEBPACK_IMPORTED_MODULE_0__["useCallback"])(() => {
        if (!isNotFieldArray) {
            removeFieldEventListener(fieldsRef.current[name], true);
        }
        register(Object.defineProperty({ name, focus: onFocusRef.current }, VALUE, {
            set(data) {
                setInputStateValue(data);
                valueRef.current = data;
            },
            get() {
                return valueRef.current;
            },
        }), rulesRef.current);
    }, [
        isNotFieldArray,
        fieldsRef,
        rulesRef,
        name,
        onFocusRef,
        register,
        removeFieldEventListener,
    ]);
    Object(react__WEBPACK_IMPORTED_MODULE_0__["useEffect"])(() => () => {
        !isNameInFieldArray(fieldArrayNamesRef.current, name) && unregister(name);
    }, [unregister, name, fieldArrayNamesRef]);
    Object(react__WEBPACK_IMPORTED_MODULE_0__["useEffect"])(() => {
        registerField();
    }, [registerField]);
    // eslint-disable-next-line react-hooks/exhaustive-deps
    Object(react__WEBPACK_IMPORTED_MODULE_0__["useEffect"])(() => {
        if (!fieldsRef.current[name]) {
            registerField();
            if (isNotFieldArray) {
                setInputStateValue(isUndefined(defaultValue)
                    ? get(defaultValuesRef.current, name)
                    : defaultValue);
            }
        }
    });
    const props = Object.assign(Object.assign(Object.assign(Object.assign({ name }, rest), (onChange
        ? { [onChangeName]: eventWrapper(onChange) }
        : { [onChangeName]: handleChange })), { [onBlurName]: (...args) => {
            if (onBlur) {
                onBlur(args);
            }
            if (readFormStateRef.current.touched &&
                !get(touchedFieldsRef.current, name)) {
                set(touchedFieldsRef.current, name, true);
                reRender();
            }
            if (shouldReValidateOnBlur) {
                triggerValidation(name);
            }
        } }), { [valueName || (isCheckboxInput ? 'checked' : VALUE)]: value });
    return Object(react__WEBPACK_IMPORTED_MODULE_0__["isValidElement"])(InnerComponent)
        ? Object(react__WEBPACK_IMPORTED_MODULE_0__["cloneElement"])(InnerComponent, props)
        : Object(react__WEBPACK_IMPORTED_MODULE_0__["createElement"])(InnerComponent, props);
};

const ErrorMessage = (_a) => {
    var { as: InnerComponent, errors, name, message, children } = _a, rest = __rest(_a, ["as", "errors", "name", "message", "children"]);
    const methods = useFormContext();
    const error = get(errors || methods.errors, name);
    if (!error) {
        return null;
    }
    const { message: messageFromRegister, types } = error;
    const props = Object.assign(Object.assign({}, (InnerComponent ? rest : {})), { children: children
            ? children({ message: messageFromRegister || message, messages: types })
            : messageFromRegister || message });
    return InnerComponent ? (Object(react__WEBPACK_IMPORTED_MODULE_0__["isValidElement"])(InnerComponent) ? (Object(react__WEBPACK_IMPORTED_MODULE_0__["cloneElement"])(InnerComponent, props)) : (Object(react__WEBPACK_IMPORTED_MODULE_0__["createElement"])(InnerComponent, props))) : (Object(react__WEBPACK_IMPORTED_MODULE_0__["createElement"])(react__WEBPACK_IMPORTED_MODULE_0__["Fragment"], Object.assign({}, props)));
};




/***/ }),

/***/ "./node_modules/react-is/cjs/react-is.development.js":
/*!***********************************************************!*\
  !*** ./node_modules/react-is/cjs/react-is.development.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/** @license React v16.13.1
 * react-is.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */





if (true) {
  (function() {
'use strict';

// The Symbol used to tag the ReactElement-like types. If there is no native Symbol
// nor polyfill, then a plain number is used for performance.
var hasSymbol = typeof Symbol === 'function' && Symbol.for;
var REACT_ELEMENT_TYPE = hasSymbol ? Symbol.for('react.element') : 0xeac7;
var REACT_PORTAL_TYPE = hasSymbol ? Symbol.for('react.portal') : 0xeaca;
var REACT_FRAGMENT_TYPE = hasSymbol ? Symbol.for('react.fragment') : 0xeacb;
var REACT_STRICT_MODE_TYPE = hasSymbol ? Symbol.for('react.strict_mode') : 0xeacc;
var REACT_PROFILER_TYPE = hasSymbol ? Symbol.for('react.profiler') : 0xead2;
var REACT_PROVIDER_TYPE = hasSymbol ? Symbol.for('react.provider') : 0xeacd;
var REACT_CONTEXT_TYPE = hasSymbol ? Symbol.for('react.context') : 0xeace; // TODO: We don't use AsyncMode or ConcurrentMode anymore. They were temporary
// (unstable) APIs that have been removed. Can we remove the symbols?

var REACT_ASYNC_MODE_TYPE = hasSymbol ? Symbol.for('react.async_mode') : 0xeacf;
var REACT_CONCURRENT_MODE_TYPE = hasSymbol ? Symbol.for('react.concurrent_mode') : 0xeacf;
var REACT_FORWARD_REF_TYPE = hasSymbol ? Symbol.for('react.forward_ref') : 0xead0;
var REACT_SUSPENSE_TYPE = hasSymbol ? Symbol.for('react.suspense') : 0xead1;
var REACT_SUSPENSE_LIST_TYPE = hasSymbol ? Symbol.for('react.suspense_list') : 0xead8;
var REACT_MEMO_TYPE = hasSymbol ? Symbol.for('react.memo') : 0xead3;
var REACT_LAZY_TYPE = hasSymbol ? Symbol.for('react.lazy') : 0xead4;
var REACT_BLOCK_TYPE = hasSymbol ? Symbol.for('react.block') : 0xead9;
var REACT_FUNDAMENTAL_TYPE = hasSymbol ? Symbol.for('react.fundamental') : 0xead5;
var REACT_RESPONDER_TYPE = hasSymbol ? Symbol.for('react.responder') : 0xead6;
var REACT_SCOPE_TYPE = hasSymbol ? Symbol.for('react.scope') : 0xead7;

function isValidElementType(type) {
  return typeof type === 'string' || typeof type === 'function' || // Note: its typeof might be other than 'symbol' or 'number' if it's a polyfill.
  type === REACT_FRAGMENT_TYPE || type === REACT_CONCURRENT_MODE_TYPE || type === REACT_PROFILER_TYPE || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || typeof type === 'object' && type !== null && (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_PROVIDER_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE || type.$$typeof === REACT_FUNDAMENTAL_TYPE || type.$$typeof === REACT_RESPONDER_TYPE || type.$$typeof === REACT_SCOPE_TYPE || type.$$typeof === REACT_BLOCK_TYPE);
}

function typeOf(object) {
  if (typeof object === 'object' && object !== null) {
    var $$typeof = object.$$typeof;

    switch ($$typeof) {
      case REACT_ELEMENT_TYPE:
        var type = object.type;

        switch (type) {
          case REACT_ASYNC_MODE_TYPE:
          case REACT_CONCURRENT_MODE_TYPE:
          case REACT_FRAGMENT_TYPE:
          case REACT_PROFILER_TYPE:
          case REACT_STRICT_MODE_TYPE:
          case REACT_SUSPENSE_TYPE:
            return type;

          default:
            var $$typeofType = type && type.$$typeof;

            switch ($$typeofType) {
              case REACT_CONTEXT_TYPE:
              case REACT_FORWARD_REF_TYPE:
              case REACT_LAZY_TYPE:
              case REACT_MEMO_TYPE:
              case REACT_PROVIDER_TYPE:
                return $$typeofType;

              default:
                return $$typeof;
            }

        }

      case REACT_PORTAL_TYPE:
        return $$typeof;
    }
  }

  return undefined;
} // AsyncMode is deprecated along with isAsyncMode

var AsyncMode = REACT_ASYNC_MODE_TYPE;
var ConcurrentMode = REACT_CONCURRENT_MODE_TYPE;
var ContextConsumer = REACT_CONTEXT_TYPE;
var ContextProvider = REACT_PROVIDER_TYPE;
var Element = REACT_ELEMENT_TYPE;
var ForwardRef = REACT_FORWARD_REF_TYPE;
var Fragment = REACT_FRAGMENT_TYPE;
var Lazy = REACT_LAZY_TYPE;
var Memo = REACT_MEMO_TYPE;
var Portal = REACT_PORTAL_TYPE;
var Profiler = REACT_PROFILER_TYPE;
var StrictMode = REACT_STRICT_MODE_TYPE;
var Suspense = REACT_SUSPENSE_TYPE;
var hasWarnedAboutDeprecatedIsAsyncMode = false; // AsyncMode should be deprecated

function isAsyncMode(object) {
  {
    if (!hasWarnedAboutDeprecatedIsAsyncMode) {
      hasWarnedAboutDeprecatedIsAsyncMode = true; // Using console['warn'] to evade Babel and ESLint

      console['warn']('The ReactIs.isAsyncMode() alias has been deprecated, ' + 'and will be removed in React 17+. Update your code to use ' + 'ReactIs.isConcurrentMode() instead. It has the exact same API.');
    }
  }

  return isConcurrentMode(object) || typeOf(object) === REACT_ASYNC_MODE_TYPE;
}
function isConcurrentMode(object) {
  return typeOf(object) === REACT_CONCURRENT_MODE_TYPE;
}
function isContextConsumer(object) {
  return typeOf(object) === REACT_CONTEXT_TYPE;
}
function isContextProvider(object) {
  return typeOf(object) === REACT_PROVIDER_TYPE;
}
function isElement(object) {
  return typeof object === 'object' && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;
}
function isForwardRef(object) {
  return typeOf(object) === REACT_FORWARD_REF_TYPE;
}
function isFragment(object) {
  return typeOf(object) === REACT_FRAGMENT_TYPE;
}
function isLazy(object) {
  return typeOf(object) === REACT_LAZY_TYPE;
}
function isMemo(object) {
  return typeOf(object) === REACT_MEMO_TYPE;
}
function isPortal(object) {
  return typeOf(object) === REACT_PORTAL_TYPE;
}
function isProfiler(object) {
  return typeOf(object) === REACT_PROFILER_TYPE;
}
function isStrictMode(object) {
  return typeOf(object) === REACT_STRICT_MODE_TYPE;
}
function isSuspense(object) {
  return typeOf(object) === REACT_SUSPENSE_TYPE;
}

exports.AsyncMode = AsyncMode;
exports.ConcurrentMode = ConcurrentMode;
exports.ContextConsumer = ContextConsumer;
exports.ContextProvider = ContextProvider;
exports.Element = Element;
exports.ForwardRef = ForwardRef;
exports.Fragment = Fragment;
exports.Lazy = Lazy;
exports.Memo = Memo;
exports.Portal = Portal;
exports.Profiler = Profiler;
exports.StrictMode = StrictMode;
exports.Suspense = Suspense;
exports.isAsyncMode = isAsyncMode;
exports.isConcurrentMode = isConcurrentMode;
exports.isContextConsumer = isContextConsumer;
exports.isContextProvider = isContextProvider;
exports.isElement = isElement;
exports.isForwardRef = isForwardRef;
exports.isFragment = isFragment;
exports.isLazy = isLazy;
exports.isMemo = isMemo;
exports.isPortal = isPortal;
exports.isProfiler = isProfiler;
exports.isStrictMode = isStrictMode;
exports.isSuspense = isSuspense;
exports.isValidElementType = isValidElementType;
exports.typeOf = typeOf;
  })();
}


/***/ }),

/***/ "./node_modules/react-is/index.js":
/*!****************************************!*\
  !*** ./node_modules/react-is/index.js ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


if (false) {} else {
  module.exports = __webpack_require__(/*! ./cjs/react-is.development.js */ "./node_modules/react-is/cjs/react-is.development.js");
}


/***/ }),

/***/ "./node_modules/regenerator-runtime/runtime.js":
/*!*****************************************************!*\
  !*** ./node_modules/regenerator-runtime/runtime.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/**
 * Copyright (c) 2014-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

var runtime = (function (exports) {
  "use strict";

  var Op = Object.prototype;
  var hasOwn = Op.hasOwnProperty;
  var undefined; // More compressible than void 0.
  var $Symbol = typeof Symbol === "function" ? Symbol : {};
  var iteratorSymbol = $Symbol.iterator || "@@iterator";
  var asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator";
  var toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag";

  function define(obj, key, value) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
    return obj[key];
  }
  try {
    // IE 8 has a broken Object.defineProperty that only works on DOM objects.
    define({}, "");
  } catch (err) {
    define = function(obj, key, value) {
      return obj[key] = value;
    };
  }

  function wrap(innerFn, outerFn, self, tryLocsList) {
    // If outerFn provided and outerFn.prototype is a Generator, then outerFn.prototype instanceof Generator.
    var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator;
    var generator = Object.create(protoGenerator.prototype);
    var context = new Context(tryLocsList || []);

    // The ._invoke method unifies the implementations of the .next,
    // .throw, and .return methods.
    generator._invoke = makeInvokeMethod(innerFn, self, context);

    return generator;
  }
  exports.wrap = wrap;

  // Try/catch helper to minimize deoptimizations. Returns a completion
  // record like context.tryEntries[i].completion. This interface could
  // have been (and was previously) designed to take a closure to be
  // invoked without arguments, but in all the cases we care about we
  // already have an existing method we want to call, so there's no need
  // to create a new function object. We can even get away with assuming
  // the method takes exactly one argument, since that happens to be true
  // in every case, so we don't have to touch the arguments object. The
  // only additional allocation required is the completion record, which
  // has a stable shape and so hopefully should be cheap to allocate.
  function tryCatch(fn, obj, arg) {
    try {
      return { type: "normal", arg: fn.call(obj, arg) };
    } catch (err) {
      return { type: "throw", arg: err };
    }
  }

  var GenStateSuspendedStart = "suspendedStart";
  var GenStateSuspendedYield = "suspendedYield";
  var GenStateExecuting = "executing";
  var GenStateCompleted = "completed";

  // Returning this object from the innerFn has the same effect as
  // breaking out of the dispatch switch statement.
  var ContinueSentinel = {};

  // Dummy constructor functions that we use as the .constructor and
  // .constructor.prototype properties for functions that return Generator
  // objects. For full spec compliance, you may wish to configure your
  // minifier not to mangle the names of these two functions.
  function Generator() {}
  function GeneratorFunction() {}
  function GeneratorFunctionPrototype() {}

  // This is a polyfill for %IteratorPrototype% for environments that
  // don't natively support it.
  var IteratorPrototype = {};
  IteratorPrototype[iteratorSymbol] = function () {
    return this;
  };

  var getProto = Object.getPrototypeOf;
  var NativeIteratorPrototype = getProto && getProto(getProto(values([])));
  if (NativeIteratorPrototype &&
      NativeIteratorPrototype !== Op &&
      hasOwn.call(NativeIteratorPrototype, iteratorSymbol)) {
    // This environment has a native %IteratorPrototype%; use it instead
    // of the polyfill.
    IteratorPrototype = NativeIteratorPrototype;
  }

  var Gp = GeneratorFunctionPrototype.prototype =
    Generator.prototype = Object.create(IteratorPrototype);
  GeneratorFunction.prototype = Gp.constructor = GeneratorFunctionPrototype;
  GeneratorFunctionPrototype.constructor = GeneratorFunction;
  GeneratorFunction.displayName = define(
    GeneratorFunctionPrototype,
    toStringTagSymbol,
    "GeneratorFunction"
  );

  // Helper for defining the .next, .throw, and .return methods of the
  // Iterator interface in terms of a single ._invoke method.
  function defineIteratorMethods(prototype) {
    ["next", "throw", "return"].forEach(function(method) {
      define(prototype, method, function(arg) {
        return this._invoke(method, arg);
      });
    });
  }

  exports.isGeneratorFunction = function(genFun) {
    var ctor = typeof genFun === "function" && genFun.constructor;
    return ctor
      ? ctor === GeneratorFunction ||
        // For the native GeneratorFunction constructor, the best we can
        // do is to check its .name property.
        (ctor.displayName || ctor.name) === "GeneratorFunction"
      : false;
  };

  exports.mark = function(genFun) {
    if (Object.setPrototypeOf) {
      Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);
    } else {
      genFun.__proto__ = GeneratorFunctionPrototype;
      define(genFun, toStringTagSymbol, "GeneratorFunction");
    }
    genFun.prototype = Object.create(Gp);
    return genFun;
  };

  // Within the body of any async function, `await x` is transformed to
  // `yield regeneratorRuntime.awrap(x)`, so that the runtime can test
  // `hasOwn.call(value, "__await")` to determine if the yielded value is
  // meant to be awaited.
  exports.awrap = function(arg) {
    return { __await: arg };
  };

  function AsyncIterator(generator, PromiseImpl) {
    function invoke(method, arg, resolve, reject) {
      var record = tryCatch(generator[method], generator, arg);
      if (record.type === "throw") {
        reject(record.arg);
      } else {
        var result = record.arg;
        var value = result.value;
        if (value &&
            typeof value === "object" &&
            hasOwn.call(value, "__await")) {
          return PromiseImpl.resolve(value.__await).then(function(value) {
            invoke("next", value, resolve, reject);
          }, function(err) {
            invoke("throw", err, resolve, reject);
          });
        }

        return PromiseImpl.resolve(value).then(function(unwrapped) {
          // When a yielded Promise is resolved, its final value becomes
          // the .value of the Promise<{value,done}> result for the
          // current iteration.
          result.value = unwrapped;
          resolve(result);
        }, function(error) {
          // If a rejected Promise was yielded, throw the rejection back
          // into the async generator function so it can be handled there.
          return invoke("throw", error, resolve, reject);
        });
      }
    }

    var previousPromise;

    function enqueue(method, arg) {
      function callInvokeWithMethodAndArg() {
        return new PromiseImpl(function(resolve, reject) {
          invoke(method, arg, resolve, reject);
        });
      }

      return previousPromise =
        // If enqueue has been called before, then we want to wait until
        // all previous Promises have been resolved before calling invoke,
        // so that results are always delivered in the correct order. If
        // enqueue has not been called before, then it is important to
        // call invoke immediately, without waiting on a callback to fire,
        // so that the async generator function has the opportunity to do
        // any necessary setup in a predictable way. This predictability
        // is why the Promise constructor synchronously invokes its
        // executor callback, and why async functions synchronously
        // execute code before the first await. Since we implement simple
        // async functions in terms of async generators, it is especially
        // important to get this right, even though it requires care.
        previousPromise ? previousPromise.then(
          callInvokeWithMethodAndArg,
          // Avoid propagating failures to Promises returned by later
          // invocations of the iterator.
          callInvokeWithMethodAndArg
        ) : callInvokeWithMethodAndArg();
    }

    // Define the unified helper method that is used to implement .next,
    // .throw, and .return (see defineIteratorMethods).
    this._invoke = enqueue;
  }

  defineIteratorMethods(AsyncIterator.prototype);
  AsyncIterator.prototype[asyncIteratorSymbol] = function () {
    return this;
  };
  exports.AsyncIterator = AsyncIterator;

  // Note that simple async functions are implemented on top of
  // AsyncIterator objects; they just return a Promise for the value of
  // the final result produced by the iterator.
  exports.async = function(innerFn, outerFn, self, tryLocsList, PromiseImpl) {
    if (PromiseImpl === void 0) PromiseImpl = Promise;

    var iter = new AsyncIterator(
      wrap(innerFn, outerFn, self, tryLocsList),
      PromiseImpl
    );

    return exports.isGeneratorFunction(outerFn)
      ? iter // If outerFn is a generator, return the full iterator.
      : iter.next().then(function(result) {
          return result.done ? result.value : iter.next();
        });
  };

  function makeInvokeMethod(innerFn, self, context) {
    var state = GenStateSuspendedStart;

    return function invoke(method, arg) {
      if (state === GenStateExecuting) {
        throw new Error("Generator is already running");
      }

      if (state === GenStateCompleted) {
        if (method === "throw") {
          throw arg;
        }

        // Be forgiving, per 25.3.3.3.3 of the spec:
        // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume
        return doneResult();
      }

      context.method = method;
      context.arg = arg;

      while (true) {
        var delegate = context.delegate;
        if (delegate) {
          var delegateResult = maybeInvokeDelegate(delegate, context);
          if (delegateResult) {
            if (delegateResult === ContinueSentinel) continue;
            return delegateResult;
          }
        }

        if (context.method === "next") {
          // Setting context._sent for legacy support of Babel's
          // function.sent implementation.
          context.sent = context._sent = context.arg;

        } else if (context.method === "throw") {
          if (state === GenStateSuspendedStart) {
            state = GenStateCompleted;
            throw context.arg;
          }

          context.dispatchException(context.arg);

        } else if (context.method === "return") {
          context.abrupt("return", context.arg);
        }

        state = GenStateExecuting;

        var record = tryCatch(innerFn, self, context);
        if (record.type === "normal") {
          // If an exception is thrown from innerFn, we leave state ===
          // GenStateExecuting and loop back for another invocation.
          state = context.done
            ? GenStateCompleted
            : GenStateSuspendedYield;

          if (record.arg === ContinueSentinel) {
            continue;
          }

          return {
            value: record.arg,
            done: context.done
          };

        } else if (record.type === "throw") {
          state = GenStateCompleted;
          // Dispatch the exception by looping back around to the
          // context.dispatchException(context.arg) call above.
          context.method = "throw";
          context.arg = record.arg;
        }
      }
    };
  }

  // Call delegate.iterator[context.method](context.arg) and handle the
  // result, either by returning a { value, done } result from the
  // delegate iterator, or by modifying context.method and context.arg,
  // setting context.delegate to null, and returning the ContinueSentinel.
  function maybeInvokeDelegate(delegate, context) {
    var method = delegate.iterator[context.method];
    if (method === undefined) {
      // A .throw or .return when the delegate iterator has no .throw
      // method always terminates the yield* loop.
      context.delegate = null;

      if (context.method === "throw") {
        // Note: ["return"] must be used for ES3 parsing compatibility.
        if (delegate.iterator["return"]) {
          // If the delegate iterator has a return method, give it a
          // chance to clean up.
          context.method = "return";
          context.arg = undefined;
          maybeInvokeDelegate(delegate, context);

          if (context.method === "throw") {
            // If maybeInvokeDelegate(context) changed context.method from
            // "return" to "throw", let that override the TypeError below.
            return ContinueSentinel;
          }
        }

        context.method = "throw";
        context.arg = new TypeError(
          "The iterator does not provide a 'throw' method");
      }

      return ContinueSentinel;
    }

    var record = tryCatch(method, delegate.iterator, context.arg);

    if (record.type === "throw") {
      context.method = "throw";
      context.arg = record.arg;
      context.delegate = null;
      return ContinueSentinel;
    }

    var info = record.arg;

    if (! info) {
      context.method = "throw";
      context.arg = new TypeError("iterator result is not an object");
      context.delegate = null;
      return ContinueSentinel;
    }

    if (info.done) {
      // Assign the result of the finished delegate to the temporary
      // variable specified by delegate.resultName (see delegateYield).
      context[delegate.resultName] = info.value;

      // Resume execution at the desired location (see delegateYield).
      context.next = delegate.nextLoc;

      // If context.method was "throw" but the delegate handled the
      // exception, let the outer generator proceed normally. If
      // context.method was "next", forget context.arg since it has been
      // "consumed" by the delegate iterator. If context.method was
      // "return", allow the original .return call to continue in the
      // outer generator.
      if (context.method !== "return") {
        context.method = "next";
        context.arg = undefined;
      }

    } else {
      // Re-yield the result returned by the delegate method.
      return info;
    }

    // The delegate iterator is finished, so forget it and continue with
    // the outer generator.
    context.delegate = null;
    return ContinueSentinel;
  }

  // Define Generator.prototype.{next,throw,return} in terms of the
  // unified ._invoke helper method.
  defineIteratorMethods(Gp);

  define(Gp, toStringTagSymbol, "Generator");

  // A Generator should always return itself as the iterator object when the
  // @@iterator function is called on it. Some browsers' implementations of the
  // iterator prototype chain incorrectly implement this, causing the Generator
  // object to not be returned from this call. This ensures that doesn't happen.
  // See https://github.com/facebook/regenerator/issues/274 for more details.
  Gp[iteratorSymbol] = function() {
    return this;
  };

  Gp.toString = function() {
    return "[object Generator]";
  };

  function pushTryEntry(locs) {
    var entry = { tryLoc: locs[0] };

    if (1 in locs) {
      entry.catchLoc = locs[1];
    }

    if (2 in locs) {
      entry.finallyLoc = locs[2];
      entry.afterLoc = locs[3];
    }

    this.tryEntries.push(entry);
  }

  function resetTryEntry(entry) {
    var record = entry.completion || {};
    record.type = "normal";
    delete record.arg;
    entry.completion = record;
  }

  function Context(tryLocsList) {
    // The root entry object (effectively a try statement without a catch
    // or a finally block) gives us a place to store values thrown from
    // locations where there is no enclosing try statement.
    this.tryEntries = [{ tryLoc: "root" }];
    tryLocsList.forEach(pushTryEntry, this);
    this.reset(true);
  }

  exports.keys = function(object) {
    var keys = [];
    for (var key in object) {
      keys.push(key);
    }
    keys.reverse();

    // Rather than returning an object with a next method, we keep
    // things simple and return the next function itself.
    return function next() {
      while (keys.length) {
        var key = keys.pop();
        if (key in object) {
          next.value = key;
          next.done = false;
          return next;
        }
      }

      // To avoid creating an additional object, we just hang the .value
      // and .done properties off the next function object itself. This
      // also ensures that the minifier will not anonymize the function.
      next.done = true;
      return next;
    };
  };

  function values(iterable) {
    if (iterable) {
      var iteratorMethod = iterable[iteratorSymbol];
      if (iteratorMethod) {
        return iteratorMethod.call(iterable);
      }

      if (typeof iterable.next === "function") {
        return iterable;
      }

      if (!isNaN(iterable.length)) {
        var i = -1, next = function next() {
          while (++i < iterable.length) {
            if (hasOwn.call(iterable, i)) {
              next.value = iterable[i];
              next.done = false;
              return next;
            }
          }

          next.value = undefined;
          next.done = true;

          return next;
        };

        return next.next = next;
      }
    }

    // Return an iterator with no values.
    return { next: doneResult };
  }
  exports.values = values;

  function doneResult() {
    return { value: undefined, done: true };
  }

  Context.prototype = {
    constructor: Context,

    reset: function(skipTempReset) {
      this.prev = 0;
      this.next = 0;
      // Resetting context._sent for legacy support of Babel's
      // function.sent implementation.
      this.sent = this._sent = undefined;
      this.done = false;
      this.delegate = null;

      this.method = "next";
      this.arg = undefined;

      this.tryEntries.forEach(resetTryEntry);

      if (!skipTempReset) {
        for (var name in this) {
          // Not sure about the optimal order of these conditions:
          if (name.charAt(0) === "t" &&
              hasOwn.call(this, name) &&
              !isNaN(+name.slice(1))) {
            this[name] = undefined;
          }
        }
      }
    },

    stop: function() {
      this.done = true;

      var rootEntry = this.tryEntries[0];
      var rootRecord = rootEntry.completion;
      if (rootRecord.type === "throw") {
        throw rootRecord.arg;
      }

      return this.rval;
    },

    dispatchException: function(exception) {
      if (this.done) {
        throw exception;
      }

      var context = this;
      function handle(loc, caught) {
        record.type = "throw";
        record.arg = exception;
        context.next = loc;

        if (caught) {
          // If the dispatched exception was caught by a catch block,
          // then let that catch block handle the exception normally.
          context.method = "next";
          context.arg = undefined;
        }

        return !! caught;
      }

      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        var record = entry.completion;

        if (entry.tryLoc === "root") {
          // Exception thrown outside of any try block that could handle
          // it, so set the completion value of the entire function to
          // throw the exception.
          return handle("end");
        }

        if (entry.tryLoc <= this.prev) {
          var hasCatch = hasOwn.call(entry, "catchLoc");
          var hasFinally = hasOwn.call(entry, "finallyLoc");

          if (hasCatch && hasFinally) {
            if (this.prev < entry.catchLoc) {
              return handle(entry.catchLoc, true);
            } else if (this.prev < entry.finallyLoc) {
              return handle(entry.finallyLoc);
            }

          } else if (hasCatch) {
            if (this.prev < entry.catchLoc) {
              return handle(entry.catchLoc, true);
            }

          } else if (hasFinally) {
            if (this.prev < entry.finallyLoc) {
              return handle(entry.finallyLoc);
            }

          } else {
            throw new Error("try statement without catch or finally");
          }
        }
      }
    },

    abrupt: function(type, arg) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.tryLoc <= this.prev &&
            hasOwn.call(entry, "finallyLoc") &&
            this.prev < entry.finallyLoc) {
          var finallyEntry = entry;
          break;
        }
      }

      if (finallyEntry &&
          (type === "break" ||
           type === "continue") &&
          finallyEntry.tryLoc <= arg &&
          arg <= finallyEntry.finallyLoc) {
        // Ignore the finally entry if control is not jumping to a
        // location outside the try/catch block.
        finallyEntry = null;
      }

      var record = finallyEntry ? finallyEntry.completion : {};
      record.type = type;
      record.arg = arg;

      if (finallyEntry) {
        this.method = "next";
        this.next = finallyEntry.finallyLoc;
        return ContinueSentinel;
      }

      return this.complete(record);
    },

    complete: function(record, afterLoc) {
      if (record.type === "throw") {
        throw record.arg;
      }

      if (record.type === "break" ||
          record.type === "continue") {
        this.next = record.arg;
      } else if (record.type === "return") {
        this.rval = this.arg = record.arg;
        this.method = "return";
        this.next = "end";
      } else if (record.type === "normal" && afterLoc) {
        this.next = afterLoc;
      }

      return ContinueSentinel;
    },

    finish: function(finallyLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.finallyLoc === finallyLoc) {
          this.complete(entry.completion, entry.afterLoc);
          resetTryEntry(entry);
          return ContinueSentinel;
        }
      }
    },

    "catch": function(tryLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.tryLoc === tryLoc) {
          var record = entry.completion;
          if (record.type === "throw") {
            var thrown = record.arg;
            resetTryEntry(entry);
          }
          return thrown;
        }
      }

      // The context.catch method must only be called with a location
      // argument that corresponds to a known catch block.
      throw new Error("illegal catch attempt");
    },

    delegateYield: function(iterable, resultName, nextLoc) {
      this.delegate = {
        iterator: values(iterable),
        resultName: resultName,
        nextLoc: nextLoc
      };

      if (this.method === "next") {
        // Deliberately forget the last sent value so that we don't
        // accidentally pass it on to the delegate.
        this.arg = undefined;
      }

      return ContinueSentinel;
    }
  };

  // Regardless of whether this script is executing as a CommonJS module
  // or not, return the runtime object so that we can declare the variable
  // regeneratorRuntime in the outer scope, which allows this module to be
  // injected easily by `bin/regenerator --include-runtime script.js`.
  return exports;

}(
  // If this script is executing as a CommonJS module, use module.exports
  // as the regeneratorRuntime namespace. Otherwise create a new empty
  // object. Either way, the resulting object will be used to initialize
  // the regeneratorRuntime variable at the top of this file.
   true ? module.exports : undefined
));

try {
  regeneratorRuntime = runtime;
} catch (accidentalStrictMode) {
  // This module should not be running in strict mode, so the above
  // assignment should always work unless something is misconfigured. Just
  // in case runtime.js accidentally runs in strict mode, we can escape
  // strict mode using a global Function call. This could conceivably fail
  // if a Content Security Policy forbids using Function, but in that case
  // the proper solution is to fix the accidental strict mode problem. If
  // you've misconfigured your bundler to force strict mode and applied a
  // CSP to forbid Function, and you're not willing to fix either of those
  // problems, please detail your unique predicament in a GitHub issue.
  Function("r", "regeneratorRuntime = r")(runtime);
}


/***/ }),

/***/ "./node_modules/unistore-hooks/dist/unistore-hooks.module.js":
/*!*******************************************************************!*\
  !*** ./node_modules/unistore-hooks/dist/unistore-hooks.module.js ***!
  \*******************************************************************/
/*! exports provided: Provider, useActions, useStore, useStoreState */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Provider", function() { return a; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "useActions", function() { return v; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "useStore", function() { return p; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "useStoreState", function() { return s; });
/* harmony import */ var preact__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! preact */ "./node_modules/preact/dist/preact.module.js");
/* harmony import */ var preact_hooks__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! preact/hooks */ "./node_modules/preact/hooks/dist/hooks.module.js");
function f(r,n,t,i,o){for(n=n.split?n.split("."):n,i=0;i<n.length;i++)r=r?r[n[i]]:o;return r===o?t:r}var u=Object(preact__WEBPACK_IMPORTED_MODULE_0__["createContext"])(),a=u.Provider;function c(r,n){var t=!1;for(var i in n)r[i]!==n[i]&&(!1===t&&(t=!0,r=Object.assign({},r)),r[i]=n[i]);return r}function p(){return Object(preact_hooks__WEBPACK_IMPORTED_MODULE_1__["useContext"])(u)}function s(r){var e=Object(preact_hooks__WEBPACK_IMPORTED_MODULE_1__["useContext"])(u),a=Object(preact_hooks__WEBPACK_IMPORTED_MODULE_1__["useMemo"])(function(){return"function"==(t=typeof(n=r))?n:("string"==t&&(n=n.split(/\s*,\s*/)),Array.isArray(n)&&(n=n.reduce(function(r,n){return r[n]=n,r},{})),function(r){var t={};if(r)for(var i in n)t[i]=i in r?r[i]:f(r,n[i]);return t});var n,t},[]),p=Object(preact_hooks__WEBPACK_IMPORTED_MODULE_1__["useReducer"])(c,e?a(e.getState()):{}),s=p[0],v=p[1];return Object(preact_hooks__WEBPACK_IMPORTED_MODULE_1__["useEffect"])(function(){return e.subscribe(function(r){return v(a(r))})},[e]),s}function v(r,i,o){if("function"==typeof o){var f=[i,o];o=f[0],i=f[1]}var a=Object(preact_hooks__WEBPACK_IMPORTED_MODULE_1__["useContext"])(u),c=Object(preact_hooks__WEBPACK_IMPORTED_MODULE_1__["useMemo"])(function(){return function(r,n){var t=n.bindings||(n.bindings=new("function"==typeof WeakMap?WeakMap:Map)),i=t.get(r);if(!i)for(var o in t.set(r,i={}),"function"==typeof r&&(r=r(n)),r)i[o]=n.action(r[o]);return i}(r,a)},[r,a]);return i=Object(preact_hooks__WEBPACK_IMPORTED_MODULE_1__["useCallback"])(i,o||[]),Object(preact_hooks__WEBPACK_IMPORTED_MODULE_1__["useMemo"])(function(){var r=i,n={};if(!r)return c;for(var t in"function"==typeof r&&(r=r(c)),r){var o=r[t];Array.isArray(o)&&(o=o[0].bind.apply(o[0],o)),n[t]=o}return n},[c,i])}


/***/ }),

/***/ "./node_modules/unistore/devtools.js":
/*!*******************************************!*\
  !*** ./node_modules/unistore/devtools.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = function unistoreDevTools(store) {
	var extension = window.__REDUX_DEVTOOLS_EXTENSION__ || window.top.__REDUX_DEVTOOLS_EXTENSION__;
	var ignoreState = false;

	if (!extension) {
		console.warn('Please install/enable Redux devtools extension');
		store.devtools = null;

		return store;
	}

	if (!store.devtools) {
		store.devtools = extension.connect();
		store.devtools.subscribe(function (message) {
			if (message.type === 'DISPATCH' && message.state) {
				ignoreState = (message.payload.type === 'JUMP_TO_ACTION' || message.payload.type === 'JUMP_TO_STATE');
				store.setState(JSON.parse(message.state), true);
			}
		});
		store.devtools.init(store.getState());
		store.subscribe(function (state, action) {
			var actionName = action && action.name || 'setState';

			if (!ignoreState) {
				store.devtools.send(actionName, state);
			} else {
				ignoreState = false;
			}
		});
	}

	return store;
}


/***/ }),

/***/ "./node_modules/unistore/dist/unistore.es.js":
/*!***************************************************!*\
  !*** ./node_modules/unistore/dist/unistore.es.js ***!
  \***************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
function n(n,t){for(var r in t)n[r]=t[r];return n}/* harmony default export */ __webpack_exports__["default"] = (function(t){var r=[];function u(n){for(var t=[],u=0;u<r.length;u++)r[u]===n?n=null:t.push(r[u]);r=t}function e(u,e,f){t=e?u:n(n({},t),u);for(var i=r,o=0;o<i.length;o++)i[o](t,f)}return t=t||{},{action:function(n){function r(t){e(t,!1,n)}return function(){for(var u=arguments,e=[t],f=0;f<arguments.length;f++)e.push(u[f]);var i=n.apply(this,e);if(null!=i)return i.then?i.then(r):r(i)}},setState:e,subscribe:function(n){return r.push(n),function(){u(n)}},unsubscribe:u,getState:function(){return t}}});
//# sourceMappingURL=unistore.es.js.map


/***/ }),

/***/ "./pages/_app.css":
/*!************************!*\
  !*** ./pages/_app.css ***!
  \************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var api = __webpack_require__(/*! ../node_modules/next/dist/build/webpack/loaders/next-style-loader/runtime/injectStylesIntoStyleTag.js */ "./node_modules/next/dist/build/webpack/loaders/next-style-loader/runtime/injectStylesIntoStyleTag.js");
            var content = __webpack_require__(/*! !../node_modules/next/dist/compiled/css-loader/cjs.js??ref--5-oneOf-6-1!../node_modules/next/dist/compiled/postcss-loader/cjs.js??ref--5-oneOf-6-2!./_app.css */ "./node_modules/next/dist/compiled/css-loader/cjs.js?!./node_modules/next/dist/compiled/postcss-loader/cjs.js?!./pages/_app.css");

            content = content.__esModule ? content.default : content;

            if (typeof content === 'string') {
              content = [[module.i, content, '']];
            }

var options = {};

options.insert = function(element){// These elements should always exist. If they do not,
// this code should fail.
var anchorElement=document.querySelector('#__next_css__DO_NOT_USE__');var parentNode=anchorElement.parentNode;// Normally <head>
// Each style tag should be placed right before our
// anchor. By inserting before and not after, we do not
// need to track the last inserted element.
parentNode.insertBefore(element,anchorElement);};
options.singleton = false;

var update = api(content, options);


if (true) {
  if (!content.locals || module.hot.invalidate) {
    var isEqualLocals = function isEqualLocals(a,b,isNamedExport){if(!a&&b||a&&!b){return false;}let p;for(p in a){if(isNamedExport&&p==='default'){// eslint-disable-next-line no-continue
continue;}if(a[p]!==b[p]){return false;}}for(p in b){if(isNamedExport&&p==='default'){// eslint-disable-next-line no-continue
continue;}if(!a[p]){return false;}}return true;};
    var oldLocals = content.locals;

    module.hot.accept(
      /*! !../node_modules/next/dist/compiled/css-loader/cjs.js??ref--5-oneOf-6-1!../node_modules/next/dist/compiled/postcss-loader/cjs.js??ref--5-oneOf-6-2!./_app.css */ "./node_modules/next/dist/compiled/css-loader/cjs.js?!./node_modules/next/dist/compiled/postcss-loader/cjs.js?!./pages/_app.css",
      function () {
        content = __webpack_require__(/*! !../node_modules/next/dist/compiled/css-loader/cjs.js??ref--5-oneOf-6-1!../node_modules/next/dist/compiled/postcss-loader/cjs.js??ref--5-oneOf-6-2!./_app.css */ "./node_modules/next/dist/compiled/css-loader/cjs.js?!./node_modules/next/dist/compiled/postcss-loader/cjs.js?!./pages/_app.css");

              content = content.__esModule ? content.default : content;

              if (typeof content === 'string') {
                content = [[module.i, content, '']];
              }

              if (!isEqualLocals(oldLocals, content.locals)) {
                module.hot.invalidate();

                return;
              }

              oldLocals = content.locals;

              update(content);
      }
    )
  }

  module.hot.dispose(function() {
    update();
  });
}

module.exports = content.locals || {};

/***/ }),

/***/ "./pages/_app.tsx":
/*!************************!*\
  !*** ./pages/_app.tsx ***!
  \************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* WEBPACK VAR INJECTION */(function(module, __prefresh_utils__) {/* harmony import */ var C_Users_admin_Documents_Dev_PWAdvent_node_modules_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./node_modules/@babel/runtime/helpers/esm/extends */ "./node_modules/@babel/runtime/helpers/esm/extends.js");
/* harmony import */ var C_Users_admin_Documents_Dev_PWAdvent_node_modules_babel_runtime_helpers_esm_slicedToArray__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./node_modules/@babel/runtime/helpers/esm/slicedToArray */ "./node_modules/@babel/runtime/helpers/esm/slicedToArray.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! react */ "./node_modules/preact/compat/dist/compat.module.js");
/* harmony import */ var unistore_hooks__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! unistore-hooks */ "./node_modules/unistore-hooks/dist/unistore-hooks.module.js");
/* harmony import */ var _theme__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @theme */ "./theme/index.ts");
/* harmony import */ var _comps_About_About__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @comps/About/About */ "./components/About/About.tsx");
/* harmony import */ var _comps_Calendar_Calendar__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @comps/Calendar/Calendar */ "./components/Calendar/Calendar.tsx");
/* harmony import */ var _comps_Content_Content__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @comps/Content/Content */ "./components/Content/Content.tsx");
/* harmony import */ var _comps_hooks_useWindowSize__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! @comps/hooks/useWindowSize */ "./components/hooks/useWindowSize.tsx");
/* harmony import */ var _store_index__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! @store/index */ "./store/index.ts");
/* harmony import */ var _app_css__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./_app.css */ "./pages/_app.css");
/* harmony import */ var _app_css__WEBPACK_IMPORTED_MODULE_10___default = /*#__PURE__*/__webpack_require__.n(_app_css__WEBPACK_IMPORTED_MODULE_10__);



var _jsxFileName = "C:\\Users\\admin\\Documents\\Dev\\PWAdvent\\pages\\_app.tsx",
    _this = undefined,
    _s = $RefreshSig$();

var __jsx = react__WEBPACK_IMPORTED_MODULE_2__["default"].createElement;









var startX = 0;
var currentX = 0;
var touchLength = 100;
var MOBILE_BP = 900;
/* harmony default export */ __webpack_exports__["default"] = (_s(function (_ref) {
  _s();

  var Component = _ref.Component,
      pageProps = _ref.pageProps;

  var _useActions = Object(unistore_hooks__WEBPACK_IMPORTED_MODULE_3__["useActions"])(_store_index__WEBPACK_IMPORTED_MODULE_9__["actions"]),
      setOffline = _useActions.setOffline,
      setMenuOpen = _useActions.setMenuOpen;

  var _useStoreState = Object(unistore_hooks__WEBPACK_IMPORTED_MODULE_3__["useStoreState"])(['menuOpen']),
      menuOpen = _useStoreState.menuOpen;

  var _React$useState = react__WEBPACK_IMPORTED_MODULE_2__["default"].useState(false),
      _React$useState2 = Object(C_Users_admin_Documents_Dev_PWAdvent_node_modules_babel_runtime_helpers_esm_slicedToArray__WEBPACK_IMPORTED_MODULE_1__["default"])(_React$useState, 2),
      isMobile = _React$useState2[0],
      setIsMobile = _React$useState2[1];

  var _React$useState3 = react__WEBPACK_IMPORTED_MODULE_2__["default"].useState(false),
      _React$useState4 = Object(C_Users_admin_Documents_Dev_PWAdvent_node_modules_babel_runtime_helpers_esm_slicedToArray__WEBPACK_IMPORTED_MODULE_1__["default"])(_React$useState3, 2),
      transition = _React$useState4[0],
      setTransition = _React$useState4[1];

  var windowSize = Object(_comps_hooks_useWindowSize__WEBPACK_IMPORTED_MODULE_8__["default"])();

  var _React$useState5 = react__WEBPACK_IMPORTED_MODULE_2__["default"].useState(false),
      _React$useState6 = Object(C_Users_admin_Documents_Dev_PWAdvent_node_modules_babel_runtime_helpers_esm_slicedToArray__WEBPACK_IMPORTED_MODULE_1__["default"])(_React$useState5, 2),
      show = _React$useState6[0],
      setShow = _React$useState6[1];

  react__WEBPACK_IMPORTED_MODULE_2__["default"].useEffect(function () {
    if (windowSize.width === null) {
      return;
    }

    if (windowSize.width >= MOBILE_BP && isMobile) {
      setMenuOpen(false);
      setIsMobile(false);
    } else if (windowSize.width < MOBILE_BP) {
      setTimeout(function () {
        return setTransition(true);
      }, 200);
      setIsMobile(true);
    }

    setShow(true);
  }, [windowSize]);
  react__WEBPACK_IMPORTED_MODULE_2__["default"].useEffect(function () {
    setOffline(!navigator.onLine);
    window.addEventListener('online', function () {
      return setOffline(false);
    }, false);
    window.addEventListener('offline', function () {
      return setOffline(true);
    }, false);
  }, []);

  var touchStart = function touchStart(e) {
    startX = e.touches[0].clientX;
  };

  var touchEnd = function touchEnd() {
    var moved = currentX === 0 ? 0 : currentX - startX;

    if (moved <= touchLength * -1) {
      setMenuOpen(false);
    } else if (moved >= touchLength) {
      setMenuOpen(true);
    }

    startX = 0;
    currentX = 0;
  };

  var touchMove = function touchMove(e) {
    currentX = e.touches[0].clientX;
  };

  react__WEBPACK_IMPORTED_MODULE_2__["default"].useEffect(function () {
    window.addEventListener('touchstart', touchStart);
    window.addEventListener('touchend', touchEnd);
    window.addEventListener('touchmove', touchMove);
    return function () {
      window.removeEventListener('touchstart', touchStart);
      window.removeEventListener('touchend', touchEnd);
      window.removeEventListener('touchmove', touchMove);
    };
  }, []);
  return __jsx(unistore_hooks__WEBPACK_IMPORTED_MODULE_3__["Provider"], {
    value: _store_index__WEBPACK_IMPORTED_MODULE_9__["store"],
    __self: _this,
    __source: {
      fileName: _jsxFileName,
      lineNumber: 74,
      columnNumber: 5
    }
  }, __jsx(Component, Object(C_Users_admin_Documents_Dev_PWAdvent_node_modules_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__["default"])({}, pageProps, {
    __self: _this,
    __source: {
      fileName: _jsxFileName,
      lineNumber: 75,
      columnNumber: 7
    }
  })), __jsx(_comps_Content_Content__WEBPACK_IMPORTED_MODULE_7__["default"], {
    className: "app-content",
    __self: _this,
    __source: {
      fileName: _jsxFileName,
      lineNumber: 76,
      columnNumber: 7
    }
  }), __jsx("div", {
    "data-menu": menuOpen ? 'open' : 'closed',
    "data-layout": isMobile ? 'mobile' : 'desktop',
    "data-layout-transition": transition,
    className: "app",
    style: {
      opacity: show ? 1 : 0
    },
    __self: _this,
    __source: {
      fileName: _jsxFileName,
      lineNumber: 77,
      columnNumber: 7
    }
  }, show && __jsx("div", {
    className: "app__inner",
    __self: _this,
    __source: {
      fileName: _jsxFileName,
      lineNumber: 85,
      columnNumber: 11
    }
  }, __jsx(_comps_About_About__WEBPACK_IMPORTED_MODULE_5__["default"], {
    className: "app__sidebar",
    __self: _this,
    __source: {
      fileName: _jsxFileName,
      lineNumber: 86,
      columnNumber: 13
    }
  }), __jsx(_comps_Calendar_Calendar__WEBPACK_IMPORTED_MODULE_6__["default"], {
    className: "app__content",
    __self: _this,
    __source: {
      fileName: _jsxFileName,
      lineNumber: 87,
      columnNumber: 13
    }
  }))), __jsx(_theme__WEBPACK_IMPORTED_MODULE_4__["Snow"], {
    className: "app__snow",
    __self: _this,
    __source: {
      fileName: _jsxFileName,
      lineNumber: 91,
      columnNumber: 7
    }
  }));
}, "1LqvUAcyKQEKco5X/zZbGYD8cbk=", false, function () {
  return [unistore_hooks__WEBPACK_IMPORTED_MODULE_3__["useActions"], unistore_hooks__WEBPACK_IMPORTED_MODULE_3__["useStoreState"], _comps_hooks_useWindowSize__WEBPACK_IMPORTED_MODULE_8__["default"]];
}));

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.i);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }


const isPrefreshComponent = __prefresh_utils__.shouldBind(module);

  if (true) {
    const currentExports = __prefresh_utils__.getExports(module);
    const previousHotModuleExports =
      module.hot.data && module.hot.data.moduleExports;

    __prefresh_utils__.registerExports(currentExports, module.i);

    if (isPrefreshComponent) {
      if (previousHotModuleExports) {
        try {
          __prefresh_utils__.flush();
          if (
            typeof __prefresh_errors__ !== 'undefined' &&
            __prefresh_errors__ &&
            __prefresh_errors__.clearRuntimeErrors
          ) {
            __prefresh_errors__.clearRuntimeErrors();
          }
        } catch (e) {
          // Only available in newer webpack versions.
          if (module.hot.invalidate) {
            module.hot.invalidate();
          } else {
            self.location.reload();
          }
        }
      }

      module.hot.dispose(data => {
        data.moduleExports = __prefresh_utils__.getExports(module);
      });

      module.hot.accept(function errorRecovery() {
        if (
          typeof __prefresh_errors__ !== 'undefined' &&
          __prefresh_errors__ &&
          __prefresh_errors__.handleRuntimeError
        ) {
          __prefresh_errors__.handleRuntimeError(error);
        }

        __webpack_require__.c[module.i].hot.accept(errorRecovery);
      });
    }
  }
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../node_modules/next/dist/compiled/webpack/harmony-module.js */ "./node_modules/next/dist/compiled/webpack/harmony-module.js")(module), __webpack_require__(/*! ./node_modules/@prefresh/webpack/src/utils/prefresh.js */ "./node_modules/@prefresh/webpack/src/utils/prefresh.js")))

/***/ }),

/***/ "./public/icon eager recursive ^\\.\\/.*$":
/*!*****************************************************!*\
  !*** ./public/icon eager ^\.\/.*$ namespace object ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var map = {
	"./mdi/bell-outline.svg": "./public/icon/mdi/bell-outline.svg",
	"./mdi/bell.svg": "./public/icon/mdi/bell.svg",
	"./mdi/calendar-month.svg": "./public/icon/mdi/calendar-month.svg",
	"./mdi/calendar.svg": "./public/icon/mdi/calendar.svg",
	"./mdi/check.svg": "./public/icon/mdi/check.svg",
	"./mdi/download.svg": "./public/icon/mdi/download.svg",
	"./mdi/email-outline.svg": "./public/icon/mdi/email-outline.svg",
	"./mdi/list.svg": "./public/icon/mdi/list.svg",
	"./mdi/menu.svg": "./public/icon/mdi/menu.svg",
	"./mdi/send.svg": "./public/icon/mdi/send.svg",
	"./mdi/share.svg": "./public/icon/mdi/share.svg",
	"./pwa-logo.svg": "./public/icon/pwa-logo.svg",
	"./pwadvent-logo-sameheight.svg": "./public/icon/pwadvent-logo-sameheight.svg",
	"./pwadvent-logo.svg": "./public/icon/pwadvent-logo.svg"
};


function webpackAsyncContext(req) {
	return webpackAsyncContextResolve(req).then(function(id) {
		return __webpack_require__.t(id, 7);
	});
}
function webpackAsyncContextResolve(req) {
	// Here Promise.resolve().then() is used instead of new Promise() to prevent
	// uncaught exception popping up in devtools
	return Promise.resolve().then(function() {
		if(!__webpack_require__.o(map, req)) {
			var e = new Error("Cannot find module '" + req + "'");
			e.code = 'MODULE_NOT_FOUND';
			throw e;
		}
		return map[req];
	});
}
webpackAsyncContext.keys = function webpackAsyncContextKeys() {
	return Object.keys(map);
};
webpackAsyncContext.resolve = webpackAsyncContextResolve;
webpackAsyncContext.id = "./public/icon eager recursive ^\\.\\/.*$";
module.exports = webpackAsyncContext;

/***/ }),

/***/ "./public/icon/mdi/bell-outline.svg":
/*!******************************************!*\
  !*** ./public/icon/mdi/bell-outline.svg ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports) {

throw new Error("Module parse failed: Unexpected token (1:0)\nYou may need an appropriate loader to handle this file type, currently no loaders are configured to process this file. See https://webpack.js.org/concepts#loaders\n> <svg viewBox=\"0 0 24 24\">\n|   <path fill=\"currentColor\"\n|         d=\"M10,21H14A2,2 0 0,1 12,23A2,2 0 0,1 10,21M21,19V20H3V19L5,17V11C5,7.9 7.03,5.17 10,4.29C10,4.19 10,4.1 10,4A2,2 0 0,1 12,2A2,2 0 0,1 14,4C14,4.1 14,4.19 14,4.29C16.97,5.17 19,7.9 19,11V17L21,19M17,11A5,5 0 0,0 12,6A5,5 0 0,0 7,11V18H17V11M19.75,3.19L18.33,4.61C20.04,6.3 21,8.6 21,11H23C23,8.07 21.84,5.25 19.75,3.19M1,11H3C3,8.6 3.96,6.3 5.67,4.61L4.25,3.19C2.16,5.25 1,8.07 1,11Z\"/>");

/***/ }),

/***/ "./public/icon/mdi/bell.svg":
/*!**********************************!*\
  !*** ./public/icon/mdi/bell.svg ***!
  \**********************************/
/*! no static exports found */
/***/ (function(module, exports) {

throw new Error("Module parse failed: Unexpected token (1:0)\nYou may need an appropriate loader to handle this file type, currently no loaders are configured to process this file. See https://webpack.js.org/concepts#loaders\n> <svg viewBox=\"0 0 24 24\">\n|   <path fill=\"currentColor\"\n|         d=\"M21,19V20H3V19L5,17V11C5,7.9 7.03,5.17 10,4.29C10,4.19 10,4.1 10,4A2,2 0 0,1 12,2A2,2 0 0,1 14,4C14,4.1 14,4.19 14,4.29C16.97,5.17 19,7.9 19,11V17L21,19M14,21A2,2 0 0,1 12,23A2,2 0 0,1 10,21M19.75,3.19L18.33,4.61C20.04,6.3 21,8.6 21,11H23C23,8.07 21.84,5.25 19.75,3.19M1,11H3C3,8.6 3.96,6.3 5.67,4.61L4.25,3.19C2.16,5.25 1,8.07 1,11Z\"/>");

/***/ }),

/***/ "./public/icon/mdi/calendar-month.svg":
/*!********************************************!*\
  !*** ./public/icon/mdi/calendar-month.svg ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

throw new Error("Module parse failed: Unexpected token (1:0)\nYou may need an appropriate loader to handle this file type, currently no loaders are configured to process this file. See https://webpack.js.org/concepts#loaders\n> <?xml version=\"1.0\" encoding=\"UTF-8\"?><!DOCTYPE svg PUBLIC \"-//W3C//DTD SVG 1.1//EN\"\n|   \"http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd\">\n| <svg xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" version=\"1.1\" id=\"mdi-calendar-month\"");

/***/ }),

/***/ "./public/icon/mdi/calendar.svg":
/*!**************************************!*\
  !*** ./public/icon/mdi/calendar.svg ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports) {

throw new Error("Module parse failed: Unexpected token (1:0)\nYou may need an appropriate loader to handle this file type, currently no loaders are configured to process this file. See https://webpack.js.org/concepts#loaders\n> <svg viewBox=\"0 0 24 24\">\n|   <path fill=\"currentColor\"\n|         d=\"M7,12H9V14H7V12M21,6V20A2,2 0 0,1 19,22H5C3.89,22 3,21.1 3,20V6A2,2 0 0,1 5,4H6V2H8V4H16V2H18V4H19A2,2 0 0,1 21,6M5,8H19V6H5V8M19,20V10H5V20H19M15,14V12H17V14H15M11,14V12H13V14H11M7,16H9V18H7V16M15,18V16H17V18H15M11,18V16H13V18H11Z\"/>");

/***/ }),

/***/ "./public/icon/mdi/check.svg":
/*!***********************************!*\
  !*** ./public/icon/mdi/check.svg ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports) {

throw new Error("Module parse failed: Unexpected token (1:0)\nYou may need an appropriate loader to handle this file type, currently no loaders are configured to process this file. See https://webpack.js.org/concepts#loaders\n> <svg viewBox=\"0 0 24 24\">\n|   <path fill=\"currentColor\" d=\"M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z\" />\n| </svg>");

/***/ }),

/***/ "./public/icon/mdi/download.svg":
/*!**************************************!*\
  !*** ./public/icon/mdi/download.svg ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports) {

throw new Error("Module parse failed: Unexpected token (1:0)\nYou may need an appropriate loader to handle this file type, currently no loaders are configured to process this file. See https://webpack.js.org/concepts#loaders\n> <?xml version=\"1.0\" encoding=\"UTF-8\"?><!DOCTYPE svg PUBLIC \"-//W3C//DTD SVG 1.1//EN\" \"http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd\"><svg xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" version=\"1.1\" id=\"mdi-download\" width=\"24\" height=\"24\" viewBox=\"0 0 24 24\"><path d=\"M5,20H19V18H5M19,9H15V3H9V9H5L12,16L19,9Z\" /></svg>");

/***/ }),

/***/ "./public/icon/mdi/email-outline.svg":
/*!*******************************************!*\
  !*** ./public/icon/mdi/email-outline.svg ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports) {

throw new Error("Module parse failed: Unexpected token (1:0)\nYou may need an appropriate loader to handle this file type, currently no loaders are configured to process this file. See https://webpack.js.org/concepts#loaders\n> <?xml version=\"1.0\" encoding=\"UTF-8\"?><!DOCTYPE svg PUBLIC \"-//W3C//DTD SVG 1.1//EN\" \"http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd\"><svg xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" version=\"1.1\" id=\"mdi-email-outline\" width=\"24\" height=\"24\" viewBox=\"0 0 24 24\"><path d=\"M22 6C22 4.9 21.1 4 20 4H4C2.9 4 2 4.9 2 6V18C2 19.1 2.9 20 4 20H20C21.1 20 22 19.1 22 18V6M20 6L12 11L4 6H20M20 18H4V8L12 13L20 8V18Z\" /></svg>");

/***/ }),

/***/ "./public/icon/mdi/list.svg":
/*!**********************************!*\
  !*** ./public/icon/mdi/list.svg ***!
  \**********************************/
/*! no static exports found */
/***/ (function(module, exports) {

throw new Error("Module parse failed: Unexpected token (1:0)\nYou may need an appropriate loader to handle this file type, currently no loaders are configured to process this file. See https://webpack.js.org/concepts#loaders\n> <svg viewBox=\"0 0 24 24\">\n|   <path fill=\"currentColor\"\n|         d=\"M19 3H14.82C14.4 1.84 13.3 1 12 1S9.6 1.84 9.18 3H5C3.9 3 3 3.9 3 5V19C3 20.1 3.9 21 5 21H19C20.1 21 21 20.1 21 19V5C21 3.9 20.1 3 19 3M12 3C12.55 3 13 3.45 13 4S12.55 5 12 5 11 4.55 11 4 11.45 3 12 3M7 7H17V5H19V19H5V5H7V7M12 17V15H17V17H12M12 11V9H17V11H12M8 12V9H7V8H9V12H8M9.25 14C9.66 14 10 14.34 10 14.75C10 14.95 9.92 15.14 9.79 15.27L8.12 17H10V18H7V17.08L9 15H7V14H9.25\"/>");

/***/ }),

/***/ "./public/icon/mdi/menu.svg":
/*!**********************************!*\
  !*** ./public/icon/mdi/menu.svg ***!
  \**********************************/
/*! no static exports found */
/***/ (function(module, exports) {

throw new Error("Module parse failed: Unexpected token (1:0)\nYou may need an appropriate loader to handle this file type, currently no loaders are configured to process this file. See https://webpack.js.org/concepts#loaders\n> <?xml version=\"1.0\" encoding=\"UTF-8\"?><!DOCTYPE svg PUBLIC \"-//W3C//DTD SVG 1.1//EN\" \"http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd\"><svg xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" version=\"1.1\" id=\"mdi-menu\" width=\"24\" height=\"24\" viewBox=\"0 0 24 24\"><path d=\"M3,6H21V8H3V6M3,11H21V13H3V11M3,16H21V18H3V16Z\" /></svg>");

/***/ }),

/***/ "./public/icon/mdi/send.svg":
/*!**********************************!*\
  !*** ./public/icon/mdi/send.svg ***!
  \**********************************/
/*! no static exports found */
/***/ (function(module, exports) {

throw new Error("Module parse failed: Unexpected token (1:0)\nYou may need an appropriate loader to handle this file type, currently no loaders are configured to process this file. See https://webpack.js.org/concepts#loaders\n> <?xml version=\"1.0\" encoding=\"UTF-8\"?><!DOCTYPE svg PUBLIC \"-//W3C//DTD SVG 1.1//EN\" \"http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd\"><svg xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" version=\"1.1\" id=\"mdi-send\" width=\"24\" height=\"24\" viewBox=\"0 0 24 24\"><path d=\"M2,21L23,12L2,3V10L17,12L2,14V21Z\" /></svg>");

/***/ }),

/***/ "./public/icon/mdi/share.svg":
/*!***********************************!*\
  !*** ./public/icon/mdi/share.svg ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports) {

throw new Error("Module parse failed: Unexpected token (1:0)\nYou may need an appropriate loader to handle this file type, currently no loaders are configured to process this file. See https://webpack.js.org/concepts#loaders\n> <?xml version=\"1.0\" encoding=\"UTF-8\"?><!DOCTYPE svg PUBLIC \"-//W3C//DTD SVG 1.1//EN\" \"http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd\"><svg xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" version=\"1.1\" id=\"mdi-share\" width=\"24\" height=\"24\" viewBox=\"0 0 24 24\"><path d=\"M21,12L14,5V9C7,10 4,15 3,20C5.5,16.5 9,14.9 14,14.9V19L21,12Z\" /></svg>");

/***/ }),

/***/ "./public/icon/pwa-logo.svg":
/*!**********************************!*\
  !*** ./public/icon/pwa-logo.svg ***!
  \**********************************/
/*! no static exports found */
/***/ (function(module, exports) {

throw new Error("Module parse failed: Unexpected token (1:0)\nYou may need an appropriate loader to handle this file type, currently no loaders are configured to process this file. See https://webpack.js.org/concepts#loaders\n> <svg xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" version=\"1.1\" baseProfile=\"full\" width=\"1952\" height=\"734.935\" viewBox=\"0 0 1952.00 734.93\" enable-background=\"new 0 0 1952.00 734.93\" xml:space=\"preserve\">\n| \t<g>\n| \t\t<path id=\"p\" fill=\"#3D3D3D\" fill-opacity=\"1\" stroke-width=\"0.2\" stroke-linejoin=\"round\" d=\"M 1436.62,603.304L 1493.01,460.705L 1655.83,460.705L 1578.56,244.39L 1675.2,0.000528336L 1952,734.933L 1747.87,734.933L 1700.57,603.304L 1436.62,603.304 Z \"/>");

/***/ }),

/***/ "./public/icon/pwadvent-logo-sameheight.svg":
/*!**************************************************!*\
  !*** ./public/icon/pwadvent-logo-sameheight.svg ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

throw new Error("Module parse failed: Unexpected token (1:0)\nYou may need an appropriate loader to handle this file type, currently no loaders are configured to process this file. See https://webpack.js.org/concepts#loaders\n> <svg viewBox=\"0 0 4650 735\" xmlns=\"http://www.w3.org/2000/svg\" fill-rule=\"evenodd\" clip-rule=\"evenodd\" stroke-linejoin=\"round\" stroke-miterlimit=\"2\">\n|   <path d=\"M1436.62 603.303l56.39-142.598h162.82l-77.27-216.316L1675.2 0 1952 734.933h-204.13l-47.3-131.63h-263.95z\" fill=\"#cb5454\" fill-rule=\"nonzero\"/>\n|   <path d=\"M1262.47 734.935L1558.79.001l-196.45.001-202.7 474.931L1015.5.003H864.499l-154.768 474.93-109.146-216.416-98.773 304.302 100.284 172.116h193.331l139.857-425.91 133.346 425.91h193.84z\" fill=\"#355454\" fill-rule=\"nonzero\"/>");

/***/ }),

/***/ "./public/icon/pwadvent-logo.svg":
/*!***************************************!*\
  !*** ./public/icon/pwadvent-logo.svg ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports) {

throw new Error("Module parse failed: Unexpected token (1:0)\nYou may need an appropriate loader to handle this file type, currently no loaders are configured to process this file. See https://webpack.js.org/concepts#loaders\n> <?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"no\"?>\n| <!DOCTYPE svg PUBLIC \"-//W3C//DTD SVG 1.1//EN\" \"http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd\">\n| <svg width=\"100%\" height=\"100%\" viewBox=\"0 0 3300 735\" version=\"1.1\" xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" xml:space=\"preserve\" xmlns:serif=\"http://www.serif.com/\" style=\"fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2;\">");

/***/ }),

/***/ "./store/idb.ts":
/*!**********************!*\
  !*** ./store/idb.ts ***!
  \**********************/
/*! exports provided: daysDB, pageDB, settingsDB */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* WEBPACK VAR INJECTION */(function(module, __prefresh_utils__) {/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "daysDB", function() { return daysDB; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "pageDB", function() { return pageDB; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "settingsDB", function() { return settingsDB; });
/* harmony import */ var C_Users_admin_Documents_Dev_PWAdvent_node_modules_babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./node_modules/@babel/runtime/regenerator */ "./node_modules/@babel/runtime/regenerator/index.js");
/* harmony import */ var C_Users_admin_Documents_Dev_PWAdvent_node_modules_babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(C_Users_admin_Documents_Dev_PWAdvent_node_modules_babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var C_Users_admin_Documents_Dev_PWAdvent_node_modules_babel_runtime_helpers_esm_asyncToGenerator__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./node_modules/@babel/runtime/helpers/esm/asyncToGenerator */ "./node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js");
/* harmony import */ var idb__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! idb */ "./node_modules/idb/build/esm/index.js");



var dbName = 'pwadvent';
var dbPromise = false ? undefined : Object(idb__WEBPACK_IMPORTED_MODULE_2__["openDB"])(dbName, 2, {
  upgrade: function upgrade(db, oldVersion) {
    if (oldVersion < 1) {
      db.createObjectStore('days');
      db.createObjectStore('page');
    }

    if (oldVersion < 2) {
      db.createObjectStore('settings');
    }
  }
});
var daysDB = {
  get: function () {
    var _get = Object(C_Users_admin_Documents_Dev_PWAdvent_node_modules_babel_runtime_helpers_esm_asyncToGenerator__WEBPACK_IMPORTED_MODULE_1__["default"])( /*#__PURE__*/C_Users_admin_Documents_Dev_PWAdvent_node_modules_babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_0___default.a.mark(function _callee(key) {
      return C_Users_admin_Documents_Dev_PWAdvent_node_modules_babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_0___default.a.wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              _context.next = 2;
              return dbPromise;

            case 2:
              return _context.abrupt("return", _context.sent.get('days', key));

            case 3:
            case "end":
              return _context.stop();
          }
        }
      }, _callee);
    }));

    function get(_x) {
      return _get.apply(this, arguments);
    }

    return get;
  }(),
  set: function () {
    var _set = Object(C_Users_admin_Documents_Dev_PWAdvent_node_modules_babel_runtime_helpers_esm_asyncToGenerator__WEBPACK_IMPORTED_MODULE_1__["default"])( /*#__PURE__*/C_Users_admin_Documents_Dev_PWAdvent_node_modules_babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_0___default.a.mark(function _callee2(key, val) {
      return C_Users_admin_Documents_Dev_PWAdvent_node_modules_babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_0___default.a.wrap(function _callee2$(_context2) {
        while (1) {
          switch (_context2.prev = _context2.next) {
            case 0:
              _context2.next = 2;
              return dbPromise;

            case 2:
              return _context2.abrupt("return", _context2.sent.put('days', val, key));

            case 3:
            case "end":
              return _context2.stop();
          }
        }
      }, _callee2);
    }));

    function set(_x2, _x3) {
      return _set.apply(this, arguments);
    }

    return set;
  }(),
  "delete": function () {
    var _delete2 = Object(C_Users_admin_Documents_Dev_PWAdvent_node_modules_babel_runtime_helpers_esm_asyncToGenerator__WEBPACK_IMPORTED_MODULE_1__["default"])( /*#__PURE__*/C_Users_admin_Documents_Dev_PWAdvent_node_modules_babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_0___default.a.mark(function _callee3(key) {
      return C_Users_admin_Documents_Dev_PWAdvent_node_modules_babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_0___default.a.wrap(function _callee3$(_context3) {
        while (1) {
          switch (_context3.prev = _context3.next) {
            case 0:
              _context3.next = 2;
              return dbPromise;

            case 2:
              return _context3.abrupt("return", _context3.sent["delete"]('days', key));

            case 3:
            case "end":
              return _context3.stop();
          }
        }
      }, _callee3);
    }));

    function _delete(_x4) {
      return _delete2.apply(this, arguments);
    }

    return _delete;
  }()
};
var pageDB = {
  get: function () {
    var _get2 = Object(C_Users_admin_Documents_Dev_PWAdvent_node_modules_babel_runtime_helpers_esm_asyncToGenerator__WEBPACK_IMPORTED_MODULE_1__["default"])( /*#__PURE__*/C_Users_admin_Documents_Dev_PWAdvent_node_modules_babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_0___default.a.mark(function _callee4(key) {
      return C_Users_admin_Documents_Dev_PWAdvent_node_modules_babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_0___default.a.wrap(function _callee4$(_context4) {
        while (1) {
          switch (_context4.prev = _context4.next) {
            case 0:
              _context4.next = 2;
              return dbPromise;

            case 2:
              return _context4.abrupt("return", _context4.sent.get('page', key));

            case 3:
            case "end":
              return _context4.stop();
          }
        }
      }, _callee4);
    }));

    function get(_x5) {
      return _get2.apply(this, arguments);
    }

    return get;
  }(),
  set: function () {
    var _set2 = Object(C_Users_admin_Documents_Dev_PWAdvent_node_modules_babel_runtime_helpers_esm_asyncToGenerator__WEBPACK_IMPORTED_MODULE_1__["default"])( /*#__PURE__*/C_Users_admin_Documents_Dev_PWAdvent_node_modules_babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_0___default.a.mark(function _callee5(key, val) {
      return C_Users_admin_Documents_Dev_PWAdvent_node_modules_babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_0___default.a.wrap(function _callee5$(_context5) {
        while (1) {
          switch (_context5.prev = _context5.next) {
            case 0:
              _context5.next = 2;
              return dbPromise;

            case 2:
              return _context5.abrupt("return", _context5.sent.put('page', val, key));

            case 3:
            case "end":
              return _context5.stop();
          }
        }
      }, _callee5);
    }));

    function set(_x6, _x7) {
      return _set2.apply(this, arguments);
    }

    return set;
  }(),
  "delete": function () {
    var _delete3 = Object(C_Users_admin_Documents_Dev_PWAdvent_node_modules_babel_runtime_helpers_esm_asyncToGenerator__WEBPACK_IMPORTED_MODULE_1__["default"])( /*#__PURE__*/C_Users_admin_Documents_Dev_PWAdvent_node_modules_babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_0___default.a.mark(function _callee6(key) {
      return C_Users_admin_Documents_Dev_PWAdvent_node_modules_babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_0___default.a.wrap(function _callee6$(_context6) {
        while (1) {
          switch (_context6.prev = _context6.next) {
            case 0:
              _context6.next = 2;
              return dbPromise;

            case 2:
              return _context6.abrupt("return", _context6.sent["delete"]('page', key));

            case 3:
            case "end":
              return _context6.stop();
          }
        }
      }, _callee6);
    }));

    function _delete(_x8) {
      return _delete3.apply(this, arguments);
    }

    return _delete;
  }()
};
var settingsDB = {
  get: function () {
    var _get3 = Object(C_Users_admin_Documents_Dev_PWAdvent_node_modules_babel_runtime_helpers_esm_asyncToGenerator__WEBPACK_IMPORTED_MODULE_1__["default"])( /*#__PURE__*/C_Users_admin_Documents_Dev_PWAdvent_node_modules_babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_0___default.a.mark(function _callee7(key) {
      return C_Users_admin_Documents_Dev_PWAdvent_node_modules_babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_0___default.a.wrap(function _callee7$(_context7) {
        while (1) {
          switch (_context7.prev = _context7.next) {
            case 0:
              _context7.next = 2;
              return dbPromise;

            case 2:
              return _context7.abrupt("return", _context7.sent.get('settings', key));

            case 3:
            case "end":
              return _context7.stop();
          }
        }
      }, _callee7);
    }));

    function get(_x9) {
      return _get3.apply(this, arguments);
    }

    return get;
  }(),
  set: function () {
    var _set3 = Object(C_Users_admin_Documents_Dev_PWAdvent_node_modules_babel_runtime_helpers_esm_asyncToGenerator__WEBPACK_IMPORTED_MODULE_1__["default"])( /*#__PURE__*/C_Users_admin_Documents_Dev_PWAdvent_node_modules_babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_0___default.a.mark(function _callee8(key, val) {
      return C_Users_admin_Documents_Dev_PWAdvent_node_modules_babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_0___default.a.wrap(function _callee8$(_context8) {
        while (1) {
          switch (_context8.prev = _context8.next) {
            case 0:
              _context8.next = 2;
              return dbPromise;

            case 2:
              return _context8.abrupt("return", _context8.sent.put('settings', val, key));

            case 3:
            case "end":
              return _context8.stop();
          }
        }
      }, _callee8);
    }));

    function set(_x10, _x11) {
      return _set3.apply(this, arguments);
    }

    return set;
  }(),
  "delete": function () {
    var _delete4 = Object(C_Users_admin_Documents_Dev_PWAdvent_node_modules_babel_runtime_helpers_esm_asyncToGenerator__WEBPACK_IMPORTED_MODULE_1__["default"])( /*#__PURE__*/C_Users_admin_Documents_Dev_PWAdvent_node_modules_babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_0___default.a.mark(function _callee9(key) {
      return C_Users_admin_Documents_Dev_PWAdvent_node_modules_babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_0___default.a.wrap(function _callee9$(_context9) {
        while (1) {
          switch (_context9.prev = _context9.next) {
            case 0:
              _context9.next = 2;
              return dbPromise;

            case 2:
              return _context9.abrupt("return", _context9.sent["delete"]('settings', key));

            case 3:
            case "end":
              return _context9.stop();
          }
        }
      }, _callee9);
    }));

    function _delete(_x12) {
      return _delete4.apply(this, arguments);
    }

    return _delete;
  }()
};

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.i);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }


const isPrefreshComponent = __prefresh_utils__.shouldBind(module);

  if (true) {
    const currentExports = __prefresh_utils__.getExports(module);
    const previousHotModuleExports =
      module.hot.data && module.hot.data.moduleExports;

    __prefresh_utils__.registerExports(currentExports, module.i);

    if (isPrefreshComponent) {
      if (previousHotModuleExports) {
        try {
          __prefresh_utils__.flush();
          if (
            typeof __prefresh_errors__ !== 'undefined' &&
            __prefresh_errors__ &&
            __prefresh_errors__.clearRuntimeErrors
          ) {
            __prefresh_errors__.clearRuntimeErrors();
          }
        } catch (e) {
          // Only available in newer webpack versions.
          if (module.hot.invalidate) {
            module.hot.invalidate();
          } else {
            self.location.reload();
          }
        }
      }

      module.hot.dispose(data => {
        data.moduleExports = __prefresh_utils__.getExports(module);
      });

      module.hot.accept(function errorRecovery() {
        if (
          typeof __prefresh_errors__ !== 'undefined' &&
          __prefresh_errors__ &&
          __prefresh_errors__.handleRuntimeError
        ) {
          __prefresh_errors__.handleRuntimeError(error);
        }

        __webpack_require__.c[module.i].hot.accept(errorRecovery);
      });
    }
  }
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../node_modules/next/dist/compiled/webpack/harmony-module.js */ "./node_modules/next/dist/compiled/webpack/harmony-module.js")(module), __webpack_require__(/*! ./node_modules/@prefresh/webpack/src/utils/prefresh.js */ "./node_modules/@prefresh/webpack/src/utils/prefresh.js")))

/***/ }),

/***/ "./store/index.ts":
/*!************************!*\
  !*** ./store/index.ts ***!
  \************************/
/*! exports provided: actions, store */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* WEBPACK VAR INJECTION */(function(module, __prefresh_utils__) {/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "actions", function() { return actions; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "store", function() { return store; });
/* harmony import */ var C_Users_admin_Documents_Dev_PWAdvent_node_modules_babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./node_modules/@babel/runtime/regenerator */ "./node_modules/@babel/runtime/regenerator/index.js");
/* harmony import */ var C_Users_admin_Documents_Dev_PWAdvent_node_modules_babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(C_Users_admin_Documents_Dev_PWAdvent_node_modules_babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var C_Users_admin_Documents_Dev_PWAdvent_node_modules_babel_runtime_helpers_esm_asyncToGenerator__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./node_modules/@babel/runtime/helpers/esm/asyncToGenerator */ "./node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js");
/* harmony import */ var C_Users_admin_Documents_Dev_PWAdvent_node_modules_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./node_modules/@babel/runtime/helpers/esm/defineProperty */ "./node_modules/@babel/runtime/helpers/esm/defineProperty.js");
/* harmony import */ var unistore__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! unistore */ "./node_modules/unistore/dist/unistore.es.js");
/* harmony import */ var unistore_devtools__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! unistore/devtools */ "./node_modules/unistore/devtools.js");
/* harmony import */ var unistore_devtools__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(unistore_devtools__WEBPACK_IMPORTED_MODULE_4__);
/* harmony import */ var _store_idb__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @store/idb */ "./store/idb.ts");
/* harmony import */ var _utils_calendar__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @utils/calendar */ "./utils/calendar.ts");
/* harmony import */ var _utils_constants__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @utils/constants */ "./utils/constants.ts");
/* harmony import */ var _utils_dayjs__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! @utils/dayjs */ "./utils/dayjs.ts");
/* harmony import */ var _utils_helpers__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! @utils/helpers */ "./utils/helpers.tsx");




function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { Object(C_Users_admin_Documents_Dev_PWAdvent_node_modules_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_2__["default"])(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }









var initialDays = {};
_utils_calendar__WEBPACK_IMPORTED_MODULE_6__["CALENDAR"].map(function (day) {
  initialDays[day] = {
    loading: false,
    error: '',
    data: {
      date: "".concat(_utils_calendar__WEBPACK_IMPORTED_MODULE_6__["YEAR"], "-12-").concat(Object(_utils_helpers__WEBPACK_IMPORTED_MODULE_9__["zeroPad"])(day, 2)),
      title: '',
      content: ''
    }
  };
});
var initialState = {
  offline: false,
  menuOpen: _utils_calendar__WEBPACK_IMPORTED_MODULE_6__["DATE_TODAY"].isBefore(_utils_calendar__WEBPACK_IMPORTED_MODULE_6__["DATE_START"]),
  days: initialDays,
  page: {
    loading: false,
    slug: '',
    data: {
      title: '',
      content: ''
    }
  }
};

var setDay = function setDay(day, store) {
  var value = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  var state = store.getState();
  var daysNow = state.days;
  store.setState({
    days: _objectSpread(_objectSpread({}, daysNow), {}, Object(C_Users_admin_Documents_Dev_PWAdvent_node_modules_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_2__["default"])({}, day, _objectSpread(_objectSpread({}, daysNow[day]), value)))
  });
};

var setPage = function setPage(slug, store, title, content) {
  var state = store.getState();

  if (state.page.slug !== slug) {
    return;
  }

  store.setState({
    page: _objectSpread(_objectSpread({}, state.page), {}, {
      loading: false,
      data: {
        title: title,
        content: content
      }
    })
  });
};

var actions = function actions(store) {
  return {
    setOffline: function setOffline(state, offline) {
      return store.setState({
        offline: offline
      });
    },
    loadDay: function () {
      var _loadDay = Object(C_Users_admin_Documents_Dev_PWAdvent_node_modules_babel_runtime_helpers_esm_asyncToGenerator__WEBPACK_IMPORTED_MODULE_1__["default"])( /*#__PURE__*/C_Users_admin_Documents_Dev_PWAdvent_node_modules_babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_0___default.a.mark(function _callee(_ref, day) {
        var days, storeDay, dayObject, resp, respJson;
        return C_Users_admin_Documents_Dev_PWAdvent_node_modules_babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_0___default.a.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                days = _ref.days;
                storeDay = days[day];

                if (!(!storeDay || !storeDay.data || !storeDay.data.date)) {
                  _context.next = 5;
                  break;
                }

                setDay(day, store, {
                  loading: false,
                  error: 'Something went wrong'
                });
                return _context.abrupt("return");

              case 5:
                if (!Object(_utils_dayjs__WEBPACK_IMPORTED_MODULE_8__["default"])(storeDay.data.date).tz('Antarctica/McMurdo', true).isAfter(_utils_calendar__WEBPACK_IMPORTED_MODULE_6__["DATE_TODAY_ZERO"])) {
                  _context.next = 8;
                  break;
                }

                setDay(day, store, {
                  loading: false,
                  error: 'This article is not yet published.'
                });
                return _context.abrupt("return");

              case 8:
                setDay(day, store, {
                  loading: true,
                  error: ''
                });
                _context.next = 11;
                return _store_idb__WEBPACK_IMPORTED_MODULE_5__["daysDB"].get(String(day));

              case 11:
                dayObject = _context.sent;

                if (dayObject) {
                  setDay(day, store, {
                    loading: false,
                    data: dayObject
                  });
                }

                _context.next = 15;
                return fetch("".concat(_utils_constants__WEBPACK_IMPORTED_MODULE_7__["apiBase"], "wp-json/advent-calendar/v1/days/").concat(day, "/").concat(_utils_constants__WEBPACK_IMPORTED_MODULE_7__["apiKey"] ? "?apiKey=".concat(_utils_constants__WEBPACK_IMPORTED_MODULE_7__["apiKey"]) : ''));

              case 15:
                resp = _context.sent;

                if (!(!resp.ok && !dayObject)) {
                  _context.next = 19;
                  break;
                }

                setDay(day, store, {
                  loading: false,
                  error: 'There is no Article for this day.'
                });
                return _context.abrupt("return");

              case 19:
                _context.next = 21;
                return resp.json();

              case 21:
                respJson = _context.sent;
                dayObject = _objectSpread(_objectSpread({}, storeDay.data), {}, {
                  title: respJson.title,
                  excerpt: respJson.excerpt,
                  content: respJson.content,
                  author: respJson.author,
                  image: respJson.image,
                  source: respJson.source
                }); //}

                setDay(day, store, {
                  loading: false,
                  data: dayObject
                });
                _context.next = 26;
                return _store_idb__WEBPACK_IMPORTED_MODULE_5__["daysDB"].set(String(day), _objectSpread({}, dayObject));

              case 26:
              case "end":
                return _context.stop();
            }
          }
        }, _callee);
      }));

      function loadDay(_x, _x2) {
        return _loadDay.apply(this, arguments);
      }

      return loadDay;
    }(),
    setMenuOpen: function setMenuOpen(state, menuOpen) {
      return store.setState({
        menuOpen: menuOpen
      });
    },
    loadPage: function () {
      var _loadPage = Object(C_Users_admin_Documents_Dev_PWAdvent_node_modules_babel_runtime_helpers_esm_asyncToGenerator__WEBPACK_IMPORTED_MODULE_1__["default"])( /*#__PURE__*/C_Users_admin_Documents_Dev_PWAdvent_node_modules_babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_0___default.a.mark(function _callee2(state, slug) {
        var content, resp, respJson;
        return C_Users_admin_Documents_Dev_PWAdvent_node_modules_babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_0___default.a.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                store.setState({
                  page: _objectSpread(_objectSpread({}, state.page), {}, {
                    loading: true,
                    slug: slug
                  })
                });
                _context2.next = 3;
                return _store_idb__WEBPACK_IMPORTED_MODULE_5__["pageDB"].get(slug);

              case 3:
                content = _context2.sent;

                if (content) {
                  setPage(slug, store, content.title, content.content);
                }

                _context2.next = 7;
                return fetch("".concat(_utils_constants__WEBPACK_IMPORTED_MODULE_7__["apiBase"], "wp-json/advent-calendar/v1/page/").concat(slug, "/"));

              case 7:
                resp = _context2.sent;

                if (!(resp.status !== 200 && !content)) {
                  _context2.next = 11;
                  break;
                }

                setPage(slug, store, 'Error 404', 'The Page you are looking for des not exist');
                return _context2.abrupt("return");

              case 11:
                _context2.next = 13;
                return resp.json();

              case 13:
                respJson = _context2.sent;
                setPage(slug, store, respJson.title, respJson.content);
                _context2.next = 17;
                return _store_idb__WEBPACK_IMPORTED_MODULE_5__["pageDB"].set(slug, {
                  title: respJson.title,
                  contsnt: respJson.content
                });

              case 17:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2);
      }));

      function loadPage(_x3, _x4) {
        return _loadPage.apply(this, arguments);
      }

      return loadPage;
    }()
  };
};
var store = _utils_constants__WEBPACK_IMPORTED_MODULE_7__["isDev"] ? Object(unistore__WEBPACK_IMPORTED_MODULE_3__["default"])(initialState) : unistore_devtools__WEBPACK_IMPORTED_MODULE_4___default()(Object(unistore__WEBPACK_IMPORTED_MODULE_3__["default"])(initialState));

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.i);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }


const isPrefreshComponent = __prefresh_utils__.shouldBind(module);

  if (true) {
    const currentExports = __prefresh_utils__.getExports(module);
    const previousHotModuleExports =
      module.hot.data && module.hot.data.moduleExports;

    __prefresh_utils__.registerExports(currentExports, module.i);

    if (isPrefreshComponent) {
      if (previousHotModuleExports) {
        try {
          __prefresh_utils__.flush();
          if (
            typeof __prefresh_errors__ !== 'undefined' &&
            __prefresh_errors__ &&
            __prefresh_errors__.clearRuntimeErrors
          ) {
            __prefresh_errors__.clearRuntimeErrors();
          }
        } catch (e) {
          // Only available in newer webpack versions.
          if (module.hot.invalidate) {
            module.hot.invalidate();
          } else {
            self.location.reload();
          }
        }
      }

      module.hot.dispose(data => {
        data.moduleExports = __prefresh_utils__.getExports(module);
      });

      module.hot.accept(function errorRecovery() {
        if (
          typeof __prefresh_errors__ !== 'undefined' &&
          __prefresh_errors__ &&
          __prefresh_errors__.handleRuntimeError
        ) {
          __prefresh_errors__.handleRuntimeError(error);
        }

        __webpack_require__.c[module.i].hot.accept(errorRecovery);
      });
    }
  }
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../node_modules/next/dist/compiled/webpack/harmony-module.js */ "./node_modules/next/dist/compiled/webpack/harmony-module.js")(module), __webpack_require__(/*! ./node_modules/@prefresh/webpack/src/utils/prefresh.js */ "./node_modules/@prefresh/webpack/src/utils/prefresh.js")))

/***/ }),

/***/ "./theme/Button/Button.module.css":
/*!****************************************!*\
  !*** ./theme/Button/Button.module.css ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var api = __webpack_require__(/*! ../../node_modules/next/dist/build/webpack/loaders/next-style-loader/runtime/injectStylesIntoStyleTag.js */ "./node_modules/next/dist/build/webpack/loaders/next-style-loader/runtime/injectStylesIntoStyleTag.js");
            var content = __webpack_require__(/*! !../../node_modules/next/dist/compiled/css-loader/cjs.js??ref--5-oneOf-2-1!../../node_modules/next/dist/compiled/postcss-loader/cjs.js??ref--5-oneOf-2-2!./Button.module.css */ "./node_modules/next/dist/compiled/css-loader/cjs.js?!./node_modules/next/dist/compiled/postcss-loader/cjs.js?!./theme/Button/Button.module.css");

            content = content.__esModule ? content.default : content;

            if (typeof content === 'string') {
              content = [[module.i, content, '']];
            }

var options = {};

options.insert = function(element){// These elements should always exist. If they do not,
// this code should fail.
var anchorElement=document.querySelector('#__next_css__DO_NOT_USE__');var parentNode=anchorElement.parentNode;// Normally <head>
// Each style tag should be placed right before our
// anchor. By inserting before and not after, we do not
// need to track the last inserted element.
parentNode.insertBefore(element,anchorElement);};
options.singleton = false;

var update = api(content, options);


if (true) {
  if (!content.locals || module.hot.invalidate) {
    var isEqualLocals = function isEqualLocals(a,b,isNamedExport){if(!a&&b||a&&!b){return false;}let p;for(p in a){if(isNamedExport&&p==='default'){// eslint-disable-next-line no-continue
continue;}if(a[p]!==b[p]){return false;}}for(p in b){if(isNamedExport&&p==='default'){// eslint-disable-next-line no-continue
continue;}if(!a[p]){return false;}}return true;};
    var oldLocals = content.locals;

    module.hot.accept(
      /*! !../../node_modules/next/dist/compiled/css-loader/cjs.js??ref--5-oneOf-2-1!../../node_modules/next/dist/compiled/postcss-loader/cjs.js??ref--5-oneOf-2-2!./Button.module.css */ "./node_modules/next/dist/compiled/css-loader/cjs.js?!./node_modules/next/dist/compiled/postcss-loader/cjs.js?!./theme/Button/Button.module.css",
      function () {
        content = __webpack_require__(/*! !../../node_modules/next/dist/compiled/css-loader/cjs.js??ref--5-oneOf-2-1!../../node_modules/next/dist/compiled/postcss-loader/cjs.js??ref--5-oneOf-2-2!./Button.module.css */ "./node_modules/next/dist/compiled/css-loader/cjs.js?!./node_modules/next/dist/compiled/postcss-loader/cjs.js?!./theme/Button/Button.module.css");

              content = content.__esModule ? content.default : content;

              if (typeof content === 'string') {
                content = [[module.i, content, '']];
              }

              if (!isEqualLocals(oldLocals, content.locals)) {
                module.hot.invalidate();

                return;
              }

              oldLocals = content.locals;

              update(content);
      }
    )
  }

  module.hot.dispose(function() {
    update();
  });
}

module.exports = content.locals || {};

/***/ }),

/***/ "./theme/Button/Button.tsx":
/*!*********************************!*\
  !*** ./theme/Button/Button.tsx ***!
  \*********************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* WEBPACK VAR INJECTION */(function(module, __prefresh_utils__) {/* harmony import */ var C_Users_admin_Documents_Dev_PWAdvent_node_modules_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./node_modules/@babel/runtime/helpers/esm/extends */ "./node_modules/@babel/runtime/helpers/esm/extends.js");
/* harmony import */ var C_Users_admin_Documents_Dev_PWAdvent_node_modules_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./node_modules/@babel/runtime/helpers/esm/defineProperty */ "./node_modules/@babel/runtime/helpers/esm/defineProperty.js");
/* harmony import */ var C_Users_admin_Documents_Dev_PWAdvent_node_modules_babel_runtime_helpers_esm_objectWithoutProperties__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./node_modules/@babel/runtime/helpers/esm/objectWithoutProperties */ "./node_modules/@babel/runtime/helpers/esm/objectWithoutProperties.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! react */ "./node_modules/preact/compat/dist/compat.module.js");
/* harmony import */ var _utils_classnames__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @utils/classnames */ "./utils/classnames.tsx");
/* harmony import */ var _index__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../index */ "./theme/index.ts");
/* harmony import */ var _Button_module_css__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./Button.module.css */ "./theme/Button/Button.module.css");
/* harmony import */ var _Button_module_css__WEBPACK_IMPORTED_MODULE_6___default = /*#__PURE__*/__webpack_require__.n(_Button_module_css__WEBPACK_IMPORTED_MODULE_6__);




var _jsxFileName = "C:\\Users\\admin\\Documents\\Dev\\PWAdvent\\theme\\Button\\Button.tsx",
    _this = undefined;

var __jsx = react__WEBPACK_IMPORTED_MODULE_3__["default"].createElement;





var Button = function Button(_ref) {
  var _cn;

  var _ref$children = _ref.children,
      children = _ref$children === void 0 ? '' : _ref$children,
      _ref$className = _ref.className,
      className = _ref$className === void 0 ? '' : _ref$className,
      _ref$onClick = _ref.onClick,
      _onClick = _ref$onClick === void 0 ? function () {} : _ref$onClick,
      _ref$layout = _ref.layout,
      layout = _ref$layout === void 0 ? 'solid' : _ref$layout,
      _ref$round = _ref.round,
      round = _ref$round === void 0 ? false : _ref$round,
      _ref$icon = _ref.icon,
      icon = _ref$icon === void 0 ? '' : _ref$icon,
      _ref$iconRight = _ref.iconRight,
      iconRight = _ref$iconRight === void 0 ? false : _ref$iconRight,
      _ref$iconCircle = _ref.iconCircle,
      iconCircle = _ref$iconCircle === void 0 ? false : _ref$iconCircle,
      _ref$size = _ref.size,
      size = _ref$size === void 0 ? 'medium' : _ref$size,
      _ref$loading = _ref.loading,
      loading = _ref$loading === void 0 ? false : _ref$loading,
      _ref$disabled = _ref.disabled,
      disabled = _ref$disabled === void 0 ? false : _ref$disabled,
      _ref$color = _ref.color,
      color = _ref$color === void 0 ? 'black' : _ref$color,
      _ref$zeroPadding = _ref.zeroPadding,
      zeroPadding = _ref$zeroPadding === void 0 ? false : _ref$zeroPadding,
      _ref$fontWeight = _ref.fontWeight,
      fontWeight = _ref$fontWeight === void 0 ? 'bold' : _ref$fontWeight,
      props = Object(C_Users_admin_Documents_Dev_PWAdvent_node_modules_babel_runtime_helpers_esm_objectWithoutProperties__WEBPACK_IMPORTED_MODULE_2__["default"])(_ref, ["children", "className", "onClick", "layout", "round", "icon", "iconRight", "iconCircle", "size", "loading", "disabled", "color", "zeroPadding", "fontWeight"]);

  return __jsx("button", Object(C_Users_admin_Documents_Dev_PWAdvent_node_modules_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__["default"])({}, props, {
    disabled: disabled,
    className: Object(_utils_classnames__WEBPACK_IMPORTED_MODULE_4__["default"])(className, _Button_module_css__WEBPACK_IMPORTED_MODULE_6___default.a.button, _Button_module_css__WEBPACK_IMPORTED_MODULE_6___default.a["type-".concat(layout)], _Button_module_css__WEBPACK_IMPORTED_MODULE_6___default.a["size-".concat(size)], _Button_module_css__WEBPACK_IMPORTED_MODULE_6___default.a["color-".concat(color)], _Button_module_css__WEBPACK_IMPORTED_MODULE_6___default.a["fontWeight-".concat(fontWeight)], (_cn = {}, Object(C_Users_admin_Documents_Dev_PWAdvent_node_modules_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_1__["default"])(_cn, _Button_module_css__WEBPACK_IMPORTED_MODULE_6___default.a.isRound, round), Object(C_Users_admin_Documents_Dev_PWAdvent_node_modules_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_1__["default"])(_cn, _Button_module_css__WEBPACK_IMPORTED_MODULE_6___default.a.isLoading, loading), Object(C_Users_admin_Documents_Dev_PWAdvent_node_modules_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_1__["default"])(_cn, _Button_module_css__WEBPACK_IMPORTED_MODULE_6___default.a.isDisabled, disabled), Object(C_Users_admin_Documents_Dev_PWAdvent_node_modules_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_1__["default"])(_cn, _Button_module_css__WEBPACK_IMPORTED_MODULE_6___default.a.zeropadding, zeroPadding), _cn)),
    onClick: function onClick() {
      return _onClick();
    },
    __self: _this,
    __source: {
      fileName: _jsxFileName,
      lineNumber: 40,
      columnNumber: 5
    }
  }), __jsx(_index__WEBPACK_IMPORTED_MODULE_5__["Loader"], {
    className: _Button_module_css__WEBPACK_IMPORTED_MODULE_6___default.a.loader,
    __self: _this,
    __source: {
      fileName: _jsxFileName,
      lineNumber: 59,
      columnNumber: 7
    }
  }), icon !== '' && !iconRight && __jsx(_index__WEBPACK_IMPORTED_MODULE_5__["Icon"], {
    className: Object(_utils_classnames__WEBPACK_IMPORTED_MODULE_4__["default"])(_Button_module_css__WEBPACK_IMPORTED_MODULE_6___default.a.icon, _Button_module_css__WEBPACK_IMPORTED_MODULE_6___default.a.iconLeft),
    icon: icon,
    circle: iconCircle,
    __self: _this,
    __source: {
      fileName: _jsxFileName,
      lineNumber: 61,
      columnNumber: 9
    }
  }), __jsx("span", {
    className: _Button_module_css__WEBPACK_IMPORTED_MODULE_6___default.a.content,
    __self: _this,
    __source: {
      fileName: _jsxFileName,
      lineNumber: 67,
      columnNumber: 7
    }
  }, children), icon !== '' && iconRight && __jsx(_index__WEBPACK_IMPORTED_MODULE_5__["Icon"], {
    className: Object(_utils_classnames__WEBPACK_IMPORTED_MODULE_4__["default"])(_Button_module_css__WEBPACK_IMPORTED_MODULE_6___default.a.icon, _Button_module_css__WEBPACK_IMPORTED_MODULE_6___default.a.iconRight),
    icon: icon,
    circle: iconCircle,
    __self: _this,
    __source: {
      fileName: _jsxFileName,
      lineNumber: 69,
      columnNumber: 9
    }
  }));
};

_c = Button;
/* harmony default export */ __webpack_exports__["default"] = (Button);

var _c;

$RefreshReg$(_c, "Button");

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.i);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }


const isPrefreshComponent = __prefresh_utils__.shouldBind(module);

  if (true) {
    const currentExports = __prefresh_utils__.getExports(module);
    const previousHotModuleExports =
      module.hot.data && module.hot.data.moduleExports;

    __prefresh_utils__.registerExports(currentExports, module.i);

    if (isPrefreshComponent) {
      if (previousHotModuleExports) {
        try {
          __prefresh_utils__.flush();
          if (
            typeof __prefresh_errors__ !== 'undefined' &&
            __prefresh_errors__ &&
            __prefresh_errors__.clearRuntimeErrors
          ) {
            __prefresh_errors__.clearRuntimeErrors();
          }
        } catch (e) {
          // Only available in newer webpack versions.
          if (module.hot.invalidate) {
            module.hot.invalidate();
          } else {
            self.location.reload();
          }
        }
      }

      module.hot.dispose(data => {
        data.moduleExports = __prefresh_utils__.getExports(module);
      });

      module.hot.accept(function errorRecovery() {
        if (
          typeof __prefresh_errors__ !== 'undefined' &&
          __prefresh_errors__ &&
          __prefresh_errors__.handleRuntimeError
        ) {
          __prefresh_errors__.handleRuntimeError(error);
        }

        __webpack_require__.c[module.i].hot.accept(errorRecovery);
      });
    }
  }
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../node_modules/next/dist/compiled/webpack/harmony-module.js */ "./node_modules/next/dist/compiled/webpack/harmony-module.js")(module), __webpack_require__(/*! ./node_modules/@prefresh/webpack/src/utils/prefresh.js */ "./node_modules/@prefresh/webpack/src/utils/prefresh.js")))

/***/ }),

/***/ "./theme/CloseButton/CloseButton.module.css":
/*!**************************************************!*\
  !*** ./theme/CloseButton/CloseButton.module.css ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var api = __webpack_require__(/*! ../../node_modules/next/dist/build/webpack/loaders/next-style-loader/runtime/injectStylesIntoStyleTag.js */ "./node_modules/next/dist/build/webpack/loaders/next-style-loader/runtime/injectStylesIntoStyleTag.js");
            var content = __webpack_require__(/*! !../../node_modules/next/dist/compiled/css-loader/cjs.js??ref--5-oneOf-2-1!../../node_modules/next/dist/compiled/postcss-loader/cjs.js??ref--5-oneOf-2-2!./CloseButton.module.css */ "./node_modules/next/dist/compiled/css-loader/cjs.js?!./node_modules/next/dist/compiled/postcss-loader/cjs.js?!./theme/CloseButton/CloseButton.module.css");

            content = content.__esModule ? content.default : content;

            if (typeof content === 'string') {
              content = [[module.i, content, '']];
            }

var options = {};

options.insert = function(element){// These elements should always exist. If they do not,
// this code should fail.
var anchorElement=document.querySelector('#__next_css__DO_NOT_USE__');var parentNode=anchorElement.parentNode;// Normally <head>
// Each style tag should be placed right before our
// anchor. By inserting before and not after, we do not
// need to track the last inserted element.
parentNode.insertBefore(element,anchorElement);};
options.singleton = false;

var update = api(content, options);


if (true) {
  if (!content.locals || module.hot.invalidate) {
    var isEqualLocals = function isEqualLocals(a,b,isNamedExport){if(!a&&b||a&&!b){return false;}let p;for(p in a){if(isNamedExport&&p==='default'){// eslint-disable-next-line no-continue
continue;}if(a[p]!==b[p]){return false;}}for(p in b){if(isNamedExport&&p==='default'){// eslint-disable-next-line no-continue
continue;}if(!a[p]){return false;}}return true;};
    var oldLocals = content.locals;

    module.hot.accept(
      /*! !../../node_modules/next/dist/compiled/css-loader/cjs.js??ref--5-oneOf-2-1!../../node_modules/next/dist/compiled/postcss-loader/cjs.js??ref--5-oneOf-2-2!./CloseButton.module.css */ "./node_modules/next/dist/compiled/css-loader/cjs.js?!./node_modules/next/dist/compiled/postcss-loader/cjs.js?!./theme/CloseButton/CloseButton.module.css",
      function () {
        content = __webpack_require__(/*! !../../node_modules/next/dist/compiled/css-loader/cjs.js??ref--5-oneOf-2-1!../../node_modules/next/dist/compiled/postcss-loader/cjs.js??ref--5-oneOf-2-2!./CloseButton.module.css */ "./node_modules/next/dist/compiled/css-loader/cjs.js?!./node_modules/next/dist/compiled/postcss-loader/cjs.js?!./theme/CloseButton/CloseButton.module.css");

              content = content.__esModule ? content.default : content;

              if (typeof content === 'string') {
                content = [[module.i, content, '']];
              }

              if (!isEqualLocals(oldLocals, content.locals)) {
                module.hot.invalidate();

                return;
              }

              oldLocals = content.locals;

              update(content);
      }
    )
  }

  module.hot.dispose(function() {
    update();
  });
}

module.exports = content.locals || {};

/***/ }),

/***/ "./theme/CloseButton/CloseButton.tsx":
/*!*******************************************!*\
  !*** ./theme/CloseButton/CloseButton.tsx ***!
  \*******************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* WEBPACK VAR INJECTION */(function(module, __prefresh_utils__) {/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ "./node_modules/preact/compat/dist/compat.module.js");
/* harmony import */ var _utils_classnames__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @utils/classnames */ "./utils/classnames.tsx");
/* harmony import */ var _CloseButton_module_css__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./CloseButton.module.css */ "./theme/CloseButton/CloseButton.module.css");
/* harmony import */ var _CloseButton_module_css__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_CloseButton_module_css__WEBPACK_IMPORTED_MODULE_2__);
var _jsxFileName = "C:\\Users\\admin\\Documents\\Dev\\PWAdvent\\theme\\CloseButton\\CloseButton.tsx",
    _this = undefined;

var __jsx = react__WEBPACK_IMPORTED_MODULE_0__["default"].createElement;




var CloseButton = function CloseButton(_ref) {
  var _ref$className = _ref.className,
      className = _ref$className === void 0 ? '' : _ref$className,
      _onClick = _ref.onClick;
  return __jsx("button", {
    className: Object(_utils_classnames__WEBPACK_IMPORTED_MODULE_1__["default"])(_CloseButton_module_css__WEBPACK_IMPORTED_MODULE_2___default.a.root, className),
    onClick: function onClick() {
      return _onClick();
    },
    __self: _this,
    __source: {
      fileName: _jsxFileName,
      lineNumber: 12,
      columnNumber: 3
    }
  }, "close");
};

_c = CloseButton;
/* harmony default export */ __webpack_exports__["default"] = (CloseButton);

var _c;

$RefreshReg$(_c, "CloseButton");

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.i);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }


const isPrefreshComponent = __prefresh_utils__.shouldBind(module);

  if (true) {
    const currentExports = __prefresh_utils__.getExports(module);
    const previousHotModuleExports =
      module.hot.data && module.hot.data.moduleExports;

    __prefresh_utils__.registerExports(currentExports, module.i);

    if (isPrefreshComponent) {
      if (previousHotModuleExports) {
        try {
          __prefresh_utils__.flush();
          if (
            typeof __prefresh_errors__ !== 'undefined' &&
            __prefresh_errors__ &&
            __prefresh_errors__.clearRuntimeErrors
          ) {
            __prefresh_errors__.clearRuntimeErrors();
          }
        } catch (e) {
          // Only available in newer webpack versions.
          if (module.hot.invalidate) {
            module.hot.invalidate();
          } else {
            self.location.reload();
          }
        }
      }

      module.hot.dispose(data => {
        data.moduleExports = __prefresh_utils__.getExports(module);
      });

      module.hot.accept(function errorRecovery() {
        if (
          typeof __prefresh_errors__ !== 'undefined' &&
          __prefresh_errors__ &&
          __prefresh_errors__.handleRuntimeError
        ) {
          __prefresh_errors__.handleRuntimeError(error);
        }

        __webpack_require__.c[module.i].hot.accept(errorRecovery);
      });
    }
  }
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../node_modules/next/dist/compiled/webpack/harmony-module.js */ "./node_modules/next/dist/compiled/webpack/harmony-module.js")(module), __webpack_require__(/*! ./node_modules/@prefresh/webpack/src/utils/prefresh.js */ "./node_modules/@prefresh/webpack/src/utils/prefresh.js")))

/***/ }),

/***/ "./theme/ContentModal/ContentModal.module.css":
/*!****************************************************!*\
  !*** ./theme/ContentModal/ContentModal.module.css ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var api = __webpack_require__(/*! ../../node_modules/next/dist/build/webpack/loaders/next-style-loader/runtime/injectStylesIntoStyleTag.js */ "./node_modules/next/dist/build/webpack/loaders/next-style-loader/runtime/injectStylesIntoStyleTag.js");
            var content = __webpack_require__(/*! !../../node_modules/next/dist/compiled/css-loader/cjs.js??ref--5-oneOf-2-1!../../node_modules/next/dist/compiled/postcss-loader/cjs.js??ref--5-oneOf-2-2!./ContentModal.module.css */ "./node_modules/next/dist/compiled/css-loader/cjs.js?!./node_modules/next/dist/compiled/postcss-loader/cjs.js?!./theme/ContentModal/ContentModal.module.css");

            content = content.__esModule ? content.default : content;

            if (typeof content === 'string') {
              content = [[module.i, content, '']];
            }

var options = {};

options.insert = function(element){// These elements should always exist. If they do not,
// this code should fail.
var anchorElement=document.querySelector('#__next_css__DO_NOT_USE__');var parentNode=anchorElement.parentNode;// Normally <head>
// Each style tag should be placed right before our
// anchor. By inserting before and not after, we do not
// need to track the last inserted element.
parentNode.insertBefore(element,anchorElement);};
options.singleton = false;

var update = api(content, options);


if (true) {
  if (!content.locals || module.hot.invalidate) {
    var isEqualLocals = function isEqualLocals(a,b,isNamedExport){if(!a&&b||a&&!b){return false;}let p;for(p in a){if(isNamedExport&&p==='default'){// eslint-disable-next-line no-continue
continue;}if(a[p]!==b[p]){return false;}}for(p in b){if(isNamedExport&&p==='default'){// eslint-disable-next-line no-continue
continue;}if(!a[p]){return false;}}return true;};
    var oldLocals = content.locals;

    module.hot.accept(
      /*! !../../node_modules/next/dist/compiled/css-loader/cjs.js??ref--5-oneOf-2-1!../../node_modules/next/dist/compiled/postcss-loader/cjs.js??ref--5-oneOf-2-2!./ContentModal.module.css */ "./node_modules/next/dist/compiled/css-loader/cjs.js?!./node_modules/next/dist/compiled/postcss-loader/cjs.js?!./theme/ContentModal/ContentModal.module.css",
      function () {
        content = __webpack_require__(/*! !../../node_modules/next/dist/compiled/css-loader/cjs.js??ref--5-oneOf-2-1!../../node_modules/next/dist/compiled/postcss-loader/cjs.js??ref--5-oneOf-2-2!./ContentModal.module.css */ "./node_modules/next/dist/compiled/css-loader/cjs.js?!./node_modules/next/dist/compiled/postcss-loader/cjs.js?!./theme/ContentModal/ContentModal.module.css");

              content = content.__esModule ? content.default : content;

              if (typeof content === 'string') {
                content = [[module.i, content, '']];
              }

              if (!isEqualLocals(oldLocals, content.locals)) {
                module.hot.invalidate();

                return;
              }

              oldLocals = content.locals;

              update(content);
      }
    )
  }

  module.hot.dispose(function() {
    update();
  });
}

module.exports = content.locals || {};

/***/ }),

/***/ "./theme/ContentModal/ContentModal.tsx":
/*!*********************************************!*\
  !*** ./theme/ContentModal/ContentModal.tsx ***!
  \*********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* WEBPACK VAR INJECTION */(function(module, __prefresh_utils__) {/* harmony import */ var next_head__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! next/head */ "./node_modules/next/head.js");
/* harmony import */ var next_head__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(next_head__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ "./node_modules/preact/compat/dist/compat.module.js");
/* harmony import */ var _utils_classnames__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @utils/classnames */ "./utils/classnames.tsx");
/* harmony import */ var _utils_metas__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @utils/metas */ "./utils/metas.ts");
/* harmony import */ var _index__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../index */ "./theme/index.ts");
/* harmony import */ var _ContentModal_module_css__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./ContentModal.module.css */ "./theme/ContentModal/ContentModal.module.css");
/* harmony import */ var _ContentModal_module_css__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(_ContentModal_module_css__WEBPACK_IMPORTED_MODULE_5__);
var _jsxFileName = "C:\\Users\\admin\\Documents\\Dev\\PWAdvent\\theme\\ContentModal\\ContentModal.tsx",
    _this = undefined;

var __jsx = react__WEBPACK_IMPORTED_MODULE_1__["default"].createElement;







var ContentModal = function ContentModal(_ref) {
  var title = _ref.title,
      children = _ref.children,
      onClose = _ref.onClose,
      _ref$className = _ref.className,
      className = _ref$className === void 0 ? '' : _ref$className,
      _ref$loading = _ref.loading,
      loading = _ref$loading === void 0 ? false : _ref$loading,
      _ref$full = _ref.full,
      full = _ref$full === void 0 ? true : _ref$full;
  return __jsx(react__WEBPACK_IMPORTED_MODULE_1__["default"].Fragment, {
    __self: _this,
    __source: {
      fileName: _jsxFileName,
      lineNumber: 23,
      columnNumber: 3
    }
  }, __jsx(next_head__WEBPACK_IMPORTED_MODULE_0___default.a, {
    __self: _this,
    __source: {
      fileName: _jsxFileName,
      lineNumber: 24,
      columnNumber: 5
    }
  }, __jsx("title", {
    __self: _this,
    __source: {
      fileName: _jsxFileName,
      lineNumber: 25,
      columnNumber: 7
    }
  }, Object(_utils_metas__WEBPACK_IMPORTED_MODULE_3__["metaTitle"])(title))), __jsx(_index__WEBPACK_IMPORTED_MODULE_4__["ShadowBox"], {
    title: title,
    close: onClose,
    className: Object(_utils_classnames__WEBPACK_IMPORTED_MODULE_2__["default"])(className),
    size: full ? 'large' : 'small',
    __self: _this,
    __source: {
      fileName: _jsxFileName,
      lineNumber: 27,
      columnNumber: 5
    }
  }, __jsx("div", {
    className: _ContentModal_module_css__WEBPACK_IMPORTED_MODULE_5___default.a.content,
    __self: _this,
    __source: {
      fileName: _jsxFileName,
      lineNumber: 33,
      columnNumber: 7
    }
  }, loading ? __jsx(_index__WEBPACK_IMPORTED_MODULE_4__["Loader"], {
    className: _ContentModal_module_css__WEBPACK_IMPORTED_MODULE_5___default.a.loader,
    __self: _this,
    __source: {
      fileName: _jsxFileName,
      lineNumber: 34,
      columnNumber: 20
    }
  }) : children)));
};

_c = ContentModal;
/* harmony default export */ __webpack_exports__["default"] = (ContentModal);

var _c;

$RefreshReg$(_c, "ContentModal");

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.i);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }


const isPrefreshComponent = __prefresh_utils__.shouldBind(module);

  if (true) {
    const currentExports = __prefresh_utils__.getExports(module);
    const previousHotModuleExports =
      module.hot.data && module.hot.data.moduleExports;

    __prefresh_utils__.registerExports(currentExports, module.i);

    if (isPrefreshComponent) {
      if (previousHotModuleExports) {
        try {
          __prefresh_utils__.flush();
          if (
            typeof __prefresh_errors__ !== 'undefined' &&
            __prefresh_errors__ &&
            __prefresh_errors__.clearRuntimeErrors
          ) {
            __prefresh_errors__.clearRuntimeErrors();
          }
        } catch (e) {
          // Only available in newer webpack versions.
          if (module.hot.invalidate) {
            module.hot.invalidate();
          } else {
            self.location.reload();
          }
        }
      }

      module.hot.dispose(data => {
        data.moduleExports = __prefresh_utils__.getExports(module);
      });

      module.hot.accept(function errorRecovery() {
        if (
          typeof __prefresh_errors__ !== 'undefined' &&
          __prefresh_errors__ &&
          __prefresh_errors__.handleRuntimeError
        ) {
          __prefresh_errors__.handleRuntimeError(error);
        }

        __webpack_require__.c[module.i].hot.accept(errorRecovery);
      });
    }
  }
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../node_modules/next/dist/compiled/webpack/harmony-module.js */ "./node_modules/next/dist/compiled/webpack/harmony-module.js")(module), __webpack_require__(/*! ./node_modules/@prefresh/webpack/src/utils/prefresh.js */ "./node_modules/@prefresh/webpack/src/utils/prefresh.js")))

/***/ }),

/***/ "./theme/Form/ConnectForm.tsx":
/*!************************************!*\
  !*** ./theme/Form/ConnectForm.tsx ***!
  \************************************/
/*! exports provided: ConnectForm */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* WEBPACK VAR INJECTION */(function(module, __prefresh_utils__) {/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ConnectForm", function() { return ConnectForm; });
/* harmony import */ var C_Users_admin_Documents_Dev_PWAdvent_node_modules_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./node_modules/@babel/runtime/helpers/esm/defineProperty */ "./node_modules/@babel/runtime/helpers/esm/defineProperty.js");
/* harmony import */ var react_hook_form__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! react-hook-form */ "./node_modules/react-hook-form/dist/react-hook-form.es.js");


var _s = $RefreshSig$();

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { Object(C_Users_admin_Documents_Dev_PWAdvent_node_modules_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }


var ConnectForm = function ConnectForm(_ref) {
  _s();

  var children = _ref.children;
  var methods = Object(react_hook_form__WEBPACK_IMPORTED_MODULE_2__["useFormContext"])();
  return children(_objectSpread({}, methods));
};

_s(ConnectForm, "u7sAMcQCpiWJQxXuJ6yWLOYZ4cg=", false, function () {
  return [react_hook_form__WEBPACK_IMPORTED_MODULE_2__["useFormContext"]];
});

_c = ConnectForm;

var _c;

$RefreshReg$(_c, "ConnectForm");

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.i);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }


const isPrefreshComponent = __prefresh_utils__.shouldBind(module);

  if (true) {
    const currentExports = __prefresh_utils__.getExports(module);
    const previousHotModuleExports =
      module.hot.data && module.hot.data.moduleExports;

    __prefresh_utils__.registerExports(currentExports, module.i);

    if (isPrefreshComponent) {
      if (previousHotModuleExports) {
        try {
          __prefresh_utils__.flush();
          if (
            typeof __prefresh_errors__ !== 'undefined' &&
            __prefresh_errors__ &&
            __prefresh_errors__.clearRuntimeErrors
          ) {
            __prefresh_errors__.clearRuntimeErrors();
          }
        } catch (e) {
          // Only available in newer webpack versions.
          if (module.hot.invalidate) {
            module.hot.invalidate();
          } else {
            self.location.reload();
          }
        }
      }

      module.hot.dispose(data => {
        data.moduleExports = __prefresh_utils__.getExports(module);
      });

      module.hot.accept(function errorRecovery() {
        if (
          typeof __prefresh_errors__ !== 'undefined' &&
          __prefresh_errors__ &&
          __prefresh_errors__.handleRuntimeError
        ) {
          __prefresh_errors__.handleRuntimeError(error);
        }

        __webpack_require__.c[module.i].hot.accept(errorRecovery);
      });
    }
  }
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../node_modules/next/dist/compiled/webpack/harmony-module.js */ "./node_modules/next/dist/compiled/webpack/harmony-module.js")(module), __webpack_require__(/*! ./node_modules/@prefresh/webpack/src/utils/prefresh.js */ "./node_modules/@prefresh/webpack/src/utils/prefresh.js")))

/***/ }),

/***/ "./theme/Form/Form.tsx":
/*!*****************************!*\
  !*** ./theme/Form/Form.tsx ***!
  \*****************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* WEBPACK VAR INJECTION */(function(module, __prefresh_utils__) {/* harmony import */ var C_Users_admin_Documents_Dev_PWAdvent_node_modules_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./node_modules/@babel/runtime/helpers/esm/extends */ "./node_modules/@babel/runtime/helpers/esm/extends.js");
/* harmony import */ var C_Users_admin_Documents_Dev_PWAdvent_node_modules_babel_runtime_helpers_esm_objectWithoutProperties__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./node_modules/@babel/runtime/helpers/esm/objectWithoutProperties */ "./node_modules/@babel/runtime/helpers/esm/objectWithoutProperties.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! react */ "./node_modules/preact/compat/dist/compat.module.js");
/* harmony import */ var react_hook_form__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! react-hook-form */ "./node_modules/react-hook-form/dist/react-hook-form.es.js");



var _jsxFileName = "C:\\Users\\admin\\Documents\\Dev\\PWAdvent\\theme\\Form\\Form.tsx",
    _this = undefined,
    _s = $RefreshSig$();

var __jsx = react__WEBPACK_IMPORTED_MODULE_2__["default"].createElement;



var Form = function Form(_ref) {
  _s();

  var onSubmit = _ref.onSubmit,
      className = _ref.className,
      children = _ref.children,
      props = Object(C_Users_admin_Documents_Dev_PWAdvent_node_modules_babel_runtime_helpers_esm_objectWithoutProperties__WEBPACK_IMPORTED_MODULE_1__["default"])(_ref, ["onSubmit", "className", "children"]);

  // @ts-ignore
  var methods = Object(react_hook_form__WEBPACK_IMPORTED_MODULE_3__["useForm"])();
  return __jsx(react_hook_form__WEBPACK_IMPORTED_MODULE_3__["FormContext"], Object(C_Users_admin_Documents_Dev_PWAdvent_node_modules_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__["default"])({}, methods, {
    __self: _this,
    __source: {
      fileName: _jsxFileName,
      lineNumber: 18,
      columnNumber: 5
    }
  }), __jsx("form", Object(C_Users_admin_Documents_Dev_PWAdvent_node_modules_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__["default"])({
    onSubmit: methods.handleSubmit(function (v) {
      return onSubmit(v);
    }),
    className: "".concat(className, " form")
  }, props, {
    __self: _this,
    __source: {
      fileName: _jsxFileName,
      lineNumber: 19,
      columnNumber: 7
    }
  }), children));
};

_s(Form, "cLnp+zYVfnD49CnXGGXF3NvR6q8=", false, function () {
  return [react_hook_form__WEBPACK_IMPORTED_MODULE_3__["useForm"]];
});

_c = Form;
/* harmony default export */ __webpack_exports__["default"] = (Form);

var _c;

$RefreshReg$(_c, "Form");

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.i);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }


const isPrefreshComponent = __prefresh_utils__.shouldBind(module);

  if (true) {
    const currentExports = __prefresh_utils__.getExports(module);
    const previousHotModuleExports =
      module.hot.data && module.hot.data.moduleExports;

    __prefresh_utils__.registerExports(currentExports, module.i);

    if (isPrefreshComponent) {
      if (previousHotModuleExports) {
        try {
          __prefresh_utils__.flush();
          if (
            typeof __prefresh_errors__ !== 'undefined' &&
            __prefresh_errors__ &&
            __prefresh_errors__.clearRuntimeErrors
          ) {
            __prefresh_errors__.clearRuntimeErrors();
          }
        } catch (e) {
          // Only available in newer webpack versions.
          if (module.hot.invalidate) {
            module.hot.invalidate();
          } else {
            self.location.reload();
          }
        }
      }

      module.hot.dispose(data => {
        data.moduleExports = __prefresh_utils__.getExports(module);
      });

      module.hot.accept(function errorRecovery() {
        if (
          typeof __prefresh_errors__ !== 'undefined' &&
          __prefresh_errors__ &&
          __prefresh_errors__.handleRuntimeError
        ) {
          __prefresh_errors__.handleRuntimeError(error);
        }

        __webpack_require__.c[module.i].hot.accept(errorRecovery);
      });
    }
  }
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../node_modules/next/dist/compiled/webpack/harmony-module.js */ "./node_modules/next/dist/compiled/webpack/harmony-module.js")(module), __webpack_require__(/*! ./node_modules/@prefresh/webpack/src/utils/prefresh.js */ "./node_modules/@prefresh/webpack/src/utils/prefresh.js")))

/***/ }),

/***/ "./theme/Form/FormControls.module.css":
/*!********************************************!*\
  !*** ./theme/Form/FormControls.module.css ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var api = __webpack_require__(/*! ../../node_modules/next/dist/build/webpack/loaders/next-style-loader/runtime/injectStylesIntoStyleTag.js */ "./node_modules/next/dist/build/webpack/loaders/next-style-loader/runtime/injectStylesIntoStyleTag.js");
            var content = __webpack_require__(/*! !../../node_modules/next/dist/compiled/css-loader/cjs.js??ref--5-oneOf-2-1!../../node_modules/next/dist/compiled/postcss-loader/cjs.js??ref--5-oneOf-2-2!./FormControls.module.css */ "./node_modules/next/dist/compiled/css-loader/cjs.js?!./node_modules/next/dist/compiled/postcss-loader/cjs.js?!./theme/Form/FormControls.module.css");

            content = content.__esModule ? content.default : content;

            if (typeof content === 'string') {
              content = [[module.i, content, '']];
            }

var options = {};

options.insert = function(element){// These elements should always exist. If they do not,
// this code should fail.
var anchorElement=document.querySelector('#__next_css__DO_NOT_USE__');var parentNode=anchorElement.parentNode;// Normally <head>
// Each style tag should be placed right before our
// anchor. By inserting before and not after, we do not
// need to track the last inserted element.
parentNode.insertBefore(element,anchorElement);};
options.singleton = false;

var update = api(content, options);


if (true) {
  if (!content.locals || module.hot.invalidate) {
    var isEqualLocals = function isEqualLocals(a,b,isNamedExport){if(!a&&b||a&&!b){return false;}let p;for(p in a){if(isNamedExport&&p==='default'){// eslint-disable-next-line no-continue
continue;}if(a[p]!==b[p]){return false;}}for(p in b){if(isNamedExport&&p==='default'){// eslint-disable-next-line no-continue
continue;}if(!a[p]){return false;}}return true;};
    var oldLocals = content.locals;

    module.hot.accept(
      /*! !../../node_modules/next/dist/compiled/css-loader/cjs.js??ref--5-oneOf-2-1!../../node_modules/next/dist/compiled/postcss-loader/cjs.js??ref--5-oneOf-2-2!./FormControls.module.css */ "./node_modules/next/dist/compiled/css-loader/cjs.js?!./node_modules/next/dist/compiled/postcss-loader/cjs.js?!./theme/Form/FormControls.module.css",
      function () {
        content = __webpack_require__(/*! !../../node_modules/next/dist/compiled/css-loader/cjs.js??ref--5-oneOf-2-1!../../node_modules/next/dist/compiled/postcss-loader/cjs.js??ref--5-oneOf-2-2!./FormControls.module.css */ "./node_modules/next/dist/compiled/css-loader/cjs.js?!./node_modules/next/dist/compiled/postcss-loader/cjs.js?!./theme/Form/FormControls.module.css");

              content = content.__esModule ? content.default : content;

              if (typeof content === 'string') {
                content = [[module.i, content, '']];
              }

              if (!isEqualLocals(oldLocals, content.locals)) {
                module.hot.invalidate();

                return;
              }

              oldLocals = content.locals;

              update(content);
      }
    )
  }

  module.hot.dispose(function() {
    update();
  });
}

module.exports = content.locals || {};

/***/ }),

/***/ "./theme/Form/FormControls.tsx":
/*!*************************************!*\
  !*** ./theme/Form/FormControls.tsx ***!
  \*************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* WEBPACK VAR INJECTION */(function(module, __prefresh_utils__) {/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ "./node_modules/preact/compat/dist/compat.module.js");
/* harmony import */ var _utils_classnames__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @utils/classnames */ "./utils/classnames.tsx");
/* harmony import */ var _FormControls_module_css__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./FormControls.module.css */ "./theme/Form/FormControls.module.css");
/* harmony import */ var _FormControls_module_css__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_FormControls_module_css__WEBPACK_IMPORTED_MODULE_2__);
var _jsxFileName = "C:\\Users\\admin\\Documents\\Dev\\PWAdvent\\theme\\Form\\FormControls.tsx",
    _this = undefined;

var __jsx = react__WEBPACK_IMPORTED_MODULE_0__["default"].createElement;




var FormControls = function FormControls(_ref) {
  var _ref$className = _ref.className,
      className = _ref$className === void 0 ? '' : _ref$className,
      children = _ref.children;
  return __jsx("div", {
    className: Object(_utils_classnames__WEBPACK_IMPORTED_MODULE_1__["default"])(_FormControls_module_css__WEBPACK_IMPORTED_MODULE_2___default.a.root, className),
    __self: _this,
    __source: {
      fileName: _jsxFileName,
      lineNumber: 12,
      columnNumber: 10
    }
  }, children);
};

_c = FormControls;
/* harmony default export */ __webpack_exports__["default"] = (FormControls);

var _c;

$RefreshReg$(_c, "FormControls");

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.i);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }


const isPrefreshComponent = __prefresh_utils__.shouldBind(module);

  if (true) {
    const currentExports = __prefresh_utils__.getExports(module);
    const previousHotModuleExports =
      module.hot.data && module.hot.data.moduleExports;

    __prefresh_utils__.registerExports(currentExports, module.i);

    if (isPrefreshComponent) {
      if (previousHotModuleExports) {
        try {
          __prefresh_utils__.flush();
          if (
            typeof __prefresh_errors__ !== 'undefined' &&
            __prefresh_errors__ &&
            __prefresh_errors__.clearRuntimeErrors
          ) {
            __prefresh_errors__.clearRuntimeErrors();
          }
        } catch (e) {
          // Only available in newer webpack versions.
          if (module.hot.invalidate) {
            module.hot.invalidate();
          } else {
            self.location.reload();
          }
        }
      }

      module.hot.dispose(data => {
        data.moduleExports = __prefresh_utils__.getExports(module);
      });

      module.hot.accept(function errorRecovery() {
        if (
          typeof __prefresh_errors__ !== 'undefined' &&
          __prefresh_errors__ &&
          __prefresh_errors__.handleRuntimeError
        ) {
          __prefresh_errors__.handleRuntimeError(error);
        }

        __webpack_require__.c[module.i].hot.accept(errorRecovery);
      });
    }
  }
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../node_modules/next/dist/compiled/webpack/harmony-module.js */ "./node_modules/next/dist/compiled/webpack/harmony-module.js")(module), __webpack_require__(/*! ./node_modules/@prefresh/webpack/src/utils/prefresh.js */ "./node_modules/@prefresh/webpack/src/utils/prefresh.js")))

/***/ }),

/***/ "./theme/Form/FormField.tsx":
/*!**********************************!*\
  !*** ./theme/Form/FormField.tsx ***!
  \**********************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* WEBPACK VAR INJECTION */(function(module, __prefresh_utils__) {/* harmony import */ var C_Users_admin_Documents_Dev_PWAdvent_node_modules_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./node_modules/@babel/runtime/helpers/esm/defineProperty */ "./node_modules/@babel/runtime/helpers/esm/defineProperty.js");
/* harmony import */ var C_Users_admin_Documents_Dev_PWAdvent_node_modules_babel_runtime_helpers_esm_objectWithoutProperties__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./node_modules/@babel/runtime/helpers/esm/objectWithoutProperties */ "./node_modules/@babel/runtime/helpers/esm/objectWithoutProperties.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! react */ "./node_modules/preact/compat/dist/compat.module.js");
/* harmony import */ var _ConnectForm__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./ConnectForm */ "./theme/Form/ConnectForm.tsx");
/* harmony import */ var _Input__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./Input */ "./theme/Form/Input.tsx");



var _jsxFileName = "C:\\Users\\admin\\Documents\\Dev\\PWAdvent\\theme\\Form\\FormField.tsx",
    _this = undefined;

var __jsx = react__WEBPACK_IMPORTED_MODULE_2__["default"].createElement;

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { Object(C_Users_admin_Documents_Dev_PWAdvent_node_modules_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }





var FormField = function FormField(_ref) {
  var name = _ref.name,
      label = _ref.label,
      _ref$component = _ref.component,
      component = _ref$component === void 0 ? _Input__WEBPACK_IMPORTED_MODULE_4__["default"] : _ref$component,
      fieldRegister = _ref.register,
      _ref$className = _ref.className,
      className = _ref$className === void 0 ? '' : _ref$className,
      _ref$classNameLabel = _ref.classNameLabel,
      classNameLabel = _ref$classNameLabel === void 0 ? '' : _ref$classNameLabel,
      _ref$classNameInput = _ref.classNameInput,
      classNameInput = _ref$classNameInput === void 0 ? '' : _ref$classNameInput,
      _ref$wide = _ref.wide,
      wide = _ref$wide === void 0 ? false : _ref$wide,
      props = Object(C_Users_admin_Documents_Dev_PWAdvent_node_modules_babel_runtime_helpers_esm_objectWithoutProperties__WEBPACK_IMPORTED_MODULE_1__["default"])(_ref, ["name", "label", "component", "register", "className", "classNameLabel", "classNameInput", "wide"]);

  return __jsx(_ConnectForm__WEBPACK_IMPORTED_MODULE_3__["ConnectForm"], {
    __self: _this,
    __source: {
      fileName: _jsxFileName,
      lineNumber: 27,
      columnNumber: 3
    }
  }, function (_ref2) {
    var register = _ref2.register,
        errors = _ref2.errors;
    return component(_objectSpread(_objectSpread({}, props), {}, {
      name: name,
      id: name,
      label: label,
      ref: register(fieldRegister),
      className: className,
      classNameInput: classNameInput,
      classNameLabel: classNameLabel,
      error: errors[name] ? errors[name].message : ''
    }));
  });
};

_c = FormField;
/* harmony default export */ __webpack_exports__["default"] = (FormField);

var _c;

$RefreshReg$(_c, "FormField");

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.i);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }


const isPrefreshComponent = __prefresh_utils__.shouldBind(module);

  if (true) {
    const currentExports = __prefresh_utils__.getExports(module);
    const previousHotModuleExports =
      module.hot.data && module.hot.data.moduleExports;

    __prefresh_utils__.registerExports(currentExports, module.i);

    if (isPrefreshComponent) {
      if (previousHotModuleExports) {
        try {
          __prefresh_utils__.flush();
          if (
            typeof __prefresh_errors__ !== 'undefined' &&
            __prefresh_errors__ &&
            __prefresh_errors__.clearRuntimeErrors
          ) {
            __prefresh_errors__.clearRuntimeErrors();
          }
        } catch (e) {
          // Only available in newer webpack versions.
          if (module.hot.invalidate) {
            module.hot.invalidate();
          } else {
            self.location.reload();
          }
        }
      }

      module.hot.dispose(data => {
        data.moduleExports = __prefresh_utils__.getExports(module);
      });

      module.hot.accept(function errorRecovery() {
        if (
          typeof __prefresh_errors__ !== 'undefined' &&
          __prefresh_errors__ &&
          __prefresh_errors__.handleRuntimeError
        ) {
          __prefresh_errors__.handleRuntimeError(error);
        }

        __webpack_require__.c[module.i].hot.accept(errorRecovery);
      });
    }
  }
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../node_modules/next/dist/compiled/webpack/harmony-module.js */ "./node_modules/next/dist/compiled/webpack/harmony-module.js")(module), __webpack_require__(/*! ./node_modules/@prefresh/webpack/src/utils/prefresh.js */ "./node_modules/@prefresh/webpack/src/utils/prefresh.js")))

/***/ }),

/***/ "./theme/Form/FormFieldset.module.css":
/*!********************************************!*\
  !*** ./theme/Form/FormFieldset.module.css ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var api = __webpack_require__(/*! ../../node_modules/next/dist/build/webpack/loaders/next-style-loader/runtime/injectStylesIntoStyleTag.js */ "./node_modules/next/dist/build/webpack/loaders/next-style-loader/runtime/injectStylesIntoStyleTag.js");
            var content = __webpack_require__(/*! !../../node_modules/next/dist/compiled/css-loader/cjs.js??ref--5-oneOf-2-1!../../node_modules/next/dist/compiled/postcss-loader/cjs.js??ref--5-oneOf-2-2!./FormFieldset.module.css */ "./node_modules/next/dist/compiled/css-loader/cjs.js?!./node_modules/next/dist/compiled/postcss-loader/cjs.js?!./theme/Form/FormFieldset.module.css");

            content = content.__esModule ? content.default : content;

            if (typeof content === 'string') {
              content = [[module.i, content, '']];
            }

var options = {};

options.insert = function(element){// These elements should always exist. If they do not,
// this code should fail.
var anchorElement=document.querySelector('#__next_css__DO_NOT_USE__');var parentNode=anchorElement.parentNode;// Normally <head>
// Each style tag should be placed right before our
// anchor. By inserting before and not after, we do not
// need to track the last inserted element.
parentNode.insertBefore(element,anchorElement);};
options.singleton = false;

var update = api(content, options);


if (true) {
  if (!content.locals || module.hot.invalidate) {
    var isEqualLocals = function isEqualLocals(a,b,isNamedExport){if(!a&&b||a&&!b){return false;}let p;for(p in a){if(isNamedExport&&p==='default'){// eslint-disable-next-line no-continue
continue;}if(a[p]!==b[p]){return false;}}for(p in b){if(isNamedExport&&p==='default'){// eslint-disable-next-line no-continue
continue;}if(!a[p]){return false;}}return true;};
    var oldLocals = content.locals;

    module.hot.accept(
      /*! !../../node_modules/next/dist/compiled/css-loader/cjs.js??ref--5-oneOf-2-1!../../node_modules/next/dist/compiled/postcss-loader/cjs.js??ref--5-oneOf-2-2!./FormFieldset.module.css */ "./node_modules/next/dist/compiled/css-loader/cjs.js?!./node_modules/next/dist/compiled/postcss-loader/cjs.js?!./theme/Form/FormFieldset.module.css",
      function () {
        content = __webpack_require__(/*! !../../node_modules/next/dist/compiled/css-loader/cjs.js??ref--5-oneOf-2-1!../../node_modules/next/dist/compiled/postcss-loader/cjs.js??ref--5-oneOf-2-2!./FormFieldset.module.css */ "./node_modules/next/dist/compiled/css-loader/cjs.js?!./node_modules/next/dist/compiled/postcss-loader/cjs.js?!./theme/Form/FormFieldset.module.css");

              content = content.__esModule ? content.default : content;

              if (typeof content === 'string') {
                content = [[module.i, content, '']];
              }

              if (!isEqualLocals(oldLocals, content.locals)) {
                module.hot.invalidate();

                return;
              }

              oldLocals = content.locals;

              update(content);
      }
    )
  }

  module.hot.dispose(function() {
    update();
  });
}

module.exports = content.locals || {};

/***/ }),

/***/ "./theme/Form/FormFieldset.tsx":
/*!*************************************!*\
  !*** ./theme/Form/FormFieldset.tsx ***!
  \*************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* WEBPACK VAR INJECTION */(function(module, __prefresh_utils__) {/* harmony import */ var C_Users_admin_Documents_Dev_PWAdvent_node_modules_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./node_modules/@babel/runtime/helpers/esm/defineProperty */ "./node_modules/@babel/runtime/helpers/esm/defineProperty.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ "./node_modules/preact/compat/dist/compat.module.js");
/* harmony import */ var _utils_classnames__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @utils/classnames */ "./utils/classnames.tsx");
/* harmony import */ var _FormFieldset_module_css__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./FormFieldset.module.css */ "./theme/Form/FormFieldset.module.css");
/* harmony import */ var _FormFieldset_module_css__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_FormFieldset_module_css__WEBPACK_IMPORTED_MODULE_3__);


var _jsxFileName = "C:\\Users\\admin\\Documents\\Dev\\PWAdvent\\theme\\Form\\FormFieldset.tsx",
    _this = undefined;

var __jsx = react__WEBPACK_IMPORTED_MODULE_1__["default"].createElement;




var FormFieldset = function FormFieldset(_ref) {
  var _ref$className = _ref.className,
      className = _ref$className === void 0 ? '' : _ref$className,
      _ref$label = _ref.label,
      label = _ref$label === void 0 ? '' : _ref$label,
      children = _ref.children,
      _ref$stacked = _ref.stacked,
      stacked = _ref$stacked === void 0 ? false : _ref$stacked;
  return __jsx("div", {
    className: Object(_utils_classnames__WEBPACK_IMPORTED_MODULE_2__["default"])(_FormFieldset_module_css__WEBPACK_IMPORTED_MODULE_3___default.a.root, className, Object(C_Users_admin_Documents_Dev_PWAdvent_node_modules_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])({}, _FormFieldset_module_css__WEBPACK_IMPORTED_MODULE_3___default.a.isStacked, stacked)),
    __self: _this,
    __source: {
      fileName: _jsxFileName,
      lineNumber: 16,
      columnNumber: 3
    }
  }, label !== '' && __jsx("h2", {
    className: _FormFieldset_module_css__WEBPACK_IMPORTED_MODULE_3___default.a.label,
    __self: _this,
    __source: {
      fileName: _jsxFileName,
      lineNumber: 21,
      columnNumber: 22
    }
  }, label), __jsx("div", {
    className: _FormFieldset_module_css__WEBPACK_IMPORTED_MODULE_3___default.a.fields,
    __self: _this,
    __source: {
      fileName: _jsxFileName,
      lineNumber: 22,
      columnNumber: 5
    }
  }, children));
};

_c = FormFieldset;
/* harmony default export */ __webpack_exports__["default"] = (FormFieldset);

var _c;

$RefreshReg$(_c, "FormFieldset");

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.i);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }


const isPrefreshComponent = __prefresh_utils__.shouldBind(module);

  if (true) {
    const currentExports = __prefresh_utils__.getExports(module);
    const previousHotModuleExports =
      module.hot.data && module.hot.data.moduleExports;

    __prefresh_utils__.registerExports(currentExports, module.i);

    if (isPrefreshComponent) {
      if (previousHotModuleExports) {
        try {
          __prefresh_utils__.flush();
          if (
            typeof __prefresh_errors__ !== 'undefined' &&
            __prefresh_errors__ &&
            __prefresh_errors__.clearRuntimeErrors
          ) {
            __prefresh_errors__.clearRuntimeErrors();
          }
        } catch (e) {
          // Only available in newer webpack versions.
          if (module.hot.invalidate) {
            module.hot.invalidate();
          } else {
            self.location.reload();
          }
        }
      }

      module.hot.dispose(data => {
        data.moduleExports = __prefresh_utils__.getExports(module);
      });

      module.hot.accept(function errorRecovery() {
        if (
          typeof __prefresh_errors__ !== 'undefined' &&
          __prefresh_errors__ &&
          __prefresh_errors__.handleRuntimeError
        ) {
          __prefresh_errors__.handleRuntimeError(error);
        }

        __webpack_require__.c[module.i].hot.accept(errorRecovery);
      });
    }
  }
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../node_modules/next/dist/compiled/webpack/harmony-module.js */ "./node_modules/next/dist/compiled/webpack/harmony-module.js")(module), __webpack_require__(/*! ./node_modules/@prefresh/webpack/src/utils/prefresh.js */ "./node_modules/@prefresh/webpack/src/utils/prefresh.js")))

/***/ }),

/***/ "./theme/Form/Input.module.css":
/*!*************************************!*\
  !*** ./theme/Form/Input.module.css ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var api = __webpack_require__(/*! ../../node_modules/next/dist/build/webpack/loaders/next-style-loader/runtime/injectStylesIntoStyleTag.js */ "./node_modules/next/dist/build/webpack/loaders/next-style-loader/runtime/injectStylesIntoStyleTag.js");
            var content = __webpack_require__(/*! !../../node_modules/next/dist/compiled/css-loader/cjs.js??ref--5-oneOf-2-1!../../node_modules/next/dist/compiled/postcss-loader/cjs.js??ref--5-oneOf-2-2!./Input.module.css */ "./node_modules/next/dist/compiled/css-loader/cjs.js?!./node_modules/next/dist/compiled/postcss-loader/cjs.js?!./theme/Form/Input.module.css");

            content = content.__esModule ? content.default : content;

            if (typeof content === 'string') {
              content = [[module.i, content, '']];
            }

var options = {};

options.insert = function(element){// These elements should always exist. If they do not,
// this code should fail.
var anchorElement=document.querySelector('#__next_css__DO_NOT_USE__');var parentNode=anchorElement.parentNode;// Normally <head>
// Each style tag should be placed right before our
// anchor. By inserting before and not after, we do not
// need to track the last inserted element.
parentNode.insertBefore(element,anchorElement);};
options.singleton = false;

var update = api(content, options);


if (true) {
  if (!content.locals || module.hot.invalidate) {
    var isEqualLocals = function isEqualLocals(a,b,isNamedExport){if(!a&&b||a&&!b){return false;}let p;for(p in a){if(isNamedExport&&p==='default'){// eslint-disable-next-line no-continue
continue;}if(a[p]!==b[p]){return false;}}for(p in b){if(isNamedExport&&p==='default'){// eslint-disable-next-line no-continue
continue;}if(!a[p]){return false;}}return true;};
    var oldLocals = content.locals;

    module.hot.accept(
      /*! !../../node_modules/next/dist/compiled/css-loader/cjs.js??ref--5-oneOf-2-1!../../node_modules/next/dist/compiled/postcss-loader/cjs.js??ref--5-oneOf-2-2!./Input.module.css */ "./node_modules/next/dist/compiled/css-loader/cjs.js?!./node_modules/next/dist/compiled/postcss-loader/cjs.js?!./theme/Form/Input.module.css",
      function () {
        content = __webpack_require__(/*! !../../node_modules/next/dist/compiled/css-loader/cjs.js??ref--5-oneOf-2-1!../../node_modules/next/dist/compiled/postcss-loader/cjs.js??ref--5-oneOf-2-2!./Input.module.css */ "./node_modules/next/dist/compiled/css-loader/cjs.js?!./node_modules/next/dist/compiled/postcss-loader/cjs.js?!./theme/Form/Input.module.css");

              content = content.__esModule ? content.default : content;

              if (typeof content === 'string') {
                content = [[module.i, content, '']];
              }

              if (!isEqualLocals(oldLocals, content.locals)) {
                module.hot.invalidate();

                return;
              }

              oldLocals = content.locals;

              update(content);
      }
    )
  }

  module.hot.dispose(function() {
    update();
  });
}

module.exports = content.locals || {};

/***/ }),

/***/ "./theme/Form/Input.tsx":
/*!******************************!*\
  !*** ./theme/Form/Input.tsx ***!
  \******************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* WEBPACK VAR INJECTION */(function(module, __prefresh_utils__) {/* harmony import */ var C_Users_admin_Documents_Dev_PWAdvent_node_modules_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./node_modules/@babel/runtime/helpers/esm/extends */ "./node_modules/@babel/runtime/helpers/esm/extends.js");
/* harmony import */ var C_Users_admin_Documents_Dev_PWAdvent_node_modules_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./node_modules/@babel/runtime/helpers/esm/defineProperty */ "./node_modules/@babel/runtime/helpers/esm/defineProperty.js");
/* harmony import */ var C_Users_admin_Documents_Dev_PWAdvent_node_modules_babel_runtime_helpers_esm_slicedToArray__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./node_modules/@babel/runtime/helpers/esm/slicedToArray */ "./node_modules/@babel/runtime/helpers/esm/slicedToArray.js");
/* harmony import */ var C_Users_admin_Documents_Dev_PWAdvent_node_modules_babel_runtime_helpers_esm_objectWithoutProperties__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./node_modules/@babel/runtime/helpers/esm/objectWithoutProperties */ "./node_modules/@babel/runtime/helpers/esm/objectWithoutProperties.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! react */ "./node_modules/preact/compat/dist/compat.module.js");
/* harmony import */ var _utils_classnames__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @utils/classnames */ "./utils/classnames.tsx");
/* harmony import */ var _Input_module_css__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./Input.module.css */ "./theme/Form/Input.module.css");
/* harmony import */ var _Input_module_css__WEBPACK_IMPORTED_MODULE_6___default = /*#__PURE__*/__webpack_require__.n(_Input_module_css__WEBPACK_IMPORTED_MODULE_6__);





var _jsxFileName = "C:\\Users\\admin\\Documents\\Dev\\PWAdvent\\theme\\Form\\Input.tsx",
    _this = undefined,
    _s = $RefreshSig$();

var __jsx = react__WEBPACK_IMPORTED_MODULE_4__["default"].createElement;

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { Object(C_Users_admin_Documents_Dev_PWAdvent_node_modules_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_1__["default"])(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }





var Input = function Input(_ref) {
  _s();

  var name = _ref.name,
      id = _ref.id,
      label = _ref.label,
      _ref$className = _ref.className,
      className = _ref$className === void 0 ? '' : _ref$className,
      _ref$classNameLabel = _ref.classNameLabel,
      classNameLabel = _ref$classNameLabel === void 0 ? '' : _ref$classNameLabel,
      _ref$classNameInput = _ref.classNameInput,
      classNameInput = _ref$classNameInput === void 0 ? '' : _ref$classNameInput,
      _ref$type = _ref.type,
      type = _ref$type === void 0 ? 'text' : _ref$type,
      _ref$subtype = _ref.subtype,
      subtype = _ref$subtype === void 0 ? 'text' : _ref$subtype,
      _ref$value = _ref.value,
      initialValue = _ref$value === void 0 ? '' : _ref$value,
      _ref$choices = _ref.choices,
      choices = _ref$choices === void 0 ? {} : _ref$choices,
      _ref$error = _ref.error,
      error = _ref$error === void 0 ? '' : _ref$error,
      _ref$onChange = _ref.onChange,
      _onChange = _ref$onChange === void 0 ? function () {} : _ref$onChange,
      _ref$onValueChanged = _ref.onValueChanged,
      onValueChanged = _ref$onValueChanged === void 0 ? function () {} : _ref$onValueChanged,
      props = Object(C_Users_admin_Documents_Dev_PWAdvent_node_modules_babel_runtime_helpers_esm_objectWithoutProperties__WEBPACK_IMPORTED_MODULE_3__["default"])(_ref, ["name", "id", "label", "className", "classNameLabel", "classNameInput", "type", "subtype", "value", "choices", "error", "onChange", "onValueChanged"]);

  var _React$useState = react__WEBPACK_IMPORTED_MODULE_4__["default"].useState(initialValue),
      _React$useState2 = Object(C_Users_admin_Documents_Dev_PWAdvent_node_modules_babel_runtime_helpers_esm_slicedToArray__WEBPACK_IMPORTED_MODULE_2__["default"])(_React$useState, 2),
      value = _React$useState2[0],
      setValue = _React$useState2[1];

  var prevValue = react__WEBPACK_IMPORTED_MODULE_4__["default"].useRef(null);

  var inputProps = _objectSpread(_objectSpread({}, props), {}, {
    className: Object(_utils_classnames__WEBPACK_IMPORTED_MODULE_5__["default"])(classNameInput, _Input_module_css__WEBPACK_IMPORTED_MODULE_6___default.a.element, "input__element--".concat(type), "input__element--".concat(value !== '' || type === 'select' && Object.values(choices).length && Object.values(choices)[0] !== '' ? 'value' : 'empty')),
    name: name,
    id: id,
    onChange: function onChange(e) {
      _onChange(e);

      setValue(e.target.value);
    }
  });

  react__WEBPACK_IMPORTED_MODULE_4__["default"].useEffect(function () {
    onValueChanged && onValueChanged(value, prevValue.current);
    prevValue.current = value;
  }, [value]);
  return __jsx("div", {
    className: Object(_utils_classnames__WEBPACK_IMPORTED_MODULE_5__["default"])(className, _Input_module_css__WEBPACK_IMPORTED_MODULE_6___default.a.root, Object(C_Users_admin_Documents_Dev_PWAdvent_node_modules_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_1__["default"])({}, _Input_module_css__WEBPACK_IMPORTED_MODULE_6___default.a.isError, error !== '')),
    __self: _this,
    __source: {
      fileName: _jsxFileName,
      lineNumber: 70,
      columnNumber: 5
    }
  }, __jsx("label", {
    className: Object(_utils_classnames__WEBPACK_IMPORTED_MODULE_5__["default"])(classNameLabel, _Input_module_css__WEBPACK_IMPORTED_MODULE_6___default.a.label),
    htmlFor: id,
    __self: _this,
    __source: {
      fileName: _jsxFileName,
      lineNumber: 75,
      columnNumber: 7
    }
  }, label), type === 'textarea' && __jsx("textarea", Object(C_Users_admin_Documents_Dev_PWAdvent_node_modules_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__["default"])({}, inputProps, {
    __self: _this,
    __source: {
      fileName: _jsxFileName,
      lineNumber: 78,
      columnNumber: 31
    }
  }), value), type === 'text' && __jsx("input", Object(C_Users_admin_Documents_Dev_PWAdvent_node_modules_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__["default"])({
    type: subtype
  }, inputProps, value ? {
    value: value
  } : {}, {
    __self: _this,
    __source: {
      fileName: _jsxFileName,
      lineNumber: 80,
      columnNumber: 9
    }
  })), type === 'select' && __jsx("select", Object(C_Users_admin_Documents_Dev_PWAdvent_node_modules_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__["default"])({}, inputProps, {
    __self: _this,
    __source: {
      fileName: _jsxFileName,
      lineNumber: 83,
      columnNumber: 9
    }
  }), Object.entries(choices).map(function (_ref2) {
    var _ref3 = Object(C_Users_admin_Documents_Dev_PWAdvent_node_modules_babel_runtime_helpers_esm_slicedToArray__WEBPACK_IMPORTED_MODULE_2__["default"])(_ref2, 2),
        key = _ref3[0],
        val = _ref3[1];

    return __jsx("option", {
      key: key,
      selected: key === value,
      __self: _this,
      __source: {
        fileName: _jsxFileName,
        lineNumber: 85,
        columnNumber: 13
      }
    }, val);
  })), error !== '' && __jsx("span", {
    className: _Input_module_css__WEBPACK_IMPORTED_MODULE_6___default.a.error,
    __self: _this,
    __source: {
      fileName: _jsxFileName,
      lineNumber: 91,
      columnNumber: 24
    }
  }, error));
};

_s(Input, "haBGPHE+drmlPxEAoILGQ8CWMPM=");

_c = Input;
/* harmony default export */ __webpack_exports__["default"] = (Input);

var _c;

$RefreshReg$(_c, "Input");

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.i);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }


const isPrefreshComponent = __prefresh_utils__.shouldBind(module);

  if (true) {
    const currentExports = __prefresh_utils__.getExports(module);
    const previousHotModuleExports =
      module.hot.data && module.hot.data.moduleExports;

    __prefresh_utils__.registerExports(currentExports, module.i);

    if (isPrefreshComponent) {
      if (previousHotModuleExports) {
        try {
          __prefresh_utils__.flush();
          if (
            typeof __prefresh_errors__ !== 'undefined' &&
            __prefresh_errors__ &&
            __prefresh_errors__.clearRuntimeErrors
          ) {
            __prefresh_errors__.clearRuntimeErrors();
          }
        } catch (e) {
          // Only available in newer webpack versions.
          if (module.hot.invalidate) {
            module.hot.invalidate();
          } else {
            self.location.reload();
          }
        }
      }

      module.hot.dispose(data => {
        data.moduleExports = __prefresh_utils__.getExports(module);
      });

      module.hot.accept(function errorRecovery() {
        if (
          typeof __prefresh_errors__ !== 'undefined' &&
          __prefresh_errors__ &&
          __prefresh_errors__.handleRuntimeError
        ) {
          __prefresh_errors__.handleRuntimeError(error);
        }

        __webpack_require__.c[module.i].hot.accept(errorRecovery);
      });
    }
  }
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../node_modules/next/dist/compiled/webpack/harmony-module.js */ "./node_modules/next/dist/compiled/webpack/harmony-module.js")(module), __webpack_require__(/*! ./node_modules/@prefresh/webpack/src/utils/prefresh.js */ "./node_modules/@prefresh/webpack/src/utils/prefresh.js")))

/***/ }),

/***/ "./theme/Form/InputSelect.tsx":
/*!************************************!*\
  !*** ./theme/Form/InputSelect.tsx ***!
  \************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* WEBPACK VAR INJECTION */(function(module, __prefresh_utils__) {/* harmony import */ var C_Users_admin_Documents_Dev_PWAdvent_node_modules_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./node_modules/@babel/runtime/helpers/esm/defineProperty */ "./node_modules/@babel/runtime/helpers/esm/defineProperty.js");
/* harmony import */ var _Input__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Input */ "./theme/Form/Input.tsx");


function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { Object(C_Users_admin_Documents_Dev_PWAdvent_node_modules_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }



var InputSelect = function InputSelect(props) {
  return Object(_Input__WEBPACK_IMPORTED_MODULE_1__["default"])(_objectSpread(_objectSpread({}, props), {}, {
    type: 'select',
    value: props.value in props.choices ? props.value : ''
  }));
};

_c = InputSelect;
/* harmony default export */ __webpack_exports__["default"] = (InputSelect);

var _c;

$RefreshReg$(_c, "InputSelect");

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.i);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }


const isPrefreshComponent = __prefresh_utils__.shouldBind(module);

  if (true) {
    const currentExports = __prefresh_utils__.getExports(module);
    const previousHotModuleExports =
      module.hot.data && module.hot.data.moduleExports;

    __prefresh_utils__.registerExports(currentExports, module.i);

    if (isPrefreshComponent) {
      if (previousHotModuleExports) {
        try {
          __prefresh_utils__.flush();
          if (
            typeof __prefresh_errors__ !== 'undefined' &&
            __prefresh_errors__ &&
            __prefresh_errors__.clearRuntimeErrors
          ) {
            __prefresh_errors__.clearRuntimeErrors();
          }
        } catch (e) {
          // Only available in newer webpack versions.
          if (module.hot.invalidate) {
            module.hot.invalidate();
          } else {
            self.location.reload();
          }
        }
      }

      module.hot.dispose(data => {
        data.moduleExports = __prefresh_utils__.getExports(module);
      });

      module.hot.accept(function errorRecovery() {
        if (
          typeof __prefresh_errors__ !== 'undefined' &&
          __prefresh_errors__ &&
          __prefresh_errors__.handleRuntimeError
        ) {
          __prefresh_errors__.handleRuntimeError(error);
        }

        __webpack_require__.c[module.i].hot.accept(errorRecovery);
      });
    }
  }
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../node_modules/next/dist/compiled/webpack/harmony-module.js */ "./node_modules/next/dist/compiled/webpack/harmony-module.js")(module), __webpack_require__(/*! ./node_modules/@prefresh/webpack/src/utils/prefresh.js */ "./node_modules/@prefresh/webpack/src/utils/prefresh.js")))

/***/ }),

/***/ "./theme/Form/InputText.tsx":
/*!**********************************!*\
  !*** ./theme/Form/InputText.tsx ***!
  \**********************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* WEBPACK VAR INJECTION */(function(module, __prefresh_utils__) {/* harmony import */ var C_Users_admin_Documents_Dev_PWAdvent_node_modules_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./node_modules/@babel/runtime/helpers/esm/defineProperty */ "./node_modules/@babel/runtime/helpers/esm/defineProperty.js");
/* harmony import */ var _Input__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Input */ "./theme/Form/Input.tsx");


function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { Object(C_Users_admin_Documents_Dev_PWAdvent_node_modules_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }



var InputText = function InputText(props) {
  return Object(_Input__WEBPACK_IMPORTED_MODULE_1__["default"])(_objectSpread(_objectSpread({}, props), {}, {
    type: 'text',
    subtype: props.type
  }));
};

_c = InputText;
/* harmony default export */ __webpack_exports__["default"] = (InputText);

var _c;

$RefreshReg$(_c, "InputText");

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.i);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }


const isPrefreshComponent = __prefresh_utils__.shouldBind(module);

  if (true) {
    const currentExports = __prefresh_utils__.getExports(module);
    const previousHotModuleExports =
      module.hot.data && module.hot.data.moduleExports;

    __prefresh_utils__.registerExports(currentExports, module.i);

    if (isPrefreshComponent) {
      if (previousHotModuleExports) {
        try {
          __prefresh_utils__.flush();
          if (
            typeof __prefresh_errors__ !== 'undefined' &&
            __prefresh_errors__ &&
            __prefresh_errors__.clearRuntimeErrors
          ) {
            __prefresh_errors__.clearRuntimeErrors();
          }
        } catch (e) {
          // Only available in newer webpack versions.
          if (module.hot.invalidate) {
            module.hot.invalidate();
          } else {
            self.location.reload();
          }
        }
      }

      module.hot.dispose(data => {
        data.moduleExports = __prefresh_utils__.getExports(module);
      });

      module.hot.accept(function errorRecovery() {
        if (
          typeof __prefresh_errors__ !== 'undefined' &&
          __prefresh_errors__ &&
          __prefresh_errors__.handleRuntimeError
        ) {
          __prefresh_errors__.handleRuntimeError(error);
        }

        __webpack_require__.c[module.i].hot.accept(errorRecovery);
      });
    }
  }
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../node_modules/next/dist/compiled/webpack/harmony-module.js */ "./node_modules/next/dist/compiled/webpack/harmony-module.js")(module), __webpack_require__(/*! ./node_modules/@prefresh/webpack/src/utils/prefresh.js */ "./node_modules/@prefresh/webpack/src/utils/prefresh.js")))

/***/ }),

/***/ "./theme/Form/InputTextarea.tsx":
/*!**************************************!*\
  !*** ./theme/Form/InputTextarea.tsx ***!
  \**************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* WEBPACK VAR INJECTION */(function(module, __prefresh_utils__) {/* harmony import */ var C_Users_admin_Documents_Dev_PWAdvent_node_modules_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./node_modules/@babel/runtime/helpers/esm/defineProperty */ "./node_modules/@babel/runtime/helpers/esm/defineProperty.js");
/* harmony import */ var _Input__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Input */ "./theme/Form/Input.tsx");


function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { Object(C_Users_admin_Documents_Dev_PWAdvent_node_modules_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }



var InputTextarea = function InputTextarea(props) {
  return Object(_Input__WEBPACK_IMPORTED_MODULE_1__["default"])(_objectSpread(_objectSpread({}, props), {}, {
    type: 'textarea',
    subtype: props.type
  }));
};

_c = InputTextarea;
/* harmony default export */ __webpack_exports__["default"] = (InputTextarea);

var _c;

$RefreshReg$(_c, "InputTextarea");

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.i);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }


const isPrefreshComponent = __prefresh_utils__.shouldBind(module);

  if (true) {
    const currentExports = __prefresh_utils__.getExports(module);
    const previousHotModuleExports =
      module.hot.data && module.hot.data.moduleExports;

    __prefresh_utils__.registerExports(currentExports, module.i);

    if (isPrefreshComponent) {
      if (previousHotModuleExports) {
        try {
          __prefresh_utils__.flush();
          if (
            typeof __prefresh_errors__ !== 'undefined' &&
            __prefresh_errors__ &&
            __prefresh_errors__.clearRuntimeErrors
          ) {
            __prefresh_errors__.clearRuntimeErrors();
          }
        } catch (e) {
          // Only available in newer webpack versions.
          if (module.hot.invalidate) {
            module.hot.invalidate();
          } else {
            self.location.reload();
          }
        }
      }

      module.hot.dispose(data => {
        data.moduleExports = __prefresh_utils__.getExports(module);
      });

      module.hot.accept(function errorRecovery() {
        if (
          typeof __prefresh_errors__ !== 'undefined' &&
          __prefresh_errors__ &&
          __prefresh_errors__.handleRuntimeError
        ) {
          __prefresh_errors__.handleRuntimeError(error);
        }

        __webpack_require__.c[module.i].hot.accept(errorRecovery);
      });
    }
  }
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../node_modules/next/dist/compiled/webpack/harmony-module.js */ "./node_modules/next/dist/compiled/webpack/harmony-module.js")(module), __webpack_require__(/*! ./node_modules/@prefresh/webpack/src/utils/prefresh.js */ "./node_modules/@prefresh/webpack/src/utils/prefresh.js")))

/***/ }),

/***/ "./theme/Image/LazyImage.module.css":
/*!******************************************!*\
  !*** ./theme/Image/LazyImage.module.css ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var api = __webpack_require__(/*! ../../node_modules/next/dist/build/webpack/loaders/next-style-loader/runtime/injectStylesIntoStyleTag.js */ "./node_modules/next/dist/build/webpack/loaders/next-style-loader/runtime/injectStylesIntoStyleTag.js");
            var content = __webpack_require__(/*! !../../node_modules/next/dist/compiled/css-loader/cjs.js??ref--5-oneOf-2-1!../../node_modules/next/dist/compiled/postcss-loader/cjs.js??ref--5-oneOf-2-2!./LazyImage.module.css */ "./node_modules/next/dist/compiled/css-loader/cjs.js?!./node_modules/next/dist/compiled/postcss-loader/cjs.js?!./theme/Image/LazyImage.module.css");

            content = content.__esModule ? content.default : content;

            if (typeof content === 'string') {
              content = [[module.i, content, '']];
            }

var options = {};

options.insert = function(element){// These elements should always exist. If they do not,
// this code should fail.
var anchorElement=document.querySelector('#__next_css__DO_NOT_USE__');var parentNode=anchorElement.parentNode;// Normally <head>
// Each style tag should be placed right before our
// anchor. By inserting before and not after, we do not
// need to track the last inserted element.
parentNode.insertBefore(element,anchorElement);};
options.singleton = false;

var update = api(content, options);


if (true) {
  if (!content.locals || module.hot.invalidate) {
    var isEqualLocals = function isEqualLocals(a,b,isNamedExport){if(!a&&b||a&&!b){return false;}let p;for(p in a){if(isNamedExport&&p==='default'){// eslint-disable-next-line no-continue
continue;}if(a[p]!==b[p]){return false;}}for(p in b){if(isNamedExport&&p==='default'){// eslint-disable-next-line no-continue
continue;}if(!a[p]){return false;}}return true;};
    var oldLocals = content.locals;

    module.hot.accept(
      /*! !../../node_modules/next/dist/compiled/css-loader/cjs.js??ref--5-oneOf-2-1!../../node_modules/next/dist/compiled/postcss-loader/cjs.js??ref--5-oneOf-2-2!./LazyImage.module.css */ "./node_modules/next/dist/compiled/css-loader/cjs.js?!./node_modules/next/dist/compiled/postcss-loader/cjs.js?!./theme/Image/LazyImage.module.css",
      function () {
        content = __webpack_require__(/*! !../../node_modules/next/dist/compiled/css-loader/cjs.js??ref--5-oneOf-2-1!../../node_modules/next/dist/compiled/postcss-loader/cjs.js??ref--5-oneOf-2-2!./LazyImage.module.css */ "./node_modules/next/dist/compiled/css-loader/cjs.js?!./node_modules/next/dist/compiled/postcss-loader/cjs.js?!./theme/Image/LazyImage.module.css");

              content = content.__esModule ? content.default : content;

              if (typeof content === 'string') {
                content = [[module.i, content, '']];
              }

              if (!isEqualLocals(oldLocals, content.locals)) {
                module.hot.invalidate();

                return;
              }

              oldLocals = content.locals;

              update(content);
      }
    )
  }

  module.hot.dispose(function() {
    update();
  });
}

module.exports = content.locals || {};

/***/ }),

/***/ "./theme/Image/LazyImage.tsx":
/*!***********************************!*\
  !*** ./theme/Image/LazyImage.tsx ***!
  \***********************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* WEBPACK VAR INJECTION */(function(module, __prefresh_utils__) {/* harmony import */ var C_Users_admin_Documents_Dev_PWAdvent_node_modules_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./node_modules/@babel/runtime/helpers/esm/extends */ "./node_modules/@babel/runtime/helpers/esm/extends.js");
/* harmony import */ var C_Users_admin_Documents_Dev_PWAdvent_node_modules_babel_runtime_helpers_esm_slicedToArray__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./node_modules/@babel/runtime/helpers/esm/slicedToArray */ "./node_modules/@babel/runtime/helpers/esm/slicedToArray.js");
/* harmony import */ var C_Users_admin_Documents_Dev_PWAdvent_node_modules_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./node_modules/@babel/runtime/helpers/esm/defineProperty */ "./node_modules/@babel/runtime/helpers/esm/defineProperty.js");
/* harmony import */ var C_Users_admin_Documents_Dev_PWAdvent_node_modules_babel_runtime_helpers_esm_objectWithoutProperties__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./node_modules/@babel/runtime/helpers/esm/objectWithoutProperties */ "./node_modules/@babel/runtime/helpers/esm/objectWithoutProperties.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! react */ "./node_modules/preact/compat/dist/compat.module.js");
/* harmony import */ var _utils_classnames__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @utils/classnames */ "./utils/classnames.tsx");
/* harmony import */ var _LazyImage_module_css__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./LazyImage.module.css */ "./theme/Image/LazyImage.module.css");
/* harmony import */ var _LazyImage_module_css__WEBPACK_IMPORTED_MODULE_6___default = /*#__PURE__*/__webpack_require__.n(_LazyImage_module_css__WEBPACK_IMPORTED_MODULE_6__);





var _jsxFileName = "C:\\Users\\admin\\Documents\\Dev\\PWAdvent\\theme\\Image\\LazyImage.tsx",
    _this = undefined,
    _s = $RefreshSig$();

var __jsx = react__WEBPACK_IMPORTED_MODULE_4__["default"].createElement;
// @ts-ignore

/*
import lazySizes from 'lazysizes';
import 'lazysizes/plugins/attrchange/ls.attrchange';
import 'lazysizes/plugins/bgset/ls.bgset';
import 'lazysizes/plugins/respimg/ls.respimg';*/



var BASE = 'lazyimage';
/*
lazySizes.cfg.lazyClass = styles.imageLazyload;
lazySizes.cfg.loadingClass = styles.imageLazyloading;
lazySizes.cfg.loadedClass = styles.imageLazyloaded;
document.addEventListener('lazyloaded', (e) => {
  lazySizesFindParent(e.target).classList.add(styles.isLoaded);
});*/

var lazySizesFindParent = function lazySizesFindParent(el) {
  while ((el = el.parentElement) && !el.classList.contains(BASE)) {
    ;
  }

  return el;
};

var LazyImage = function LazyImage(_ref) {
  _s();

  var image = _ref.image,
      _ref$background = _ref.background,
      background = _ref$background === void 0 ? false : _ref$background,
      alt = _ref.alt,
      _ref$width = _ref.width,
      width = _ref$width === void 0 ? 0 : _ref$width,
      _ref$height = _ref.height,
      height = _ref$height === void 0 ? 0 : _ref$height,
      _ref$className = _ref.className,
      className = _ref$className === void 0 ? '' : _ref$className,
      props = Object(C_Users_admin_Documents_Dev_PWAdvent_node_modules_babel_runtime_helpers_esm_objectWithoutProperties__WEBPACK_IMPORTED_MODULE_3__["default"])(_ref, ["image", "background", "alt", "width", "height", "className"]);

  var mainImage = react__WEBPACK_IMPORTED_MODULE_4__["default"].useMemo(function () {
    return Object.values(image.sizes).map(function (size) {
      return {
        url: size.url,
        width: size.width,
        height: size.height
      };
    })[0];
  }, [image]);
  return __jsx("figure", Object(C_Users_admin_Documents_Dev_PWAdvent_node_modules_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__["default"])({
    className: Object(_utils_classnames__WEBPACK_IMPORTED_MODULE_5__["default"])(_LazyImage_module_css__WEBPACK_IMPORTED_MODULE_6___default.a.root, Object(C_Users_admin_Documents_Dev_PWAdvent_node_modules_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_2__["default"])({}, _LazyImage_module_css__WEBPACK_IMPORTED_MODULE_6___default.a.background, background), className)
  }, props, {
    __self: _this,
    __source: {
      fileName: _jsxFileName,
      lineNumber: 56,
      columnNumber: 5
    }
  }), background ? __jsx(react__WEBPACK_IMPORTED_MODULE_4__["default"].Fragment, {
    __self: _this,
    __source: {
      fileName: _jsxFileName,
      lineNumber: 65,
      columnNumber: 9
    }
  }, __jsx("div", {
    "aria-hidden": "true",
    className: _LazyImage_module_css__WEBPACK_IMPORTED_MODULE_6___default.a.background,
    style: {
      backgroundImage: "url('" + image.placeholder + "')"
    },
    __self: _this,
    __source: {
      fileName: _jsxFileName,
      lineNumber: 66,
      columnNumber: 11
    }
  }), __jsx("div", {
    title: alt || image.alt,
    className: Object(_utils_classnames__WEBPACK_IMPORTED_MODULE_5__["default"])(_LazyImage_module_css__WEBPACK_IMPORTED_MODULE_6___default.a.image, _LazyImage_module_css__WEBPACK_IMPORTED_MODULE_6___default.a.imageLazyload),
    style: {
      backgroundImage: "url('" + image.placeholder + "')"
    },
    "data-bgset": Object.entries(image.sizes).map(function (_ref2) {
      var _ref3 = Object(C_Users_admin_Documents_Dev_PWAdvent_node_modules_babel_runtime_helpers_esm_slicedToArray__WEBPACK_IMPORTED_MODULE_1__["default"])(_ref2, 2),
          width = _ref3[0],
          url = _ref3[1];

      return "".concat(url, " ").concat(width, "w");
    }).join(', '),
    __self: _this,
    __source: {
      fileName: _jsxFileName,
      lineNumber: 73,
      columnNumber: 11
    }
  })) : __jsx(react__WEBPACK_IMPORTED_MODULE_4__["default"].Fragment, {
    __self: _this,
    __source: {
      fileName: _jsxFileName,
      lineNumber: 83,
      columnNumber: 9
    }
  }, __jsx("img", {
    "aria-hidden": "true",
    className: _LazyImage_module_css__WEBPACK_IMPORTED_MODULE_6___default.a.preview,
    src: image.placeholder,
    __self: _this,
    __source: {
      fileName: _jsxFileName,
      lineNumber: 84,
      columnNumber: 11
    }
  }), __jsx("img", {
    alt: alt || image.alt,
    width: mainImage.width,
    height: mainImage.height,
    className: Object(_utils_classnames__WEBPACK_IMPORTED_MODULE_5__["default"])(_LazyImage_module_css__WEBPACK_IMPORTED_MODULE_6___default.a.image, _LazyImage_module_css__WEBPACK_IMPORTED_MODULE_6___default.a.imageLazyload),
    "data-sizes": "auto",
    src: image.placeholder,
    "data-src": mainImage.url,
    "data-srcset": Object.entries(image.sizes).map(function (_ref4) {
      var _ref5 = Object(C_Users_admin_Documents_Dev_PWAdvent_node_modules_babel_runtime_helpers_esm_slicedToArray__WEBPACK_IMPORTED_MODULE_1__["default"])(_ref4, 2),
          name = _ref5[0],
          _ref5$ = _ref5[1],
          width = _ref5$.width,
          url = _ref5$.url;

      return "".concat(url, " ").concat(width, "w");
    }).join(', '),
    __self: _this,
    __source: {
      fileName: _jsxFileName,
      lineNumber: 89,
      columnNumber: 11
    }
  })));
};

_s(LazyImage, "QxKAEmD/aHF3rJVK3i1OUwUmrPY=");

_c = LazyImage;
/* harmony default export */ __webpack_exports__["default"] = (LazyImage);

var _c;

$RefreshReg$(_c, "LazyImage");

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.i);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }


const isPrefreshComponent = __prefresh_utils__.shouldBind(module);

  if (true) {
    const currentExports = __prefresh_utils__.getExports(module);
    const previousHotModuleExports =
      module.hot.data && module.hot.data.moduleExports;

    __prefresh_utils__.registerExports(currentExports, module.i);

    if (isPrefreshComponent) {
      if (previousHotModuleExports) {
        try {
          __prefresh_utils__.flush();
          if (
            typeof __prefresh_errors__ !== 'undefined' &&
            __prefresh_errors__ &&
            __prefresh_errors__.clearRuntimeErrors
          ) {
            __prefresh_errors__.clearRuntimeErrors();
          }
        } catch (e) {
          // Only available in newer webpack versions.
          if (module.hot.invalidate) {
            module.hot.invalidate();
          } else {
            self.location.reload();
          }
        }
      }

      module.hot.dispose(data => {
        data.moduleExports = __prefresh_utils__.getExports(module);
      });

      module.hot.accept(function errorRecovery() {
        if (
          typeof __prefresh_errors__ !== 'undefined' &&
          __prefresh_errors__ &&
          __prefresh_errors__.handleRuntimeError
        ) {
          __prefresh_errors__.handleRuntimeError(error);
        }

        __webpack_require__.c[module.i].hot.accept(errorRecovery);
      });
    }
  }
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../node_modules/next/dist/compiled/webpack/harmony-module.js */ "./node_modules/next/dist/compiled/webpack/harmony-module.js")(module), __webpack_require__(/*! ./node_modules/@prefresh/webpack/src/utils/prefresh.js */ "./node_modules/@prefresh/webpack/src/utils/prefresh.js")))

/***/ }),

/***/ "./theme/Loader/Loader.module.css":
/*!****************************************!*\
  !*** ./theme/Loader/Loader.module.css ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var api = __webpack_require__(/*! ../../node_modules/next/dist/build/webpack/loaders/next-style-loader/runtime/injectStylesIntoStyleTag.js */ "./node_modules/next/dist/build/webpack/loaders/next-style-loader/runtime/injectStylesIntoStyleTag.js");
            var content = __webpack_require__(/*! !../../node_modules/next/dist/compiled/css-loader/cjs.js??ref--5-oneOf-2-1!../../node_modules/next/dist/compiled/postcss-loader/cjs.js??ref--5-oneOf-2-2!./Loader.module.css */ "./node_modules/next/dist/compiled/css-loader/cjs.js?!./node_modules/next/dist/compiled/postcss-loader/cjs.js?!./theme/Loader/Loader.module.css");

            content = content.__esModule ? content.default : content;

            if (typeof content === 'string') {
              content = [[module.i, content, '']];
            }

var options = {};

options.insert = function(element){// These elements should always exist. If they do not,
// this code should fail.
var anchorElement=document.querySelector('#__next_css__DO_NOT_USE__');var parentNode=anchorElement.parentNode;// Normally <head>
// Each style tag should be placed right before our
// anchor. By inserting before and not after, we do not
// need to track the last inserted element.
parentNode.insertBefore(element,anchorElement);};
options.singleton = false;

var update = api(content, options);


if (true) {
  if (!content.locals || module.hot.invalidate) {
    var isEqualLocals = function isEqualLocals(a,b,isNamedExport){if(!a&&b||a&&!b){return false;}let p;for(p in a){if(isNamedExport&&p==='default'){// eslint-disable-next-line no-continue
continue;}if(a[p]!==b[p]){return false;}}for(p in b){if(isNamedExport&&p==='default'){// eslint-disable-next-line no-continue
continue;}if(!a[p]){return false;}}return true;};
    var oldLocals = content.locals;

    module.hot.accept(
      /*! !../../node_modules/next/dist/compiled/css-loader/cjs.js??ref--5-oneOf-2-1!../../node_modules/next/dist/compiled/postcss-loader/cjs.js??ref--5-oneOf-2-2!./Loader.module.css */ "./node_modules/next/dist/compiled/css-loader/cjs.js?!./node_modules/next/dist/compiled/postcss-loader/cjs.js?!./theme/Loader/Loader.module.css",
      function () {
        content = __webpack_require__(/*! !../../node_modules/next/dist/compiled/css-loader/cjs.js??ref--5-oneOf-2-1!../../node_modules/next/dist/compiled/postcss-loader/cjs.js??ref--5-oneOf-2-2!./Loader.module.css */ "./node_modules/next/dist/compiled/css-loader/cjs.js?!./node_modules/next/dist/compiled/postcss-loader/cjs.js?!./theme/Loader/Loader.module.css");

              content = content.__esModule ? content.default : content;

              if (typeof content === 'string') {
                content = [[module.i, content, '']];
              }

              if (!isEqualLocals(oldLocals, content.locals)) {
                module.hot.invalidate();

                return;
              }

              oldLocals = content.locals;

              update(content);
      }
    )
  }

  module.hot.dispose(function() {
    update();
  });
}

module.exports = content.locals || {};

/***/ }),

/***/ "./theme/Loader/Loader.tsx":
/*!*********************************!*\
  !*** ./theme/Loader/Loader.tsx ***!
  \*********************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* WEBPACK VAR INJECTION */(function(module, __prefresh_utils__) {/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ "./node_modules/preact/compat/dist/compat.module.js");
/* harmony import */ var _utils_classnames__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @utils/classnames */ "./utils/classnames.tsx");
/* harmony import */ var _Loader_module_css__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Loader.module.css */ "./theme/Loader/Loader.module.css");
/* harmony import */ var _Loader_module_css__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_Loader_module_css__WEBPACK_IMPORTED_MODULE_2__);
var _jsxFileName = "C:\\Users\\admin\\Documents\\Dev\\PWAdvent\\theme\\Loader\\Loader.tsx",
    _this = undefined;

var __jsx = react__WEBPACK_IMPORTED_MODULE_0__["default"].createElement;




var Loader = function Loader(_ref) {
  var _ref$className = _ref.className,
      className = _ref$className === void 0 ? '' : _ref$className;
  return __jsx("div", {
    className: Object(_utils_classnames__WEBPACK_IMPORTED_MODULE_1__["default"])(_Loader_module_css__WEBPACK_IMPORTED_MODULE_2___default.a.root, className),
    __self: _this,
    __source: {
      fileName: _jsxFileName,
      lineNumber: 6,
      columnNumber: 3
    }
  });
};

_c = Loader;
/* harmony default export */ __webpack_exports__["default"] = (Loader);

var _c;

$RefreshReg$(_c, "Loader");

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.i);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }


const isPrefreshComponent = __prefresh_utils__.shouldBind(module);

  if (true) {
    const currentExports = __prefresh_utils__.getExports(module);
    const previousHotModuleExports =
      module.hot.data && module.hot.data.moduleExports;

    __prefresh_utils__.registerExports(currentExports, module.i);

    if (isPrefreshComponent) {
      if (previousHotModuleExports) {
        try {
          __prefresh_utils__.flush();
          if (
            typeof __prefresh_errors__ !== 'undefined' &&
            __prefresh_errors__ &&
            __prefresh_errors__.clearRuntimeErrors
          ) {
            __prefresh_errors__.clearRuntimeErrors();
          }
        } catch (e) {
          // Only available in newer webpack versions.
          if (module.hot.invalidate) {
            module.hot.invalidate();
          } else {
            self.location.reload();
          }
        }
      }

      module.hot.dispose(data => {
        data.moduleExports = __prefresh_utils__.getExports(module);
      });

      module.hot.accept(function errorRecovery() {
        if (
          typeof __prefresh_errors__ !== 'undefined' &&
          __prefresh_errors__ &&
          __prefresh_errors__.handleRuntimeError
        ) {
          __prefresh_errors__.handleRuntimeError(error);
        }

        __webpack_require__.c[module.i].hot.accept(errorRecovery);
      });
    }
  }
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../node_modules/next/dist/compiled/webpack/harmony-module.js */ "./node_modules/next/dist/compiled/webpack/harmony-module.js")(module), __webpack_require__(/*! ./node_modules/@prefresh/webpack/src/utils/prefresh.js */ "./node_modules/@prefresh/webpack/src/utils/prefresh.js")))

/***/ }),

/***/ "./theme/Logo/Logo.module.css":
/*!************************************!*\
  !*** ./theme/Logo/Logo.module.css ***!
  \************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var api = __webpack_require__(/*! ../../node_modules/next/dist/build/webpack/loaders/next-style-loader/runtime/injectStylesIntoStyleTag.js */ "./node_modules/next/dist/build/webpack/loaders/next-style-loader/runtime/injectStylesIntoStyleTag.js");
            var content = __webpack_require__(/*! !../../node_modules/next/dist/compiled/css-loader/cjs.js??ref--5-oneOf-2-1!../../node_modules/next/dist/compiled/postcss-loader/cjs.js??ref--5-oneOf-2-2!./Logo.module.css */ "./node_modules/next/dist/compiled/css-loader/cjs.js?!./node_modules/next/dist/compiled/postcss-loader/cjs.js?!./theme/Logo/Logo.module.css");

            content = content.__esModule ? content.default : content;

            if (typeof content === 'string') {
              content = [[module.i, content, '']];
            }

var options = {};

options.insert = function(element){// These elements should always exist. If they do not,
// this code should fail.
var anchorElement=document.querySelector('#__next_css__DO_NOT_USE__');var parentNode=anchorElement.parentNode;// Normally <head>
// Each style tag should be placed right before our
// anchor. By inserting before and not after, we do not
// need to track the last inserted element.
parentNode.insertBefore(element,anchorElement);};
options.singleton = false;

var update = api(content, options);


if (true) {
  if (!content.locals || module.hot.invalidate) {
    var isEqualLocals = function isEqualLocals(a,b,isNamedExport){if(!a&&b||a&&!b){return false;}let p;for(p in a){if(isNamedExport&&p==='default'){// eslint-disable-next-line no-continue
continue;}if(a[p]!==b[p]){return false;}}for(p in b){if(isNamedExport&&p==='default'){// eslint-disable-next-line no-continue
continue;}if(!a[p]){return false;}}return true;};
    var oldLocals = content.locals;

    module.hot.accept(
      /*! !../../node_modules/next/dist/compiled/css-loader/cjs.js??ref--5-oneOf-2-1!../../node_modules/next/dist/compiled/postcss-loader/cjs.js??ref--5-oneOf-2-2!./Logo.module.css */ "./node_modules/next/dist/compiled/css-loader/cjs.js?!./node_modules/next/dist/compiled/postcss-loader/cjs.js?!./theme/Logo/Logo.module.css",
      function () {
        content = __webpack_require__(/*! !../../node_modules/next/dist/compiled/css-loader/cjs.js??ref--5-oneOf-2-1!../../node_modules/next/dist/compiled/postcss-loader/cjs.js??ref--5-oneOf-2-2!./Logo.module.css */ "./node_modules/next/dist/compiled/css-loader/cjs.js?!./node_modules/next/dist/compiled/postcss-loader/cjs.js?!./theme/Logo/Logo.module.css");

              content = content.__esModule ? content.default : content;

              if (typeof content === 'string') {
                content = [[module.i, content, '']];
              }

              if (!isEqualLocals(oldLocals, content.locals)) {
                module.hot.invalidate();

                return;
              }

              oldLocals = content.locals;

              update(content);
      }
    )
  }

  module.hot.dispose(function() {
    update();
  });
}

module.exports = content.locals || {};

/***/ }),

/***/ "./theme/Logo/Logo.tsx":
/*!*****************************!*\
  !*** ./theme/Logo/Logo.tsx ***!
  \*****************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* WEBPACK VAR INJECTION */(function(module, __prefresh_utils__) {/* harmony import */ var C_Users_admin_Documents_Dev_PWAdvent_node_modules_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./node_modules/@babel/runtime/helpers/esm/extends */ "./node_modules/@babel/runtime/helpers/esm/extends.js");
/* harmony import */ var C_Users_admin_Documents_Dev_PWAdvent_node_modules_babel_runtime_helpers_esm_objectWithoutProperties__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./node_modules/@babel/runtime/helpers/esm/objectWithoutProperties */ "./node_modules/@babel/runtime/helpers/esm/objectWithoutProperties.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! react */ "./node_modules/preact/compat/dist/compat.module.js");
/* harmony import */ var _theme__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @theme */ "./theme/index.ts");
/* harmony import */ var _utils_classnames__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @utils/classnames */ "./utils/classnames.tsx");
/* harmony import */ var _Logo_module_css__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./Logo.module.css */ "./theme/Logo/Logo.module.css");
/* harmony import */ var _Logo_module_css__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(_Logo_module_css__WEBPACK_IMPORTED_MODULE_5__);



var _jsxFileName = "C:\\Users\\admin\\Documents\\Dev\\PWAdvent\\theme\\Logo\\Logo.tsx",
    _this = undefined;

var __jsx = react__WEBPACK_IMPORTED_MODULE_2__["default"].createElement;





var Logo = function Logo(_ref) {
  var _ref$className = _ref.className,
      className = _ref$className === void 0 ? '' : _ref$className,
      title = _ref.title,
      alt = _ref.alt,
      _ref$sameheight = _ref.sameheight,
      sameheight = _ref$sameheight === void 0 ? false : _ref$sameheight,
      props = Object(C_Users_admin_Documents_Dev_PWAdvent_node_modules_babel_runtime_helpers_esm_objectWithoutProperties__WEBPACK_IMPORTED_MODULE_1__["default"])(_ref, ["className", "title", "alt", "sameheight"]);

  return __jsx(_theme__WEBPACK_IMPORTED_MODULE_3__["SVG"], Object(C_Users_admin_Documents_Dev_PWAdvent_node_modules_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__["default"])({
    className: Object(_utils_classnames__WEBPACK_IMPORTED_MODULE_4__["default"])(className, _Logo_module_css__WEBPACK_IMPORTED_MODULE_5___default.a.root),
    path: sameheight ? "icon/pwadvent-logo-sameheight.svg" : "icon/pwadvent-logo.svg",
    title: title,
    alt: alt
  }, props, {
    __self: _this,
    __source: {
      fileName: _jsxFileName,
      lineNumber: 19,
      columnNumber: 3
    }
  }));
};

_c = Logo;
/* harmony default export */ __webpack_exports__["default"] = (Logo);

var _c;

$RefreshReg$(_c, "Logo");

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.i);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }


const isPrefreshComponent = __prefresh_utils__.shouldBind(module);

  if (true) {
    const currentExports = __prefresh_utils__.getExports(module);
    const previousHotModuleExports =
      module.hot.data && module.hot.data.moduleExports;

    __prefresh_utils__.registerExports(currentExports, module.i);

    if (isPrefreshComponent) {
      if (previousHotModuleExports) {
        try {
          __prefresh_utils__.flush();
          if (
            typeof __prefresh_errors__ !== 'undefined' &&
            __prefresh_errors__ &&
            __prefresh_errors__.clearRuntimeErrors
          ) {
            __prefresh_errors__.clearRuntimeErrors();
          }
        } catch (e) {
          // Only available in newer webpack versions.
          if (module.hot.invalidate) {
            module.hot.invalidate();
          } else {
            self.location.reload();
          }
        }
      }

      module.hot.dispose(data => {
        data.moduleExports = __prefresh_utils__.getExports(module);
      });

      module.hot.accept(function errorRecovery() {
        if (
          typeof __prefresh_errors__ !== 'undefined' &&
          __prefresh_errors__ &&
          __prefresh_errors__.handleRuntimeError
        ) {
          __prefresh_errors__.handleRuntimeError(error);
        }

        __webpack_require__.c[module.i].hot.accept(errorRecovery);
      });
    }
  }
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../node_modules/next/dist/compiled/webpack/harmony-module.js */ "./node_modules/next/dist/compiled/webpack/harmony-module.js")(module), __webpack_require__(/*! ./node_modules/@prefresh/webpack/src/utils/prefresh.js */ "./node_modules/@prefresh/webpack/src/utils/prefresh.js")))

/***/ }),

/***/ "./theme/Misc/Notification.module.css":
/*!********************************************!*\
  !*** ./theme/Misc/Notification.module.css ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var api = __webpack_require__(/*! ../../node_modules/next/dist/build/webpack/loaders/next-style-loader/runtime/injectStylesIntoStyleTag.js */ "./node_modules/next/dist/build/webpack/loaders/next-style-loader/runtime/injectStylesIntoStyleTag.js");
            var content = __webpack_require__(/*! !../../node_modules/next/dist/compiled/css-loader/cjs.js??ref--5-oneOf-2-1!../../node_modules/next/dist/compiled/postcss-loader/cjs.js??ref--5-oneOf-2-2!./Notification.module.css */ "./node_modules/next/dist/compiled/css-loader/cjs.js?!./node_modules/next/dist/compiled/postcss-loader/cjs.js?!./theme/Misc/Notification.module.css");

            content = content.__esModule ? content.default : content;

            if (typeof content === 'string') {
              content = [[module.i, content, '']];
            }

var options = {};

options.insert = function(element){// These elements should always exist. If they do not,
// this code should fail.
var anchorElement=document.querySelector('#__next_css__DO_NOT_USE__');var parentNode=anchorElement.parentNode;// Normally <head>
// Each style tag should be placed right before our
// anchor. By inserting before and not after, we do not
// need to track the last inserted element.
parentNode.insertBefore(element,anchorElement);};
options.singleton = false;

var update = api(content, options);


if (true) {
  if (!content.locals || module.hot.invalidate) {
    var isEqualLocals = function isEqualLocals(a,b,isNamedExport){if(!a&&b||a&&!b){return false;}let p;for(p in a){if(isNamedExport&&p==='default'){// eslint-disable-next-line no-continue
continue;}if(a[p]!==b[p]){return false;}}for(p in b){if(isNamedExport&&p==='default'){// eslint-disable-next-line no-continue
continue;}if(!a[p]){return false;}}return true;};
    var oldLocals = content.locals;

    module.hot.accept(
      /*! !../../node_modules/next/dist/compiled/css-loader/cjs.js??ref--5-oneOf-2-1!../../node_modules/next/dist/compiled/postcss-loader/cjs.js??ref--5-oneOf-2-2!./Notification.module.css */ "./node_modules/next/dist/compiled/css-loader/cjs.js?!./node_modules/next/dist/compiled/postcss-loader/cjs.js?!./theme/Misc/Notification.module.css",
      function () {
        content = __webpack_require__(/*! !../../node_modules/next/dist/compiled/css-loader/cjs.js??ref--5-oneOf-2-1!../../node_modules/next/dist/compiled/postcss-loader/cjs.js??ref--5-oneOf-2-2!./Notification.module.css */ "./node_modules/next/dist/compiled/css-loader/cjs.js?!./node_modules/next/dist/compiled/postcss-loader/cjs.js?!./theme/Misc/Notification.module.css");

              content = content.__esModule ? content.default : content;

              if (typeof content === 'string') {
                content = [[module.i, content, '']];
              }

              if (!isEqualLocals(oldLocals, content.locals)) {
                module.hot.invalidate();

                return;
              }

              oldLocals = content.locals;

              update(content);
      }
    )
  }

  module.hot.dispose(function() {
    update();
  });
}

module.exports = content.locals || {};

/***/ }),

/***/ "./theme/Misc/Notification.tsx":
/*!*************************************!*\
  !*** ./theme/Misc/Notification.tsx ***!
  \*************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* WEBPACK VAR INJECTION */(function(module, __prefresh_utils__) {/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ "./node_modules/preact/compat/dist/compat.module.js");
/* harmony import */ var _utils_classnames__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @utils/classnames */ "./utils/classnames.tsx");
/* harmony import */ var _Notification_module_css__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Notification.module.css */ "./theme/Misc/Notification.module.css");
/* harmony import */ var _Notification_module_css__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_Notification_module_css__WEBPACK_IMPORTED_MODULE_2__);
var _jsxFileName = "C:\\Users\\admin\\Documents\\Dev\\PWAdvent\\theme\\Misc\\Notification.tsx",
    _this = undefined;

var __jsx = react__WEBPACK_IMPORTED_MODULE_0__["default"].createElement;




var Notification = function Notification(_ref) {
  var _ref$className = _ref.className,
      className = _ref$className === void 0 ? '' : _ref$className,
      _ref$type = _ref.type,
      type = _ref$type === void 0 ? 'message' : _ref$type,
      children = _ref.children;
  return __jsx("div", {
    className: Object(_utils_classnames__WEBPACK_IMPORTED_MODULE_1__["default"])(className, _Notification_module_css__WEBPACK_IMPORTED_MODULE_2___default.a.root, _Notification_module_css__WEBPACK_IMPORTED_MODULE_2___default.a["type-".concat(type)]),
    __self: _this,
    __source: {
      fileName: _jsxFileName,
      lineNumber: 14,
      columnNumber: 3
    }
  }, __jsx("p", {
    className: _Notification_module_css__WEBPACK_IMPORTED_MODULE_2___default.a.text,
    __self: _this,
    __source: {
      fileName: _jsxFileName,
      lineNumber: 15,
      columnNumber: 5
    }
  }, children));
};

_c = Notification;
/* harmony default export */ __webpack_exports__["default"] = (Notification);

var _c;

$RefreshReg$(_c, "Notification");

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.i);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }


const isPrefreshComponent = __prefresh_utils__.shouldBind(module);

  if (true) {
    const currentExports = __prefresh_utils__.getExports(module);
    const previousHotModuleExports =
      module.hot.data && module.hot.data.moduleExports;

    __prefresh_utils__.registerExports(currentExports, module.i);

    if (isPrefreshComponent) {
      if (previousHotModuleExports) {
        try {
          __prefresh_utils__.flush();
          if (
            typeof __prefresh_errors__ !== 'undefined' &&
            __prefresh_errors__ &&
            __prefresh_errors__.clearRuntimeErrors
          ) {
            __prefresh_errors__.clearRuntimeErrors();
          }
        } catch (e) {
          // Only available in newer webpack versions.
          if (module.hot.invalidate) {
            module.hot.invalidate();
          } else {
            self.location.reload();
          }
        }
      }

      module.hot.dispose(data => {
        data.moduleExports = __prefresh_utils__.getExports(module);
      });

      module.hot.accept(function errorRecovery() {
        if (
          typeof __prefresh_errors__ !== 'undefined' &&
          __prefresh_errors__ &&
          __prefresh_errors__.handleRuntimeError
        ) {
          __prefresh_errors__.handleRuntimeError(error);
        }

        __webpack_require__.c[module.i].hot.accept(errorRecovery);
      });
    }
  }
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../node_modules/next/dist/compiled/webpack/harmony-module.js */ "./node_modules/next/dist/compiled/webpack/harmony-module.js")(module), __webpack_require__(/*! ./node_modules/@prefresh/webpack/src/utils/prefresh.js */ "./node_modules/@prefresh/webpack/src/utils/prefresh.js")))

/***/ }),

/***/ "./theme/Misc/Snow.module.css":
/*!************************************!*\
  !*** ./theme/Misc/Snow.module.css ***!
  \************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var api = __webpack_require__(/*! ../../node_modules/next/dist/build/webpack/loaders/next-style-loader/runtime/injectStylesIntoStyleTag.js */ "./node_modules/next/dist/build/webpack/loaders/next-style-loader/runtime/injectStylesIntoStyleTag.js");
            var content = __webpack_require__(/*! !../../node_modules/next/dist/compiled/css-loader/cjs.js??ref--5-oneOf-2-1!../../node_modules/next/dist/compiled/postcss-loader/cjs.js??ref--5-oneOf-2-2!./Snow.module.css */ "./node_modules/next/dist/compiled/css-loader/cjs.js?!./node_modules/next/dist/compiled/postcss-loader/cjs.js?!./theme/Misc/Snow.module.css");

            content = content.__esModule ? content.default : content;

            if (typeof content === 'string') {
              content = [[module.i, content, '']];
            }

var options = {};

options.insert = function(element){// These elements should always exist. If they do not,
// this code should fail.
var anchorElement=document.querySelector('#__next_css__DO_NOT_USE__');var parentNode=anchorElement.parentNode;// Normally <head>
// Each style tag should be placed right before our
// anchor. By inserting before and not after, we do not
// need to track the last inserted element.
parentNode.insertBefore(element,anchorElement);};
options.singleton = false;

var update = api(content, options);


if (true) {
  if (!content.locals || module.hot.invalidate) {
    var isEqualLocals = function isEqualLocals(a,b,isNamedExport){if(!a&&b||a&&!b){return false;}let p;for(p in a){if(isNamedExport&&p==='default'){// eslint-disable-next-line no-continue
continue;}if(a[p]!==b[p]){return false;}}for(p in b){if(isNamedExport&&p==='default'){// eslint-disable-next-line no-continue
continue;}if(!a[p]){return false;}}return true;};
    var oldLocals = content.locals;

    module.hot.accept(
      /*! !../../node_modules/next/dist/compiled/css-loader/cjs.js??ref--5-oneOf-2-1!../../node_modules/next/dist/compiled/postcss-loader/cjs.js??ref--5-oneOf-2-2!./Snow.module.css */ "./node_modules/next/dist/compiled/css-loader/cjs.js?!./node_modules/next/dist/compiled/postcss-loader/cjs.js?!./theme/Misc/Snow.module.css",
      function () {
        content = __webpack_require__(/*! !../../node_modules/next/dist/compiled/css-loader/cjs.js??ref--5-oneOf-2-1!../../node_modules/next/dist/compiled/postcss-loader/cjs.js??ref--5-oneOf-2-2!./Snow.module.css */ "./node_modules/next/dist/compiled/css-loader/cjs.js?!./node_modules/next/dist/compiled/postcss-loader/cjs.js?!./theme/Misc/Snow.module.css");

              content = content.__esModule ? content.default : content;

              if (typeof content === 'string') {
                content = [[module.i, content, '']];
              }

              if (!isEqualLocals(oldLocals, content.locals)) {
                module.hot.invalidate();

                return;
              }

              oldLocals = content.locals;

              update(content);
      }
    )
  }

  module.hot.dispose(function() {
    update();
  });
}

module.exports = content.locals || {};

/***/ }),

/***/ "./theme/Misc/Snow.tsx":
/*!*****************************!*\
  !*** ./theme/Misc/Snow.tsx ***!
  \*****************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* WEBPACK VAR INJECTION */(function(module, __prefresh_utils__) {/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ "./node_modules/preact/compat/dist/compat.module.js");
/* harmony import */ var _utils_classnames__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @utils/classnames */ "./utils/classnames.tsx");
/* harmony import */ var _Snow_module_css__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Snow.module.css */ "./theme/Misc/Snow.module.css");
/* harmony import */ var _Snow_module_css__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_Snow_module_css__WEBPACK_IMPORTED_MODULE_2__);
var _jsxFileName = "C:\\Users\\admin\\Documents\\Dev\\PWAdvent\\theme\\Misc\\Snow.tsx",
    _this = undefined;

var __jsx = react__WEBPACK_IMPORTED_MODULE_0__["default"].createElement;




var Snow = function Snow(_ref) {
  var _ref$className = _ref.className,
      className = _ref$className === void 0 ? '' : _ref$className;
  return __jsx("div", {
    className: Object(_utils_classnames__WEBPACK_IMPORTED_MODULE_1__["default"])(className, _Snow_module_css__WEBPACK_IMPORTED_MODULE_2___default.a.root),
    __self: _this,
    __source: {
      fileName: _jsxFileName,
      lineNumber: 6,
      columnNumber: 3
    }
  }, ['near', 'mid', 'far'].map(function (position) {
    return __jsx(react__WEBPACK_IMPORTED_MODULE_0__["default"].Fragment, {
      key: position,
      __self: _this,
      __source: {
        fileName: _jsxFileName,
        lineNumber: 8,
        columnNumber: 7
      }
    }, __jsx("div", {
      className: Object(_utils_classnames__WEBPACK_IMPORTED_MODULE_1__["default"])(_Snow_module_css__WEBPACK_IMPORTED_MODULE_2___default.a.level, _Snow_module_css__WEBPACK_IMPORTED_MODULE_2___default.a["position-".concat(position)]),
      __self: _this,
      __source: {
        fileName: _jsxFileName,
        lineNumber: 9,
        columnNumber: 9
      }
    }), __jsx("div", {
      className: Object(_utils_classnames__WEBPACK_IMPORTED_MODULE_1__["default"])(_Snow_module_css__WEBPACK_IMPORTED_MODULE_2___default.a.level, _Snow_module_css__WEBPACK_IMPORTED_MODULE_2___default.a["position-".concat(position)], _Snow_module_css__WEBPACK_IMPORTED_MODULE_2___default.a.levelAlt),
      __self: _this,
      __source: {
        fileName: _jsxFileName,
        lineNumber: 10,
        columnNumber: 9
      }
    }));
  }));
};

_c = Snow;
/* harmony default export */ __webpack_exports__["default"] = (Snow);

var _c;

$RefreshReg$(_c, "Snow");

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.i);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }


const isPrefreshComponent = __prefresh_utils__.shouldBind(module);

  if (true) {
    const currentExports = __prefresh_utils__.getExports(module);
    const previousHotModuleExports =
      module.hot.data && module.hot.data.moduleExports;

    __prefresh_utils__.registerExports(currentExports, module.i);

    if (isPrefreshComponent) {
      if (previousHotModuleExports) {
        try {
          __prefresh_utils__.flush();
          if (
            typeof __prefresh_errors__ !== 'undefined' &&
            __prefresh_errors__ &&
            __prefresh_errors__.clearRuntimeErrors
          ) {
            __prefresh_errors__.clearRuntimeErrors();
          }
        } catch (e) {
          // Only available in newer webpack versions.
          if (module.hot.invalidate) {
            module.hot.invalidate();
          } else {
            self.location.reload();
          }
        }
      }

      module.hot.dispose(data => {
        data.moduleExports = __prefresh_utils__.getExports(module);
      });

      module.hot.accept(function errorRecovery() {
        if (
          typeof __prefresh_errors__ !== 'undefined' &&
          __prefresh_errors__ &&
          __prefresh_errors__.handleRuntimeError
        ) {
          __prefresh_errors__.handleRuntimeError(error);
        }

        __webpack_require__.c[module.i].hot.accept(errorRecovery);
      });
    }
  }
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../node_modules/next/dist/compiled/webpack/harmony-module.js */ "./node_modules/next/dist/compiled/webpack/harmony-module.js")(module), __webpack_require__(/*! ./node_modules/@prefresh/webpack/src/utils/prefresh.js */ "./node_modules/@prefresh/webpack/src/utils/prefresh.js")))

/***/ }),

/***/ "./theme/SVG/Icon.module.css":
/*!***********************************!*\
  !*** ./theme/SVG/Icon.module.css ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var api = __webpack_require__(/*! ../../node_modules/next/dist/build/webpack/loaders/next-style-loader/runtime/injectStylesIntoStyleTag.js */ "./node_modules/next/dist/build/webpack/loaders/next-style-loader/runtime/injectStylesIntoStyleTag.js");
            var content = __webpack_require__(/*! !../../node_modules/next/dist/compiled/css-loader/cjs.js??ref--5-oneOf-2-1!../../node_modules/next/dist/compiled/postcss-loader/cjs.js??ref--5-oneOf-2-2!./Icon.module.css */ "./node_modules/next/dist/compiled/css-loader/cjs.js?!./node_modules/next/dist/compiled/postcss-loader/cjs.js?!./theme/SVG/Icon.module.css");

            content = content.__esModule ? content.default : content;

            if (typeof content === 'string') {
              content = [[module.i, content, '']];
            }

var options = {};

options.insert = function(element){// These elements should always exist. If they do not,
// this code should fail.
var anchorElement=document.querySelector('#__next_css__DO_NOT_USE__');var parentNode=anchorElement.parentNode;// Normally <head>
// Each style tag should be placed right before our
// anchor. By inserting before and not after, we do not
// need to track the last inserted element.
parentNode.insertBefore(element,anchorElement);};
options.singleton = false;

var update = api(content, options);


if (true) {
  if (!content.locals || module.hot.invalidate) {
    var isEqualLocals = function isEqualLocals(a,b,isNamedExport){if(!a&&b||a&&!b){return false;}let p;for(p in a){if(isNamedExport&&p==='default'){// eslint-disable-next-line no-continue
continue;}if(a[p]!==b[p]){return false;}}for(p in b){if(isNamedExport&&p==='default'){// eslint-disable-next-line no-continue
continue;}if(!a[p]){return false;}}return true;};
    var oldLocals = content.locals;

    module.hot.accept(
      /*! !../../node_modules/next/dist/compiled/css-loader/cjs.js??ref--5-oneOf-2-1!../../node_modules/next/dist/compiled/postcss-loader/cjs.js??ref--5-oneOf-2-2!./Icon.module.css */ "./node_modules/next/dist/compiled/css-loader/cjs.js?!./node_modules/next/dist/compiled/postcss-loader/cjs.js?!./theme/SVG/Icon.module.css",
      function () {
        content = __webpack_require__(/*! !../../node_modules/next/dist/compiled/css-loader/cjs.js??ref--5-oneOf-2-1!../../node_modules/next/dist/compiled/postcss-loader/cjs.js??ref--5-oneOf-2-2!./Icon.module.css */ "./node_modules/next/dist/compiled/css-loader/cjs.js?!./node_modules/next/dist/compiled/postcss-loader/cjs.js?!./theme/SVG/Icon.module.css");

              content = content.__esModule ? content.default : content;

              if (typeof content === 'string') {
                content = [[module.i, content, '']];
              }

              if (!isEqualLocals(oldLocals, content.locals)) {
                module.hot.invalidate();

                return;
              }

              oldLocals = content.locals;

              update(content);
      }
    )
  }

  module.hot.dispose(function() {
    update();
  });
}

module.exports = content.locals || {};

/***/ }),

/***/ "./theme/SVG/Icon.tsx":
/*!****************************!*\
  !*** ./theme/SVG/Icon.tsx ***!
  \****************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* WEBPACK VAR INJECTION */(function(module, __prefresh_utils__) {/* harmony import */ var C_Users_admin_Documents_Dev_PWAdvent_node_modules_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./node_modules/@babel/runtime/helpers/esm/extends */ "./node_modules/@babel/runtime/helpers/esm/extends.js");
/* harmony import */ var C_Users_admin_Documents_Dev_PWAdvent_node_modules_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./node_modules/@babel/runtime/helpers/esm/defineProperty */ "./node_modules/@babel/runtime/helpers/esm/defineProperty.js");
/* harmony import */ var C_Users_admin_Documents_Dev_PWAdvent_node_modules_babel_runtime_helpers_esm_objectWithoutProperties__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./node_modules/@babel/runtime/helpers/esm/objectWithoutProperties */ "./node_modules/@babel/runtime/helpers/esm/objectWithoutProperties.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! react */ "./node_modules/preact/compat/dist/compat.module.js");
/* harmony import */ var _utils_classnames__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @utils/classnames */ "./utils/classnames.tsx");
/* harmony import */ var _Icon_module_css__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./Icon.module.css */ "./theme/SVG/Icon.module.css");
/* harmony import */ var _Icon_module_css__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(_Icon_module_css__WEBPACK_IMPORTED_MODULE_5__);
/* harmony import */ var _SVG__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./SVG */ "./theme/SVG/SVG.tsx");




var _jsxFileName = "C:\\Users\\admin\\Documents\\Dev\\PWAdvent\\theme\\SVG\\Icon.tsx",
    _this = undefined;

var __jsx = react__WEBPACK_IMPORTED_MODULE_3__["default"].createElement;





var Icon = function Icon(_ref) {
  var _cn;

  var icon = _ref.icon,
      _ref$className = _ref.className,
      className = _ref$className === void 0 ? '' : _ref$className,
      _ref$spinning = _ref.spinning,
      spinning = _ref$spinning === void 0 ? false : _ref$spinning,
      _ref$rotate = _ref.rotate,
      rotate = _ref$rotate === void 0 ? false : _ref$rotate,
      _ref$button = _ref.button,
      button = _ref$button === void 0 ? false : _ref$button,
      _ref$round = _ref.round,
      round = _ref$round === void 0 ? false : _ref$round,
      _ref$circle = _ref.circle,
      circle = _ref$circle === void 0 ? false : _ref$circle,
      props = Object(C_Users_admin_Documents_Dev_PWAdvent_node_modules_babel_runtime_helpers_esm_objectWithoutProperties__WEBPACK_IMPORTED_MODULE_2__["default"])(_ref, ["icon", "className", "spinning", "rotate", "button", "round", "circle"]);

  return __jsx(_SVG__WEBPACK_IMPORTED_MODULE_6__["default"], Object(C_Users_admin_Documents_Dev_PWAdvent_node_modules_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__["default"])({
    className: Object(_utils_classnames__WEBPACK_IMPORTED_MODULE_4__["default"])(className, _Icon_module_css__WEBPACK_IMPORTED_MODULE_5___default.a.root, (_cn = {}, Object(C_Users_admin_Documents_Dev_PWAdvent_node_modules_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_1__["default"])(_cn, _Icon_module_css__WEBPACK_IMPORTED_MODULE_5___default.a["rotate-".concat(rotate)], rotate !== false), Object(C_Users_admin_Documents_Dev_PWAdvent_node_modules_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_1__["default"])(_cn, _Icon_module_css__WEBPACK_IMPORTED_MODULE_5___default.a.animationSpin, spinning), Object(C_Users_admin_Documents_Dev_PWAdvent_node_modules_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_1__["default"])(_cn, _Icon_module_css__WEBPACK_IMPORTED_MODULE_5___default.a.isRound, round), Object(C_Users_admin_Documents_Dev_PWAdvent_node_modules_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_1__["default"])(_cn, _Icon_module_css__WEBPACK_IMPORTED_MODULE_5___default.a.circle, circle), _cn)),
    path: "icon/".concat(icon, ".svg")
  }, props, {
    __self: _this,
    __source: {
      fileName: _jsxFileName,
      lineNumber: 26,
      columnNumber: 5
    }
  }));
};

_c = Icon;
/* harmony default export */ __webpack_exports__["default"] = (Icon);

var _c;

$RefreshReg$(_c, "Icon");

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.i);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }


const isPrefreshComponent = __prefresh_utils__.shouldBind(module);

  if (true) {
    const currentExports = __prefresh_utils__.getExports(module);
    const previousHotModuleExports =
      module.hot.data && module.hot.data.moduleExports;

    __prefresh_utils__.registerExports(currentExports, module.i);

    if (isPrefreshComponent) {
      if (previousHotModuleExports) {
        try {
          __prefresh_utils__.flush();
          if (
            typeof __prefresh_errors__ !== 'undefined' &&
            __prefresh_errors__ &&
            __prefresh_errors__.clearRuntimeErrors
          ) {
            __prefresh_errors__.clearRuntimeErrors();
          }
        } catch (e) {
          // Only available in newer webpack versions.
          if (module.hot.invalidate) {
            module.hot.invalidate();
          } else {
            self.location.reload();
          }
        }
      }

      module.hot.dispose(data => {
        data.moduleExports = __prefresh_utils__.getExports(module);
      });

      module.hot.accept(function errorRecovery() {
        if (
          typeof __prefresh_errors__ !== 'undefined' &&
          __prefresh_errors__ &&
          __prefresh_errors__.handleRuntimeError
        ) {
          __prefresh_errors__.handleRuntimeError(error);
        }

        __webpack_require__.c[module.i].hot.accept(errorRecovery);
      });
    }
  }
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../node_modules/next/dist/compiled/webpack/harmony-module.js */ "./node_modules/next/dist/compiled/webpack/harmony-module.js")(module), __webpack_require__(/*! ./node_modules/@prefresh/webpack/src/utils/prefresh.js */ "./node_modules/@prefresh/webpack/src/utils/prefresh.js")))

/***/ }),

/***/ "./theme/SVG/SVG.module.css":
/*!**********************************!*\
  !*** ./theme/SVG/SVG.module.css ***!
  \**********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var api = __webpack_require__(/*! ../../node_modules/next/dist/build/webpack/loaders/next-style-loader/runtime/injectStylesIntoStyleTag.js */ "./node_modules/next/dist/build/webpack/loaders/next-style-loader/runtime/injectStylesIntoStyleTag.js");
            var content = __webpack_require__(/*! !../../node_modules/next/dist/compiled/css-loader/cjs.js??ref--5-oneOf-2-1!../../node_modules/next/dist/compiled/postcss-loader/cjs.js??ref--5-oneOf-2-2!./SVG.module.css */ "./node_modules/next/dist/compiled/css-loader/cjs.js?!./node_modules/next/dist/compiled/postcss-loader/cjs.js?!./theme/SVG/SVG.module.css");

            content = content.__esModule ? content.default : content;

            if (typeof content === 'string') {
              content = [[module.i, content, '']];
            }

var options = {};

options.insert = function(element){// These elements should always exist. If they do not,
// this code should fail.
var anchorElement=document.querySelector('#__next_css__DO_NOT_USE__');var parentNode=anchorElement.parentNode;// Normally <head>
// Each style tag should be placed right before our
// anchor. By inserting before and not after, we do not
// need to track the last inserted element.
parentNode.insertBefore(element,anchorElement);};
options.singleton = false;

var update = api(content, options);


if (true) {
  if (!content.locals || module.hot.invalidate) {
    var isEqualLocals = function isEqualLocals(a,b,isNamedExport){if(!a&&b||a&&!b){return false;}let p;for(p in a){if(isNamedExport&&p==='default'){// eslint-disable-next-line no-continue
continue;}if(a[p]!==b[p]){return false;}}for(p in b){if(isNamedExport&&p==='default'){// eslint-disable-next-line no-continue
continue;}if(!a[p]){return false;}}return true;};
    var oldLocals = content.locals;

    module.hot.accept(
      /*! !../../node_modules/next/dist/compiled/css-loader/cjs.js??ref--5-oneOf-2-1!../../node_modules/next/dist/compiled/postcss-loader/cjs.js??ref--5-oneOf-2-2!./SVG.module.css */ "./node_modules/next/dist/compiled/css-loader/cjs.js?!./node_modules/next/dist/compiled/postcss-loader/cjs.js?!./theme/SVG/SVG.module.css",
      function () {
        content = __webpack_require__(/*! !../../node_modules/next/dist/compiled/css-loader/cjs.js??ref--5-oneOf-2-1!../../node_modules/next/dist/compiled/postcss-loader/cjs.js??ref--5-oneOf-2-2!./SVG.module.css */ "./node_modules/next/dist/compiled/css-loader/cjs.js?!./node_modules/next/dist/compiled/postcss-loader/cjs.js?!./theme/SVG/SVG.module.css");

              content = content.__esModule ? content.default : content;

              if (typeof content === 'string') {
                content = [[module.i, content, '']];
              }

              if (!isEqualLocals(oldLocals, content.locals)) {
                module.hot.invalidate();

                return;
              }

              oldLocals = content.locals;

              update(content);
      }
    )
  }

  module.hot.dispose(function() {
    update();
  });
}

module.exports = content.locals || {};

/***/ }),

/***/ "./theme/SVG/SVG.tsx":
/*!***************************!*\
  !*** ./theme/SVG/SVG.tsx ***!
  \***************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* WEBPACK VAR INJECTION */(function(module, __prefresh_utils__) {/* harmony import */ var C_Users_admin_Documents_Dev_PWAdvent_node_modules_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./node_modules/@babel/runtime/helpers/esm/extends */ "./node_modules/@babel/runtime/helpers/esm/extends.js");
/* harmony import */ var C_Users_admin_Documents_Dev_PWAdvent_node_modules_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./node_modules/@babel/runtime/helpers/esm/defineProperty */ "./node_modules/@babel/runtime/helpers/esm/defineProperty.js");
/* harmony import */ var C_Users_admin_Documents_Dev_PWAdvent_node_modules_babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./node_modules/@babel/runtime/regenerator */ "./node_modules/@babel/runtime/regenerator/index.js");
/* harmony import */ var C_Users_admin_Documents_Dev_PWAdvent_node_modules_babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(C_Users_admin_Documents_Dev_PWAdvent_node_modules_babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var C_Users_admin_Documents_Dev_PWAdvent_node_modules_babel_runtime_helpers_esm_asyncToGenerator__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./node_modules/@babel/runtime/helpers/esm/asyncToGenerator */ "./node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js");
/* harmony import */ var C_Users_admin_Documents_Dev_PWAdvent_node_modules_babel_runtime_helpers_esm_slicedToArray__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./node_modules/@babel/runtime/helpers/esm/slicedToArray */ "./node_modules/@babel/runtime/helpers/esm/slicedToArray.js");
/* harmony import */ var C_Users_admin_Documents_Dev_PWAdvent_node_modules_babel_runtime_helpers_esm_objectWithoutProperties__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./node_modules/@babel/runtime/helpers/esm/objectWithoutProperties */ "./node_modules/@babel/runtime/helpers/esm/objectWithoutProperties.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! react */ "./node_modules/preact/compat/dist/compat.module.js");
/* harmony import */ var _utils_classnames__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @utils/classnames */ "./utils/classnames.tsx");
/* harmony import */ var _SVG_module_css__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./SVG.module.css */ "./theme/SVG/SVG.module.css");
/* harmony import */ var _SVG_module_css__WEBPACK_IMPORTED_MODULE_8___default = /*#__PURE__*/__webpack_require__.n(_SVG_module_css__WEBPACK_IMPORTED_MODULE_8__);







var _jsxFileName = "C:\\Users\\admin\\Documents\\Dev\\PWAdvent\\theme\\SVG\\SVG.tsx",
    _this = undefined,
    _s = $RefreshSig$();

var __jsx = react__WEBPACK_IMPORTED_MODULE_6__["default"].createElement;




var SVG = function SVG(_ref) {
  _s();

  var path = _ref.path,
      _ref$className = _ref.className,
      className = _ref$className === void 0 ? '' : _ref$className,
      _ref$inline = _ref.inline,
      inline = _ref$inline === void 0 ? false : _ref$inline,
      props = Object(C_Users_admin_Documents_Dev_PWAdvent_node_modules_babel_runtime_helpers_esm_objectWithoutProperties__WEBPACK_IMPORTED_MODULE_5__["default"])(_ref, ["path", "className", "inline"]);

  var _React$useState = react__WEBPACK_IMPORTED_MODULE_6__["default"].useState(''),
      _React$useState2 = Object(C_Users_admin_Documents_Dev_PWAdvent_node_modules_babel_runtime_helpers_esm_slicedToArray__WEBPACK_IMPORTED_MODULE_4__["default"])(_React$useState, 2),
      loadedIcon = _React$useState2[0],
      setLoadedIcon = _React$useState2[1];

  react__WEBPACK_IMPORTED_MODULE_6__["default"].useEffect(function () {
    function loadIcon() {
      return _loadIcon.apply(this, arguments);
    }

    function _loadIcon() {
      _loadIcon = Object(C_Users_admin_Documents_Dev_PWAdvent_node_modules_babel_runtime_helpers_esm_asyncToGenerator__WEBPACK_IMPORTED_MODULE_3__["default"])( /*#__PURE__*/C_Users_admin_Documents_Dev_PWAdvent_node_modules_babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_2___default.a.mark(function _callee() {
        return C_Users_admin_Documents_Dev_PWAdvent_node_modules_babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_2___default.a.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                _context.next = 2;
                return __webpack_require__("./public/icon eager recursive ^\\.\\/.*$")("./".concat(path));

              case 2:
                return _context.abrupt("return", _context.sent);

              case 3:
              case "end":
                return _context.stop();
            }
          }
        }, _callee);
      }));
      return _loadIcon.apply(this, arguments);
    }

    loadIcon().then(function (loaded) {
      return setLoadedIcon(loaded["default"]);
    });
  }, [path]);
  return __jsx("figure", Object(C_Users_admin_Documents_Dev_PWAdvent_node_modules_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__["default"])({
    className: Object(_utils_classnames__WEBPACK_IMPORTED_MODULE_7__["default"])(className, _SVG_module_css__WEBPACK_IMPORTED_MODULE_8___default.a.root, Object(C_Users_admin_Documents_Dev_PWAdvent_node_modules_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_1__["default"])({}, _SVG_module_css__WEBPACK_IMPORTED_MODULE_8___default.a.isInline, inline)),
    dangerouslySetInnerHTML: {
      __html: loadedIcon
    }
  }, props, {
    __self: _this,
    __source: {
      fileName: _jsxFileName,
      lineNumber: 28,
      columnNumber: 5
    }
  }));
};

_s(SVG, "sMqLaGCugj3v9IMs+QrLkSP4LPA=");

_c = SVG;
/* harmony default export */ __webpack_exports__["default"] = (SVG);

var _c;

$RefreshReg$(_c, "SVG");

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.i);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }


const isPrefreshComponent = __prefresh_utils__.shouldBind(module);

  if (true) {
    const currentExports = __prefresh_utils__.getExports(module);
    const previousHotModuleExports =
      module.hot.data && module.hot.data.moduleExports;

    __prefresh_utils__.registerExports(currentExports, module.i);

    if (isPrefreshComponent) {
      if (previousHotModuleExports) {
        try {
          __prefresh_utils__.flush();
          if (
            typeof __prefresh_errors__ !== 'undefined' &&
            __prefresh_errors__ &&
            __prefresh_errors__.clearRuntimeErrors
          ) {
            __prefresh_errors__.clearRuntimeErrors();
          }
        } catch (e) {
          // Only available in newer webpack versions.
          if (module.hot.invalidate) {
            module.hot.invalidate();
          } else {
            self.location.reload();
          }
        }
      }

      module.hot.dispose(data => {
        data.moduleExports = __prefresh_utils__.getExports(module);
      });

      module.hot.accept(function errorRecovery() {
        if (
          typeof __prefresh_errors__ !== 'undefined' &&
          __prefresh_errors__ &&
          __prefresh_errors__.handleRuntimeError
        ) {
          __prefresh_errors__.handleRuntimeError(error);
        }

        __webpack_require__.c[module.i].hot.accept(errorRecovery);
      });
    }
  }
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../node_modules/next/dist/compiled/webpack/harmony-module.js */ "./node_modules/next/dist/compiled/webpack/harmony-module.js")(module), __webpack_require__(/*! ./node_modules/@prefresh/webpack/src/utils/prefresh.js */ "./node_modules/@prefresh/webpack/src/utils/prefresh.js")))

/***/ }),

/***/ "./theme/ShadowBox/PortalBox.tsx":
/*!***************************************!*\
  !*** ./theme/ShadowBox/PortalBox.tsx ***!
  \***************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* WEBPACK VAR INJECTION */(function(module, __prefresh_utils__) {/* harmony import */ var C_Users_admin_Documents_Dev_PWAdvent_node_modules_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./node_modules/@babel/runtime/helpers/esm/extends */ "./node_modules/@babel/runtime/helpers/esm/extends.js");
/* harmony import */ var C_Users_admin_Documents_Dev_PWAdvent_node_modules_babel_runtime_helpers_esm_objectWithoutProperties__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./node_modules/@babel/runtime/helpers/esm/objectWithoutProperties */ "./node_modules/@babel/runtime/helpers/esm/objectWithoutProperties.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! react */ "./node_modules/preact/compat/dist/compat.module.js");
/* harmony import */ var _index__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../index */ "./theme/index.ts");



var _jsxFileName = "C:\\Users\\admin\\Documents\\Dev\\PWAdvent\\theme\\ShadowBox\\PortalBox.tsx",
    _this = undefined;

var __jsx = react__WEBPACK_IMPORTED_MODULE_2__["default"].createElement;




var Portal = function Portal(_ref) {
  var children = _ref.children;
  return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_2__["default"].createPortal(children, document.querySelector('#shadowbox'));
};

_c = Portal;
/* harmony default export */ __webpack_exports__["default"] = (function (_ref2) {
  var children = _ref2.children,
      close = _ref2.close,
      size = _ref2.size,
      props = Object(C_Users_admin_Documents_Dev_PWAdvent_node_modules_babel_runtime_helpers_esm_objectWithoutProperties__WEBPACK_IMPORTED_MODULE_1__["default"])(_ref2, ["children", "close", "size"]);

  return __jsx(Portal, {
    __self: _this,
    __source: {
      fileName: _jsxFileName,
      lineNumber: 19,
      columnNumber: 3
    }
  }, __jsx(_index__WEBPACK_IMPORTED_MODULE_3__["ShadowBox"], Object(C_Users_admin_Documents_Dev_PWAdvent_node_modules_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__["default"])({
    children: children,
    close: close,
    size: size
  }, props, {
    __self: _this,
    __source: {
      fileName: _jsxFileName,
      lineNumber: 20,
      columnNumber: 5
    }
  })));
});

var _c;

$RefreshReg$(_c, "Portal");

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.i);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }


const isPrefreshComponent = __prefresh_utils__.shouldBind(module);

  if (true) {
    const currentExports = __prefresh_utils__.getExports(module);
    const previousHotModuleExports =
      module.hot.data && module.hot.data.moduleExports;

    __prefresh_utils__.registerExports(currentExports, module.i);

    if (isPrefreshComponent) {
      if (previousHotModuleExports) {
        try {
          __prefresh_utils__.flush();
          if (
            typeof __prefresh_errors__ !== 'undefined' &&
            __prefresh_errors__ &&
            __prefresh_errors__.clearRuntimeErrors
          ) {
            __prefresh_errors__.clearRuntimeErrors();
          }
        } catch (e) {
          // Only available in newer webpack versions.
          if (module.hot.invalidate) {
            module.hot.invalidate();
          } else {
            self.location.reload();
          }
        }
      }

      module.hot.dispose(data => {
        data.moduleExports = __prefresh_utils__.getExports(module);
      });

      module.hot.accept(function errorRecovery() {
        if (
          typeof __prefresh_errors__ !== 'undefined' &&
          __prefresh_errors__ &&
          __prefresh_errors__.handleRuntimeError
        ) {
          __prefresh_errors__.handleRuntimeError(error);
        }

        __webpack_require__.c[module.i].hot.accept(errorRecovery);
      });
    }
  }
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../node_modules/next/dist/compiled/webpack/harmony-module.js */ "./node_modules/next/dist/compiled/webpack/harmony-module.js")(module), __webpack_require__(/*! ./node_modules/@prefresh/webpack/src/utils/prefresh.js */ "./node_modules/@prefresh/webpack/src/utils/prefresh.js")))

/***/ }),

/***/ "./theme/ShadowBox/ShadowBox.module.css":
/*!**********************************************!*\
  !*** ./theme/ShadowBox/ShadowBox.module.css ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var api = __webpack_require__(/*! ../../node_modules/next/dist/build/webpack/loaders/next-style-loader/runtime/injectStylesIntoStyleTag.js */ "./node_modules/next/dist/build/webpack/loaders/next-style-loader/runtime/injectStylesIntoStyleTag.js");
            var content = __webpack_require__(/*! !../../node_modules/next/dist/compiled/css-loader/cjs.js??ref--5-oneOf-2-1!../../node_modules/next/dist/compiled/postcss-loader/cjs.js??ref--5-oneOf-2-2!./ShadowBox.module.css */ "./node_modules/next/dist/compiled/css-loader/cjs.js?!./node_modules/next/dist/compiled/postcss-loader/cjs.js?!./theme/ShadowBox/ShadowBox.module.css");

            content = content.__esModule ? content.default : content;

            if (typeof content === 'string') {
              content = [[module.i, content, '']];
            }

var options = {};

options.insert = function(element){// These elements should always exist. If they do not,
// this code should fail.
var anchorElement=document.querySelector('#__next_css__DO_NOT_USE__');var parentNode=anchorElement.parentNode;// Normally <head>
// Each style tag should be placed right before our
// anchor. By inserting before and not after, we do not
// need to track the last inserted element.
parentNode.insertBefore(element,anchorElement);};
options.singleton = false;

var update = api(content, options);


if (true) {
  if (!content.locals || module.hot.invalidate) {
    var isEqualLocals = function isEqualLocals(a,b,isNamedExport){if(!a&&b||a&&!b){return false;}let p;for(p in a){if(isNamedExport&&p==='default'){// eslint-disable-next-line no-continue
continue;}if(a[p]!==b[p]){return false;}}for(p in b){if(isNamedExport&&p==='default'){// eslint-disable-next-line no-continue
continue;}if(!a[p]){return false;}}return true;};
    var oldLocals = content.locals;

    module.hot.accept(
      /*! !../../node_modules/next/dist/compiled/css-loader/cjs.js??ref--5-oneOf-2-1!../../node_modules/next/dist/compiled/postcss-loader/cjs.js??ref--5-oneOf-2-2!./ShadowBox.module.css */ "./node_modules/next/dist/compiled/css-loader/cjs.js?!./node_modules/next/dist/compiled/postcss-loader/cjs.js?!./theme/ShadowBox/ShadowBox.module.css",
      function () {
        content = __webpack_require__(/*! !../../node_modules/next/dist/compiled/css-loader/cjs.js??ref--5-oneOf-2-1!../../node_modules/next/dist/compiled/postcss-loader/cjs.js??ref--5-oneOf-2-2!./ShadowBox.module.css */ "./node_modules/next/dist/compiled/css-loader/cjs.js?!./node_modules/next/dist/compiled/postcss-loader/cjs.js?!./theme/ShadowBox/ShadowBox.module.css");

              content = content.__esModule ? content.default : content;

              if (typeof content === 'string') {
                content = [[module.i, content, '']];
              }

              if (!isEqualLocals(oldLocals, content.locals)) {
                module.hot.invalidate();

                return;
              }

              oldLocals = content.locals;

              update(content);
      }
    )
  }

  module.hot.dispose(function() {
    update();
  });
}

module.exports = content.locals || {};

/***/ }),

/***/ "./theme/ShadowBox/ShadowBox.tsx":
/*!***************************************!*\
  !*** ./theme/ShadowBox/ShadowBox.tsx ***!
  \***************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* WEBPACK VAR INJECTION */(function(module, __prefresh_utils__) {/* harmony import */ var C_Users_admin_Documents_Dev_PWAdvent_node_modules_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./node_modules/@babel/runtime/helpers/esm/defineProperty */ "./node_modules/@babel/runtime/helpers/esm/defineProperty.js");
/* harmony import */ var C_Users_admin_Documents_Dev_PWAdvent_node_modules_babel_runtime_helpers_esm_slicedToArray__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./node_modules/@babel/runtime/helpers/esm/slicedToArray */ "./node_modules/@babel/runtime/helpers/esm/slicedToArray.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! react */ "./node_modules/preact/compat/dist/compat.module.js");
/* harmony import */ var _utils_classnames__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @utils/classnames */ "./utils/classnames.tsx");
/* harmony import */ var _utils_helpers__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @utils/helpers */ "./utils/helpers.tsx");
/* harmony import */ var _index__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../index */ "./theme/index.ts");
/* harmony import */ var _ShadowBox_module_css__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./ShadowBox.module.css */ "./theme/ShadowBox/ShadowBox.module.css");
/* harmony import */ var _ShadowBox_module_css__WEBPACK_IMPORTED_MODULE_6___default = /*#__PURE__*/__webpack_require__.n(_ShadowBox_module_css__WEBPACK_IMPORTED_MODULE_6__);



var _jsxFileName = "C:\\Users\\admin\\Documents\\Dev\\PWAdvent\\theme\\ShadowBox\\ShadowBox.tsx",
    _this = undefined,
    _s = $RefreshSig$();

var __jsx = react__WEBPACK_IMPORTED_MODULE_2__["default"].createElement;





/* harmony default export */ __webpack_exports__["default"] = (_s(function (_ref) {
  var _cn;

  _s();

  var title = _ref.title,
      children = _ref.children,
      close = _ref.close,
      _ref$size = _ref.size,
      size = _ref$size === void 0 ? 'large' : _ref$size,
      _ref$className = _ref.className,
      className = _ref$className === void 0 ? '' : _ref$className;

  var _React$useState = react__WEBPACK_IMPORTED_MODULE_2__["default"].useState(false),
      _React$useState2 = Object(C_Users_admin_Documents_Dev_PWAdvent_node_modules_babel_runtime_helpers_esm_slicedToArray__WEBPACK_IMPORTED_MODULE_1__["default"])(_React$useState, 2),
      show = _React$useState2[0],
      setShow = _React$useState2[1];

  var _React$useState3 = react__WEBPACK_IMPORTED_MODULE_2__["default"].useState(false),
      _React$useState4 = Object(C_Users_admin_Documents_Dev_PWAdvent_node_modules_babel_runtime_helpers_esm_slicedToArray__WEBPACK_IMPORTED_MODULE_1__["default"])(_React$useState3, 2),
      shadow = _React$useState4[0],
      setShadow = _React$useState4[1];

  react__WEBPACK_IMPORTED_MODULE_2__["default"].useEffect(function () {
    setShow(true);
    return function () {
      setShow(false);
    };
  }, []);

  var onClose = function onClose() {
    setShow(false);
    window.setTimeout(function () {
      close();
    }, 200);
  };

  return __jsx("div", {
    className: Object(_utils_classnames__WEBPACK_IMPORTED_MODULE_3__["default"])(className, _ShadowBox_module_css__WEBPACK_IMPORTED_MODULE_6___default.a.root, _ShadowBox_module_css__WEBPACK_IMPORTED_MODULE_6___default.a["size-".concat(size)]),
    "data-visible": show,
    __self: _this,
    __source: {
      fileName: _jsxFileName,
      lineNumber: 38,
      columnNumber: 5
    }
  }, __jsx("div", {
    className: _ShadowBox_module_css__WEBPACK_IMPORTED_MODULE_6___default.a.shadow,
    onClick: onClose,
    __self: _this,
    __source: {
      fileName: _jsxFileName,
      lineNumber: 42,
      columnNumber: 7
    }
  }), __jsx("article", {
    className: _ShadowBox_module_css__WEBPACK_IMPORTED_MODULE_6___default.a.box,
    onScroll: function onScroll(e) {
      var scroll = e.target.scrollTop;

      if (shadow && scroll === 0) {
        setShadow(false);
      } else {
        setShadow(true);
      }
    },
    __self: _this,
    __source: {
      fileName: _jsxFileName,
      lineNumber: 43,
      columnNumber: 7
    }
  }, __jsx("header", {
    className: Object(_utils_classnames__WEBPACK_IMPORTED_MODULE_3__["default"])(_ShadowBox_module_css__WEBPACK_IMPORTED_MODULE_6___default.a.header, (_cn = {}, Object(C_Users_admin_Documents_Dev_PWAdvent_node_modules_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(_cn, _ShadowBox_module_css__WEBPACK_IMPORTED_MODULE_6___default.a.headerShadow, shadow), Object(C_Users_admin_Documents_Dev_PWAdvent_node_modules_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(_cn, _ShadowBox_module_css__WEBPACK_IMPORTED_MODULE_6___default.a.headerIos, _utils_helpers__WEBPACK_IMPORTED_MODULE_4__["isIos"]), _cn)),
    __self: _this,
    __source: {
      fileName: _jsxFileName,
      lineNumber: 54,
      columnNumber: 9
    }
  }, title !== null && __jsx("h1", {
    className: _ShadowBox_module_css__WEBPACK_IMPORTED_MODULE_6___default.a.title,
    __self: _this,
    __source: {
      fileName: _jsxFileName,
      lineNumber: 60,
      columnNumber: 30
    }
  }, title), ' ', __jsx(_index__WEBPACK_IMPORTED_MODULE_5__["CloseButton"], {
    className: _ShadowBox_module_css__WEBPACK_IMPORTED_MODULE_6___default.a.close,
    onClick: onClose,
    __self: _this,
    __source: {
      fileName: _jsxFileName,
      lineNumber: 61,
      columnNumber: 11
    }
  })), __jsx("div", {
    className: _ShadowBox_module_css__WEBPACK_IMPORTED_MODULE_6___default.a.content,
    __self: _this,
    __source: {
      fileName: _jsxFileName,
      lineNumber: 63,
      columnNumber: 9
    }
  }, children)));
}, "VK+GPhgH7qJbJfSU9EfvmnjrY68="));

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.i);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }


const isPrefreshComponent = __prefresh_utils__.shouldBind(module);

  if (true) {
    const currentExports = __prefresh_utils__.getExports(module);
    const previousHotModuleExports =
      module.hot.data && module.hot.data.moduleExports;

    __prefresh_utils__.registerExports(currentExports, module.i);

    if (isPrefreshComponent) {
      if (previousHotModuleExports) {
        try {
          __prefresh_utils__.flush();
          if (
            typeof __prefresh_errors__ !== 'undefined' &&
            __prefresh_errors__ &&
            __prefresh_errors__.clearRuntimeErrors
          ) {
            __prefresh_errors__.clearRuntimeErrors();
          }
        } catch (e) {
          // Only available in newer webpack versions.
          if (module.hot.invalidate) {
            module.hot.invalidate();
          } else {
            self.location.reload();
          }
        }
      }

      module.hot.dispose(data => {
        data.moduleExports = __prefresh_utils__.getExports(module);
      });

      module.hot.accept(function errorRecovery() {
        if (
          typeof __prefresh_errors__ !== 'undefined' &&
          __prefresh_errors__ &&
          __prefresh_errors__.handleRuntimeError
        ) {
          __prefresh_errors__.handleRuntimeError(error);
        }

        __webpack_require__.c[module.i].hot.accept(errorRecovery);
      });
    }
  }
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../node_modules/next/dist/compiled/webpack/harmony-module.js */ "./node_modules/next/dist/compiled/webpack/harmony-module.js")(module), __webpack_require__(/*! ./node_modules/@prefresh/webpack/src/utils/prefresh.js */ "./node_modules/@prefresh/webpack/src/utils/prefresh.js")))

/***/ }),

/***/ "./theme/index.ts":
/*!************************!*\
  !*** ./theme/index.ts ***!
  \************************/
/*! exports provided: Button, CloseButton, ShadowBox, PortalBox, SVG, Icon, LazyImage, Logo, Loader, ContentModal, Notification, Snow, Form, FormField, FormFieldset, FormControls, InputText, InputSelect, InputTextarea */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* WEBPACK VAR INJECTION */(function(module, __prefresh_utils__) {/* harmony import */ var _Button_Button__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Button/Button */ "./theme/Button/Button.tsx");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Button", function() { return _Button_Button__WEBPACK_IMPORTED_MODULE_0__["default"]; });

/* harmony import */ var _CloseButton_CloseButton__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./CloseButton/CloseButton */ "./theme/CloseButton/CloseButton.tsx");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "CloseButton", function() { return _CloseButton_CloseButton__WEBPACK_IMPORTED_MODULE_1__["default"]; });

/* harmony import */ var _ShadowBox_ShadowBox__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./ShadowBox/ShadowBox */ "./theme/ShadowBox/ShadowBox.tsx");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "ShadowBox", function() { return _ShadowBox_ShadowBox__WEBPACK_IMPORTED_MODULE_2__["default"]; });

/* harmony import */ var _ShadowBox_PortalBox__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./ShadowBox/PortalBox */ "./theme/ShadowBox/PortalBox.tsx");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "PortalBox", function() { return _ShadowBox_PortalBox__WEBPACK_IMPORTED_MODULE_3__["default"]; });

/* harmony import */ var _SVG_SVG__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./SVG/SVG */ "./theme/SVG/SVG.tsx");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "SVG", function() { return _SVG_SVG__WEBPACK_IMPORTED_MODULE_4__["default"]; });

/* harmony import */ var _SVG_Icon__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./SVG/Icon */ "./theme/SVG/Icon.tsx");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Icon", function() { return _SVG_Icon__WEBPACK_IMPORTED_MODULE_5__["default"]; });

/* harmony import */ var _Image_LazyImage__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./Image/LazyImage */ "./theme/Image/LazyImage.tsx");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "LazyImage", function() { return _Image_LazyImage__WEBPACK_IMPORTED_MODULE_6__["default"]; });

/* harmony import */ var _Logo_Logo__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./Logo/Logo */ "./theme/Logo/Logo.tsx");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Logo", function() { return _Logo_Logo__WEBPACK_IMPORTED_MODULE_7__["default"]; });

/* harmony import */ var _Loader_Loader__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./Loader/Loader */ "./theme/Loader/Loader.tsx");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Loader", function() { return _Loader_Loader__WEBPACK_IMPORTED_MODULE_8__["default"]; });

/* harmony import */ var _ContentModal_ContentModal__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./ContentModal/ContentModal */ "./theme/ContentModal/ContentModal.tsx");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "ContentModal", function() { return _ContentModal_ContentModal__WEBPACK_IMPORTED_MODULE_9__["default"]; });

/* harmony import */ var _Misc_Notification__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./Misc/Notification */ "./theme/Misc/Notification.tsx");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Notification", function() { return _Misc_Notification__WEBPACK_IMPORTED_MODULE_10__["default"]; });

/* harmony import */ var _Misc_Snow__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./Misc/Snow */ "./theme/Misc/Snow.tsx");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Snow", function() { return _Misc_Snow__WEBPACK_IMPORTED_MODULE_11__["default"]; });

/* harmony import */ var _Form_Form__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./Form/Form */ "./theme/Form/Form.tsx");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Form", function() { return _Form_Form__WEBPACK_IMPORTED_MODULE_12__["default"]; });

/* harmony import */ var _Form_FormField__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./Form/FormField */ "./theme/Form/FormField.tsx");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "FormField", function() { return _Form_FormField__WEBPACK_IMPORTED_MODULE_13__["default"]; });

/* harmony import */ var _Form_FormFieldset__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./Form/FormFieldset */ "./theme/Form/FormFieldset.tsx");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "FormFieldset", function() { return _Form_FormFieldset__WEBPACK_IMPORTED_MODULE_14__["default"]; });

/* harmony import */ var _Form_FormControls__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./Form/FormControls */ "./theme/Form/FormControls.tsx");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "FormControls", function() { return _Form_FormControls__WEBPACK_IMPORTED_MODULE_15__["default"]; });

/* harmony import */ var _Form_InputText__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./Form/InputText */ "./theme/Form/InputText.tsx");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "InputText", function() { return _Form_InputText__WEBPACK_IMPORTED_MODULE_16__["default"]; });

/* harmony import */ var _Form_InputSelect__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ./Form/InputSelect */ "./theme/Form/InputSelect.tsx");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "InputSelect", function() { return _Form_InputSelect__WEBPACK_IMPORTED_MODULE_17__["default"]; });

/* harmony import */ var _Form_InputTextarea__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ./Form/InputTextarea */ "./theme/Form/InputTextarea.tsx");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "InputTextarea", function() { return _Form_InputTextarea__WEBPACK_IMPORTED_MODULE_18__["default"]; });












 // Form









;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.i);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }


const isPrefreshComponent = __prefresh_utils__.shouldBind(module);

  if (true) {
    const currentExports = __prefresh_utils__.getExports(module);
    const previousHotModuleExports =
      module.hot.data && module.hot.data.moduleExports;

    __prefresh_utils__.registerExports(currentExports, module.i);

    if (isPrefreshComponent) {
      if (previousHotModuleExports) {
        try {
          __prefresh_utils__.flush();
          if (
            typeof __prefresh_errors__ !== 'undefined' &&
            __prefresh_errors__ &&
            __prefresh_errors__.clearRuntimeErrors
          ) {
            __prefresh_errors__.clearRuntimeErrors();
          }
        } catch (e) {
          // Only available in newer webpack versions.
          if (module.hot.invalidate) {
            module.hot.invalidate();
          } else {
            self.location.reload();
          }
        }
      }

      module.hot.dispose(data => {
        data.moduleExports = __prefresh_utils__.getExports(module);
      });

      module.hot.accept(function errorRecovery() {
        if (
          typeof __prefresh_errors__ !== 'undefined' &&
          __prefresh_errors__ &&
          __prefresh_errors__.handleRuntimeError
        ) {
          __prefresh_errors__.handleRuntimeError(error);
        }

        __webpack_require__.c[module.i].hot.accept(errorRecovery);
      });
    }
  }
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../node_modules/next/dist/compiled/webpack/harmony-module.js */ "./node_modules/next/dist/compiled/webpack/harmony-module.js")(module), __webpack_require__(/*! ./node_modules/@prefresh/webpack/src/utils/prefresh.js */ "./node_modules/@prefresh/webpack/src/utils/prefresh.js")))

/***/ }),

/***/ "./utils/calendar.ts":
/*!***************************!*\
  !*** ./utils/calendar.ts ***!
  \***************************/
/*! exports provided: YEAR, CALENDAR, DATE_TODAY, DATE_TODAY_ZERO, DATE_START, DATE_END, THEMEN */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* WEBPACK VAR INJECTION */(function(process, module, __prefresh_utils__) {/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "YEAR", function() { return YEAR; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CALENDAR", function() { return CALENDAR; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DATE_TODAY", function() { return DATE_TODAY; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DATE_TODAY_ZERO", function() { return DATE_TODAY_ZERO; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DATE_START", function() { return DATE_START; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DATE_END", function() { return DATE_END; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "THEMEN", function() { return THEMEN; });
/* harmony import */ var _utils_dayjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @utils/dayjs */ "./utils/dayjs.ts");

var YEAR = 2020;
var CALENDAR = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24];
var TODAY = process && "\"3wXX6TCGvlyuLzBGzdhDHQbYcmalv3x9AY0cIKciyaubAXwQxF9SgvAJWGGoTOZJXloirZzgrQgd45C6\"";
var DATE_TODAY = TODAY ? Object(_utils_dayjs__WEBPACK_IMPORTED_MODULE_0__["default"])(TODAY) : Object(_utils_dayjs__WEBPACK_IMPORTED_MODULE_0__["default"])();
var DATE_TODAY_ZERO = DATE_TODAY.tz('Antarctica/McMurdo');
var DATE_START = Object(_utils_dayjs__WEBPACK_IMPORTED_MODULE_0__["default"])('2020-12-01');
var DATE_END = Object(_utils_dayjs__WEBPACK_IMPORTED_MODULE_0__["default"])('2020-12-24');
var THEMEN = ['manifest', 'sharing', 'shortcuts / badging', 'ServiceWorker', 'SW Cache', 'IndexedDB', 'persistent Storage', 'BKG sync', 'Push Notifications', 'Push Trigger', 'Media Session', 'native file system', 'Wake Lock', 'font access', 'Orientation lock', 'Multi window', 'credentials', 'payments', 'Web Midi', 'shape detection', 'contact picker', 'sms reciever', 'Paw Clipboard API', 'WASM'];

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.i);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }


const isPrefreshComponent = __prefresh_utils__.shouldBind(module);

  if (true) {
    const currentExports = __prefresh_utils__.getExports(module);
    const previousHotModuleExports =
      module.hot.data && module.hot.data.moduleExports;

    __prefresh_utils__.registerExports(currentExports, module.i);

    if (isPrefreshComponent) {
      if (previousHotModuleExports) {
        try {
          __prefresh_utils__.flush();
          if (
            typeof __prefresh_errors__ !== 'undefined' &&
            __prefresh_errors__ &&
            __prefresh_errors__.clearRuntimeErrors
          ) {
            __prefresh_errors__.clearRuntimeErrors();
          }
        } catch (e) {
          // Only available in newer webpack versions.
          if (module.hot.invalidate) {
            module.hot.invalidate();
          } else {
            self.location.reload();
          }
        }
      }

      module.hot.dispose(data => {
        data.moduleExports = __prefresh_utils__.getExports(module);
      });

      module.hot.accept(function errorRecovery() {
        if (
          typeof __prefresh_errors__ !== 'undefined' &&
          __prefresh_errors__ &&
          __prefresh_errors__.handleRuntimeError
        ) {
          __prefresh_errors__.handleRuntimeError(error);
        }

        __webpack_require__.c[module.i].hot.accept(errorRecovery);
      });
    }
  }
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../node_modules/process/browser.js */ "./node_modules/process/browser.js"), __webpack_require__(/*! ./../node_modules/next/dist/compiled/webpack/harmony-module.js */ "./node_modules/next/dist/compiled/webpack/harmony-module.js")(module), __webpack_require__(/*! ./node_modules/@prefresh/webpack/src/utils/prefresh.js */ "./node_modules/@prefresh/webpack/src/utils/prefresh.js")))

/***/ }),

/***/ "./utils/classnames.tsx":
/*!******************************!*\
  !*** ./utils/classnames.tsx ***!
  \******************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* WEBPACK VAR INJECTION */(function(module, __prefresh_utils__) {/* harmony import */ var C_Users_admin_Documents_Dev_PWAdvent_node_modules_babel_runtime_helpers_esm_slicedToArray__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./node_modules/@babel/runtime/helpers/esm/slicedToArray */ "./node_modules/@babel/runtime/helpers/esm/slicedToArray.js");


var cn = function cn() {
  for (var _len = arguments.length, classes = new Array(_len), _key = 0; _key < _len; _key++) {
    classes[_key] = arguments[_key];
  }

  return classes.map(function (entry) {
    return typeof entry === 'string' ? entry : Object.entries(entry).filter(function (_ref) {
      var _ref2 = Object(C_Users_admin_Documents_Dev_PWAdvent_node_modules_babel_runtime_helpers_esm_slicedToArray__WEBPACK_IMPORTED_MODULE_0__["default"])(_ref, 2),
          cl = _ref2[0],
          append = _ref2[1];

      return append;
    }).map(function (_ref3) {
      var _ref4 = Object(C_Users_admin_Documents_Dev_PWAdvent_node_modules_babel_runtime_helpers_esm_slicedToArray__WEBPACK_IMPORTED_MODULE_0__["default"])(_ref3, 1),
          cl = _ref4[0];

      return cl;
    }).join(' ');
  }).filter(function (e) {
    return e !== '';
  }).join(' ');
};

/* harmony default export */ __webpack_exports__["default"] = (cn);

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.i);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }


const isPrefreshComponent = __prefresh_utils__.shouldBind(module);

  if (true) {
    const currentExports = __prefresh_utils__.getExports(module);
    const previousHotModuleExports =
      module.hot.data && module.hot.data.moduleExports;

    __prefresh_utils__.registerExports(currentExports, module.i);

    if (isPrefreshComponent) {
      if (previousHotModuleExports) {
        try {
          __prefresh_utils__.flush();
          if (
            typeof __prefresh_errors__ !== 'undefined' &&
            __prefresh_errors__ &&
            __prefresh_errors__.clearRuntimeErrors
          ) {
            __prefresh_errors__.clearRuntimeErrors();
          }
        } catch (e) {
          // Only available in newer webpack versions.
          if (module.hot.invalidate) {
            module.hot.invalidate();
          } else {
            self.location.reload();
          }
        }
      }

      module.hot.dispose(data => {
        data.moduleExports = __prefresh_utils__.getExports(module);
      });

      module.hot.accept(function errorRecovery() {
        if (
          typeof __prefresh_errors__ !== 'undefined' &&
          __prefresh_errors__ &&
          __prefresh_errors__.handleRuntimeError
        ) {
          __prefresh_errors__.handleRuntimeError(error);
        }

        __webpack_require__.c[module.i].hot.accept(errorRecovery);
      });
    }
  }
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../node_modules/next/dist/compiled/webpack/harmony-module.js */ "./node_modules/next/dist/compiled/webpack/harmony-module.js")(module), __webpack_require__(/*! ./node_modules/@prefresh/webpack/src/utils/prefresh.js */ "./node_modules/@prefresh/webpack/src/utils/prefresh.js")))

/***/ }),

/***/ "./utils/constants.ts":
/*!****************************!*\
  !*** ./utils/constants.ts ***!
  \****************************/
/*! exports provided: apiBase, apiKey, appTitle, appDescription, isDev, registerSw, daysOrder, daysOrderCorrect, VIEW_TYPES, SUBJECTS */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* WEBPACK VAR INJECTION */(function(process, module, __prefresh_utils__) {/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "apiBase", function() { return apiBase; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "apiKey", function() { return apiKey; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "appTitle", function() { return appTitle; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "appDescription", function() { return appDescription; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isDev", function() { return isDev; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "registerSw", function() { return registerSw; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "daysOrder", function() { return daysOrder; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "daysOrderCorrect", function() { return daysOrderCorrect; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "VIEW_TYPES", function() { return VIEW_TYPES; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SUBJECTS", function() { return SUBJECTS; });
/* harmony import */ var C_Users_admin_Documents_Dev_PWAdvent_node_modules_babel_runtime_helpers_esm_toConsumableArray__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./node_modules/@babel/runtime/helpers/esm/toConsumableArray */ "./node_modules/@babel/runtime/helpers/esm/toConsumableArray.js");
/* harmony import */ var _utils_helpers__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @utils/helpers */ "./utils/helpers.tsx");


var apiBase = Object(_utils_helpers__WEBPACK_IMPORTED_MODULE_1__["trailingSlashIt"])(process && "\"https://api.pwadvent.dev/\"");
var apiKey = process && "\"3wXX6TCGvlyuLzBGzdhDHQbYcmalv3x9AY0cIKciyaubAXwQxF9SgvAJWGGoTOZJXloirZzgrQgd45C6\"";
var appTitle = process && "\"PWAdvent\"";
var appDescription = process && "\"24 great browserfeatures - from the first to the 24th of december 2020\"";
var isDev = process && true;
var registerSw = process && false || !isDev;
var random = false;
var twoToTwentythree = [2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23];
var shuffeled = random ? Object(_utils_helpers__WEBPACK_IMPORTED_MODULE_1__["shuffle"])(twoToTwentythree) : [6, 21, 12, 20, 14, 4, 19, 16, 15, 2, 17, 9, 8, 13, 11, 5, 22, 18, 3, 23, 7, 10];
var daysOrder = [1].concat(Object(C_Users_admin_Documents_Dev_PWAdvent_node_modules_babel_runtime_helpers_esm_toConsumableArray__WEBPACK_IMPORTED_MODULE_0__["default"])(shuffeled), [24]);
var daysOrderCorrect = [1].concat(twoToTwentythree, [24]);
var VIEW_TYPES = {
  LIST: 'list',
  CALENDAR: 'calendar'
};
var SUBJECTS = ['Add to Homescreen', 'Sharing on the web', 'Shortcuts', 'Service Worker', 'ServiceWorker Cache', 'IndexedDB', 'Storage-Managers', 'Background-Sync', 'Push Notifications', 'Media Session API', 'Shape Detection API', 'Wake Lock API', 'Payment Request API', 'Vibration', 'Dual Screen Support', 'Contact Picker API', 'Credential Management API', 'Font Access API', 'Web MIDI', 'File System Access API', 'File Handling API', 'Web OTP API', 'Badging API', 'WASM'];

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.i);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }


const isPrefreshComponent = __prefresh_utils__.shouldBind(module);

  if (true) {
    const currentExports = __prefresh_utils__.getExports(module);
    const previousHotModuleExports =
      module.hot.data && module.hot.data.moduleExports;

    __prefresh_utils__.registerExports(currentExports, module.i);

    if (isPrefreshComponent) {
      if (previousHotModuleExports) {
        try {
          __prefresh_utils__.flush();
          if (
            typeof __prefresh_errors__ !== 'undefined' &&
            __prefresh_errors__ &&
            __prefresh_errors__.clearRuntimeErrors
          ) {
            __prefresh_errors__.clearRuntimeErrors();
          }
        } catch (e) {
          // Only available in newer webpack versions.
          if (module.hot.invalidate) {
            module.hot.invalidate();
          } else {
            self.location.reload();
          }
        }
      }

      module.hot.dispose(data => {
        data.moduleExports = __prefresh_utils__.getExports(module);
      });

      module.hot.accept(function errorRecovery() {
        if (
          typeof __prefresh_errors__ !== 'undefined' &&
          __prefresh_errors__ &&
          __prefresh_errors__.handleRuntimeError
        ) {
          __prefresh_errors__.handleRuntimeError(error);
        }

        __webpack_require__.c[module.i].hot.accept(errorRecovery);
      });
    }
  }
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../node_modules/process/browser.js */ "./node_modules/process/browser.js"), __webpack_require__(/*! ./../node_modules/next/dist/compiled/webpack/harmony-module.js */ "./node_modules/next/dist/compiled/webpack/harmony-module.js")(module), __webpack_require__(/*! ./node_modules/@prefresh/webpack/src/utils/prefresh.js */ "./node_modules/@prefresh/webpack/src/utils/prefresh.js")))

/***/ }),

/***/ "./utils/dayjs.ts":
/*!************************!*\
  !*** ./utils/dayjs.ts ***!
  \************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* WEBPACK VAR INJECTION */(function(module, __prefresh_utils__) {/* harmony import */ var dayjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! dayjs */ "./node_modules/dayjs/dayjs.min.js");
/* harmony import */ var dayjs__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(dayjs__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var dayjs_plugin_localizedFormat__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! dayjs/plugin/localizedFormat */ "./node_modules/dayjs/plugin/localizedFormat.js");
/* harmony import */ var dayjs_plugin_localizedFormat__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(dayjs_plugin_localizedFormat__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var dayjs_plugin_utc__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! dayjs/plugin/utc */ "./node_modules/dayjs/plugin/utc.js");
/* harmony import */ var dayjs_plugin_utc__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(dayjs_plugin_utc__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var dayjs_plugin_timezone__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! dayjs/plugin/timezone */ "./node_modules/dayjs/plugin/timezone.js");
/* harmony import */ var dayjs_plugin_timezone__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(dayjs_plugin_timezone__WEBPACK_IMPORTED_MODULE_3__);




dayjs__WEBPACK_IMPORTED_MODULE_0___default.a.extend(dayjs_plugin_utc__WEBPACK_IMPORTED_MODULE_2___default.a);
dayjs__WEBPACK_IMPORTED_MODULE_0___default.a.extend(dayjs_plugin_timezone__WEBPACK_IMPORTED_MODULE_3___default.a);
dayjs__WEBPACK_IMPORTED_MODULE_0___default.a.extend(dayjs_plugin_localizedFormat__WEBPACK_IMPORTED_MODULE_1___default.a);
/* harmony default export */ __webpack_exports__["default"] = (dayjs__WEBPACK_IMPORTED_MODULE_0___default.a);

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.i);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }


const isPrefreshComponent = __prefresh_utils__.shouldBind(module);

  if (true) {
    const currentExports = __prefresh_utils__.getExports(module);
    const previousHotModuleExports =
      module.hot.data && module.hot.data.moduleExports;

    __prefresh_utils__.registerExports(currentExports, module.i);

    if (isPrefreshComponent) {
      if (previousHotModuleExports) {
        try {
          __prefresh_utils__.flush();
          if (
            typeof __prefresh_errors__ !== 'undefined' &&
            __prefresh_errors__ &&
            __prefresh_errors__.clearRuntimeErrors
          ) {
            __prefresh_errors__.clearRuntimeErrors();
          }
        } catch (e) {
          // Only available in newer webpack versions.
          if (module.hot.invalidate) {
            module.hot.invalidate();
          } else {
            self.location.reload();
          }
        }
      }

      module.hot.dispose(data => {
        data.moduleExports = __prefresh_utils__.getExports(module);
      });

      module.hot.accept(function errorRecovery() {
        if (
          typeof __prefresh_errors__ !== 'undefined' &&
          __prefresh_errors__ &&
          __prefresh_errors__.handleRuntimeError
        ) {
          __prefresh_errors__.handleRuntimeError(error);
        }

        __webpack_require__.c[module.i].hot.accept(errorRecovery);
      });
    }
  }
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../node_modules/next/dist/compiled/webpack/harmony-module.js */ "./node_modules/next/dist/compiled/webpack/harmony-module.js")(module), __webpack_require__(/*! ./node_modules/@prefresh/webpack/src/utils/prefresh.js */ "./node_modules/@prefresh/webpack/src/utils/prefresh.js")))

/***/ }),

/***/ "./utils/helpers.tsx":
/*!***************************!*\
  !*** ./utils/helpers.tsx ***!
  \***************************/
/*! exports provided: zeroPad, windowResize, getRandomNumber, untrailingSlashIt, trailingSlashIt, shuffle, urlB64ToUint8Array, isIos */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* WEBPACK VAR INJECTION */(function(module, __prefresh_utils__) {/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "zeroPad", function() { return zeroPad; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "windowResize", function() { return windowResize; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getRandomNumber", function() { return getRandomNumber; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "untrailingSlashIt", function() { return untrailingSlashIt; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "trailingSlashIt", function() { return trailingSlashIt; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "shuffle", function() { return shuffle; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "urlB64ToUint8Array", function() { return urlB64ToUint8Array; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isIos", function() { return isIos; });
var zeroPad = function zeroPad(number, length) {
  return number.toString().padStart(length, '0');
};
var windowResize = function windowResize() {
  var vh = window.innerHeight * 0.01;
  document.documentElement.style.setProperty('--vh', "".concat(vh, "px"));
};
var getRandomNumber = function getRandomNumber(min, max) {
  return Math.random() * (max - min) + min;
};
var untrailingSlashIt = function untrailingSlashIt() {
  var str = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
  return str.replace(/\/$/, '');
};
var trailingSlashIt = function trailingSlashIt() {
  var str = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 's';
  return untrailingSlashIt(str) + '/';
};
var shuffle = function shuffle(items) {
  var recur = function recur(arr, currentIndex) {
    if (currentIndex === 0) {
      return arr;
    }

    var randomIndex = Math.floor(Math.random() * currentIndex);
    var swap = arr[currentIndex];
    arr[currentIndex] = arr[randomIndex];
    arr[randomIndex] = swap;
    return recur(arr, currentIndex - 1);
  };

  return recur(items.map(function (x) {
    return x;
  }), items.length - 1);
};
var urlB64ToUint8Array = function urlB64ToUint8Array(base64String) {
  var padding = '='.repeat((4 - base64String.length % 4) % 4);
  var base64 = (base64String + padding).replace(/\-/g, '+').replace(/_/g, '/');
  var rawData = window.atob(base64);
  var outputArray = new Uint8Array(rawData.length);

  for (var i = 0; i < rawData.length; ++i) {
    outputArray[i] = rawData.charCodeAt(i);
  }

  return outputArray;
};
var PLATFORM = true ? navigator.platform : undefined;
var USER_AGENT = true ? navigator.userAgent : undefined;
var isIos = ['iPad Simulator', 'iPhone Simulator', 'iPod Simulator', 'iPad', 'iPhone', 'iPod'].includes(PLATFORM) || USER_AGENT.includes('Mac') && 'ontouchend' in document;

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.i);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }


const isPrefreshComponent = __prefresh_utils__.shouldBind(module);

  if (true) {
    const currentExports = __prefresh_utils__.getExports(module);
    const previousHotModuleExports =
      module.hot.data && module.hot.data.moduleExports;

    __prefresh_utils__.registerExports(currentExports, module.i);

    if (isPrefreshComponent) {
      if (previousHotModuleExports) {
        try {
          __prefresh_utils__.flush();
          if (
            typeof __prefresh_errors__ !== 'undefined' &&
            __prefresh_errors__ &&
            __prefresh_errors__.clearRuntimeErrors
          ) {
            __prefresh_errors__.clearRuntimeErrors();
          }
        } catch (e) {
          // Only available in newer webpack versions.
          if (module.hot.invalidate) {
            module.hot.invalidate();
          } else {
            self.location.reload();
          }
        }
      }

      module.hot.dispose(data => {
        data.moduleExports = __prefresh_utils__.getExports(module);
      });

      module.hot.accept(function errorRecovery() {
        if (
          typeof __prefresh_errors__ !== 'undefined' &&
          __prefresh_errors__ &&
          __prefresh_errors__.handleRuntimeError
        ) {
          __prefresh_errors__.handleRuntimeError(error);
        }

        __webpack_require__.c[module.i].hot.accept(errorRecovery);
      });
    }
  }
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../node_modules/next/dist/compiled/webpack/harmony-module.js */ "./node_modules/next/dist/compiled/webpack/harmony-module.js")(module), __webpack_require__(/*! ./node_modules/@prefresh/webpack/src/utils/prefresh.js */ "./node_modules/@prefresh/webpack/src/utils/prefresh.js")))

/***/ }),

/***/ "./utils/metas.ts":
/*!************************!*\
  !*** ./utils/metas.ts ***!
  \************************/
/*! exports provided: metaTitle */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* WEBPACK VAR INJECTION */(function(module, __prefresh_utils__) {/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "metaTitle", function() { return metaTitle; });
/* harmony import */ var _utils_constants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @utils/constants */ "./utils/constants.ts");

var metaTitle = function metaTitle() {
  var title = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
  return title === '' ? "".concat(_utils_constants__WEBPACK_IMPORTED_MODULE_0__["appTitle"], " \u2744 ").concat(_utils_constants__WEBPACK_IMPORTED_MODULE_0__["appDescription"]) : "".concat(title, " \u2744 ").concat(_utils_constants__WEBPACK_IMPORTED_MODULE_0__["appTitle"]);
};

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.i);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }


const isPrefreshComponent = __prefresh_utils__.shouldBind(module);

  if (true) {
    const currentExports = __prefresh_utils__.getExports(module);
    const previousHotModuleExports =
      module.hot.data && module.hot.data.moduleExports;

    __prefresh_utils__.registerExports(currentExports, module.i);

    if (isPrefreshComponent) {
      if (previousHotModuleExports) {
        try {
          __prefresh_utils__.flush();
          if (
            typeof __prefresh_errors__ !== 'undefined' &&
            __prefresh_errors__ &&
            __prefresh_errors__.clearRuntimeErrors
          ) {
            __prefresh_errors__.clearRuntimeErrors();
          }
        } catch (e) {
          // Only available in newer webpack versions.
          if (module.hot.invalidate) {
            module.hot.invalidate();
          } else {
            self.location.reload();
          }
        }
      }

      module.hot.dispose(data => {
        data.moduleExports = __prefresh_utils__.getExports(module);
      });

      module.hot.accept(function errorRecovery() {
        if (
          typeof __prefresh_errors__ !== 'undefined' &&
          __prefresh_errors__ &&
          __prefresh_errors__.handleRuntimeError
        ) {
          __prefresh_errors__.handleRuntimeError(error);
        }

        __webpack_require__.c[module.i].hot.accept(errorRecovery);
      });
    }
  }
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../node_modules/next/dist/compiled/webpack/harmony-module.js */ "./node_modules/next/dist/compiled/webpack/harmony-module.js")(module), __webpack_require__(/*! ./node_modules/@prefresh/webpack/src/utils/prefresh.js */ "./node_modules/@prefresh/webpack/src/utils/prefresh.js")))

/***/ }),

/***/ "./utils/prism.js":
/*!************************!*\
  !*** ./utils/prism.js ***!
  \************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global, module, __prefresh_utils__) {/* PrismJS 1.22.0
https://prismjs.com/download.html#themes=prism-tomorrow&languages=markup+css+clike+javascript+json+sass+scss+typescript+typoscript&plugins=line-numbers */
var _self = true ? window : undefined,
    Prism = function (u) {
  var c = /\blang(?:uage)?-([\w-]+)\b/i,
      n = 0,
      _ = {
    manual: u.Prism && u.Prism.manual,
    disableWorkerMessageHandler: u.Prism && u.Prism.disableWorkerMessageHandler,
    util: {
      encode: function e(n) {
        return n instanceof M ? new M(n.type, e(n.content), n.alias) : Array.isArray(n) ? n.map(e) : n.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/\u00a0/g, ' ');
      },
      type: function type(e) {
        return Object.prototype.toString.call(e).slice(8, -1);
      },
      objId: function objId(e) {
        return e.__id || Object.defineProperty(e, '__id', {
          value: ++n
        }), e.__id;
      },
      clone: function t(e, r) {
        var a, n;

        switch (r = r || {}, _.util.type(e)) {
          case 'Object':
            if (n = _.util.objId(e), r[n]) return r[n];

            for (var i in a = {}, r[n] = a, e) {
              e.hasOwnProperty(i) && (a[i] = t(e[i], r));
            }

            return a;

          case 'Array':
            return n = _.util.objId(e), r[n] ? r[n] : (a = [], r[n] = a, e.forEach(function (e, n) {
              a[n] = t(e, r);
            }), a);

          default:
            return e;
        }
      },
      getLanguage: function getLanguage(e) {
        for (; e && !c.test(e.className);) {
          e = e.parentElement;
        }

        return e ? (e.className.match(c) || [, 'none'])[1].toLowerCase() : 'none';
      },
      currentScript: function currentScript() {
        if ('undefined' == typeof document) return null;
        if ('currentScript' in document) return document.currentScript;

        try {
          throw new Error();
        } catch (e) {
          var n = (/at [^(\r\n]*\((.*):.+:.+\)$/i.exec(e.stack) || [])[1];

          if (n) {
            var t = document.getElementsByTagName('script');

            for (var r in t) {
              if (t[r].src == n) return t[r];
            }
          }

          return null;
        }
      },
      isActive: function isActive(e, n, t) {
        for (var r = 'no-' + n; e;) {
          var a = e.classList;
          if (a.contains(n)) return !0;
          if (a.contains(r)) return !1;
          e = e.parentElement;
        }

        return !!t;
      }
    },
    languages: {
      extend: function extend(e, n) {
        var t = _.util.clone(_.languages[e]);

        for (var r in n) {
          t[r] = n[r];
        }

        return t;
      },
      insertBefore: function insertBefore(t, e, n, r) {
        var a = (r = r || _.languages)[t],
            i = {};

        for (var l in a) {
          if (a.hasOwnProperty(l)) {
            if (l == e) for (var o in n) {
              n.hasOwnProperty(o) && (i[o] = n[o]);
            }
            n.hasOwnProperty(l) || (i[l] = a[l]);
          }
        }

        var s = r[t];
        return r[t] = i, _.languages.DFS(_.languages, function (e, n) {
          n === s && e != t && (this[e] = i);
        }), i;
      },
      DFS: function e(n, t, r, a) {
        a = a || {};
        var i = _.util.objId;

        for (var l in n) {
          if (n.hasOwnProperty(l)) {
            t.call(n, l, n[l], r || l);

            var o = n[l],
                s = _.util.type(o);

            'Object' !== s || a[i(o)] ? 'Array' !== s || a[i(o)] || (a[i(o)] = !0, e(o, t, l, a)) : (a[i(o)] = !0, e(o, t, null, a));
          }
        }
      }
    },
    plugins: {},
    highlightAll: function highlightAll(e, n) {
      _.highlightAllUnder(document, e, n);
    },
    highlightAllUnder: function highlightAllUnder(e, n, t) {
      var r = {
        callback: t,
        container: e,
        selector: 'code[class*="language-"], [class*="language-"] code, code[class*="lang-"], [class*="lang-"] code'
      };
      _.hooks.run('before-highlightall', r), r.elements = Array.prototype.slice.apply(r.container.querySelectorAll(r.selector)), _.hooks.run('before-all-elements-highlight', r);

      for (var a, i = 0; a = r.elements[i++];) {
        _.highlightElement(a, !0 === n, r.callback);
      }
    },
    highlightElement: function highlightElement(e, n, t) {
      var r = _.util.getLanguage(e),
          a = _.languages[r];

      e.className = e.className.replace(c, '').replace(/\s+/g, ' ') + ' language-' + r;
      var i = e.parentElement;
      i && 'pre' === i.nodeName.toLowerCase() && (i.className = i.className.replace(c, '').replace(/\s+/g, ' ') + ' language-' + r);
      var l = {
        element: e,
        language: r,
        grammar: a,
        code: e.textContent
      };

      function o(e) {
        l.highlightedCode = e, _.hooks.run('before-insert', l), l.element.innerHTML = l.highlightedCode, _.hooks.run('after-highlight', l), _.hooks.run('complete', l), t && t.call(l.element);
      }

      if (_.hooks.run('before-sanity-check', l), !l.code) return _.hooks.run('complete', l), void (t && t.call(l.element));
      if (_.hooks.run('before-highlight', l), l.grammar) {
        if (n && u.Worker) {
          var s = new Worker(_.filename);
          s.onmessage = function (e) {
            o(e.data);
          }, s.postMessage(JSON.stringify({
            language: l.language,
            code: l.code,
            immediateClose: !0
          }));
        } else o(_.highlight(l.code, l.grammar, l.language));
      } else o(_.util.encode(l.code));
    },
    highlight: function highlight(e, n, t) {
      var r = {
        code: e,
        grammar: n,
        language: t
      };
      return _.hooks.run('before-tokenize', r), r.tokens = _.tokenize(r.code, r.grammar), _.hooks.run('after-tokenize', r), M.stringify(_.util.encode(r.tokens), r.language);
    },
    tokenize: function tokenize(e, n) {
      var t = n.rest;

      if (t) {
        for (var r in t) {
          n[r] = t[r];
        }

        delete n.rest;
      }

      var a = new i();
      return z(a, a.head, e), function e(n, t, r, a, i, l) {
        for (var o in r) {
          if (r.hasOwnProperty(o) && r[o]) {
            var s = r[o];
            s = Array.isArray(s) ? s : [s];

            for (var u = 0; u < s.length; ++u) {
              if (l && l.cause == o + ',' + u) return;
              var c = s[u],
                  g = c.inside,
                  f = !!c.lookbehind,
                  h = !!c.greedy,
                  d = c.alias;

              if (h && !c.pattern.global) {
                var v = c.pattern.toString().match(/[imsuy]*$/)[0];
                c.pattern = RegExp(c.pattern.source, v + 'g');
              }

              for (var p = c.pattern || c, m = a.next, y = i; m !== t.tail && !(l && y >= l.reach); y += m.value.length, m = m.next) {
                var k = m.value;
                if (t.length > n.length) return;

                if (!(k instanceof M)) {
                  var b,
                      x = 1;

                  if (h) {
                    if (!(b = W(p, y, n, f))) break;
                    var w = b.index,
                        A = b.index + b[0].length,
                        P = y;

                    for (P += m.value.length; P <= w;) {
                      m = m.next, P += m.value.length;
                    }

                    if (P -= m.value.length, y = P, m.value instanceof M) continue;

                    for (var S = m; S !== t.tail && (P < A || 'string' == typeof S.value); S = S.next) {
                      x++, P += S.value.length;
                    }

                    x--, k = n.slice(y, P), b.index -= y;
                  } else if (!(b = W(p, 0, k, f))) continue;

                  var w = b.index,
                      E = b[0],
                      O = k.slice(0, w),
                      L = k.slice(w + E.length),
                      N = y + k.length;
                  l && N > l.reach && (l.reach = N);
                  var j = m.prev;
                  O && (j = z(t, j, O), y += O.length), I(t, j, x);
                  var C = new M(o, g ? _.tokenize(E, g) : E, d, E);
                  m = z(t, j, C), L && z(t, m, L), 1 < x && e(n, t, r, m.prev, y, {
                    cause: o + ',' + u,
                    reach: N
                  });
                }
              }
            }
          }
        }
      }(e, a, n, a.head, 0), function (e) {
        var n = [],
            t = e.head.next;

        for (; t !== e.tail;) {
          n.push(t.value), t = t.next;
        }

        return n;
      }(a);
    },
    hooks: {
      all: {},
      add: function add(e, n) {
        var t = _.hooks.all;
        t[e] = t[e] || [], t[e].push(n);
      },
      run: function run(e, n) {
        var t = _.hooks.all[e];
        if (t && t.length) for (var r, a = 0; r = t[a++];) {
          r(n);
        }
      }
    },
    Token: M
  };

  function M(e, n, t, r) {
    this.type = e, this.content = n, this.alias = t, this.length = 0 | (r || '').length;
  }

  function W(e, n, t, r) {
    e.lastIndex = n;
    var a = e.exec(t);

    if (a && r && a[1]) {
      var i = a[1].length;
      a.index += i, a[0] = a[0].slice(i);
    }

    return a;
  }

  function i() {
    var e = {
      value: null,
      prev: null,
      next: null
    },
        n = {
      value: null,
      prev: e,
      next: null
    };
    e.next = n, this.head = e, this.tail = n, this.length = 0;
  }

  function z(e, n, t) {
    var r = n.next,
        a = {
      value: t,
      prev: n,
      next: r
    };
    return n.next = a, r.prev = a, e.length++, a;
  }

  function I(e, n, t) {
    for (var r = n.next, a = 0; a < t && r !== e.tail; a++) {
      r = r.next;
    }

    (n.next = r).prev = n, e.length -= a;
  }

  if (u.Prism = _, M.stringify = function n(e, t) {
    if ('string' == typeof e) return e;

    if (Array.isArray(e)) {
      var r = '';
      return e.forEach(function (e) {
        r += n(e, t);
      }), r;
    }

    var a = {
      type: e.type,
      content: n(e.content, t),
      tag: 'span',
      classes: ['token', e.type],
      attributes: {},
      language: t
    },
        i = e.alias;
    i && (Array.isArray(i) ? Array.prototype.push.apply(a.classes, i) : a.classes.push(i)), _.hooks.run('wrap', a);
    var l = '';

    for (var o in a.attributes) {
      l += ' ' + o + '="' + (a.attributes[o] || '').replace(/"/g, '&quot;') + '"';
    }

    return '<' + a.tag + ' class="' + a.classes.join(' ') + '"' + l + '>' + a.content + '</' + a.tag + '>';
  }, !u.document) return u.addEventListener && (_.disableWorkerMessageHandler || u.addEventListener('message', function (e) {
    var n = JSON.parse(e.data),
        t = n.language,
        r = n.code,
        a = n.immediateClose;
    u.postMessage(_.highlight(r, _.languages[t], t)), a && u.close();
  }, !1)), _;

  var e = _.util.currentScript();

  function t() {
    _.manual || _.highlightAll();
  }

  if (e && (_.filename = e.src, e.hasAttribute('data-manual') && (_.manual = !0)), !_.manual) {
    var r = document.readyState;
    'loading' === r || 'interactive' === r && e && e.defer ? document.addEventListener('DOMContentLoaded', t) : window.requestAnimationFrame ? window.requestAnimationFrame(t) : window.setTimeout(t, 16);
  }

  return _;
}(_self);

 true && module.exports && (module.exports = Prism), 'undefined' != typeof global && (global.Prism = Prism);
Prism.languages.markup = {
  comment: /<!--[\s\S]*?-->/,
  prolog: /<\?[\s\S]+?\?>/,
  doctype: {
    pattern: /<!DOCTYPE(?:[^>"'[\]]|"[^"]*"|'[^']*')+(?:\[(?:[^<"'\]]|"[^"]*"|'[^']*'|<(?!!--)|<!--(?:[^-]|-(?!->))*-->)*\]\s*)?>/i,
    greedy: !0,
    inside: {
      'internal-subset': {
        pattern: /(\[)[\s\S]+(?=\]>$)/,
        lookbehind: !0,
        greedy: !0,
        inside: null
      },
      string: {
        pattern: /"[^"]*"|'[^']*'/,
        greedy: !0
      },
      punctuation: /^<!|>$|[[\]]/,
      'doctype-tag': /^DOCTYPE/,
      name: /[^\s<>'"]+/
    }
  },
  cdata: /<!\[CDATA\[[\s\S]*?]]>/i,
  tag: {
    pattern: /<\/?(?!\d)[^\s>\/=$<%]+(?:\s(?:\s*[^\s>\/=]+(?:\s*=\s*(?:"[^"]*"|'[^']*'|[^\s'">=]+(?=[\s>]))|(?=[\s/>])))+)?\s*\/?>/,
    greedy: !0,
    inside: {
      tag: {
        pattern: /^<\/?[^\s>\/]+/,
        inside: {
          punctuation: /^<\/?/,
          namespace: /^[^\s>\/:]+:/
        }
      },
      'attr-value': {
        pattern: /=\s*(?:"[^"]*"|'[^']*'|[^\s'">=]+)/,
        inside: {
          punctuation: [{
            pattern: /^=/,
            alias: 'attr-equals'
          }, /"|'/]
        }
      },
      punctuation: /\/?>/,
      'attr-name': {
        pattern: /[^\s>\/]+/,
        inside: {
          namespace: /^[^\s>\/:]+:/
        }
      }
    }
  },
  entity: [{
    pattern: /&[\da-z]{1,8};/i,
    alias: 'named-entity'
  }, /&#x?[\da-f]{1,8};/i]
}, Prism.languages.markup.tag.inside['attr-value'].inside.entity = Prism.languages.markup.entity, Prism.languages.markup.doctype.inside['internal-subset'].inside = Prism.languages.markup, Prism.hooks.add('wrap', function (a) {
  'entity' === a.type && (a.attributes.title = a.content.replace(/&amp;/, '&'));
}), Object.defineProperty(Prism.languages.markup.tag, 'addInlined', {
  value: function value(a, e) {
    var s = {};
    s['language-' + e] = {
      pattern: /(^<!\[CDATA\[)[\s\S]+?(?=\]\]>$)/i,
      lookbehind: !0,
      inside: Prism.languages[e]
    }, s.cdata = /^<!\[CDATA\[|\]\]>$/i;
    var n = {
      'included-cdata': {
        pattern: /<!\[CDATA\[[\s\S]*?\]\]>/i,
        inside: s
      }
    };
    n['language-' + e] = {
      pattern: /[\s\S]+/,
      inside: Prism.languages[e]
    };
    var t = {};
    t[a] = {
      pattern: RegExp('(<__[^]*?>)(?:<!\\[CDATA\\[(?:[^\\]]|\\](?!\\]>))*\\]\\]>|(?!<!\\[CDATA\\[)[^])*?(?=</__>)'.replace(/__/g, function () {
        return a;
      }), 'i'),
      lookbehind: !0,
      greedy: !0,
      inside: n
    }, Prism.languages.insertBefore('markup', 'cdata', t);
  }
}), Prism.languages.html = Prism.languages.markup, Prism.languages.mathml = Prism.languages.markup, Prism.languages.svg = Prism.languages.markup, Prism.languages.xml = Prism.languages.extend('markup', {}), Prism.languages.ssml = Prism.languages.xml, Prism.languages.atom = Prism.languages.xml, Prism.languages.rss = Prism.languages.xml;
!function (e) {
  var t = /("|')(?:\\(?:\r\n|[\s\S])|(?!\1)[^\\\r\n])*\1/;
  e.languages.css = {
    comment: /\/\*[\s\S]*?\*\//,
    atrule: {
      pattern: /@[\w-]+[\s\S]*?(?:;|(?=\s*\{))/,
      inside: {
        rule: /^@[\w-]+/,
        'selector-function-argument': {
          pattern: /(\bselector\s*\((?!\s*\))\s*)(?:[^()]|\((?:[^()]|\([^()]*\))*\))+?(?=\s*\))/,
          lookbehind: !0,
          alias: 'selector'
        },
        keyword: {
          pattern: /(^|[^\w-])(?:and|not|only|or)(?![\w-])/,
          lookbehind: !0
        }
      }
    },
    url: {
      pattern: RegExp('\\burl\\((?:' + t.source + '|(?:[^\\\\\r\n()"\']|\\\\[^])*)\\)', 'i'),
      greedy: !0,
      inside: {
        "function": /^url/i,
        punctuation: /^\(|\)$/,
        string: {
          pattern: RegExp('^' + t.source + '$'),
          alias: 'url'
        }
      }
    },
    selector: RegExp('[^{}\\s](?:[^{};"\']|' + t.source + ')*?(?=\\s*\\{)'),
    string: {
      pattern: t,
      greedy: !0
    },
    property: /[-_a-z\xA0-\uFFFF][-\w\xA0-\uFFFF]*(?=\s*:)/i,
    important: /!important\b/i,
    "function": /[-a-z0-9]+(?=\()/i,
    punctuation: /[(){};:,]/
  }, e.languages.css.atrule.inside.rest = e.languages.css;
  var s = e.languages.markup;
  s && (s.tag.addInlined('style', 'css'), e.languages.insertBefore('inside', 'attr-value', {
    'style-attr': {
      pattern: /(^|["'\s])style\s*=\s*(?:"[^"]*"|'[^']*')/i,
      lookbehind: !0,
      inside: {
        'attr-value': {
          pattern: /=\s*(?:"[^"]*"|'[^']*'|[^\s'">=]+)/,
          inside: {
            style: {
              pattern: /(["'])[\s\S]+(?=["']$)/,
              lookbehind: !0,
              alias: 'language-css',
              inside: e.languages.css
            },
            punctuation: [{
              pattern: /^=/,
              alias: 'attr-equals'
            }, /"|'/]
          }
        },
        'attr-name': /^style/i
      }
    }
  }, s.tag));
}(Prism);
Prism.languages.clike = {
  comment: [{
    pattern: /(^|[^\\])\/\*[\s\S]*?(?:\*\/|$)/,
    lookbehind: !0
  }, {
    pattern: /(^|[^\\:])\/\/.*/,
    lookbehind: !0,
    greedy: !0
  }],
  string: {
    pattern: /(["'])(?:\\(?:\r\n|[\s\S])|(?!\1)[^\\\r\n])*\1/,
    greedy: !0
  },
  'class-name': {
    pattern: /(\b(?:class|interface|extends|implements|trait|instanceof|new)\s+|\bcatch\s+\()[\w.\\]+/i,
    lookbehind: !0,
    inside: {
      punctuation: /[.\\]/
    }
  },
  keyword: /\b(?:if|else|while|do|for|return|in|instanceof|function|new|try|throw|catch|finally|null|break|continue)\b/,
  "boolean": /\b(?:true|false)\b/,
  "function": /\w+(?=\()/,
  number: /\b0x[\da-f]+\b|(?:\b\d+\.?\d*|\B\.\d+)(?:e[+-]?\d+)?/i,
  operator: /[<>]=?|[!=]=?=?|--?|\+\+?|&&?|\|\|?|[?*/~^%]/,
  punctuation: /[{}[\];(),.:]/
};
Prism.languages.javascript = Prism.languages.extend('clike', {
  'class-name': [Prism.languages.clike['class-name'], {
    pattern: /(^|[^$\w\xA0-\uFFFF])[_$A-Z\xA0-\uFFFF][$\w\xA0-\uFFFF]*(?=\.(?:prototype|constructor))/,
    lookbehind: !0
  }],
  keyword: [{
    pattern: /((?:^|})\s*)(?:catch|finally)\b/,
    lookbehind: !0
  }, {
    pattern: /(^|[^.]|\.\.\.\s*)\b(?:as|async(?=\s*(?:function\b|\(|[$\w\xA0-\uFFFF]|$))|await|break|case|class|const|continue|debugger|default|delete|do|else|enum|export|extends|for|from|function|(?:get|set)(?=\s*[\[$\w\xA0-\uFFFF])|if|implements|import|in|instanceof|interface|let|new|null|of|package|private|protected|public|return|static|super|switch|this|throw|try|typeof|undefined|var|void|while|with|yield)\b/,
    lookbehind: !0
  }],
  number: /\b(?:(?:0[xX](?:[\dA-Fa-f](?:_[\dA-Fa-f])?)+|0[bB](?:[01](?:_[01])?)+|0[oO](?:[0-7](?:_[0-7])?)+)n?|(?:\d(?:_\d)?)+n|NaN|Infinity)\b|(?:\b(?:\d(?:_\d)?)+\.?(?:\d(?:_\d)?)*|\B\.(?:\d(?:_\d)?)+)(?:[Ee][+-]?(?:\d(?:_\d)?)+)?/,
  "function": /#?[_$a-zA-Z\xA0-\uFFFF][$\w\xA0-\uFFFF]*(?=\s*(?:\.\s*(?:apply|bind|call)\s*)?\()/,
  operator: /--|\+\+|\*\*=?|=>|&&=?|\|\|=?|[!=]==|<<=?|>>>?=?|[-+*/%&|^!=<>]=?|\.{3}|\?\?=?|\?\.?|[~:]/
}), Prism.languages.javascript['class-name'][0].pattern = /(\b(?:class|interface|extends|implements|instanceof|new)\s+)[\w.\\]+/, Prism.languages.insertBefore('javascript', 'keyword', {
  regex: {
    pattern: /((?:^|[^$\w\xA0-\uFFFF."'\])\s]|\b(?:return|yield))\s*)\/(?:\[(?:[^\]\\\r\n]|\\.)*]|\\.|[^/\\\[\r\n])+\/[gimyus]{0,6}(?=(?:\s|\/\*(?:[^*]|\*(?!\/))*\*\/)*(?:$|[\r\n,.;:})\]]|\/\/))/,
    lookbehind: !0,
    greedy: !0,
    inside: {
      'regex-source': {
        pattern: /^(\/)[\s\S]+(?=\/[a-z]*$)/,
        lookbehind: !0,
        alias: 'language-regex',
        inside: Prism.languages.regex
      },
      'regex-flags': /[a-z]+$/,
      'regex-delimiter': /^\/|\/$/
    }
  },
  'function-variable': {
    pattern: /#?[_$a-zA-Z\xA0-\uFFFF][$\w\xA0-\uFFFF]*(?=\s*[=:]\s*(?:async\s*)?(?:\bfunction\b|(?:\((?:[^()]|\([^()]*\))*\)|[_$a-zA-Z\xA0-\uFFFF][$\w\xA0-\uFFFF]*)\s*=>))/,
    alias: 'function'
  },
  parameter: [{
    pattern: /(function(?:\s+[_$A-Za-z\xA0-\uFFFF][$\w\xA0-\uFFFF]*)?\s*\(\s*)(?!\s)(?:[^()]|\([^()]*\))+?(?=\s*\))/,
    lookbehind: !0,
    inside: Prism.languages.javascript
  }, {
    pattern: /[_$a-z\xA0-\uFFFF][$\w\xA0-\uFFFF]*(?=\s*=>)/i,
    inside: Prism.languages.javascript
  }, {
    pattern: /(\(\s*)(?!\s)(?:[^()]|\([^()]*\))+?(?=\s*\)\s*=>)/,
    lookbehind: !0,
    inside: Prism.languages.javascript
  }, {
    pattern: /((?:\b|\s|^)(?!(?:as|async|await|break|case|catch|class|const|continue|debugger|default|delete|do|else|enum|export|extends|finally|for|from|function|get|if|implements|import|in|instanceof|interface|let|new|null|of|package|private|protected|public|return|set|static|super|switch|this|throw|try|typeof|undefined|var|void|while|with|yield)(?![$\w\xA0-\uFFFF]))(?:[_$A-Za-z\xA0-\uFFFF][$\w\xA0-\uFFFF]*\s*)\(\s*|\]\s*\(\s*)(?!\s)(?:[^()]|\([^()]*\))+?(?=\s*\)\s*\{)/,
    lookbehind: !0,
    inside: Prism.languages.javascript
  }],
  constant: /\b[A-Z](?:[A-Z_]|\dx?)*\b/
}), Prism.languages.insertBefore('javascript', 'string', {
  'template-string': {
    pattern: /`(?:\\[\s\S]|\${(?:[^{}]|{(?:[^{}]|{[^}]*})*})+}|(?!\${)[^\\`])*`/,
    greedy: !0,
    inside: {
      'template-punctuation': {
        pattern: /^`|`$/,
        alias: 'string'
      },
      interpolation: {
        pattern: /((?:^|[^\\])(?:\\{2})*)\${(?:[^{}]|{(?:[^{}]|{[^}]*})*})+}/,
        lookbehind: !0,
        inside: {
          'interpolation-punctuation': {
            pattern: /^\${|}$/,
            alias: 'punctuation'
          },
          rest: Prism.languages.javascript
        }
      },
      string: /[\s\S]+/
    }
  }
}), Prism.languages.markup && Prism.languages.markup.tag.addInlined('script', 'javascript'), Prism.languages.js = Prism.languages.javascript;
Prism.languages.json = {
  property: {
    pattern: /"(?:\\.|[^\\"\r\n])*"(?=\s*:)/,
    greedy: !0
  },
  string: {
    pattern: /"(?:\\.|[^\\"\r\n])*"(?!\s*:)/,
    greedy: !0
  },
  comment: {
    pattern: /\/\/.*|\/\*[\s\S]*?(?:\*\/|$)/,
    greedy: !0
  },
  number: /-?\b\d+(?:\.\d+)?(?:e[+-]?\d+)?\b/i,
  punctuation: /[{}[\],]/,
  operator: /:/,
  "boolean": /\b(?:true|false)\b/,
  "null": {
    pattern: /\bnull\b/,
    alias: 'keyword'
  }
}, Prism.languages.webmanifest = Prism.languages.json;
!function (e) {
  e.languages.sass = e.languages.extend('css', {
    comment: {
      pattern: /^([ \t]*)\/[\/*].*(?:(?:\r?\n|\r)\1[ \t]+.+)*/m,
      lookbehind: !0
    }
  }), e.languages.insertBefore('sass', 'atrule', {
    'atrule-line': {
      pattern: /^(?:[ \t]*)[@+=].+/m,
      inside: {
        atrule: /(?:@[\w-]+|[+=])/m
      }
    }
  }), delete e.languages.sass.atrule;
  var t = /\$[-\w]+|#\{\$[-\w]+\}/,
      a = [/[+*\/%]|[=!]=|<=?|>=?|\b(?:and|or|not)\b/, {
    pattern: /(\s+)-(?=\s)/,
    lookbehind: !0
  }];
  e.languages.insertBefore('sass', 'property', {
    'variable-line': {
      pattern: /^[ \t]*\$.+/m,
      inside: {
        punctuation: /:/,
        variable: t,
        operator: a
      }
    },
    'property-line': {
      pattern: /^[ \t]*(?:[^:\s]+ *:.*|:[^:\s]+.*)/m,
      inside: {
        property: [/[^:\s]+(?=\s*:)/, {
          pattern: /(:)[^:\s]+/,
          lookbehind: !0
        }],
        punctuation: /:/,
        variable: t,
        operator: a,
        important: e.languages.sass.important
      }
    }
  }), delete e.languages.sass.property, delete e.languages.sass.important, e.languages.insertBefore('sass', 'punctuation', {
    selector: {
      pattern: /([ \t]*)\S(?:,[^,\r\n]+|[^,\r\n]*)(?:,[^,\r\n]+)*(?:,(?:\r?\n|\r)\1[ \t]+\S(?:,[^,\r\n]+|[^,\r\n]*)(?:,[^,\r\n]+)*)*/,
      lookbehind: !0
    }
  });
}(Prism);
Prism.languages.scss = Prism.languages.extend('css', {
  comment: {
    pattern: /(^|[^\\])(?:\/\*[\s\S]*?\*\/|\/\/.*)/,
    lookbehind: !0
  },
  atrule: {
    pattern: /@[\w-]+(?:\([^()]+\)|[^(])*?(?=\s+[{;])/,
    inside: {
      rule: /@[\w-]+/
    }
  },
  url: /(?:[-a-z]+-)?url(?=\()/i,
  selector: {
    pattern: /(?=\S)[^@;{}()]?(?:[^@;{}()]|#\{\$[-\w]+\})+(?=\s*\{(?:\}|\s|[^}]+[:{][^}]+))/m,
    inside: {
      parent: {
        pattern: /&/,
        alias: 'important'
      },
      placeholder: /%[-\w]+/,
      variable: /\$[-\w]+|#\{\$[-\w]+\}/
    }
  },
  property: {
    pattern: /(?:[-\w]|\$[-\w]|#\{\$[-\w]+\})+(?=\s*:)/,
    inside: {
      variable: /\$[-\w]+|#\{\$[-\w]+\}/
    }
  }
}), Prism.languages.insertBefore('scss', 'atrule', {
  keyword: [/@(?:if|else(?: if)?|forward|for|each|while|import|use|extend|debug|warn|mixin|include|function|return|content)\b/i, {
    pattern: /( +)(?:from|through)(?= )/,
    lookbehind: !0
  }]
}), Prism.languages.insertBefore('scss', 'important', {
  variable: /\$[-\w]+|#\{\$[-\w]+\}/
}), Prism.languages.insertBefore('scss', 'function', {
  'module-modifier': {
    pattern: /\b(?:as|with|show|hide)\b/i,
    alias: 'keyword'
  },
  placeholder: {
    pattern: /%[-\w]+/,
    alias: 'selector'
  },
  statement: {
    pattern: /\B!(?:default|optional)\b/i,
    alias: 'keyword'
  },
  "boolean": /\b(?:true|false)\b/,
  "null": {
    pattern: /\bnull\b/,
    alias: 'keyword'
  },
  operator: {
    pattern: /(\s)(?:[-+*\/%]|[=!]=|<=?|>=?|and|or|not)(?=\s)/,
    lookbehind: !0
  }
}), Prism.languages.scss.atrule.inside.rest = Prism.languages.scss;
!function (e) {
  e.languages.typescript = e.languages.extend('javascript', {
    'class-name': {
      pattern: /(\b(?:class|extends|implements|instanceof|interface|new|type)\s+)(?!keyof\b)[_$a-zA-Z\xA0-\uFFFF][$\w\xA0-\uFFFF]*(?:\s*<(?:[^<>]|<(?:[^<>]|<[^<>]*>)*>)*>)?/,
      lookbehind: !0,
      greedy: !0,
      inside: null
    },
    keyword: /\b(?:abstract|as|asserts|async|await|break|case|catch|class|const|constructor|continue|debugger|declare|default|delete|do|else|enum|export|extends|finally|for|from|function|get|if|implements|import|in|instanceof|interface|is|keyof|let|module|namespace|new|null|of|package|private|protected|public|readonly|return|require|set|static|super|switch|this|throw|try|type|typeof|undefined|var|void|while|with|yield)\b/,
    builtin: /\b(?:string|Function|any|number|boolean|Array|symbol|console|Promise|unknown|never)\b/
  }), delete e.languages.typescript.parameter;
  var n = e.languages.extend('typescript', {});
  delete n['class-name'], e.languages.typescript['class-name'].inside = n, e.languages.insertBefore('typescript', 'function', {
    'generic-function': {
      pattern: /#?[_$a-zA-Z\xA0-\uFFFF][$\w\xA0-\uFFFF]*\s*<(?:[^<>]|<(?:[^<>]|<[^<>]*>)*>)*>(?=\s*\()/,
      greedy: !0,
      inside: {
        "function": /^#?[_$a-zA-Z\xA0-\uFFFF][$\w\xA0-\uFFFF]*/,
        generic: {
          pattern: /<[\s\S]+/,
          alias: 'class-name',
          inside: n
        }
      }
    }
  }), e.languages.ts = e.languages.typescript;
}(Prism);
!function (E) {
  var n = /\b(?:ACT|ACTIFSUB|CARRAY|CASE|CLEARGIF|COA|COA_INT|CONSTANTS|CONTENT|CUR|EDITPANEL|EFFECT|EXT|FILE|FLUIDTEMPLATE|FORM|FRAME|FRAMESET|GIFBUILDER|GMENU|GMENU_FOLDOUT|GMENU_LAYERS|GP|HMENU|HRULER|HTML|IENV|IFSUB|IMAGE|IMGMENU|IMGMENUITEM|IMGTEXT|IMG_RESOURCE|INCLUDE_TYPOSCRIPT|JSMENU|JSMENUITEM|LLL|LOAD_REGISTER|NO|PAGE|RECORDS|RESTORE_REGISTER|TEMPLATE|TEXT|TMENU|TMENUITEM|TMENU_LAYERS|USER|USER_INT|_GIFBUILDER|global|globalString|globalVar)\b/;
  E.languages.typoscript = {
    comment: [{
      pattern: /(^|[^\\])\/\*[\s\S]*?(?:\*\/|$)/,
      lookbehind: !0
    }, {
      pattern: /(^|[^\\:= \t]|(?:^|[^= \t])[ \t]+)\/\/.*/,
      lookbehind: !0,
      greedy: !0
    }, {
      pattern: /(^|[^"'])#.*/,
      lookbehind: !0,
      greedy: !0
    }],
    "function": [{
      pattern: /<INCLUDE_TYPOSCRIPT:\s*source\s*=\s*(?:"[^"\r\n]*"|'[^'\r\n]*')\s*>/,
      inside: {
        string: {
          pattern: /"[^"\r\n]*"|'[^'\r\n]*'/,
          inside: {
            keyword: n
          }
        },
        keyword: {
          pattern: /INCLUDE_TYPOSCRIPT/
        }
      }
    }, {
      pattern: /@import\s*(?:"[^"\r\n]*"|'[^'\r\n]*')/,
      inside: {
        string: /"[^"\r\n]*"|'[^'\r\n]*'/
      }
    }],
    string: {
      pattern: /^([^=]*=[< ]?)(?:(?!]\n).)*/,
      lookbehind: !0,
      inside: {
        "function": /{\$.*}/,
        keyword: n,
        number: /^[0-9]+$/,
        punctuation: /[,|:]/
      }
    },
    keyword: n,
    number: {
      pattern: /[0-9]+\s*[.{=]/,
      inside: {
        operator: /[.{=]/
      }
    },
    tag: {
      pattern: /\.?[\w-\\]+\.?/,
      inside: {
        punctuation: /\./
      }
    },
    punctuation: /[{}[\];(),.:|]/,
    operator: /[<>]=?|[!=]=?=?|--?|\+\+?|&&?|\|\|?|[?*/~^%]/
  }, E.languages.tsconfig = E.languages.typoscript;
}(Prism);
!function () {
  if ('undefined' != typeof self && self.Prism && self.document) {
    var o = 'line-numbers',
        a = /\n(?!$)/g,
        e = Prism.plugins.lineNumbers = {
      getLine: function getLine(e, n) {
        if ('PRE' === e.tagName && e.classList.contains(o)) {
          var t = e.querySelector('.line-numbers-rows');

          if (t) {
            var i = parseInt(e.getAttribute('data-start'), 10) || 1,
                r = i + (t.children.length - 1);
            n < i && (n = i), r < n && (n = r);
            var s = n - i;
            return t.children[s];
          }
        }
      },
      resize: function resize(e) {
        u([e]);
      },
      assumeViewportIndependence: !0
    },
        t = function t(e) {
      return e ? window.getComputedStyle ? getComputedStyle(e) : e.currentStyle || null : null;
    },
        n = void 0;

    window.addEventListener('resize', function () {
      e.assumeViewportIndependence && n === window.innerWidth || (n = window.innerWidth, u(Array.prototype.slice.call(document.querySelectorAll('pre.' + o))));
    }), Prism.hooks.add('complete', function (e) {
      if (e.code) {
        var n = e.element,
            t = n.parentNode;

        if (t && /pre/i.test(t.nodeName) && !n.querySelector('.line-numbers-rows') && Prism.util.isActive(n, o)) {
          n.classList.remove(o), t.classList.add(o);
          var i,
              r = e.code.match(a),
              s = r ? r.length + 1 : 1,
              l = new Array(s + 1).join('<span></span>');
          (i = document.createElement('span')).setAttribute('aria-hidden', 'true'), i.className = 'line-numbers-rows', i.innerHTML = l, t.hasAttribute('data-start') && (t.style.counterReset = 'linenumber ' + (parseInt(t.getAttribute('data-start'), 10) - 1)), e.element.appendChild(i), u([t]), Prism.hooks.run('line-numbers', e);
        }
      }
    }), Prism.hooks.add('line-numbers', function (e) {
      e.plugins = e.plugins || {}, e.plugins.lineNumbers = !0;
    });
  }

  function u(e) {
    if (0 != (e = e.filter(function (e) {
      var n = t(e)['white-space'];
      return 'pre-wrap' === n || 'pre-line' === n;
    })).length) {
      var n = e.map(function (e) {
        var n = e.querySelector('code'),
            t = e.querySelector('.line-numbers-rows');

        if (n && t) {
          var i = e.querySelector('.line-numbers-sizer'),
              r = n.textContent.split(a);
          i || ((i = document.createElement('span')).className = 'line-numbers-sizer', n.appendChild(i)), i.innerHTML = '0', i.style.display = 'block';
          var s = i.getBoundingClientRect().height;
          return i.innerHTML = '', {
            element: e,
            lines: r,
            lineHeights: [],
            oneLinerHeight: s,
            sizer: i
          };
        }
      }).filter(Boolean);
      n.forEach(function (e) {
        var i = e.sizer,
            n = e.lines,
            r = e.lineHeights,
            s = e.oneLinerHeight;
        r[n.length - 1] = void 0, n.forEach(function (e, n) {
          if (e && 1 < e.length) {
            var t = i.appendChild(document.createElement('span'));
            t.style.display = 'block', t.textContent = e;
          } else r[n] = s;
        });
      }), n.forEach(function (e) {
        for (var n = e.sizer, t = e.lineHeights, i = 0, r = 0; r < t.length; r++) {
          void 0 === t[r] && (t[r] = n.children[i++].getBoundingClientRect().height);
        }
      }), n.forEach(function (e) {
        var n = e.sizer,
            t = e.element.querySelector('.line-numbers-rows');
        n.style.display = 'none', n.innerHTML = '', e.lineHeights.forEach(function (e, n) {
          t.children[n].style.height = e + 'px';
        });
      });
    }
  }
}();

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.i);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }


const isPrefreshComponent = __prefresh_utils__.shouldBind(module);

  if (true) {
    const currentExports = __prefresh_utils__.getExports(module);
    const previousHotModuleExports =
      module.hot.data && module.hot.data.moduleExports;

    __prefresh_utils__.registerExports(currentExports, module.i);

    if (isPrefreshComponent) {
      if (previousHotModuleExports) {
        try {
          __prefresh_utils__.flush();
          if (
            typeof __prefresh_errors__ !== 'undefined' &&
            __prefresh_errors__ &&
            __prefresh_errors__.clearRuntimeErrors
          ) {
            __prefresh_errors__.clearRuntimeErrors();
          }
        } catch (e) {
          // Only available in newer webpack versions.
          if (module.hot.invalidate) {
            module.hot.invalidate();
          } else {
            self.location.reload();
          }
        }
      }

      module.hot.dispose(data => {
        data.moduleExports = __prefresh_utils__.getExports(module);
      });

      module.hot.accept(function errorRecovery() {
        if (
          typeof __prefresh_errors__ !== 'undefined' &&
          __prefresh_errors__ &&
          __prefresh_errors__.handleRuntimeError
        ) {
          __prefresh_errors__.handleRuntimeError(error);
        }

        __webpack_require__.c[module.i].hot.accept(errorRecovery);
      });
    }
  }
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../node_modules/next/dist/compiled/webpack/global.js */ "./node_modules/next/dist/compiled/webpack/global.js"), __webpack_require__(/*! ./../node_modules/next/dist/compiled/webpack/module.js */ "./node_modules/next/dist/compiled/webpack/module.js")(module), __webpack_require__(/*! ./node_modules/@prefresh/webpack/src/utils/prefresh.js */ "./node_modules/@prefresh/webpack/src/utils/prefresh.js")))

/***/ }),

/***/ 4:
/*!***************************************************************************************************************************************************************************************!*\
  !*** multi ./node_modules/@prefresh/core/src/index.js next-client-pages-loader?page=%2F_app&absolutePagePath=private-next-pages%2F_app.tsx ./node_modules/next/dist/client/router.js ***!
  \***************************************************************************************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(/*! C:\Users\admin\Documents\Dev\PWAdvent\node_modules\@prefresh\core\src\index.js */"./node_modules/@prefresh/core/src/index.js");
__webpack_require__(/*! next-client-pages-loader?page=%2F_app&absolutePagePath=private-next-pages%2F_app.tsx! */"./node_modules/next/dist/build/webpack/loaders/next-client-pages-loader.js?page=%2F_app&absolutePagePath=private-next-pages%2F_app.tsx!./");
module.exports = __webpack_require__(/*! C:\Users\admin\Documents\Dev\PWAdvent\node_modules\next\dist\client\router.js */"./node_modules/next/dist/client/router.js");


/***/ })

},[[4,"webpack"]]]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vY29tcG9uZW50cy9BYm91dC9BYm91dC5tb2R1bGUuY3NzPzhkNTMiLCJ3ZWJwYWNrOi8vX05fRS8uL2NvbXBvbmVudHMvQWJvdXQvQWJvdXQudHN4Iiwid2VicGFjazovL19OX0UvLi9jb21wb25lbnRzL0Fib3V0L0Fib3V0Q29udHJvbHMubW9kdWxlLmNzcz8wMWJiIiwid2VicGFjazovL19OX0UvLi9jb21wb25lbnRzL0Fib3V0L0Fib3V0Q29udHJvbHMudHN4Iiwid2VicGFjazovL19OX0UvLi9jb21wb25lbnRzL0Fib3V0L0Fib3V0TmF2aWdhdGlvbi5tb2R1bGUuY3NzP2I3MGMiLCJ3ZWJwYWNrOi8vX05fRS8uL2NvbXBvbmVudHMvQWJvdXQvQWJvdXROYXZpZ2F0aW9uLnRzeCIsIndlYnBhY2s6Ly9fTl9FLy4vY29tcG9uZW50cy9BYm91dC9FbWFpbFNpZ251cC5tb2R1bGUuY3NzPzNkMjgiLCJ3ZWJwYWNrOi8vX05fRS8uL2NvbXBvbmVudHMvQWJvdXQvRW1haWxTaWdudXAudHN4Iiwid2VicGFjazovL19OX0UvLi9jb21wb25lbnRzL0Fib3V0L1B1c2hOb3RpZmljYXRpb25zLm1vZHVsZS5jc3M/MGFiNCIsIndlYnBhY2s6Ly9fTl9FLy4vY29tcG9uZW50cy9BYm91dC9QdXNoTm90aWZpY2F0aW9ucy50c3giLCJ3ZWJwYWNrOi8vX05fRS8uL2NvbXBvbmVudHMvQ2FsZW5kYXIvQ2FsZW5kYXIubW9kdWxlLmNzcz85OTA1Iiwid2VicGFjazovL19OX0UvLi9jb21wb25lbnRzL0NhbGVuZGFyL0NhbGVuZGFyLnRzeCIsIndlYnBhY2s6Ly9fTl9FLy4vY29tcG9uZW50cy9DYWxlbmRhci9DYWxlbmRhckRheS5tb2R1bGUuY3NzPzhhMGEiLCJ3ZWJwYWNrOi8vX05fRS8uL2NvbXBvbmVudHMvQ2FsZW5kYXIvQ2FsZW5kYXJEYXkudHN4Iiwid2VicGFjazovL19OX0UvLi9jb21wb25lbnRzL0NhbGVuZGFyL0NhbGVuZGFyRGF5TGlzdC5tb2R1bGUuY3NzPzk0MzMiLCJ3ZWJwYWNrOi8vX05fRS8uL2NvbXBvbmVudHMvQ2FsZW5kYXIvQ2FsZW5kYXJEYXlMaXN0LnRzeCIsIndlYnBhY2s6Ly9fTl9FLy4vY29tcG9uZW50cy9DYWxlbmRhci9DYWxlbmRhckhlYWRlci5tb2R1bGUuY3NzP2JhOWIiLCJ3ZWJwYWNrOi8vX05fRS8uL2NvbXBvbmVudHMvQ2FsZW5kYXIvQ2FsZW5kYXJIZWFkZXIudHN4Iiwid2VicGFjazovL19OX0UvLi9jb21wb25lbnRzL0NvbnRlbnQvQ29udGVudC50c3giLCJ3ZWJwYWNrOi8vX05fRS8uL2NvbXBvbmVudHMvQ29udGVudC9Db250ZW50QXV0aG9yLm1vZHVsZS5jc3M/M2UwNCIsIndlYnBhY2s6Ly9fTl9FLy4vY29tcG9uZW50cy9Db250ZW50L0NvbnRlbnRBdXRob3IudHN4Iiwid2VicGFjazovL19OX0UvLi9jb21wb25lbnRzL0NvbnRlbnQvQ29udGVudENhbGVuZGFyLm1vZHVsZS5jc3M/MjMwNiIsIndlYnBhY2s6Ly9fTl9FLy4vY29tcG9uZW50cy9Db250ZW50L0NvbnRlbnRDYWxlbmRhci50c3giLCJ3ZWJwYWNrOi8vX05fRS8uL2NvbXBvbmVudHMvQ29udGVudC9Db250ZW50UGFnZS50c3giLCJ3ZWJwYWNrOi8vX05fRS8uL2NvbXBvbmVudHMvaG9va3MvdXNlV2luZG93U2l6ZS50c3giLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2FycmF5TGlrZVRvQXJyYXkuanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2FycmF5V2l0aEhvbGVzLmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9hcnJheVdpdGhvdXRIb2xlcy5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvYXNzZXJ0VGhpc0luaXRpYWxpemVkLmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9hc3luY1RvR2VuZXJhdG9yLmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9jbGFzc0NhbGxDaGVjay5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvY29uc3RydWN0LmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9jcmVhdGVDbGFzcy5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvZGVmaW5lUHJvcGVydHkuanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9hcnJheUxpa2VUb0FycmF5LmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vYXJyYXlXaXRoSG9sZXMuanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9hcnJheVdpdGhvdXRIb2xlcy5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL2FzeW5jVG9HZW5lcmF0b3IuanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9kZWZpbmVQcm9wZXJ0eS5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL2V4dGVuZHMuanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9pdGVyYWJsZVRvQXJyYXkuanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9pdGVyYWJsZVRvQXJyYXlMaW1pdC5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL25vbkl0ZXJhYmxlUmVzdC5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL25vbkl0ZXJhYmxlU3ByZWFkLmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vb2JqZWN0V2l0aG91dFByb3BlcnRpZXMuanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlLmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vc2xpY2VkVG9BcnJheS5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL3RvQ29uc3VtYWJsZUFycmF5LmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkuanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2dldFByb3RvdHlwZU9mLmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9pbmhlcml0cy5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvaW50ZXJvcFJlcXVpcmVEZWZhdWx0LmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkLmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QuanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2l0ZXJhYmxlVG9BcnJheS5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvaXRlcmFibGVUb0FycmF5TGltaXQuanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL25vbkl0ZXJhYmxlUmVzdC5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvbm9uSXRlcmFibGVTcHJlYWQuanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4uanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL3NldFByb3RvdHlwZU9mLmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9zbGljZWRUb0FycmF5LmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy90b0NvbnN1bWFibGVBcnJheS5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvdHlwZW9mLmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheS5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL3JlZ2VuZXJhdG9yL2luZGV4LmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQHByZWZyZXNoL2NvcmUvc3JjL2NvbXB1dGVLZXkuanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9AcHJlZnJlc2gvY29yZS9zcmMvY29uc3RhbnRzLmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQHByZWZyZXNoL2NvcmUvc3JjL2luZGV4LmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQHByZWZyZXNoL2NvcmUvc3JjL3J1bnRpbWUvY2F0Y2hFcnJvci5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0BwcmVmcmVzaC9jb3JlL3NyYy9ydW50aW1lL2RlYm91bmNlUmVuZGVyaW5nLmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQHByZWZyZXNoL2NvcmUvc3JjL3J1bnRpbWUvc2lnbmF0dXJlc0ZvclR5cGUuanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9AcHJlZnJlc2gvY29yZS9zcmMvcnVudGltZS91bm1vdW50LmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQHByZWZyZXNoL2NvcmUvc3JjL3J1bnRpbWUvdm5vZGUuanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9AcHJlZnJlc2gvY29yZS9zcmMvcnVudGltZS92bm9kZXNGb3JDb21wb25lbnQuanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9AcHJlZnJlc2gvdXRpbHMvc3JjL2luZGV4LmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQHByZWZyZXNoL3dlYnBhY2svc3JjL3V0aWxzL3ByZWZyZXNoLmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvZGF5anMvZGF5anMubWluLmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvZGF5anMvcGx1Z2luL2xvY2FsaXplZEZvcm1hdC5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2RheWpzL3BsdWdpbi90aW1lem9uZS5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2RheWpzL3BsdWdpbi91dGMuanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9pZGIvYnVpbGQvZXNtL2luZGV4LmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvaWRiL2J1aWxkL2VzbS93cmFwLWlkYi12YWx1ZS5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9idWlsZC93ZWJwYWNrL2xvYWRlcnMvbmV4dC1jbGllbnQtcGFnZXMtbG9hZGVyLmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2J1aWxkL3dlYnBhY2svbG9hZGVycy9uZXh0LXN0eWxlLWxvYWRlci9ydW50aW1lL2luamVjdFN0eWxlc0ludG9TdHlsZVRhZy5qcyIsIndlYnBhY2s6Ly9fTl9FLy4uLy4uL2NsaWVudC9saW5rLnRzeCIsIndlYnBhY2s6Ly9fTl9FLy4uLy4uL2NsaWVudC9ub3JtYWxpemUtdHJhaWxpbmctc2xhc2gudHMiLCJ3ZWJwYWNrOi8vX05fRS8uLi8uLi9jbGllbnQvcmVxdWVzdC1pZGxlLWNhbGxiYWNrLnRzIiwid2VicGFjazovL19OX0UvLi4vLi4vY2xpZW50L3JvdXRlLWxvYWRlci50cyIsIndlYnBhY2s6Ly9fTl9FLy4uLy4uL2NsaWVudC9yb3V0ZXIudHMiLCJ3ZWJwYWNrOi8vX05fRS8uLi8uLi9jbGllbnQvdXNlLWludGVyc2VjdGlvbi50c3giLCJ3ZWJwYWNrOi8vX05fRS8uLi8uLi9jbGllbnQvd2l0aC1yb3V0ZXIudHN4Iiwid2VicGFjazovL19OX0UvKHdlYnBhY2spL2Nzcy1sb2FkZXIvYXBpLmpzIiwid2VicGFjazovL19OX0UvLi9jb21wb25lbnRzL0Fib3V0L0Fib3V0Lm1vZHVsZS5jc3MiLCJ3ZWJwYWNrOi8vX05fRS8uL2NvbXBvbmVudHMvQWJvdXQvQWJvdXRDb250cm9scy5tb2R1bGUuY3NzIiwid2VicGFjazovL19OX0UvLi9jb21wb25lbnRzL0Fib3V0L0Fib3V0TmF2aWdhdGlvbi5tb2R1bGUuY3NzIiwid2VicGFjazovL19OX0UvLi9jb21wb25lbnRzL0Fib3V0L0VtYWlsU2lnbnVwLm1vZHVsZS5jc3MiLCJ3ZWJwYWNrOi8vX05fRS8uL2NvbXBvbmVudHMvQWJvdXQvUHVzaE5vdGlmaWNhdGlvbnMubW9kdWxlLmNzcyIsIndlYnBhY2s6Ly9fTl9FLy4vY29tcG9uZW50cy9DYWxlbmRhci9DYWxlbmRhci5tb2R1bGUuY3NzIiwid2VicGFjazovL19OX0UvLi9jb21wb25lbnRzL0NhbGVuZGFyL0NhbGVuZGFyRGF5Lm1vZHVsZS5jc3MiLCJ3ZWJwYWNrOi8vX05fRS8uL2NvbXBvbmVudHMvQ2FsZW5kYXIvQ2FsZW5kYXJEYXlMaXN0Lm1vZHVsZS5jc3MiLCJ3ZWJwYWNrOi8vX05fRS8uL2NvbXBvbmVudHMvQ2FsZW5kYXIvQ2FsZW5kYXJIZWFkZXIubW9kdWxlLmNzcyIsIndlYnBhY2s6Ly9fTl9FLy4vY29tcG9uZW50cy9Db250ZW50L0NvbnRlbnRBdXRob3IubW9kdWxlLmNzcyIsIndlYnBhY2s6Ly9fTl9FLy4vY29tcG9uZW50cy9Db250ZW50L0NvbnRlbnRDYWxlbmRhci5tb2R1bGUuY3NzIiwid2VicGFjazovL19OX0UvLi9wYWdlcy9fYXBwLmNzcyIsIndlYnBhY2s6Ly9fTl9FLy4vc3R5bGVzL2NvbG9ycy5jc3MiLCJ3ZWJwYWNrOi8vX05fRS8uL3N0eWxlcy9kb2N1bWVudC5jc3MiLCJ3ZWJwYWNrOi8vX05fRS8uL3N0eWxlcy9mb250cy9mb250LXdvZmYyLmNzcyIsIndlYnBhY2s6Ly9fTl9FLy4vc3R5bGVzL2dyaWQuY3NzIiwid2VicGFjazovL19OX0UvLi9zdHlsZXMva2V5ZnJhbWVzL3NwaW5uZXIuY3NzIiwid2VicGFjazovL19OX0UvLi9zdHlsZXMvcmVzZXQuY3NzIiwid2VicGFjazovL19OX0UvLi9zdHlsZXMvdHlwb2dyYXBoeS5jc3MiLCJ3ZWJwYWNrOi8vX05fRS8uL3N0eWxlcy92YXJzLmNzcyIsIndlYnBhY2s6Ly9fTl9FLy4vdGhlbWUvQnV0dG9uL0J1dHRvbi5tb2R1bGUuY3NzIiwid2VicGFjazovL19OX0UvLi90aGVtZS9DbG9zZUJ1dHRvbi9DbG9zZUJ1dHRvbi5tb2R1bGUuY3NzIiwid2VicGFjazovL19OX0UvLi90aGVtZS9Db250ZW50TW9kYWwvQ29udGVudE1vZGFsLm1vZHVsZS5jc3MiLCJ3ZWJwYWNrOi8vX05fRS8uL3RoZW1lL0Zvcm0vRm9ybUNvbnRyb2xzLm1vZHVsZS5jc3MiLCJ3ZWJwYWNrOi8vX05fRS8uL3RoZW1lL0Zvcm0vRm9ybUZpZWxkc2V0Lm1vZHVsZS5jc3MiLCJ3ZWJwYWNrOi8vX05fRS8uL3RoZW1lL0Zvcm0vSW5wdXQubW9kdWxlLmNzcyIsIndlYnBhY2s6Ly9fTl9FLy4vdGhlbWUvSW1hZ2UvTGF6eUltYWdlLm1vZHVsZS5jc3MiLCJ3ZWJwYWNrOi8vX05fRS8uL3RoZW1lL0xvYWRlci9Mb2FkZXIubW9kdWxlLmNzcyIsIndlYnBhY2s6Ly9fTl9FLy4vdGhlbWUvTG9nby9Mb2dvLm1vZHVsZS5jc3MiLCJ3ZWJwYWNrOi8vX05fRS8uL3RoZW1lL01pc2MvTm90aWZpY2F0aW9uLm1vZHVsZS5jc3MiLCJ3ZWJwYWNrOi8vX05fRS8uL3RoZW1lL01pc2MvU25vdy5tb2R1bGUuY3NzIiwid2VicGFjazovL19OX0UvLi90aGVtZS9TVkcvSWNvbi5tb2R1bGUuY3NzIiwid2VicGFjazovL19OX0UvLi90aGVtZS9TVkcvU1ZHLm1vZHVsZS5jc3MiLCJ3ZWJwYWNrOi8vX05fRS8uL3RoZW1lL1NoYWRvd0JveC9TaGFkb3dCb3gubW9kdWxlLmNzcyIsIndlYnBhY2s6Ly9fTl9FLyh3ZWJwYWNrKS93ZWJwYWNrL2dsb2JhbC5qcyIsIndlYnBhY2s6Ly9fTl9FLyh3ZWJwYWNrKS93ZWJwYWNrL2hhcm1vbnktbW9kdWxlLmpzIiwid2VicGFjazovL19OX0UvKHdlYnBhY2spL3dlYnBhY2svbW9kdWxlLmpzIiwid2VicGFjazovL19OX0UvLi4vLi4vLi4vbmV4dC1zZXJ2ZXIvbGliL2FtcC1jb250ZXh0LnRzIiwid2VicGFjazovL19OX0UvLi4vLi4vLi4vbmV4dC1zZXJ2ZXIvbGliL2FtcC50cyIsIndlYnBhY2s6Ly9fTl9FLy4uLy4uLy4uL25leHQtc2VydmVyL2xpYi9oZWFkLW1hbmFnZXItY29udGV4dC50cyIsIndlYnBhY2s6Ly9fTl9FLy4uLy4uLy4uL25leHQtc2VydmVyL2xpYi9oZWFkLnRzeCIsIndlYnBhY2s6Ly9fTl9FLy4uLy4uLy4uLy4uL25leHQtc2VydmVyL2xpYi9pMThuL25vcm1hbGl6ZS1sb2NhbGUtcGF0aC50cyIsIndlYnBhY2s6Ly9fTl9FLy4uLy4uLy4uL25leHQtc2VydmVyL2xpYi9taXR0LnRzIiwid2VicGFjazovL19OX0UvLi4vLi4vLi4vbmV4dC1zZXJ2ZXIvbGliL3JvdXRlci1jb250ZXh0LnRzIiwid2VicGFjazovL19OX0UvLi4vLi4vLi4vLi4vbmV4dC1zZXJ2ZXIvbGliL3JvdXRlci9yb3V0ZXIudHMiLCJ3ZWJwYWNrOi8vX05fRS8uLi8uLi8uLi8uLi8uLi9uZXh0LXNlcnZlci9saWIvcm91dGVyL3V0aWxzL2Zvcm1hdC11cmwudHMiLCJ3ZWJwYWNrOi8vX05fRS8uLi8uLi8uLi8uLi8uLi9uZXh0LXNlcnZlci9saWIvcm91dGVyL3V0aWxzL2dldC1hc3NldC1wYXRoLWZyb20tcm91dGUudHMiLCJ3ZWJwYWNrOi8vX05fRS8uLi8uLi8uLi8uLi8uLi9uZXh0LXNlcnZlci9saWIvcm91dGVyL3V0aWxzL2lzLWR5bmFtaWMudHMiLCJ3ZWJwYWNrOi8vX05fRS8uLi8uLi8uLi8uLi8uLi9uZXh0LXNlcnZlci9saWIvcm91dGVyL3V0aWxzL3BhcnNlLXJlbGF0aXZlLXVybC50cyIsIndlYnBhY2s6Ly9fTl9FLy4uLy4uLy4uLy4uLy4uL25leHQtc2VydmVyL2xpYi9yb3V0ZXIvdXRpbHMvcXVlcnlzdHJpbmcudHMiLCJ3ZWJwYWNrOi8vX05fRS8uLi8uLi8uLi8uLi8uLi9uZXh0LXNlcnZlci9saWIvcm91dGVyL3V0aWxzL3Jlc29sdmUtcmV3cml0ZXMtbm9vcC50cyIsIndlYnBhY2s6Ly9fTl9FLy4uLy4uLy4uLy4uLy4uL25leHQtc2VydmVyL2xpYi9yb3V0ZXIvdXRpbHMvcm91dGUtbWF0Y2hlci50cyIsIndlYnBhY2s6Ly9fTl9FLy4uLy4uLy4uLy4uLy4uL25leHQtc2VydmVyL2xpYi9yb3V0ZXIvdXRpbHMvcm91dGUtcmVnZXgudHMiLCJ3ZWJwYWNrOi8vX05fRS8uLi8uLi8uLi9uZXh0LXNlcnZlci9saWIvc2lkZS1lZmZlY3QudHN4Iiwid2VicGFjazovL19OX0UvLi4vLi4vLi4vbmV4dC1zZXJ2ZXIvbGliL3V0aWxzLnRzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L25leHQtc2VydmVyL3NlcnZlci9kZW5vcm1hbGl6ZS1wYWdlLXBhdGguanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9uZXh0L2hlYWQuanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9uZXh0L2xpbmsuanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9wcmVhY3QvY29tcGF0L2Rpc3QvY29tcGF0Lm1vZHVsZS5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3ByZWFjdC9kaXN0L3ByZWFjdC5tb2R1bGUuanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9wcmVhY3QvaG9va3MvZGlzdC9ob29rcy5tb2R1bGUuanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9wcm9jZXNzL2Jyb3dzZXIuanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9yZWFjdC1ob29rLWZvcm0vZGlzdC9yZWFjdC1ob29rLWZvcm0uZXMuanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9yZWFjdC1pcy9janMvcmVhY3QtaXMuZGV2ZWxvcG1lbnQuanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9yZWFjdC1pcy9pbmRleC5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3JlZ2VuZXJhdG9yLXJ1bnRpbWUvcnVudGltZS5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3VuaXN0b3JlLWhvb2tzL2Rpc3QvdW5pc3RvcmUtaG9va3MubW9kdWxlLmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvdW5pc3RvcmUvZGV2dG9vbHMuanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy91bmlzdG9yZS9kaXN0L3VuaXN0b3JlLmVzLmpzIiwid2VicGFjazovL19OX0UvLi9wYWdlcy9fYXBwLmNzcz81Yjc0Iiwid2VicGFjazovL19OX0UvLi9wYWdlcy9fYXBwLnRzeCIsIndlYnBhY2s6Ly9fTl9FLy4vcHVibGljL2ljb24gZWFnZXIgXlxcLlxcLy4qJCBuYW1lc3BhY2Ugb2JqZWN0Iiwid2VicGFjazovL19OX0UvLi9zdG9yZS9pZGIudHMiLCJ3ZWJwYWNrOi8vX05fRS8uL3N0b3JlL2luZGV4LnRzIiwid2VicGFjazovL19OX0UvLi90aGVtZS9CdXR0b24vQnV0dG9uLm1vZHVsZS5jc3M/ODY4YSIsIndlYnBhY2s6Ly9fTl9FLy4vdGhlbWUvQnV0dG9uL0J1dHRvbi50c3giLCJ3ZWJwYWNrOi8vX05fRS8uL3RoZW1lL0Nsb3NlQnV0dG9uL0Nsb3NlQnV0dG9uLm1vZHVsZS5jc3M/YzliNyIsIndlYnBhY2s6Ly9fTl9FLy4vdGhlbWUvQ2xvc2VCdXR0b24vQ2xvc2VCdXR0b24udHN4Iiwid2VicGFjazovL19OX0UvLi90aGVtZS9Db250ZW50TW9kYWwvQ29udGVudE1vZGFsLm1vZHVsZS5jc3M/MTM4MyIsIndlYnBhY2s6Ly9fTl9FLy4vdGhlbWUvQ29udGVudE1vZGFsL0NvbnRlbnRNb2RhbC50c3giLCJ3ZWJwYWNrOi8vX05fRS8uL3RoZW1lL0Zvcm0vQ29ubmVjdEZvcm0udHN4Iiwid2VicGFjazovL19OX0UvLi90aGVtZS9Gb3JtL0Zvcm0udHN4Iiwid2VicGFjazovL19OX0UvLi90aGVtZS9Gb3JtL0Zvcm1Db250cm9scy5tb2R1bGUuY3NzP2IyNWUiLCJ3ZWJwYWNrOi8vX05fRS8uL3RoZW1lL0Zvcm0vRm9ybUNvbnRyb2xzLnRzeCIsIndlYnBhY2s6Ly9fTl9FLy4vdGhlbWUvRm9ybS9Gb3JtRmllbGQudHN4Iiwid2VicGFjazovL19OX0UvLi90aGVtZS9Gb3JtL0Zvcm1GaWVsZHNldC5tb2R1bGUuY3NzPzI1ZmIiLCJ3ZWJwYWNrOi8vX05fRS8uL3RoZW1lL0Zvcm0vRm9ybUZpZWxkc2V0LnRzeCIsIndlYnBhY2s6Ly9fTl9FLy4vdGhlbWUvRm9ybS9JbnB1dC5tb2R1bGUuY3NzP2RjNWMiLCJ3ZWJwYWNrOi8vX05fRS8uL3RoZW1lL0Zvcm0vSW5wdXQudHN4Iiwid2VicGFjazovL19OX0UvLi90aGVtZS9Gb3JtL0lucHV0U2VsZWN0LnRzeCIsIndlYnBhY2s6Ly9fTl9FLy4vdGhlbWUvRm9ybS9JbnB1dFRleHQudHN4Iiwid2VicGFjazovL19OX0UvLi90aGVtZS9Gb3JtL0lucHV0VGV4dGFyZWEudHN4Iiwid2VicGFjazovL19OX0UvLi90aGVtZS9JbWFnZS9MYXp5SW1hZ2UubW9kdWxlLmNzcz8wZTdhIiwid2VicGFjazovL19OX0UvLi90aGVtZS9JbWFnZS9MYXp5SW1hZ2UudHN4Iiwid2VicGFjazovL19OX0UvLi90aGVtZS9Mb2FkZXIvTG9hZGVyLm1vZHVsZS5jc3M/OWYxMiIsIndlYnBhY2s6Ly9fTl9FLy4vdGhlbWUvTG9hZGVyL0xvYWRlci50c3giLCJ3ZWJwYWNrOi8vX05fRS8uL3RoZW1lL0xvZ28vTG9nby5tb2R1bGUuY3NzPzRmZmUiLCJ3ZWJwYWNrOi8vX05fRS8uL3RoZW1lL0xvZ28vTG9nby50c3giLCJ3ZWJwYWNrOi8vX05fRS8uL3RoZW1lL01pc2MvTm90aWZpY2F0aW9uLm1vZHVsZS5jc3M/YTE2NyIsIndlYnBhY2s6Ly9fTl9FLy4vdGhlbWUvTWlzYy9Ob3RpZmljYXRpb24udHN4Iiwid2VicGFjazovL19OX0UvLi90aGVtZS9NaXNjL1Nub3cubW9kdWxlLmNzcz9mM2NlIiwid2VicGFjazovL19OX0UvLi90aGVtZS9NaXNjL1Nub3cudHN4Iiwid2VicGFjazovL19OX0UvLi90aGVtZS9TVkcvSWNvbi5tb2R1bGUuY3NzPzRlYzQiLCJ3ZWJwYWNrOi8vX05fRS8uL3RoZW1lL1NWRy9JY29uLnRzeCIsIndlYnBhY2s6Ly9fTl9FLy4vdGhlbWUvU1ZHL1NWRy5tb2R1bGUuY3NzPzU0YjQiLCJ3ZWJwYWNrOi8vX05fRS8uL3RoZW1lL1NWRy9TVkcudHN4Iiwid2VicGFjazovL19OX0UvLi90aGVtZS9TaGFkb3dCb3gvUG9ydGFsQm94LnRzeCIsIndlYnBhY2s6Ly9fTl9FLy4vdGhlbWUvU2hhZG93Qm94L1NoYWRvd0JveC5tb2R1bGUuY3NzP2I5MTYiLCJ3ZWJwYWNrOi8vX05fRS8uL3RoZW1lL1NoYWRvd0JveC9TaGFkb3dCb3gudHN4Iiwid2VicGFjazovL19OX0UvLi90aGVtZS9pbmRleC50cyIsIndlYnBhY2s6Ly9fTl9FLy4vdXRpbHMvY2FsZW5kYXIudHMiLCJ3ZWJwYWNrOi8vX05fRS8uL3V0aWxzL2NsYXNzbmFtZXMudHN4Iiwid2VicGFjazovL19OX0UvLi91dGlscy9jb25zdGFudHMudHMiLCJ3ZWJwYWNrOi8vX05fRS8uL3V0aWxzL2RheWpzLnRzIiwid2VicGFjazovL19OX0UvLi91dGlscy9oZWxwZXJzLnRzeCIsIndlYnBhY2s6Ly9fTl9FLy4vdXRpbHMvbWV0YXMudHMiLCJ3ZWJwYWNrOi8vX05fRS8uL3V0aWxzL3ByaXNtLmpzIl0sIm5hbWVzIjpbIkFib3V0IiwiY2xhc3NOYW1lIiwicHJvcHMiLCJ1c2VBY3Rpb25zIiwiYWN0aW9ucyIsInNldE1lbnVPcGVuIiwic3R5bGVzIiwiaGVhZGVyIiwibG9nbyIsImJ1dHRvbiIsImRlc2NyaXB0aW9uIiwiY29udHJvbHMiLCJuYXZpZ2F0aW9uIiwiQWJvdXRDb250cm9scyIsIlJlYWN0IiwidXNlU3RhdGUiLCJlbWFpbEJveCIsInNldEVtYWlsQm94IiwicHVzaEJveCIsInNldFB1c2hCb3giLCJjbiIsInJvb3QiLCJpdGVtIiwibmF2aWdhdG9yIiwic2hhcmUiLCJ1cmwiLCJ3aW5kb3ciLCJsb2NhdGlvbiIsImhyZWYiLCJ0ZXh0IiwiYXBwRGVzY3JpcHRpb24iLCJ0aXRsZSIsImFwcFRpdGxlIiwiaW5zdGFsbFByb21wdCIsInByb21wdCIsIkFib3V0TmF2aWdhdGlvbiIsIk9iamVjdCIsImVudHJpZXMiLCJsZWdhbCIsInByaXZhY3kiLCJjcmVkaXRzIiwibWFwIiwic2x1ZyIsIkVtYWlsU2lnbnVwIiwibG9hZGluZyIsInNldExvYWRpbmciLCJmb3JtU3VjY2VzcyIsInNldEZvcm1TdWNjZXNzIiwiZm9ybUVycm9yIiwic2V0Rm9ybUVycm9yIiwiY29udGVudCIsIm5vdGlmaWNhdGlvbiIsImZvcm0iLCJkYXRhIiwiZmV0Y2giLCJhcGlCYXNlIiwibWV0aG9kIiwiYm9keSIsIkpTT04iLCJzdHJpbmdpZnkiLCJlbWFpbCIsInRpbWV6b25lT2Zmc2V0IiwiRGF0ZSIsImdldFRpbWV6b25lT2Zmc2V0IiwiaGVhZGVycyIsInJlc3AiLCJzdGF0dXMiLCJFcnJvciIsIklucHV0VGV4dCIsInJlcXVpcmVkIiwicGF0dGVybiIsInZhbHVlIiwibWVzc2FnZSIsImRpc2NsYWltZXIiLCJQdXNoTm90aWZpY2F0aW9ucyIsImVycm9yIiwic2V0RXJyb3IiLCJpc1N1YnNjcmliZWQiLCJzZXRJc1N1YnNjcmliZWQiLCJzdXBwb3J0c1B1c2giLCJ1c2VFZmZlY3QiLCJOb3RpZmljYXRpb24iLCJwZXJtaXNzaW9uIiwic2VydmljZVdvcmtlciIsImdldFJlZ2lzdHJhdGlvbiIsInJlZyIsInB1c2hNYW5hZ2VyIiwiZ2V0U3Vic2NyaXB0aW9uIiwic3Vic2NyaXB0aW9uIiwic2VuZFN1YnNjcmlwdGlvbiIsInRvSlNPTiIsImVmZmVjdCIsImdldFZhcGlkS2V5Iiwia2V5Iiwib2siLCJqc29uIiwicmVzcEpzb24iLCJwdWJsaWNLZXkiLCJzdWJzY3JpYmUiLCJ2YXBpZEtleSIsImFsZXJ0IiwidXNlclZpc2libGVPbmx5IiwiYXBwbGljYXRpb25TZXJ2ZXJLZXkiLCJVaW50OEFycmF5IiwidXJsQjY0VG9VaW50OEFycmF5IiwidW5zdWJzY3JpYmUiLCJzZW5kRGVsZXRlU3Vic2NyaXB0aW9uIiwiYWJvdXQiLCJmZWVkYmFjayIsImlzSW9zIiwiY2hlY2tlZCIsIkNhbGVuZGFyIiwidmlldyIsInNldFZpZXciLCJ1c2VXaW5kb3dTaXplIiwiY2FsZW5kYXJSZWYiLCJ1c2VSZWYiLCJoZWlnaHQiLCJzZXRIZWlnaHQiLCJvcGFjaXR5Iiwic2V0T3BhY2l0eSIsInVzZVN0b3JlU3RhdGUiLCJtZW51T3BlbiIsImlzQ2FsZW5kYXIiLCJ1c2VNZW1vIiwiVklFV19UWVBFUyIsIkNBTEVOREFSIiwiREFURV9UT0RBWSIsImlzQWZ0ZXIiLCJEQVRFX0VORCIsInNldHRpbmdzREIiLCJnZXQiLCJ0aGVuIiwidiIsInNldCIsInNldFRpbWVvdXQiLCJjdXJyZW50Iiwid2lkdGgiLCJpc1BvcnRyYWl0IiwibWF4SGVpZ2h0IiwiTWF0aCIsInJvdW5kIiwiY2xpZW50V2lkdGgiLCJidXR0b25PdmVybGF5IiwiY2FsZW5kYXIiLCJsaXN0IiwiZGF5c09yZGVyIiwiZGF5c09yZGVyQ29ycmVjdCIsImRheSIsInBhcnNlSW50IiwiQ2FsZW5kYXJEYXkiLCJzdG9yZURheXMiLCJkYXlzIiwiZGF5T2JqZWN0IiwiaXNBY3RpdmUiLCJkYXlqcyIsImRhdGUiLCJXcmFwcGVyIiwiY2hpbGRyZW4iLCJkYXlBY3RpdmUiLCJpbm5lciIsIkNhbGVuZGFyRGF5V3JhcHBlciIsIndyYXBwZXIiLCJzbm93IiwiemVyb1BhZCIsInJvb3RBY3RpdmUiLCJudW1iZXIiLCJTVUJKRUNUUyIsIndyYXBwZXJJbm5lciIsIkNhbGVuZGFySGVhZGVyIiwidmFsdWVzIiwidHlwZSIsInZpZXdCdXR0b24iLCJ2aWV3QnV0dG9uQWN0aXZlIiwiQ29udGVudCIsImxvYWREYXkiLCJ1c2VQYXJhbXMiLCJwYWdlIiwidXNlSGlzdG9yeSIsInB1c2giLCJhY3RpdmUiLCJhY3RpdmVEYXkiLCJtZXRhVGl0bGUiLCJsaW5rTGlzdCIsInR3aXR0ZXIiLCJkZXZ0byIsIndlYmRldiIsIkNvbnRlbnRBdXRob3IiLCJhdXRob3IiLCJzbWFsbCIsImxpbmtzIiwibGluayIsImZpbHRlciIsImUiLCJpbWFnZSIsInNyYyIsIm5hbWUiLCJwZXJzb25hbCIsImxlbmd0aCIsImxpbmtzSXRlbSIsIkNvbnRlbnRDYWxlbmRhciIsImNvbnRlbnRSZWYiLCJvcmlnaW5hbFNvdXJjZSIsInNvdXJjZSIsIlVSTCIsInJlZ2V4IiwibSIsImMiLCJleGVjIiwiaW5kZXgiLCJsYXN0SW5kZXgiLCJyZXBsYWNlIiwiUHJpc20iLCJoaWdobGlnaHRBbGwiLCJmb3JtYXQiLCJleGNlcnB0IiwibWV0YSIsIl9faHRtbCIsImNhbm5vbmljYWwiLCJob3N0IiwiQ29udGVudFBhZ2UiLCJvbkNsb3NlIiwibG9hZFBhZ2UiLCJ3aW5kb3dTaXplIiwic2V0V2luZG93U2l6ZSIsImhhbmRsZVJlc2l6ZSIsImlubmVyV2lkdGgiLCJpbm5lckhlaWdodCIsImFkZEV2ZW50TGlzdGVuZXIiLCJyZW1vdmVFdmVudExpc3RlbmVyIiwicHJlZmV0Y2hlZCIsInJvdXRlciIsImVyciIsImN1ckxvY2FsZSIsIm9wdGlvbnMiLCJldmVudCIsInRhcmdldCIsIm5vZGVOYW1lIiwiaXNNb2RpZmllZEV2ZW50Iiwic2Nyb2xsIiwiYXMiLCJzaGFsbG93IiwibG9jYWxlIiwiYXJncyIsImV4cGVjdGVkIiwicmVxdWlyZWRQcm9wc0d1YXJkIiwicmVxdWlyZWRQcm9wcyIsImNyZWF0ZVByb3BFcnJvciIsImFjdHVhbCIsIl8iLCJvcHRpb25hbFByb3BzR3VhcmQiLCJwYXNzSHJlZiIsInByZWZldGNoIiwib3B0aW9uYWxQcm9wcyIsInZhbFR5cGUiLCJoYXNXYXJuZWQiLCJjb25zb2xlIiwicCIsInBhdGhuYW1lIiwicmVzb2x2ZWRBcyIsImNoaWxkIiwiQ2hpbGRyZW4iLCJjaGlsZFJlZiIsInJvb3RNYXJnaW4iLCJzZXRSZWYiLCJlbCIsInNldEludGVyc2VjdGlvblJlZiIsInNob3VsZFByZWZldGNoIiwiaXNWaXNpYmxlIiwiaXNQcmVmZXRjaGVkIiwiY2hpbGRQcm9wcyIsInJlZiIsIm9uQ2xpY2siLCJsaW5rQ2xpY2tlZCIsInByaW9yaXR5IiwibG9jYWxlRG9tYWluIiwiTGluayIsInBhdGgiLCJub3JtYWxpemVQYXRoVHJhaWxpbmdTbGFzaCIsInByb2Nlc3MiLCJyZXF1ZXN0SWRsZUNhbGxiYWNrIiwic2VsZiIsInN0YXJ0IiwiY2IiLCJkaWRUaW1lb3V0IiwidGltZVJlbWFpbmluZyIsImNhbmNlbElkbGVDYWxsYmFjayIsImNsZWFyVGltZW91dCIsIk1TX01BWF9JRExFX0RFTEFZIiwiZW50cnkiLCJQcm9taXNlIiwicHJvbSIsInJlc29sdmUiLCJyZXNvbHZlciIsImZ1dHVyZSIsImdlbmVyYXRvciIsImRvY3VtZW50IiwiY2FuUHJlZmV0Y2giLCJoYXNQcmVmZXRjaCIsInJlcyIsIkFTU0VUX0xPQURfRVJST1IiLCJTeW1ib2wiLCJzY3JpcHQiLCJyZWplY3QiLCJtYXJrQXNzZXRFcnJvciIsImNhbmNlbGxlZCIsInIiLCJvbkJ1aWxkTWFuaWZlc3QiLCJyZXNvbHZlUHJvbWlzZVdpdGhUaW1lb3V0Iiwic2NyaXB0cyIsImFzc2V0UHJlZml4IiwiZW5jb2RlVVJJIiwiY3NzIiwiZ2V0Q2xpZW50QnVpbGRNYW5pZmVzdCIsIm1hbmlmZXN0Iiwicm91dGUiLCJhbGxGaWxlcyIsImVudHJ5cG9pbnRzIiwibG9hZGVkU2NyaXB0cyIsInN0eWxlU2hlZXRzIiwicm91dGVzIiwiYXBwZW5kU2NyaXB0Iiwid2hlbkVudHJ5cG9pbnQiLCJ3aXRoRnV0dXJlIiwib25FbnRyeXBvaW50IiwiZm4iLCJleHBvcnRzIiwiY29tcG9uZW50IiwiaW5wdXQiLCJvbGQiLCJsb2FkUm91dGUiLCJnZXRGaWxlc0ZvclJvdXRlIiwiZW50cnlwb2ludCIsIm91dHB1dCIsInByZWZldGNoVmlhRG9tIiwiY3JlYXRlUm91dGVMb2FkZXIiLCJzaW5nbGV0b25Sb3V0ZXIiLCJyZWFkeUNhbGxiYWNrcyIsInJlYWR5IiwidXJsUHJvcGVydHlGaWVsZHMiLCJyb3V0ZXJFdmVudHMiLCJjb3JlTWV0aG9kRmllbGRzIiwiUm91dGVyIiwiZmllbGQiLCJnZXRSb3V0ZXIiLCJldmVudEZpZWxkIiwiX3NpbmdsZXRvblJvdXRlciIsIlJvdXRlckNvbnRleHQiLCJjcmVhdGVSb3V0ZXIiLCJfcm91dGVyIiwiaW5zdGFuY2UiLCJBcnJheSIsImhhc0ludGVyc2VjdGlvbk9ic2VydmVyIiwiaXNEaXNhYmxlZCIsImRpc2FibGVkIiwidW5vYnNlcnZlIiwib2JzZXJ2ZSIsInNldFZpc2libGUiLCJpZGxlQ2FsbGJhY2siLCJjcmVhdGVPYnNlcnZlciIsImVsZW1lbnRzIiwib2JzZXJ2ZXIiLCJvYnNlcnZlcnMiLCJpZCIsImNhbGxiYWNrIiwiQ29tcG9zZWRDb21wb25lbnQiLCJnZXRJbml0aWFsUHJvcHMiLCJXaXRoUm91dGVyV3JhcHBlciIsIkFtcFN0YXRlQ29udGV4dCIsImFtcEZpcnN0IiwiaHlicmlkIiwiaGFzUXVlcnkiLCJpc0luQW1wTW9kZSIsIkhlYWRNYW5hZ2VyQ29udGV4dCIsImluQW1wTW9kZSIsImhlYWQiLCJmcmFnbWVudExpc3QiLCJNRVRBVFlQRVMiLCJrZXlzIiwidGFncyIsIm1ldGFUeXBlcyIsIm1ldGFDYXRlZ29yaWVzIiwiaCIsImlzVW5pcXVlIiwiaGFzS2V5IiwiaSIsImxlbiIsIm1ldGF0eXBlIiwiY2F0ZWdvcnkiLCJjYXRlZ29yaWVzIiwiaGVhZEVsZW1lbnRzIiwiaGVhZEVsZW1lbnRDaGlsZHJlbiIsImhlYWRFbGVtZW50IiwiZGVmYXVsdEhlYWQiLCJ1bmlxdWUiLCJhbXBTdGF0ZSIsImhlYWRNYW5hZ2VyIiwiSGVhZCIsInBhdGhuYW1lUGFydHMiLCJsb2NhbGVzIiwiZGV0ZWN0ZWRMb2NhbGUiLCJhbGwiLCJvbiIsIm9mZiIsImVtaXQiLCJoYW5kbGVyIiwiYmFzZVBhdGgiLCJwcmVmaXgiLCJwYXRoTm9RdWVyeUhhc2giLCJxdWVyeUluZGV4IiwiaGFzaEluZGV4IiwiYWRkUGF0aFByZWZpeCIsImxvY2F0aW9uT3JpZ2luIiwicmVzb2x2ZWQiLCJoYXNCYXNlUGF0aCIsImludGVycG9sYXRlZFJvdXRlIiwiZHluYW1pY1JlZ2V4IiwiZHluYW1pY0dyb3VwcyIsImR5bmFtaWNNYXRjaGVzIiwiYXNQYXRobmFtZSIsInBhcmFtcyIsInBhcmFtIiwicmVwbGFjZWQiLCJyZXBlYXQiLCJvcHRpb25hbCIsInNlZ21lbnQiLCJlbmNvZGVVUklDb21wb25lbnQiLCJyZXN1bHQiLCJmaWx0ZXJlZFF1ZXJ5IiwicXVlcnkiLCJiYXNlIiwidXJsQXNTdHJpbmciLCJpc0xvY2FsVVJMIiwicmVzb2x2ZUFzIiwiZmluYWxVcmwiLCJpbnRlcnBvbGF0ZWRBcyIsImludGVycG9sYXRlQXMiLCJoYXNoIiwib21pdFBhcm1zRnJvbVF1ZXJ5IiwicmVzb2x2ZWRIcmVmIiwib3JpZ2luIiwicmVzb2x2ZUhyZWYiLCJocmVmSGFkT3JpZ2luIiwiYXNIYWRPcmlnaW4iLCJzdHJpcE9yaWdpbiIsInByZXBhcmVkVXJsIiwiYWRkQmFzZVBhdGgiLCJwcmVwYXJlZEFzIiwiY2xlYW5QYXRobmFtZSIsInBhZ2VzIiwibWFudWFsU2Nyb2xsUmVzdG9yYXRpb24iLCJTU0dfREFUQV9OT1RfRk9VTkQiLCJjcmVkZW50aWFscyIsImF0dGVtcHRzIiwiZmV0Y2hSZXRyeSIsIm5vdEZvdW5kIiwiaXNTZXJ2ZXJSZW5kZXIiLCJjb25zdHJ1Y3RvciIsImFzUGF0aCIsImNvbXBvbmVudHMiLCJzZGMiLCJzZHIiLCJzdWIiLCJjbGMiLCJwYWdlTG9hZGVyIiwiX2JwcyIsImV2ZW50cyIsIl93cmFwQXBwIiwiaXNTc3IiLCJpc0ZhbGxiYWNrIiwiX2luRmxpZ2h0Um91dGUiLCJfc2hhbGxvdyIsImRlZmF1bHRMb2NhbGUiLCJkb21haW5Mb2NhbGVzIiwiaXNSZWFkeSIsImlzUHJldmlldyIsImlzTG9jYWxlRG9tYWluIiwiX2lkeCIsInN0YXRlIiwiQ29tcG9uZW50IiwiaW5pdGlhbCIsIl9fTl9TU0ciLCJpbml0aWFsUHJvcHMiLCJfX05fU1NQIiwiYXV0b0V4cG9ydER5bmFtaWMiLCJyZWxvYWQiLCJwcmVwYXJlVXJsQXMiLCJzaG91bGRSZXNvbHZlSHJlZiIsImxvY2FsZUNoYW5nZSIsInBhcnNlZEFzIiwiZGVsQmFzZVBhdGgiLCJsb2NhbGVQYXRoUmVzdWx0IiwiZGlkTmF2aWdhdGUiLCJkZXRlY3RlZERvbWFpbiIsImRldGVjdERvbWFpbkxvY2FsZSIsIlNUIiwicGVyZm9ybWFuY2UiLCJyb3V0ZVByb3BzIiwiYWRkTG9jYWxlIiwiY2xlYW5lZEFzIiwiZGVsTG9jYWxlIiwicGFyc2VkIiwiX19yZXdyaXRlcyIsInJlc29sdmVEeW5hbWljUm91dGUiLCJyb3V0ZVJlZ2V4Iiwicm91dGVNYXRjaCIsInNob3VsZEludGVycG9sYXRlIiwibWlzc2luZ1BhcmFtcyIsInJvdXRlSW5mbyIsImRlc3RpbmF0aW9uIiwicGFyc2VkSHJlZiIsIm5vdEZvdW5kUm91dGUiLCJhcHBDb21wIiwiaXNWYWxpZFNoYWxsb3dSb3V0ZSIsImZvcmNlZFNjcm9sbCIsIngiLCJ5IiwiX19OIiwiaWR4IiwiYnVpbGRDYW5jZWxsYXRpb25FcnJvciIsImV4aXN0aW5nUm91dGVJbmZvIiwiY2FjaGVkUm91dGVJbmZvIiwicmVxdWlyZSIsImlzVmFsaWRFbGVtZW50VHlwZSIsImRhdGFIcmVmIiwib25seUFIYXNoQ2hhbmdlIiwibmV3SGFzaCIsIm9sZFVybE5vSGFzaCIsIm9sZEhhc2giLCJzY3JvbGxUb0hhc2giLCJpZEVsIiwibmFtZUVsIiwidXJsSXNOZXciLCJyZXdyaXRlc1Jlc3VsdCIsImlzU3NnIiwiY2FuY2VsIiwiY29tcG9uZW50UmVzdWx0IiwiX2dldFN0YXRpY0RhdGEiLCJmZXRjaE5leHREYXRhIiwiX2dldFNlcnZlckRhdGEiLCJBcHBUcmVlIiwiY3R4IiwiYWJvcnRDb21wb25lbnRMb2FkIiwibm90aWZ5Iiwic2xhc2hlZFByb3RvY29scyIsInByb3RvY29sIiwidXJsT2JqIiwiYXV0aCIsImhvc3RuYW1lIiwiU3RyaW5nIiwicXVlcnlzdHJpbmciLCJzZWFyY2giLCJleHQiLCJURVNUX1JPVVRFIiwiZ2xvYmFsQmFzZSIsInJlc29sdmVkQmFzZSIsInNlYXJjaFBhcmFtcyIsImlzTmFOIiwic3RyaW5naWZ5VXJsUXVlcnlQYXJhbSIsInNlYXJjaFBhcmFtc0xpc3QiLCJyZSIsImRlY29kZSIsImRlY29kZVVSSUNvbXBvbmVudCIsInNsdWdOYW1lIiwiZyIsImdyb3VwcyIsInN0ciIsInNlZ21lbnRzIiwibm9ybWFsaXplZFJvdXRlIiwiZ3JvdXBJbmRleCIsInBhcmFtZXRlcml6ZWRSb3V0ZSIsInBhcnNlUGFyYW1ldGVyIiwicG9zIiwiZXNjYXBlUmVnZXgiLCJpc1NlcnZlciIsIl9oYXNIZWFkTWFuYWdlciIsImVtaXRDaGFuZ2UiLCJjb21wb25lbnREaWRNb3VudCIsImNvbXBvbmVudERpZFVwZGF0ZSIsImNvbXBvbmVudFdpbGxVbm1vdW50IiwicmVuZGVyIiwidXNlZCIsInBvcnQiLCJnZXRMb2NhdGlvbk9yaWdpbiIsIkFwcCIsImdldERpc3BsYXlOYW1lIiwibG9hZEdldEluaXRpYWxQcm9wcyIsInBhZ2VQcm9wcyIsImlzUmVzU2VudCIsInVybE9iamVjdEtleXMiLCJTUCIsInN0YXJ0WCIsImN1cnJlbnRYIiwidG91Y2hMZW5ndGgiLCJNT0JJTEVfQlAiLCJzZXRPZmZsaW5lIiwiaXNNb2JpbGUiLCJzZXRJc01vYmlsZSIsInRyYW5zaXRpb24iLCJzZXRUcmFuc2l0aW9uIiwic2hvdyIsInNldFNob3ciLCJvbkxpbmUiLCJ0b3VjaFN0YXJ0IiwidG91Y2hlcyIsImNsaWVudFgiLCJ0b3VjaEVuZCIsIm1vdmVkIiwidG91Y2hNb3ZlIiwic3RvcmUiLCJkYk5hbWUiLCJkYlByb21pc2UiLCJvcGVuREIiLCJ1cGdyYWRlIiwiZGIiLCJvbGRWZXJzaW9uIiwiY3JlYXRlT2JqZWN0U3RvcmUiLCJkYXlzREIiLCJ2YWwiLCJwdXQiLCJwYWdlREIiLCJpbml0aWFsRGF5cyIsIllFQVIiLCJpbml0aWFsU3RhdGUiLCJvZmZsaW5lIiwiaXNCZWZvcmUiLCJEQVRFX1NUQVJUIiwic2V0RGF5IiwiZ2V0U3RhdGUiLCJkYXlzTm93Iiwic2V0U3RhdGUiLCJzZXRQYWdlIiwic3RvcmVEYXkiLCJ0eiIsIkRBVEVfVE9EQVlfWkVSTyIsImFwaUtleSIsImNvbnRzbnQiLCJpc0RldiIsImNyZWF0ZVN0b3JlIiwiZGV2dG9vbHMiLCJCdXR0b24iLCJsYXlvdXQiLCJpY29uIiwiaWNvblJpZ2h0IiwiaWNvbkNpcmNsZSIsInNpemUiLCJjb2xvciIsInplcm9QYWRkaW5nIiwiZm9udFdlaWdodCIsImlzUm91bmQiLCJpc0xvYWRpbmciLCJ6ZXJvcGFkZGluZyIsImxvYWRlciIsImljb25MZWZ0IiwiQ2xvc2VCdXR0b24iLCJDb250ZW50TW9kYWwiLCJmdWxsIiwiQ29ubmVjdEZvcm0iLCJtZXRob2RzIiwidXNlRm9ybUNvbnRleHQiLCJGb3JtIiwib25TdWJtaXQiLCJ1c2VGb3JtIiwiaGFuZGxlU3VibWl0IiwiRm9ybUNvbnRyb2xzIiwiRm9ybUZpZWxkIiwibGFiZWwiLCJmaWVsZFJlZ2lzdGVyIiwicmVnaXN0ZXIiLCJjbGFzc05hbWVMYWJlbCIsImNsYXNzTmFtZUlucHV0Iiwid2lkZSIsImVycm9ycyIsIkZvcm1GaWVsZHNldCIsInN0YWNrZWQiLCJpc1N0YWNrZWQiLCJmaWVsZHMiLCJJbnB1dCIsInN1YnR5cGUiLCJpbml0aWFsVmFsdWUiLCJjaG9pY2VzIiwib25DaGFuZ2UiLCJvblZhbHVlQ2hhbmdlZCIsInNldFZhbHVlIiwicHJldlZhbHVlIiwiaW5wdXRQcm9wcyIsImVsZW1lbnQiLCJpc0Vycm9yIiwiSW5wdXRTZWxlY3QiLCJJbnB1dFRleHRhcmVhIiwiQkFTRSIsImxhenlTaXplc0ZpbmRQYXJlbnQiLCJwYXJlbnRFbGVtZW50IiwiY2xhc3NMaXN0IiwiY29udGFpbnMiLCJMYXp5SW1hZ2UiLCJiYWNrZ3JvdW5kIiwiYWx0IiwibWFpbkltYWdlIiwic2l6ZXMiLCJiYWNrZ3JvdW5kSW1hZ2UiLCJwbGFjZWhvbGRlciIsImltYWdlTGF6eWxvYWQiLCJqb2luIiwicHJldmlldyIsIkxvYWRlciIsIkxvZ28iLCJzYW1laGVpZ2h0IiwiU25vdyIsInBvc2l0aW9uIiwibGV2ZWwiLCJsZXZlbEFsdCIsIkljb24iLCJzcGlubmluZyIsInJvdGF0ZSIsImNpcmNsZSIsImFuaW1hdGlvblNwaW4iLCJTVkciLCJpbmxpbmUiLCJsb2FkZWRJY29uIiwic2V0TG9hZGVkSWNvbiIsImxvYWRJY29uIiwibG9hZGVkIiwiaXNJbmxpbmUiLCJQb3J0YWwiLCJSZWFjdERPTSIsImNyZWF0ZVBvcnRhbCIsInF1ZXJ5U2VsZWN0b3IiLCJjbG9zZSIsInNoYWRvdyIsInNldFNoYWRvdyIsImJveCIsInNjcm9sbFRvcCIsImhlYWRlclNoYWRvdyIsImhlYWRlcklvcyIsIlRPREFZIiwiVEhFTUVOIiwiY2xhc3NlcyIsImNsIiwiYXBwZW5kIiwidHJhaWxpbmdTbGFzaEl0IiwicmVnaXN0ZXJTdyIsInJhbmRvbSIsInR3b1RvVHdlbnR5dGhyZWUiLCJzaHVmZmVsZWQiLCJzaHVmZmxlIiwiTElTVCIsImV4dGVuZCIsInV0YyIsInRpbWV6b25lIiwibG9jYWxpemVkRm9ybWF0IiwidG9TdHJpbmciLCJwYWRTdGFydCIsIndpbmRvd1Jlc2l6ZSIsInZoIiwiZG9jdW1lbnRFbGVtZW50Iiwic3R5bGUiLCJzZXRQcm9wZXJ0eSIsImdldFJhbmRvbU51bWJlciIsIm1pbiIsIm1heCIsInVudHJhaWxpbmdTbGFzaEl0IiwiaXRlbXMiLCJyZWN1ciIsImFyciIsImN1cnJlbnRJbmRleCIsInJhbmRvbUluZGV4IiwiZmxvb3IiLCJzd2FwIiwiYmFzZTY0U3RyaW5nIiwicGFkZGluZyIsImJhc2U2NCIsInJhd0RhdGEiLCJhdG9iIiwib3V0cHV0QXJyYXkiLCJjaGFyQ29kZUF0IiwiUExBVEZPUk0iLCJwbGF0Zm9ybSIsIlVTRVJfQUdFTlQiLCJ1c2VyQWdlbnQiLCJpbmNsdWRlcyIsIl9zZWxmIiwidSIsIm4iLCJtYW51YWwiLCJkaXNhYmxlV29ya2VyTWVzc2FnZUhhbmRsZXIiLCJ1dGlsIiwiZW5jb2RlIiwiTSIsImFsaWFzIiwiaXNBcnJheSIsInByb3RvdHlwZSIsImNhbGwiLCJzbGljZSIsIm9iaklkIiwiX19pZCIsImRlZmluZVByb3BlcnR5IiwiY2xvbmUiLCJ0IiwiYSIsImhhc093blByb3BlcnR5IiwiZm9yRWFjaCIsImdldExhbmd1YWdlIiwidGVzdCIsIm1hdGNoIiwidG9Mb3dlckNhc2UiLCJjdXJyZW50U2NyaXB0Iiwic3RhY2siLCJnZXRFbGVtZW50c0J5VGFnTmFtZSIsImxhbmd1YWdlcyIsImluc2VydEJlZm9yZSIsImwiLCJvIiwicyIsIkRGUyIsInBsdWdpbnMiLCJoaWdobGlnaHRBbGxVbmRlciIsImNvbnRhaW5lciIsInNlbGVjdG9yIiwiaG9va3MiLCJydW4iLCJhcHBseSIsInF1ZXJ5U2VsZWN0b3JBbGwiLCJoaWdobGlnaHRFbGVtZW50IiwibGFuZ3VhZ2UiLCJncmFtbWFyIiwiY29kZSIsInRleHRDb250ZW50IiwiaGlnaGxpZ2h0ZWRDb2RlIiwiaW5uZXJIVE1MIiwiV29ya2VyIiwiZmlsZW5hbWUiLCJvbm1lc3NhZ2UiLCJwb3N0TWVzc2FnZSIsImltbWVkaWF0ZUNsb3NlIiwiaGlnaGxpZ2h0IiwidG9rZW5zIiwidG9rZW5pemUiLCJyZXN0IiwieiIsImNhdXNlIiwiaW5zaWRlIiwiZiIsImxvb2tiZWhpbmQiLCJncmVlZHkiLCJkIiwiZ2xvYmFsIiwiUmVnRXhwIiwibmV4dCIsInRhaWwiLCJyZWFjaCIsImsiLCJiIiwiVyIsInciLCJBIiwiUCIsIlMiLCJFIiwiTyIsIkwiLCJOIiwiaiIsInByZXYiLCJJIiwiQyIsImFkZCIsIlRva2VuIiwidGFnIiwiYXR0cmlidXRlcyIsInBhcnNlIiwiaGFzQXR0cmlidXRlIiwicmVhZHlTdGF0ZSIsImRlZmVyIiwicmVxdWVzdEFuaW1hdGlvbkZyYW1lIiwibW9kdWxlIiwibWFya3VwIiwiY29tbWVudCIsInByb2xvZyIsImRvY3R5cGUiLCJzdHJpbmciLCJwdW5jdHVhdGlvbiIsImNkYXRhIiwibmFtZXNwYWNlIiwiZW50aXR5IiwiaHRtbCIsIm1hdGhtbCIsInN2ZyIsInhtbCIsInNzbWwiLCJhdG9tIiwicnNzIiwiYXRydWxlIiwicnVsZSIsImtleXdvcmQiLCJwcm9wZXJ0eSIsImltcG9ydGFudCIsImFkZElubGluZWQiLCJjbGlrZSIsIm9wZXJhdG9yIiwiamF2YXNjcmlwdCIsInBhcmFtZXRlciIsImNvbnN0YW50IiwiaW50ZXJwb2xhdGlvbiIsImpzIiwid2VibWFuaWZlc3QiLCJzYXNzIiwidmFyaWFibGUiLCJzY3NzIiwicGFyZW50Iiwic3RhdGVtZW50IiwidHlwZXNjcmlwdCIsImJ1aWx0aW4iLCJnZW5lcmljIiwidHMiLCJ0eXBvc2NyaXB0IiwidHNjb25maWciLCJsaW5lTnVtYmVycyIsImdldExpbmUiLCJ0YWdOYW1lIiwiZ2V0QXR0cmlidXRlIiwicmVzaXplIiwiYXNzdW1lVmlld3BvcnRJbmRlcGVuZGVuY2UiLCJnZXRDb21wdXRlZFN0eWxlIiwiY3VycmVudFN0eWxlIiwicGFyZW50Tm9kZSIsInJlbW92ZSIsImNyZWF0ZUVsZW1lbnQiLCJzZXRBdHRyaWJ1dGUiLCJjb3VudGVyUmVzZXQiLCJhcHBlbmRDaGlsZCIsInNwbGl0IiwiZGlzcGxheSIsImdldEJvdW5kaW5nQ2xpZW50UmVjdCIsImxpbmVzIiwibGluZUhlaWdodHMiLCJvbmVMaW5lckhlaWdodCIsInNpemVyIiwiQm9vbGVhbiJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7OztBQUFBLFVBQVUsbUJBQU8sQ0FBQyxzTkFBMkc7QUFDN0gsMEJBQTBCLG1CQUFPLENBQUMsc1VB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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUMsY0FBYyxlQUFlO0FBQ3RFLENBQUMsSUFBSTs7QUFFTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixvQ0FBb0M7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLFlBQVksYUFBYSxvQkFBb0I7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxVQUFVO0FBQ3pCO0FBQ0E7QUFDQSx1QkFBdUIsdUJBQXVCO0FBQzlDO0FBQ0E7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LHFFQUFxRTtBQUNyRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixRQUFRO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdELEtBQUssR0FBRyxXQUFXLElBQUksSUFBSTtBQUMzRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscURBQXFELEtBQUssR0FBRyxlQUFlLElBQUksSUFBSTtBQUNwRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUksdURBQVM7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsSUFBSSx1REFBUztBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0ws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O0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0EsV0FBVztBQUNYOztBQUVBO0FBQ0E7QUFDQSx3Q0FBd0MsV0FBVztBQUNuRDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG9DQUFvQyxjQUFjO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGlDQUFpQyxrQkFBa0I7QUFDbkQ7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGlCQUFpQjs7QUFFakI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGlCQUFpQjtBQUN6QztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFlBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0EsWUFBWTtBQUNaOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsOENBQThDLFFBQVE7QUFDdEQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBOztBQUVBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7O0FBRUEsV0FBVztBQUNYO0FBQ0E7QUFDQTs7QUFFQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0EsOENBQThDLFFBQVE7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7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QWQsQ0FBc0IsVUFBU2htQixDQUFULEVBQVk4a0IsQ0FBWixFQUFlO0FBQ25DZSxXQUFDLENBQUNob0IsUUFBRixDQUFXaW5CLENBQVgsRUFBYzNCLEtBQWQsQ0FBb0IvbkIsTUFBcEIsR0FBNkI0RSxDQUFDLEdBQUcsSUFBakM7QUFDRCxTQUZELENBRkY7QUFLRCxPQVJELENBdEJGO0FBK0JEO0FBQ0Y7QUFDRixDQTFJQSxFQUFEIiwiZmlsZSI6InN0YXRpYy9jaHVua3MvcGFnZXMvX2FwcC5qcyIsInNvdXJjZXNDb250ZW50IjpbInZhciBhcGkgPSByZXF1aXJlKFwiIS4uLy4uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvYnVpbGQvd2VicGFjay9sb2FkZXJzL25leHQtc3R5bGUtbG9hZGVyL3J1bnRpbWUvaW5qZWN0U3R5bGVzSW50b1N0eWxlVGFnLmpzXCIpO1xuICAgICAgICAgICAgdmFyIGNvbnRlbnQgPSByZXF1aXJlKFwiISEuLi8uLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NvbXBpbGVkL2Nzcy1sb2FkZXIvY2pzLmpzPz9yZWYtLTUtb25lT2YtMi0xIS4uLy4uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvcG9zdGNzcy1sb2FkZXIvY2pzLmpzPz9yZWYtLTUtb25lT2YtMi0yIS4vQWJvdXQubW9kdWxlLmNzc1wiKTtcblxuICAgICAgICAgICAgY29udGVudCA9IGNvbnRlbnQuX19lc01vZHVsZSA/IGNvbnRlbnQuZGVmYXVsdCA6IGNvbnRlbnQ7XG5cbiAgICAgICAgICAgIGlmICh0eXBlb2YgY29udGVudCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgY29udGVudCA9IFtbbW9kdWxlLmlkLCBjb250ZW50LCAnJ11dO1xuICAgICAgICAgICAgfVxuXG52YXIgb3B0aW9ucyA9IHt9O1xuXG5vcHRpb25zLmluc2VydCA9IGZ1bmN0aW9uKGVsZW1lbnQpey8vIFRoZXNlIGVsZW1lbnRzIHNob3VsZCBhbHdheXMgZXhpc3QuIElmIHRoZXkgZG8gbm90LFxuLy8gdGhpcyBjb2RlIHNob3VsZCBmYWlsLlxudmFyIGFuY2hvckVsZW1lbnQ9ZG9jdW1lbnQucXVlcnlTZWxlY3RvcignI19fbmV4dF9jc3NfX0RPX05PVF9VU0VfXycpO3ZhciBwYXJlbnROb2RlPWFuY2hvckVsZW1lbnQucGFyZW50Tm9kZTsvLyBOb3JtYWxseSA8aGVhZD5cbi8vIEVhY2ggc3R5bGUgdGFnIHNob3VsZCBiZSBwbGFjZWQgcmlnaHQgYmVmb3JlIG91clxuLy8gYW5jaG9yLiBCeSBpbnNlcnRpbmcgYmVmb3JlIGFuZCBub3QgYWZ0ZXIsIHdlIGRvIG5vdFxuLy8gbmVlZCB0byB0cmFjayB0aGUgbGFzdCBpbnNlcnRlZCBlbGVtZW50LlxucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUoZWxlbWVudCxhbmNob3JFbGVtZW50KTt9O1xub3B0aW9ucy5zaW5nbGV0b24gPSBmYWxzZTtcblxudmFyIHVwZGF0ZSA9IGFwaShjb250ZW50LCBvcHRpb25zKTtcblxuXG5pZiAobW9kdWxlLmhvdCkge1xuICBpZiAoIWNvbnRlbnQubG9jYWxzIHx8IG1vZHVsZS5ob3QuaW52YWxpZGF0ZSkge1xuICAgIHZhciBpc0VxdWFsTG9jYWxzID0gZnVuY3Rpb24gaXNFcXVhbExvY2FscyhhLGIsaXNOYW1lZEV4cG9ydCl7aWYoIWEmJmJ8fGEmJiFiKXtyZXR1cm4gZmFsc2U7fWxldCBwO2ZvcihwIGluIGEpe2lmKGlzTmFtZWRFeHBvcnQmJnA9PT0nZGVmYXVsdCcpey8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb250aW51ZVxuY29udGludWU7fWlmKGFbcF0hPT1iW3BdKXtyZXR1cm4gZmFsc2U7fX1mb3IocCBpbiBiKXtpZihpc05hbWVkRXhwb3J0JiZwPT09J2RlZmF1bHQnKXsvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29udGludWVcbmNvbnRpbnVlO31pZighYVtwXSl7cmV0dXJuIGZhbHNlO319cmV0dXJuIHRydWU7fTtcbiAgICB2YXIgb2xkTG9jYWxzID0gY29udGVudC5sb2NhbHM7XG5cbiAgICBtb2R1bGUuaG90LmFjY2VwdChcbiAgICAgIFwiISEuLi8uLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NvbXBpbGVkL2Nzcy1sb2FkZXIvY2pzLmpzPz9yZWYtLTUtb25lT2YtMi0xIS4uLy4uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvcG9zdGNzcy1sb2FkZXIvY2pzLmpzPz9yZWYtLTUtb25lT2YtMi0yIS4vQWJvdXQubW9kdWxlLmNzc1wiLFxuICAgICAgZnVuY3Rpb24gKCkge1xuICAgICAgICBjb250ZW50ID0gcmVxdWlyZShcIiEhLi4vLi4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jb21waWxlZC9jc3MtbG9hZGVyL2Nqcy5qcz8/cmVmLS01LW9uZU9mLTItMSEuLi8uLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NvbXBpbGVkL3Bvc3Rjc3MtbG9hZGVyL2Nqcy5qcz8/cmVmLS01LW9uZU9mLTItMiEuL0Fib3V0Lm1vZHVsZS5jc3NcIik7XG5cbiAgICAgICAgICAgICAgY29udGVudCA9IGNvbnRlbnQuX19lc01vZHVsZSA/IGNvbnRlbnQuZGVmYXVsdCA6IGNvbnRlbnQ7XG5cbiAgICAgICAgICAgICAgaWYgKHR5cGVvZiBjb250ZW50ID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIGNvbnRlbnQgPSBbW21vZHVsZS5pZCwgY29udGVudCwgJyddXTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGlmICghaXNFcXVhbExvY2FscyhvbGRMb2NhbHMsIGNvbnRlbnQubG9jYWxzKSkge1xuICAgICAgICAgICAgICAgIG1vZHVsZS5ob3QuaW52YWxpZGF0ZSgpO1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgb2xkTG9jYWxzID0gY29udGVudC5sb2NhbHM7XG5cbiAgICAgICAgICAgICAgdXBkYXRlKGNvbnRlbnQpO1xuICAgICAgfVxuICAgIClcbiAgfVxuXG4gIG1vZHVsZS5ob3QuZGlzcG9zZShmdW5jdGlvbigpIHtcbiAgICB1cGRhdGUoKTtcbiAgfSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gY29udGVudC5sb2NhbHMgfHwge307IiwiaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IHVzZUFjdGlvbnMgfSBmcm9tICd1bmlzdG9yZS1ob29rcyc7XG5pbXBvcnQgeyBCdXR0b24sIExvZ28gfSBmcm9tICdAdGhlbWUnO1xuaW1wb3J0IEFib3V0Q29udHJvbHMgZnJvbSAnQGNvbXBzL0Fib3V0L0Fib3V0Q29udHJvbHMnO1xuaW1wb3J0IEFib3V0TmF2aWdhdGlvbiBmcm9tICdAY29tcHMvQWJvdXQvQWJvdXROYXZpZ2F0aW9uJztcbmltcG9ydCB7IGFjdGlvbnMgfSBmcm9tICdAc3RvcmUvaW5kZXgnO1xuaW1wb3J0IHN0eWxlcyBmcm9tICcuL0Fib3V0Lm1vZHVsZS5jc3MnO1xuXG5jb25zdCBBYm91dCA9ICh7XG4gIGNsYXNzTmFtZSA9ICcnLFxuICAuLi5wcm9wc1xufToge1xuICBjbGFzc05hbWU/OiBzdHJpbmc7XG4gIFtrZXk6IHN0cmluZ106IGFueTtcbn0pID0+IHtcbiAgY29uc3QgeyBzZXRNZW51T3BlbiB9ID0gdXNlQWN0aW9ucyhhY3Rpb25zKTtcblxuICByZXR1cm4gKFxuICAgIDxhcnRpY2xlIGNsYXNzTmFtZT17YCR7Y2xhc3NOYW1lfWB9IHsuLi5wcm9wc30+XG4gICAgICA8aGVhZGVyIGNsYXNzTmFtZT17c3R5bGVzLmhlYWRlcn0+XG4gICAgICAgIDxMb2dvXG4gICAgICAgICAgY2xhc3NOYW1lPXtzdHlsZXMubG9nb31cbiAgICAgICAgICB0aXRsZT1cIlBXQWR2ZW50IExvZ29cIlxuICAgICAgICAgIGFsdD1cIlBXQWR2ZW50IExvZ29cIlxuICAgICAgICAvPlxuICAgICAgICA8QnV0dG9uXG4gICAgICAgICAgb25DbGljaz17KCkgPT4gc2V0TWVudU9wZW4oZmFsc2UpfVxuICAgICAgICAgIGNsYXNzTmFtZT17c3R5bGVzLmJ1dHRvbn1cbiAgICAgICAgICBsYXlvdXQ9XCJnaG9zdFwiXG4gICAgICAgICAgaWNvbj1cIm1kaS9jYWxlbmRhci1tb250aFwiXG4gICAgICAgICAgcm91bmRcbiAgICAgICAgICBzaXplPVwic21hbGxcIlxuICAgICAgICA+XG4gICAgICAgICAgQ2FsZW5kYXJcbiAgICAgICAgPC9CdXR0b24+XG4gICAgICA8L2hlYWRlcj5cbiAgICAgIDxkaXYgY2xhc3NOYW1lPXtzdHlsZXMuZGVzY3JpcHRpb259PlxuICAgICAgICA8cD5cbiAgICAgICAgICBQV0FkdmVudCBpcyB0aGUgcGVyZmVjdCBhZHZlbnQgY2FsZW5kYXIgZm9yIGV2ZXJ5b25lIHdobydzIGV4Y2l0ZWRcbiAgICAgICAgICBhYm91dCB0aGUgd2ViIHBsYXRmb3JtLiBUYWtlIGEgbG9vayBhdCBhbGwgdGhlIGdyZWF0IHN0dWZmIHRoZSB3ZWIgaGFzXG4gICAgICAgICAgdG8gb2ZmZXIuXG4gICAgICAgIDwvcD5cbiAgICAgICAgPHA+XG4gICAgICAgICAgRnJvbSB0aGUgMXN0IHRvIHRoZSAyNHRoIG9mIERlY2VtYmVyIDIwMjAgd2Ugd2lsbCBpbnRyb2R1Y2UgYSBuZXdcbiAgICAgICAgICBwcm9ncmVzc2l2ZSBicm93c2VyIGZlYXR1cmUgZXZlcnkgZGF5IOKAlCBzdGF5IHR1bmVkIGZvciBhIHNldCBvZlxuICAgICAgICAgIGZlYXR1cmVzIHlvdSBtb3N0IGNlcnRhaW5seSBkaWQgbm90IGtub3cgdGhlIHdlYiBpcyBjYXBhYmxlIG9mLlxuICAgICAgICA8L3A+XG4gICAgICA8L2Rpdj5cbiAgICAgIDxBYm91dENvbnRyb2xzIGNsYXNzTmFtZT17c3R5bGVzLmNvbnRyb2xzfSAvPlxuICAgICAgPEFib3V0TmF2aWdhdGlvbiBjbGFzc05hbWU9e3N0eWxlcy5uYXZpZ2F0aW9ufSAvPlxuICAgIDwvYXJ0aWNsZT5cbiAgKTtcbn07XG5cbmV4cG9ydCBkZWZhdWx0IEFib3V0O1xuIiwidmFyIGFwaSA9IHJlcXVpcmUoXCIhLi4vLi4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9idWlsZC93ZWJwYWNrL2xvYWRlcnMvbmV4dC1zdHlsZS1sb2FkZXIvcnVudGltZS9pbmplY3RTdHlsZXNJbnRvU3R5bGVUYWcuanNcIik7XG4gICAgICAgICAgICB2YXIgY29udGVudCA9IHJlcXVpcmUoXCIhIS4uLy4uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvY3NzLWxvYWRlci9janMuanM/P3JlZi0tNS1vbmVPZi0yLTEhLi4vLi4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jb21waWxlZC9wb3N0Y3NzLWxvYWRlci9janMuanM/P3JlZi0tNS1vbmVPZi0yLTIhLi9BYm91dENvbnRyb2xzLm1vZHVsZS5jc3NcIik7XG5cbiAgICAgICAgICAgIGNvbnRlbnQgPSBjb250ZW50Ll9fZXNNb2R1bGUgPyBjb250ZW50LmRlZmF1bHQgOiBjb250ZW50O1xuXG4gICAgICAgICAgICBpZiAodHlwZW9mIGNvbnRlbnQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgIGNvbnRlbnQgPSBbW21vZHVsZS5pZCwgY29udGVudCwgJyddXTtcbiAgICAgICAgICAgIH1cblxudmFyIG9wdGlvbnMgPSB7fTtcblxub3B0aW9ucy5pbnNlcnQgPSBmdW5jdGlvbihlbGVtZW50KXsvLyBUaGVzZSBlbGVtZW50cyBzaG91bGQgYWx3YXlzIGV4aXN0LiBJZiB0aGV5IGRvIG5vdCxcbi8vIHRoaXMgY29kZSBzaG91bGQgZmFpbC5cbnZhciBhbmNob3JFbGVtZW50PWRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJyNfX25leHRfY3NzX19ET19OT1RfVVNFX18nKTt2YXIgcGFyZW50Tm9kZT1hbmNob3JFbGVtZW50LnBhcmVudE5vZGU7Ly8gTm9ybWFsbHkgPGhlYWQ+XG4vLyBFYWNoIHN0eWxlIHRhZyBzaG91bGQgYmUgcGxhY2VkIHJpZ2h0IGJlZm9yZSBvdXJcbi8vIGFuY2hvci4gQnkgaW5zZXJ0aW5nIGJlZm9yZSBhbmQgbm90IGFmdGVyLCB3ZSBkbyBub3Rcbi8vIG5lZWQgdG8gdHJhY2sgdGhlIGxhc3QgaW5zZXJ0ZWQgZWxlbWVudC5cbnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKGVsZW1lbnQsYW5jaG9yRWxlbWVudCk7fTtcbm9wdGlvbnMuc2luZ2xldG9uID0gZmFsc2U7XG5cbnZhciB1cGRhdGUgPSBhcGkoY29udGVudCwgb3B0aW9ucyk7XG5cblxuaWYgKG1vZHVsZS5ob3QpIHtcbiAgaWYgKCFjb250ZW50LmxvY2FscyB8fCBtb2R1bGUuaG90LmludmFsaWRhdGUpIHtcbiAgICB2YXIgaXNFcXVhbExvY2FscyA9IGZ1bmN0aW9uIGlzRXF1YWxMb2NhbHMoYSxiLGlzTmFtZWRFeHBvcnQpe2lmKCFhJiZifHxhJiYhYil7cmV0dXJuIGZhbHNlO31sZXQgcDtmb3IocCBpbiBhKXtpZihpc05hbWVkRXhwb3J0JiZwPT09J2RlZmF1bHQnKXsvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29udGludWVcbmNvbnRpbnVlO31pZihhW3BdIT09YltwXSl7cmV0dXJuIGZhbHNlO319Zm9yKHAgaW4gYil7aWYoaXNOYW1lZEV4cG9ydCYmcD09PSdkZWZhdWx0Jyl7Ly8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnRpbnVlXG5jb250aW51ZTt9aWYoIWFbcF0pe3JldHVybiBmYWxzZTt9fXJldHVybiB0cnVlO307XG4gICAgdmFyIG9sZExvY2FscyA9IGNvbnRlbnQubG9jYWxzO1xuXG4gICAgbW9kdWxlLmhvdC5hY2NlcHQoXG4gICAgICBcIiEhLi4vLi4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jb21waWxlZC9jc3MtbG9hZGVyL2Nqcy5qcz8/cmVmLS01LW9uZU9mLTItMSEuLi8uLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NvbXBpbGVkL3Bvc3Rjc3MtbG9hZGVyL2Nqcy5qcz8/cmVmLS01LW9uZU9mLTItMiEuL0Fib3V0Q29udHJvbHMubW9kdWxlLmNzc1wiLFxuICAgICAgZnVuY3Rpb24gKCkge1xuICAgICAgICBjb250ZW50ID0gcmVxdWlyZShcIiEhLi4vLi4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jb21waWxlZC9jc3MtbG9hZGVyL2Nqcy5qcz8/cmVmLS01LW9uZU9mLTItMSEuLi8uLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NvbXBpbGVkL3Bvc3Rjc3MtbG9hZGVyL2Nqcy5qcz8/cmVmLS01LW9uZU9mLTItMiEuL0Fib3V0Q29udHJvbHMubW9kdWxlLmNzc1wiKTtcblxuICAgICAgICAgICAgICBjb250ZW50ID0gY29udGVudC5fX2VzTW9kdWxlID8gY29udGVudC5kZWZhdWx0IDogY29udGVudDtcblxuICAgICAgICAgICAgICBpZiAodHlwZW9mIGNvbnRlbnQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgY29udGVudCA9IFtbbW9kdWxlLmlkLCBjb250ZW50LCAnJ11dO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgaWYgKCFpc0VxdWFsTG9jYWxzKG9sZExvY2FscywgY29udGVudC5sb2NhbHMpKSB7XG4gICAgICAgICAgICAgICAgbW9kdWxlLmhvdC5pbnZhbGlkYXRlKCk7XG5cbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBvbGRMb2NhbHMgPSBjb250ZW50LmxvY2FscztcblxuICAgICAgICAgICAgICB1cGRhdGUoY29udGVudCk7XG4gICAgICB9XG4gICAgKVxuICB9XG5cbiAgbW9kdWxlLmhvdC5kaXNwb3NlKGZ1bmN0aW9uKCkge1xuICAgIHVwZGF0ZSgpO1xuICB9KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjb250ZW50LmxvY2FscyB8fCB7fTsiLCJpbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsgQnV0dG9uLCBQb3J0YWxCb3gsIFNWRyB9IGZyb20gJ0B0aGVtZSc7XG5pbXBvcnQgRW1haWxTaWdudXAgZnJvbSAnQGNvbXBzL0Fib3V0L0VtYWlsU2lnbnVwJztcbmltcG9ydCBQdXNoTm90aWZpY2F0aW9ucyBmcm9tICdAY29tcHMvQWJvdXQvUHVzaE5vdGlmaWNhdGlvbnMnO1xuaW1wb3J0IGNuIGZyb20gJ0B1dGlscy9jbGFzc25hbWVzJztcbmltcG9ydCB7IGFwcERlc2NyaXB0aW9uLCBhcHBUaXRsZSB9IGZyb20gJ0B1dGlscy9jb25zdGFudHMnO1xuaW1wb3J0IHN0eWxlcyBmcm9tICcuL0Fib3V0Q29udHJvbHMubW9kdWxlLmNzcyc7XG5cbmNvbnN0IEFib3V0Q29udHJvbHMgPSAoeyBjbGFzc05hbWUgPSAnJyB9OiB7IGNsYXNzTmFtZT86IHN0cmluZyB9KSA9PiB7XG4gIGNvbnN0IFtlbWFpbEJveCwgc2V0RW1haWxCb3hdID0gUmVhY3QudXNlU3RhdGU8Ym9vbGVhbj4oZmFsc2UpO1xuICBjb25zdCBbcHVzaEJveCwgc2V0UHVzaEJveF0gPSBSZWFjdC51c2VTdGF0ZTxib29sZWFuPihmYWxzZSk7XG5cbiAgcmV0dXJuIChcbiAgICA8UmVhY3QuRnJhZ21lbnQ+XG4gICAgICA8dWwgY2xhc3NOYW1lPXtjbihzdHlsZXMucm9vdCwgY2xhc3NOYW1lKX0+XG4gICAgICAgIDxsaSBjbGFzc05hbWU9e2NuKHN0eWxlcy5pdGVtKX0+XG4gICAgICAgICAgPEJ1dHRvblxuICAgICAgICAgICAgY2xhc3NOYW1lPXtjbihzdHlsZXMuYnV0dG9uKX1cbiAgICAgICAgICAgIG9uQ2xpY2s9eygpID0+IHNldEVtYWlsQm94KHRydWUpfVxuICAgICAgICAgICAgbGF5b3V0PVwiZW1wdHlcIlxuICAgICAgICAgICAgcm91bmRcbiAgICAgICAgICAgIGljb249XCJtZGkvZW1haWwtb3V0bGluZVwiXG4gICAgICAgICAgICBpY29uUmlnaHRcbiAgICAgICAgICA+XG4gICAgICAgICAgICBTdWJzY3JpYmUgRW1haWxcbiAgICAgICAgICA8L0J1dHRvbj5cbiAgICAgICAgPC9saT5cbiAgICAgICAgPGxpIGNsYXNzTmFtZT17Y24oc3R5bGVzLml0ZW0pfT5cbiAgICAgICAgICA8QnV0dG9uXG4gICAgICAgICAgICBjbGFzc05hbWU9e2NuKHN0eWxlcy5idXR0b24pfVxuICAgICAgICAgICAgb25DbGljaz17KCkgPT4gc2V0UHVzaEJveCh0cnVlKX1cbiAgICAgICAgICAgIGxheW91dD1cImVtcHR5XCJcbiAgICAgICAgICAgIHJvdW5kXG4gICAgICAgICAgICBpY29uPVwibWRpL2JlbGwtb3V0bGluZVwiXG4gICAgICAgICAgICBpY29uUmlnaHRcbiAgICAgICAgICA+XG4gICAgICAgICAgICBQdXNoIE5vdGlmaWNhdGlvbnNcbiAgICAgICAgICA8L0J1dHRvbj5cbiAgICAgICAgPC9saT5cbiAgICAgICAgeydzaGFyZScgaW4gbmF2aWdhdG9yICYmIChcbiAgICAgICAgICA8bGkgY2xhc3NOYW1lPXtjbihzdHlsZXMuaXRlbSl9PlxuICAgICAgICAgICAgPEJ1dHRvblxuICAgICAgICAgICAgICBjbGFzc05hbWU9e2NuKHN0eWxlcy5idXR0b24pfVxuICAgICAgICAgICAgICBvbkNsaWNrPXsoKSA9PlxuICAgICAgICAgICAgICAgIG5hdmlnYXRvci5zaGFyZSh7XG4gICAgICAgICAgICAgICAgICB1cmw6IHdpbmRvdy5sb2NhdGlvbi5ocmVmLFxuICAgICAgICAgICAgICAgICAgdGV4dDogYENoZWNrIG91dCBQV0FkdmVudC5kZXYuICR7YXBwRGVzY3JpcHRpb259YCxcbiAgICAgICAgICAgICAgICAgIHRpdGxlOiBhcHBUaXRsZSxcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGxheW91dD1cImVtcHR5XCJcbiAgICAgICAgICAgICAgcm91bmRcbiAgICAgICAgICAgICAgaWNvbj1cIm1kaS9zaGFyZVwiXG4gICAgICAgICAgICAgIGljb25SaWdodFxuICAgICAgICAgICAgPlxuICAgICAgICAgICAgICBUZWxsIHlvdXIgZnJpZW5kc1xuICAgICAgICAgICAgPC9CdXR0b24+XG4gICAgICAgICAgPC9saT5cbiAgICAgICAgKX1cbiAgICAgICAgeyh3aW5kb3cgYXMgYW55KS5pbnN0YWxsUHJvbXB0ICYmIChcbiAgICAgICAgICA8bGkgY2xhc3NOYW1lPXtjbihzdHlsZXMuaXRlbSl9PlxuICAgICAgICAgICAgPEJ1dHRvblxuICAgICAgICAgICAgICBjbGFzc05hbWU9e2NuKHN0eWxlcy5idXR0b24pfVxuICAgICAgICAgICAgICBvbkNsaWNrPXsoKSA9PiAod2luZG93IGFzIGFueSkuaW5zdGFsbFByb21wdC5wcm9tcHQoKX1cbiAgICAgICAgICAgICAgbGF5b3V0PVwiZW1wdHlcIlxuICAgICAgICAgICAgICByb3VuZFxuICAgICAgICAgICAgICBpY29uPVwibWRpL2Rvd25sb2FkXCJcbiAgICAgICAgICAgICAgaWNvblJpZ2h0XG4gICAgICAgICAgICA+XG4gICAgICAgICAgICAgIEFkZCB0byBob21lc2NyZWVuXG4gICAgICAgICAgICA8L0J1dHRvbj5cbiAgICAgICAgICA8L2xpPlxuICAgICAgICApfVxuICAgICAgPC91bD5cbiAgICAgIHtlbWFpbEJveCAmJiAoXG4gICAgICAgIDxQb3J0YWxCb3hcbiAgICAgICAgICBzaXplPVwic21hbGxcIlxuICAgICAgICAgIGNsb3NlPXsoKSA9PiB7XG4gICAgICAgICAgICAvL3NldHRpbmdzREIuc2V0KCdlbWFpbFBvcHVwQ2xvc2VkJywgdHJ1ZSk7XG4gICAgICAgICAgICBzZXRFbWFpbEJveChmYWxzZSk7XG4gICAgICAgICAgfX1cbiAgICAgICAgICB0aXRsZT1cIkVtYWlsIHNpZ251cFwiXG4gICAgICAgID5cbiAgICAgICAgICA8RW1haWxTaWdudXAgLz5cbiAgICAgICAgPC9Qb3J0YWxCb3g+XG4gICAgICApfVxuICAgICAge3B1c2hCb3ggJiYgKFxuICAgICAgICA8UG9ydGFsQm94XG4gICAgICAgICAgc2l6ZT1cInNtYWxsXCJcbiAgICAgICAgICBjbG9zZT17KCkgPT4gc2V0UHVzaEJveChmYWxzZSl9XG4gICAgICAgICAgdGl0bGU9XCJQdXNoIE5vdGlmaWNhdGlvbnNcIlxuICAgICAgICA+XG4gICAgICAgICAgPFB1c2hOb3RpZmljYXRpb25zIC8+XG4gICAgICAgIDwvUG9ydGFsQm94PlxuICAgICAgKX1cbiAgICA8L1JlYWN0LkZyYWdtZW50PlxuICApO1xufTtcblxuZXhwb3J0IGRlZmF1bHQgQWJvdXRDb250cm9scztcbiIsInZhciBhcGkgPSByZXF1aXJlKFwiIS4uLy4uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvYnVpbGQvd2VicGFjay9sb2FkZXJzL25leHQtc3R5bGUtbG9hZGVyL3J1bnRpbWUvaW5qZWN0U3R5bGVzSW50b1N0eWxlVGFnLmpzXCIpO1xuICAgICAgICAgICAgdmFyIGNvbnRlbnQgPSByZXF1aXJlKFwiISEuLi8uLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NvbXBpbGVkL2Nzcy1sb2FkZXIvY2pzLmpzPz9yZWYtLTUtb25lT2YtMi0xIS4uLy4uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvcG9zdGNzcy1sb2FkZXIvY2pzLmpzPz9yZWYtLTUtb25lT2YtMi0yIS4vQWJvdXROYXZpZ2F0aW9uLm1vZHVsZS5jc3NcIik7XG5cbiAgICAgICAgICAgIGNvbnRlbnQgPSBjb250ZW50Ll9fZXNNb2R1bGUgPyBjb250ZW50LmRlZmF1bHQgOiBjb250ZW50O1xuXG4gICAgICAgICAgICBpZiAodHlwZW9mIGNvbnRlbnQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgIGNvbnRlbnQgPSBbW21vZHVsZS5pZCwgY29udGVudCwgJyddXTtcbiAgICAgICAgICAgIH1cblxudmFyIG9wdGlvbnMgPSB7fTtcblxub3B0aW9ucy5pbnNlcnQgPSBmdW5jdGlvbihlbGVtZW50KXsvLyBUaGVzZSBlbGVtZW50cyBzaG91bGQgYWx3YXlzIGV4aXN0LiBJZiB0aGV5IGRvIG5vdCxcbi8vIHRoaXMgY29kZSBzaG91bGQgZmFpbC5cbnZhciBhbmNob3JFbGVtZW50PWRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJyNfX25leHRfY3NzX19ET19OT1RfVVNFX18nKTt2YXIgcGFyZW50Tm9kZT1hbmNob3JFbGVtZW50LnBhcmVudE5vZGU7Ly8gTm9ybWFsbHkgPGhlYWQ+XG4vLyBFYWNoIHN0eWxlIHRhZyBzaG91bGQgYmUgcGxhY2VkIHJpZ2h0IGJlZm9yZSBvdXJcbi8vIGFuY2hvci4gQnkgaW5zZXJ0aW5nIGJlZm9yZSBhbmQgbm90IGFmdGVyLCB3ZSBkbyBub3Rcbi8vIG5lZWQgdG8gdHJhY2sgdGhlIGxhc3QgaW5zZXJ0ZWQgZWxlbWVudC5cbnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKGVsZW1lbnQsYW5jaG9yRWxlbWVudCk7fTtcbm9wdGlvbnMuc2luZ2xldG9uID0gZmFsc2U7XG5cbnZhciB1cGRhdGUgPSBhcGkoY29udGVudCwgb3B0aW9ucyk7XG5cblxuaWYgKG1vZHVsZS5ob3QpIHtcbiAgaWYgKCFjb250ZW50LmxvY2FscyB8fCBtb2R1bGUuaG90LmludmFsaWRhdGUpIHtcbiAgICB2YXIgaXNFcXVhbExvY2FscyA9IGZ1bmN0aW9uIGlzRXF1YWxMb2NhbHMoYSxiLGlzTmFtZWRFeHBvcnQpe2lmKCFhJiZifHxhJiYhYil7cmV0dXJuIGZhbHNlO31sZXQgcDtmb3IocCBpbiBhKXtpZihpc05hbWVkRXhwb3J0JiZwPT09J2RlZmF1bHQnKXsvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29udGludWVcbmNvbnRpbnVlO31pZihhW3BdIT09YltwXSl7cmV0dXJuIGZhbHNlO319Zm9yKHAgaW4gYil7aWYoaXNOYW1lZEV4cG9ydCYmcD09PSdkZWZhdWx0Jyl7Ly8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnRpbnVlXG5jb250aW51ZTt9aWYoIWFbcF0pe3JldHVybiBmYWxzZTt9fXJldHVybiB0cnVlO307XG4gICAgdmFyIG9sZExvY2FscyA9IGNvbnRlbnQubG9jYWxzO1xuXG4gICAgbW9kdWxlLmhvdC5hY2NlcHQoXG4gICAgICBcIiEhLi4vLi4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jb21waWxlZC9jc3MtbG9hZGVyL2Nqcy5qcz8/cmVmLS01LW9uZU9mLTItMSEuLi8uLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NvbXBpbGVkL3Bvc3Rjc3MtbG9hZGVyL2Nqcy5qcz8/cmVmLS01LW9uZU9mLTItMiEuL0Fib3V0TmF2aWdhdGlvbi5tb2R1bGUuY3NzXCIsXG4gICAgICBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGNvbnRlbnQgPSByZXF1aXJlKFwiISEuLi8uLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NvbXBpbGVkL2Nzcy1sb2FkZXIvY2pzLmpzPz9yZWYtLTUtb25lT2YtMi0xIS4uLy4uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvcG9zdGNzcy1sb2FkZXIvY2pzLmpzPz9yZWYtLTUtb25lT2YtMi0yIS4vQWJvdXROYXZpZ2F0aW9uLm1vZHVsZS5jc3NcIik7XG5cbiAgICAgICAgICAgICAgY29udGVudCA9IGNvbnRlbnQuX19lc01vZHVsZSA/IGNvbnRlbnQuZGVmYXVsdCA6IGNvbnRlbnQ7XG5cbiAgICAgICAgICAgICAgaWYgKHR5cGVvZiBjb250ZW50ID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIGNvbnRlbnQgPSBbW21vZHVsZS5pZCwgY29udGVudCwgJyddXTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGlmICghaXNFcXVhbExvY2FscyhvbGRMb2NhbHMsIGNvbnRlbnQubG9jYWxzKSkge1xuICAgICAgICAgICAgICAgIG1vZHVsZS5ob3QuaW52YWxpZGF0ZSgpO1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgb2xkTG9jYWxzID0gY29udGVudC5sb2NhbHM7XG5cbiAgICAgICAgICAgICAgdXBkYXRlKGNvbnRlbnQpO1xuICAgICAgfVxuICAgIClcbiAgfVxuXG4gIG1vZHVsZS5ob3QuZGlzcG9zZShmdW5jdGlvbigpIHtcbiAgICB1cGRhdGUoKTtcbiAgfSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gY29udGVudC5sb2NhbHMgfHwge307IiwiaW1wb3J0IExpbmsgZnJvbSAnbmV4dC9saW5rJztcbmltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgY24gZnJvbSAnQHV0aWxzL2NsYXNzbmFtZXMnO1xuaW1wb3J0IHN0eWxlcyBmcm9tICcuL0Fib3V0TmF2aWdhdGlvbi5tb2R1bGUuY3NzJztcblxuY29uc3QgQWJvdXROYXZpZ2F0aW9uID0gKHsgY2xhc3NOYW1lID0gJycgfTogeyBjbGFzc05hbWU/OiBzdHJpbmcgfSkgPT4gKFxuICA8bmF2IGNsYXNzTmFtZT17Y24oY2xhc3NOYW1lLCBzdHlsZXMucm9vdCl9PlxuICAgIHtPYmplY3QuZW50cmllcyh7XG4gICAgICBsZWdhbDogJ0xlZ2FsJyxcbiAgICAgIHByaXZhY3k6ICdQcml2YWN5JyxcbiAgICAgIGNyZWRpdHM6ICdDcmVkaXRzJyxcbiAgICB9KS5tYXAoKFtzbHVnLCB0aXRsZV0pID0+IChcbiAgICAgIDxMaW5rIGhyZWY9e2AvJHtzbHVnfS9gfT5cbiAgICAgICAgPGEgY2xhc3NOYW1lPXtzdHlsZXMuaXRlbX0+e3RpdGxlfTwvYT5cbiAgICAgIDwvTGluaz5cbiAgICApKX1cbiAgPC9uYXY+XG4pO1xuXG5leHBvcnQgZGVmYXVsdCBBYm91dE5hdmlnYXRpb247XG4iLCJ2YXIgYXBpID0gcmVxdWlyZShcIiEuLi8uLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2J1aWxkL3dlYnBhY2svbG9hZGVycy9uZXh0LXN0eWxlLWxvYWRlci9ydW50aW1lL2luamVjdFN0eWxlc0ludG9TdHlsZVRhZy5qc1wiKTtcbiAgICAgICAgICAgIHZhciBjb250ZW50ID0gcmVxdWlyZShcIiEhLi4vLi4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jb21waWxlZC9jc3MtbG9hZGVyL2Nqcy5qcz8/cmVmLS01LW9uZU9mLTItMSEuLi8uLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NvbXBpbGVkL3Bvc3Rjc3MtbG9hZGVyL2Nqcy5qcz8/cmVmLS01LW9uZU9mLTItMiEuL0VtYWlsU2lnbnVwLm1vZHVsZS5jc3NcIik7XG5cbiAgICAgICAgICAgIGNvbnRlbnQgPSBjb250ZW50Ll9fZXNNb2R1bGUgPyBjb250ZW50LmRlZmF1bHQgOiBjb250ZW50O1xuXG4gICAgICAgICAgICBpZiAodHlwZW9mIGNvbnRlbnQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgIGNvbnRlbnQgPSBbW21vZHVsZS5pZCwgY29udGVudCwgJyddXTtcbiAgICAgICAgICAgIH1cblxudmFyIG9wdGlvbnMgPSB7fTtcblxub3B0aW9ucy5pbnNlcnQgPSBmdW5jdGlvbihlbGVtZW50KXsvLyBUaGVzZSBlbGVtZW50cyBzaG91bGQgYWx3YXlzIGV4aXN0LiBJZiB0aGV5IGRvIG5vdCxcbi8vIHRoaXMgY29kZSBzaG91bGQgZmFpbC5cbnZhciBhbmNob3JFbGVtZW50PWRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJyNfX25leHRfY3NzX19ET19OT1RfVVNFX18nKTt2YXIgcGFyZW50Tm9kZT1hbmNob3JFbGVtZW50LnBhcmVudE5vZGU7Ly8gTm9ybWFsbHkgPGhlYWQ+XG4vLyBFYWNoIHN0eWxlIHRhZyBzaG91bGQgYmUgcGxhY2VkIHJpZ2h0IGJlZm9yZSBvdXJcbi8vIGFuY2hvci4gQnkgaW5zZXJ0aW5nIGJlZm9yZSBhbmQgbm90IGFmdGVyLCB3ZSBkbyBub3Rcbi8vIG5lZWQgdG8gdHJhY2sgdGhlIGxhc3QgaW5zZXJ0ZWQgZWxlbWVudC5cbnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKGVsZW1lbnQsYW5jaG9yRWxlbWVudCk7fTtcbm9wdGlvbnMuc2luZ2xldG9uID0gZmFsc2U7XG5cbnZhciB1cGRhdGUgPSBhcGkoY29udGVudCwgb3B0aW9ucyk7XG5cblxuaWYgKG1vZHVsZS5ob3QpIHtcbiAgaWYgKCFjb250ZW50LmxvY2FscyB8fCBtb2R1bGUuaG90LmludmFsaWRhdGUpIHtcbiAgICB2YXIgaXNFcXVhbExvY2FscyA9IGZ1bmN0aW9uIGlzRXF1YWxMb2NhbHMoYSxiLGlzTmFtZWRFeHBvcnQpe2lmKCFhJiZifHxhJiYhYil7cmV0dXJuIGZhbHNlO31sZXQgcDtmb3IocCBpbiBhKXtpZihpc05hbWVkRXhwb3J0JiZwPT09J2RlZmF1bHQnKXsvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29udGludWVcbmNvbnRpbnVlO31pZihhW3BdIT09YltwXSl7cmV0dXJuIGZhbHNlO319Zm9yKHAgaW4gYil7aWYoaXNOYW1lZEV4cG9ydCYmcD09PSdkZWZhdWx0Jyl7Ly8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnRpbnVlXG5jb250aW51ZTt9aWYoIWFbcF0pe3JldHVybiBmYWxzZTt9fXJldHVybiB0cnVlO307XG4gICAgdmFyIG9sZExvY2FscyA9IGNvbnRlbnQubG9jYWxzO1xuXG4gICAgbW9kdWxlLmhvdC5hY2NlcHQoXG4gICAgICBcIiEhLi4vLi4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jb21waWxlZC9jc3MtbG9hZGVyL2Nqcy5qcz8/cmVmLS01LW9uZU9mLTItMSEuLi8uLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NvbXBpbGVkL3Bvc3Rjc3MtbG9hZGVyL2Nqcy5qcz8/cmVmLS01LW9uZU9mLTItMiEuL0VtYWlsU2lnbnVwLm1vZHVsZS5jc3NcIixcbiAgICAgIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgY29udGVudCA9IHJlcXVpcmUoXCIhIS4uLy4uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvY3NzLWxvYWRlci9janMuanM/P3JlZi0tNS1vbmVPZi0yLTEhLi4vLi4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jb21waWxlZC9wb3N0Y3NzLWxvYWRlci9janMuanM/P3JlZi0tNS1vbmVPZi0yLTIhLi9FbWFpbFNpZ251cC5tb2R1bGUuY3NzXCIpO1xuXG4gICAgICAgICAgICAgIGNvbnRlbnQgPSBjb250ZW50Ll9fZXNNb2R1bGUgPyBjb250ZW50LmRlZmF1bHQgOiBjb250ZW50O1xuXG4gICAgICAgICAgICAgIGlmICh0eXBlb2YgY29udGVudCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICBjb250ZW50ID0gW1ttb2R1bGUuaWQsIGNvbnRlbnQsICcnXV07XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBpZiAoIWlzRXF1YWxMb2NhbHMob2xkTG9jYWxzLCBjb250ZW50LmxvY2FscykpIHtcbiAgICAgICAgICAgICAgICBtb2R1bGUuaG90LmludmFsaWRhdGUoKTtcblxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIG9sZExvY2FscyA9IGNvbnRlbnQubG9jYWxzO1xuXG4gICAgICAgICAgICAgIHVwZGF0ZShjb250ZW50KTtcbiAgICAgIH1cbiAgICApXG4gIH1cblxuICBtb2R1bGUuaG90LmRpc3Bvc2UoZnVuY3Rpb24oKSB7XG4gICAgdXBkYXRlKCk7XG4gIH0pO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNvbnRlbnQubG9jYWxzIHx8IHt9OyIsImltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQge1xuICBCdXR0b24sXG4gIEZvcm0sXG4gIEZvcm1Db250cm9scyxcbiAgRm9ybUZpZWxkLFxuICBGb3JtRmllbGRzZXQsXG4gIElucHV0VGV4dCxcbiAgTm90aWZpY2F0aW9uLFxufSBmcm9tICdAdGhlbWUnO1xuaW1wb3J0IGNuIGZyb20gJ0B1dGlscy9jbGFzc25hbWVzJztcbmltcG9ydCB7IGFwaUJhc2UgfSBmcm9tICdAdXRpbHMvY29uc3RhbnRzJztcbmltcG9ydCBzdHlsZXMgZnJvbSAnLi9FbWFpbFNpZ251cC5tb2R1bGUuY3NzJztcblxuY29uc3QgRW1haWxTaWdudXAgPSAoeyBjbGFzc05hbWUgPSAnJyB9OiB7IGNsYXNzTmFtZT86IHN0cmluZyB9KSA9PiB7XG4gIGNvbnN0IFtsb2FkaW5nLCBzZXRMb2FkaW5nXSA9IFJlYWN0LnVzZVN0YXRlPGJvb2xlYW4+KGZhbHNlKTtcbiAgY29uc3QgW2Zvcm1TdWNjZXNzLCBzZXRGb3JtU3VjY2Vzc10gPSBSZWFjdC51c2VTdGF0ZTxzdHJpbmc+KCcnKTtcbiAgY29uc3QgW2Zvcm1FcnJvciwgc2V0Rm9ybUVycm9yXSA9IFJlYWN0LnVzZVN0YXRlPHN0cmluZz4oJycpO1xuXG4gIHJldHVybiAoXG4gICAgPGRpdiBjbGFzc05hbWU9e2NuKGNsYXNzTmFtZSl9PlxuICAgICAgPGRpdiBjbGFzc05hbWU9e2NuKHN0eWxlcy5jb250ZW50KX0+XG4gICAgICAgIDxwPlxuICAgICAgICAgIEFyZSB5b3UgZXhjaXRlZCBmb3IgUHJvZ3Jlc3NpdmUgV2ViIEFwcHM/IExldCdzIGdldCByZWFkeSBmb3JcbiAgICAgICAgICBQV0FkdmVudCEgMjQgZmVhdHVyZXMgaW4gMjQgZGF5cy5cbiAgICAgICAgPC9wPlxuICAgICAgICA8cD5cbiAgICAgICAgICBNYWtlIHN1cmUgdG8gc3Vic2NyaWJlIGFuZCBnZXQgbm90aWZpZWQgYXMgc29vbiBhcyBhIG5ldyBmZWF0dXJlIGlzXG4gICAgICAgICAgcHVibGlzaGVkLlxuICAgICAgICA8L3A+XG4gICAgICA8L2Rpdj5cbiAgICAgIHtmb3JtRXJyb3IgIT09ICcnID8gKFxuICAgICAgICA8Tm90aWZpY2F0aW9uIGNsYXNzTmFtZT17Y24oc3R5bGVzLm5vdGlmaWNhdGlvbil9IHR5cGU9XCJlcnJvclwiPlxuICAgICAgICAgIHtmb3JtRXJyb3J9XG4gICAgICAgIDwvTm90aWZpY2F0aW9uPlxuICAgICAgKSA6IGZvcm1TdWNjZXNzICE9PSAnJyA/IChcbiAgICAgICAgPE5vdGlmaWNhdGlvbiBjbGFzc05hbWU9e2NuKHN0eWxlcy5ub3RpZmljYXRpb24pfSB0eXBlPVwic3VjY2Vzc1wiPlxuICAgICAgICAgIHtmb3JtU3VjY2Vzc31cbiAgICAgICAgPC9Ob3RpZmljYXRpb24+XG4gICAgICApIDogKFxuICAgICAgICA8UmVhY3QuRnJhZ21lbnQ+XG4gICAgICAgICAgPEZvcm1cbiAgICAgICAgICAgIGNsYXNzTmFtZT17Y24oc3R5bGVzLmZvcm0pfVxuICAgICAgICAgICAgb25TdWJtaXQ9e2FzeW5jIChkYXRhKSA9PiB7XG4gICAgICAgICAgICAgIHNldExvYWRpbmcodHJ1ZSk7XG4gICAgICAgICAgICAgIHNldEZvcm1TdWNjZXNzKCcnKTtcbiAgICAgICAgICAgICAgc2V0Rm9ybUVycm9yKCcnKTtcblxuICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3AgPSBhd2FpdCBmZXRjaChcbiAgICAgICAgICAgICAgICAgIGAke2FwaUJhc2V9d3AtanNvbi9hZHZlbnQtY2FsZW5kYXIvdjEvZW1haWwtbm90aWZpY2F0aW9uL2AsXG4gICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIG1ldGhvZDogJ3Bvc3QnLFxuICAgICAgICAgICAgICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeSh7XG4gICAgICAgICAgICAgICAgICAgICAgZW1haWw6IGRhdGEuZW1haWwsXG4gICAgICAgICAgICAgICAgICAgICAgdGltZXpvbmVPZmZzZXQ6IG5ldyBEYXRlKCkuZ2V0VGltZXpvbmVPZmZzZXQoKSxcbiAgICAgICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICAgICAgICAgICAgICAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgaWYgKHJlc3Auc3RhdHVzID09PSA0MDkpIHtcbiAgICAgICAgICAgICAgICAgIHNldEZvcm1TdWNjZXNzKFxuICAgICAgICAgICAgICAgICAgICAnVGhhbmsgeW91IHZlcnkgbXVjaC4gWW91ciBlbWFpbCBoYXMgYWxyZWFkeSBiZWVuIHJlZ2lzdGVyZWQuJ1xuICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHJlc3Auc3RhdHVzID09PSAyMDApIHtcbiAgICAgICAgICAgICAgICAgIHNldEZvcm1TdWNjZXNzKFxuICAgICAgICAgICAgICAgICAgICAnVGhhbmsgeW91IHZlcnkgbXVjaC4gWW91IHdpbGwgcmVjZWl2ZSBhbiBlbWFpbCBzaG9ydGx5LCBpbiB3aGljaCB5b3UgY2FuIGNvbmZpcm0geW91ciBhZGRyZXNzJ1xuICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgbmV3IEVycm9yKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgc2V0Rm9ybUVycm9yKFxuICAgICAgICAgICAgICAgICAgJ09vcHMuLiBTb21ldGhpbmcgd2VudCB3cm9uZy4gUGxlYXNlIHRyeSBhZ2FpbiBsYXRlci4nXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBzZXRMb2FkaW5nKGZhbHNlKTtcbiAgICAgICAgICAgIH19XG4gICAgICAgICAgPlxuICAgICAgICAgICAgPEZvcm1GaWVsZHNldCBzdGFja2VkPlxuICAgICAgICAgICAgICA8Rm9ybUZpZWxkXG4gICAgICAgICAgICAgICAgbmFtZT1cImVtYWlsXCJcbiAgICAgICAgICAgICAgICBsYWJlbD1cIkVtYWlsXCJcbiAgICAgICAgICAgICAgICBjb21wb25lbnQ9e0lucHV0VGV4dH1cbiAgICAgICAgICAgICAgICBkaXNhYmxlZD17bG9hZGluZ31cbiAgICAgICAgICAgICAgICB0eXBlPVwiZW1haWxcIlxuICAgICAgICAgICAgICAgIHJlZ2lzdGVyPXt7XG4gICAgICAgICAgICAgICAgICByZXF1aXJlZDogJ1RoaXMgdmFsdWUgaXMgcmVxdWlyZWQnLFxuICAgICAgICAgICAgICAgICAgcGF0dGVybjoge1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZTpcbiAgICAgICAgICAgICAgICAgICAgICAvXigoW148PigpXFxbXFxdXFxcXC4sOzpcXHNAXCJdKyhcXC5bXjw+KClcXFtcXF1cXFxcLiw7Olxcc0BcIl0rKSopfChcIi4rXCIpKUAoKFxcW1swLTldezEsM31cXC5bMC05XXsxLDN9XFwuWzAtOV17MSwzfVxcLlswLTldezEsM31cXF0pfCgoW2EtekEtWlxcLTAtOV0rXFwuKStbYS16QS1aXXsyLH0pKSQvLFxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiAnVGhpcyBuZWVkcyB0byBiZSBhIHZhbGlkIEVtYWlsIGFkcmVzcycsXG4gICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIH19XG4gICAgICAgICAgICAgIC8+XG4gICAgICAgICAgICAgIDxGb3JtQ29udHJvbHM+XG4gICAgICAgICAgICAgICAgPEJ1dHRvblxuICAgICAgICAgICAgICAgICAgdHlwZT1cInN1Ym1pdFwiXG4gICAgICAgICAgICAgICAgICBsb2FkaW5nPXtsb2FkaW5nfVxuICAgICAgICAgICAgICAgICAgZGlzYWJsZWQ9e2xvYWRpbmd9XG4gICAgICAgICAgICAgICAgICBpY29uPVwibWRpL3NlbmRcIlxuICAgICAgICAgICAgICAgICAgaWNvblJpZ2h0XG4gICAgICAgICAgICAgICAgPlxuICAgICAgICAgICAgICAgICAgU3VibWl0XG4gICAgICAgICAgICAgICAgPC9CdXR0b24+XG4gICAgICAgICAgICAgIDwvRm9ybUNvbnRyb2xzPlxuICAgICAgICAgICAgPC9Gb3JtRmllbGRzZXQ+XG4gICAgICAgICAgPC9Gb3JtPlxuICAgICAgICAgIDxwIGNsYXNzTmFtZT17Y24oc3R5bGVzLmRpc2NsYWltZXIpfT5cbiAgICAgICAgICAgIFdlIHVzZSB5b3VyIGVtYWlsIGV4Y2x1c2l2ZWx5IHRvIHNlbmQgeW91IHRoZSBsaW5rIHRvIHRoZSBwdWJsaXNoZWRcbiAgICAgICAgICAgIGVudHJ5IGV2ZXJ5IG1vcm5pbmcgYmV0d2VlbiAyMDIwLTEyLTAxIGFuZCAyMDIwLTEyLTI0LiBZb3UgY2FuXG4gICAgICAgICAgICBjYW5jZWwgdGhpcyBzZXJ2aWNlIGF0IGFueSB0aW1lLCB5b3VyIGRhdGEgd2lsbCBub3QgYmUgcGFzc2VkIG9uIHRvXG4gICAgICAgICAgICB0aGlyZCBwYXJ0aWVzLlxuICAgICAgICAgIDwvcD5cbiAgICAgICAgPC9SZWFjdC5GcmFnbWVudD5cbiAgICAgICl9XG4gICAgPC9kaXY+XG4gICk7XG59O1xuXG5leHBvcnQgZGVmYXVsdCBFbWFpbFNpZ251cDtcbiIsInZhciBhcGkgPSByZXF1aXJlKFwiIS4uLy4uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvYnVpbGQvd2VicGFjay9sb2FkZXJzL25leHQtc3R5bGUtbG9hZGVyL3J1bnRpbWUvaW5qZWN0U3R5bGVzSW50b1N0eWxlVGFnLmpzXCIpO1xuICAgICAgICAgICAgdmFyIGNvbnRlbnQgPSByZXF1aXJlKFwiISEuLi8uLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NvbXBpbGVkL2Nzcy1sb2FkZXIvY2pzLmpzPz9yZWYtLTUtb25lT2YtMi0xIS4uLy4uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvcG9zdGNzcy1sb2FkZXIvY2pzLmpzPz9yZWYtLTUtb25lT2YtMi0yIS4vUHVzaE5vdGlmaWNhdGlvbnMubW9kdWxlLmNzc1wiKTtcblxuICAgICAgICAgICAgY29udGVudCA9IGNvbnRlbnQuX19lc01vZHVsZSA/IGNvbnRlbnQuZGVmYXVsdCA6IGNvbnRlbnQ7XG5cbiAgICAgICAgICAgIGlmICh0eXBlb2YgY29udGVudCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgY29udGVudCA9IFtbbW9kdWxlLmlkLCBjb250ZW50LCAnJ11dO1xuICAgICAgICAgICAgfVxuXG52YXIgb3B0aW9ucyA9IHt9O1xuXG5vcHRpb25zLmluc2VydCA9IGZ1bmN0aW9uKGVsZW1lbnQpey8vIFRoZXNlIGVsZW1lbnRzIHNob3VsZCBhbHdheXMgZXhpc3QuIElmIHRoZXkgZG8gbm90LFxuLy8gdGhpcyBjb2RlIHNob3VsZCBmYWlsLlxudmFyIGFuY2hvckVsZW1lbnQ9ZG9jdW1lbnQucXVlcnlTZWxlY3RvcignI19fbmV4dF9jc3NfX0RPX05PVF9VU0VfXycpO3ZhciBwYXJlbnROb2RlPWFuY2hvckVsZW1lbnQucGFyZW50Tm9kZTsvLyBOb3JtYWxseSA8aGVhZD5cbi8vIEVhY2ggc3R5bGUgdGFnIHNob3VsZCBiZSBwbGFjZWQgcmlnaHQgYmVmb3JlIG91clxuLy8gYW5jaG9yLiBCeSBpbnNlcnRpbmcgYmVmb3JlIGFuZCBub3QgYWZ0ZXIsIHdlIGRvIG5vdFxuLy8gbmVlZCB0byB0cmFjayB0aGUgbGFzdCBpbnNlcnRlZCBlbGVtZW50LlxucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUoZWxlbWVudCxhbmNob3JFbGVtZW50KTt9O1xub3B0aW9ucy5zaW5nbGV0b24gPSBmYWxzZTtcblxudmFyIHVwZGF0ZSA9IGFwaShjb250ZW50LCBvcHRpb25zKTtcblxuXG5pZiAobW9kdWxlLmhvdCkge1xuICBpZiAoIWNvbnRlbnQubG9jYWxzIHx8IG1vZHVsZS5ob3QuaW52YWxpZGF0ZSkge1xuICAgIHZhciBpc0VxdWFsTG9jYWxzID0gZnVuY3Rpb24gaXNFcXVhbExvY2FscyhhLGIsaXNOYW1lZEV4cG9ydCl7aWYoIWEmJmJ8fGEmJiFiKXtyZXR1cm4gZmFsc2U7fWxldCBwO2ZvcihwIGluIGEpe2lmKGlzTmFtZWRFeHBvcnQmJnA9PT0nZGVmYXVsdCcpey8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb250aW51ZVxuY29udGludWU7fWlmKGFbcF0hPT1iW3BdKXtyZXR1cm4gZmFsc2U7fX1mb3IocCBpbiBiKXtpZihpc05hbWVkRXhwb3J0JiZwPT09J2RlZmF1bHQnKXsvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29udGludWVcbmNvbnRpbnVlO31pZighYVtwXSl7cmV0dXJuIGZhbHNlO319cmV0dXJuIHRydWU7fTtcbiAgICB2YXIgb2xkTG9jYWxzID0gY29udGVudC5sb2NhbHM7XG5cbiAgICBtb2R1bGUuaG90LmFjY2VwdChcbiAgICAgIFwiISEuLi8uLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NvbXBpbGVkL2Nzcy1sb2FkZXIvY2pzLmpzPz9yZWYtLTUtb25lT2YtMi0xIS4uLy4uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvcG9zdGNzcy1sb2FkZXIvY2pzLmpzPz9yZWYtLTUtb25lT2YtMi0yIS4vUHVzaE5vdGlmaWNhdGlvbnMubW9kdWxlLmNzc1wiLFxuICAgICAgZnVuY3Rpb24gKCkge1xuICAgICAgICBjb250ZW50ID0gcmVxdWlyZShcIiEhLi4vLi4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jb21waWxlZC9jc3MtbG9hZGVyL2Nqcy5qcz8/cmVmLS01LW9uZU9mLTItMSEuLi8uLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NvbXBpbGVkL3Bvc3Rjc3MtbG9hZGVyL2Nqcy5qcz8/cmVmLS01LW9uZU9mLTItMiEuL1B1c2hOb3RpZmljYXRpb25zLm1vZHVsZS5jc3NcIik7XG5cbiAgICAgICAgICAgICAgY29udGVudCA9IGNvbnRlbnQuX19lc01vZHVsZSA/IGNvbnRlbnQuZGVmYXVsdCA6IGNvbnRlbnQ7XG5cbiAgICAgICAgICAgICAgaWYgKHR5cGVvZiBjb250ZW50ID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIGNvbnRlbnQgPSBbW21vZHVsZS5pZCwgY29udGVudCwgJyddXTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGlmICghaXNFcXVhbExvY2FscyhvbGRMb2NhbHMsIGNvbnRlbnQubG9jYWxzKSkge1xuICAgICAgICAgICAgICAgIG1vZHVsZS5ob3QuaW52YWxpZGF0ZSgpO1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgb2xkTG9jYWxzID0gY29udGVudC5sb2NhbHM7XG5cbiAgICAgICAgICAgICAgdXBkYXRlKGNvbnRlbnQpO1xuICAgICAgfVxuICAgIClcbiAgfVxuXG4gIG1vZHVsZS5ob3QuZGlzcG9zZShmdW5jdGlvbigpIHtcbiAgICB1cGRhdGUoKTtcbiAgfSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gY29udGVudC5sb2NhbHMgfHwge307IiwiaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IHVzZVN0b3JlU3RhdGUgfSBmcm9tICd1bmlzdG9yZS1ob29rcyc7XG5pbXBvcnQgeyBCdXR0b24sIExvYWRlciwgTm90aWZpY2F0aW9uLCBTVkcgfSBmcm9tICdAdGhlbWUnO1xuaW1wb3J0IHsgU3RhdGUgfSBmcm9tICdAc3RvcmUvdHlwZXMnO1xuaW1wb3J0IGNuIGZyb20gJ0B1dGlscy9jbGFzc25hbWVzJztcbmltcG9ydCB7IGFwaUJhc2UgfSBmcm9tICdAdXRpbHMvY29uc3RhbnRzJztcbmltcG9ydCB7IGlzSW9zLCB1cmxCNjRUb1VpbnQ4QXJyYXkgfSBmcm9tICdAdXRpbHMvaGVscGVycyc7XG5pbXBvcnQgc3R5bGVzIGZyb20gJy4vUHVzaE5vdGlmaWNhdGlvbnMubW9kdWxlLmNzcyc7XG5cbmNvbnN0IFB1c2hOb3RpZmljYXRpb25zID0gKHsgY2xhc3NOYW1lID0gJycgfTogeyBjbGFzc05hbWU/OiBzdHJpbmcgfSkgPT4ge1xuICBjb25zdCBbZXJyb3IsIHNldEVycm9yXSA9IFJlYWN0LnVzZVN0YXRlPHN0cmluZz4oJycpO1xuICBjb25zdCBbaXNTdWJzY3JpYmVkLCBzZXRJc1N1YnNjcmliZWRdID0gUmVhY3QudXNlU3RhdGU8Ym9vbGVhbj4oZmFsc2UpO1xuICBjb25zdCBbbG9hZGluZywgc2V0TG9hZGluZ10gPSBSZWFjdC51c2VTdGF0ZTxib29sZWFuPihmYWxzZSk7XG5cbiAgY29uc3Qgc3VwcG9ydHNQdXNoID0gJ1B1c2hNYW5hZ2VyJyBpbiB3aW5kb3cgJiYgJ3NlcnZpY2VXb3JrZXInIGluIG5hdmlnYXRvcjtcblxuICBSZWFjdC51c2VFZmZlY3QoKCkgPT4ge1xuICAgIChhc3luYyBmdW5jdGlvbiBlZmZlY3QoKSB7XG4gICAgICBpZiAod2luZG93Lk5vdGlmaWNhdGlvbi5wZXJtaXNzaW9uID09PSAnZGVuaWVkJykge1xuICAgICAgICBzZXRFcnJvcihcbiAgICAgICAgICAnSXQgbG9va3MgbGlrZSB5b3UgYWxyZWFkeSBleHBsaWNpdGx5IGRlbmllZCBwZXJtaXNzaW9uIGZvciBwd2FkdmVudC5kZXYgdG8gZGlzcGxheSBzeXN0ZW0gbm90aWZpY2F0aW9ucy4gUGxlYXNlIGNoYW5nZSB0aGlzIG9wdGlvbiBpbiB0aGUgc2l0ZSBzZXR0aW5ncyBhbmQgcmVsb2FkIHRoaXMgcGFnZS4nXG4gICAgICAgICk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgY29uc3QgcmVnID0gYXdhaXQgbmF2aWdhdG9yLnNlcnZpY2VXb3JrZXIuZ2V0UmVnaXN0cmF0aW9uKCk7XG4gICAgICBjb25zdCBzdWJzY3JpcHRpb24gPSBhd2FpdCByZWcucHVzaE1hbmFnZXIuZ2V0U3Vic2NyaXB0aW9uKCk7XG4gICAgICBpZiAoc3Vic2NyaXB0aW9uKSB7XG4gICAgICAgIGF3YWl0IHNlbmRTdWJzY3JpcHRpb24oc3Vic2NyaXB0aW9uLnRvSlNPTigpKTtcbiAgICAgICAgc2V0SXNTdWJzY3JpYmVkKHRydWUpO1xuICAgICAgfVxuICAgIH0pKCk7XG4gIH0sIFtdKTtcblxuICBjb25zdCBnZXRWYXBpZEtleSA9IGFzeW5jICgpID0+IHtcbiAgICBsZXQga2V5ID0gJyc7XG4gICAgY29uc3QgcmVzcCA9IGF3YWl0IGZldGNoKFxuICAgICAgYCR7YXBpQmFzZX13cC1qc29uL2FkdmVudC1jYWxlbmRhci92MS93ZWItcHVzaC9wdWJsaWMta2V5YFxuICAgICk7XG5cbiAgICBpZiAocmVzcC5vaykge1xuICAgICAgY29uc3QgcmVzcEpzb24gPSBhd2FpdCByZXNwLmpzb24oKTtcbiAgICAgIGtleSA9IHJlc3BKc29uLnB1YmxpY0tleTtcbiAgICB9XG4gICAgcmV0dXJuIGtleTtcbiAgfTtcblxuICBjb25zdCBzdWJzY3JpYmUgPSBhc3luYyAoKSA9PiB7XG4gICAgc2V0TG9hZGluZyh0cnVlKTtcbiAgICBjb25zdCByZWcgPSBhd2FpdCBuYXZpZ2F0b3Iuc2VydmljZVdvcmtlci5nZXRSZWdpc3RyYXRpb24oKTtcbiAgICBjb25zdCB2YXBpZEtleSA9IGF3YWl0IGdldFZhcGlkS2V5KCk7XG4gICAgaWYgKHZhcGlkS2V5ID09PSAnJykge1xuICAgICAgYWxlcnQoJ3NvbWV0aGluZyB3ZW50IHdyb25nLiBDb3VsZCBub3QgY29ubmVjdCB0byB0aGUgcHVzaCBzZXJ2ZXInKTtcbiAgICB9XG4gICAgY29uc3Qgc3Vic2NyaXB0aW9uID0gYXdhaXQgcmVnLnB1c2hNYW5hZ2VyLnN1YnNjcmliZSh7XG4gICAgICB1c2VyVmlzaWJsZU9ubHk6IHRydWUsXG4gICAgICBhcHBsaWNhdGlvblNlcnZlcktleTogbmV3IFVpbnQ4QXJyYXkodXJsQjY0VG9VaW50OEFycmF5KHZhcGlkS2V5KSksXG4gICAgfSk7XG4gICAgYXdhaXQgc2VuZFN1YnNjcmlwdGlvbihzdWJzY3JpcHRpb24udG9KU09OKCkpO1xuICAgIHNldExvYWRpbmcoZmFsc2UpO1xuICAgIHNldElzU3Vic2NyaWJlZCh0cnVlKTtcbiAgfTtcblxuICBjb25zdCB1bnN1YnNjcmliZSA9IGFzeW5jICgpID0+IHtcbiAgICBzZXRMb2FkaW5nKHRydWUpO1xuICAgIGNvbnN0IHJlZyA9IGF3YWl0IG5hdmlnYXRvci5zZXJ2aWNlV29ya2VyLmdldFJlZ2lzdHJhdGlvbigpO1xuICAgIGNvbnN0IHN1YnNjcmlwdGlvbiA9IGF3YWl0IHJlZy5wdXNoTWFuYWdlci5nZXRTdWJzY3JpcHRpb24oKTtcbiAgICBhd2FpdCBzZW5kRGVsZXRlU3Vic2NyaXB0aW9uKHN1YnNjcmlwdGlvbi50b0pTT04oKSk7XG4gICAgYXdhaXQgc3Vic2NyaXB0aW9uLnVuc3Vic2NyaWJlKCk7XG4gICAgc2V0TG9hZGluZyhmYWxzZSk7XG4gICAgc2V0SXNTdWJzY3JpYmVkKGZhbHNlKTtcbiAgfTtcblxuICBjb25zdCBzZW5kU3Vic2NyaXB0aW9uID0gYXN5bmMgKHN1YnNjcmlwdGlvbjogUHVzaFN1YnNjcmlwdGlvbkpTT04pID0+XG4gICAgZmV0Y2goYCR7YXBpQmFzZX13cC1qc29uL2FkdmVudC1jYWxlbmRhci92MS93ZWItcHVzaC9zdWJzY3JpcHRpb24vYCwge1xuICAgICAgbWV0aG9kOiAncG9zdCcsXG4gICAgICBib2R5OiBKU09OLnN0cmluZ2lmeSh7XG4gICAgICAgIHN1YnNjcmlwdGlvbjogc3Vic2NyaXB0aW9uLFxuICAgICAgICB0aW1lem9uZU9mZnNldDogbmV3IERhdGUoKS5nZXRUaW1lem9uZU9mZnNldCgpLFxuICAgICAgfSksXG4gICAgICBoZWFkZXJzOiB7XG4gICAgICAgICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICB9LFxuICAgIH0pO1xuXG4gIGNvbnN0IHNlbmREZWxldGVTdWJzY3JpcHRpb24gPSBhc3luYyAoc3Vic2NyaXB0aW9uOiBQdXNoU3Vic2NyaXB0aW9uSlNPTikgPT5cbiAgICBmZXRjaChgJHthcGlCYXNlfXdwLWpzb24vYWR2ZW50LWNhbGVuZGFyL3YxL3dlYi1wdXNoL3N1YnNjcmlwdGlvbi9gLCB7XG4gICAgICBtZXRob2Q6ICdkZWxldGUnLFxuICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoe1xuICAgICAgICBzdWJzY3JpcHRpb246IHN1YnNjcmlwdGlvbixcbiAgICAgIH0pLFxuICAgICAgaGVhZGVyczoge1xuICAgICAgICAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgfSxcbiAgICB9KTtcblxuICByZXR1cm4gKFxuICAgIDxkaXYgY2xhc3NOYW1lPXtjbihjbGFzc05hbWUpfT5cbiAgICAgIDxwIGNsYXNzTmFtZT17c3R5bGVzLmFib3V0fT5cbiAgICAgICAgPGI+TmV2ZXIgbWlzcyBhIGZlYXR1cmUgYWdhaW4hPC9iPlxuICAgICAgICA8YnIgLz5cbiAgICAgICAgU3Vic2NyaWJlIHRvIHB1c2ggbm90aWZpY2F0aW9ucyBhbmQgcmVjZWl2ZSBhIGRhaWx5IG5vdGlmaWNhdGlvbiB3aGVuXG4gICAgICAgIHRoZSBuZXcgd2luZG93IG9wZW5zLlxuICAgICAgPC9wPlxuICAgICAgPGRpdiBjbGFzc05hbWU9e3N0eWxlcy5mZWVkYmFja30+XG4gICAgICAgIHtlcnJvciAhPT0gJycgPyAoXG4gICAgICAgICAgPE5vdGlmaWNhdGlvbiB0eXBlPVwiZXJyb3JcIj5cbiAgICAgICAgICAgIDxwPntlcnJvcn08L3A+XG4gICAgICAgICAgPC9Ob3RpZmljYXRpb24+XG4gICAgICAgICkgOiAhc3VwcG9ydHNQdXNoID8gKFxuICAgICAgICAgIDxSZWFjdC5GcmFnbWVudD5cbiAgICAgICAgICAgIDxOb3RpZmljYXRpb24gdHlwZT1cImVycm9yXCI+XG4gICAgICAgICAgICAgIDxwPllvdXIgYnJvd3NlciBkb2VzIG5vdCBzdXBwb3J0IHdlYiBwdXNoIG5vdGlmaWNhdGlvbnMuPC9wPlxuICAgICAgICAgICAgPC9Ob3RpZmljYXRpb24+XG4gICAgICAgICAgICB7aXNJb3MgJiYgKFxuICAgICAgICAgICAgICA8cD5cbiAgICAgICAgICAgICAgICA8YnIgLz5cbiAgICAgICAgICAgICAgICBVbmZvcnR1bmF0ZWx5LCA8Yj5BcHBsZTwvYj4gdHJpZXMgdG8gaG9sZCBiYWNrIHRoZSBmdXJ0aGVyXG4gICAgICAgICAgICAgICAgZGV2ZWxvcG1lbnQgb2YgcmljaCB3ZWIgYXBwbGljYXRpb25zIGJ5eycgJ31cbiAgICAgICAgICAgICAgICA8Yj5ub3QgaW1wbGVtZW50aW5nIGZlYXR1cmVzIGxpa2Ugd2ViIHB1c2ggaW50byBpT1MuPC9iPlxuICAgICAgICAgICAgICAgIDxiciAvPlxuICAgICAgICAgICAgICAgIEl0IGlzIG5vdyB1cCB0byB1cyB0byBidWlsZCBwcmVzc3VyZSBieXsnICd9XG4gICAgICAgICAgICAgICAgPGFcbiAgICAgICAgICAgICAgICAgIGhyZWY9XCJodHRwczovL2J1Z3Mud2Via2l0Lm9yZy9zaG93X2J1Zy5jZ2k/aWQ9MTgyNTY2XCJcbiAgICAgICAgICAgICAgICAgIHRhcmdldD1cIl9ibGFua1wiXG4gICAgICAgICAgICAgICAgPlxuICAgICAgICAgICAgICAgICAgZGVzY3JpYmluZyBvdXIgdXNlY2FzZVxuICAgICAgICAgICAgICAgIDwvYT57JyAnfVxuICAgICAgICAgICAgICAgIGFuZC9vcnsnICd9XG4gICAgICAgICAgICAgICAgPGFcbiAgICAgICAgICAgICAgICAgIGhyZWY9XCJodHRwczovL3d3dy5jaGFuZ2Uub3JnL3AvdGltLWNvb2stYXBwbGUtaW5jLWltcGxlbWVudC13ZWItcHVzaC1ub3RpZmljYXRpb25zLW9uLWlvcy1kZXZpY2VzP3V0bV9jb250ZW50PWNsX3NoYXJlY29weV8xODE3ODY3MF9mci1GUiUzQXYxJnJlY3J1aXRlcj0xMDkyMzMwMTY4JnJlY3J1aXRlZF9ieV9pZD03NjI5MzU3MC05YmE2LTExZWEtYmQwMS1lNWQzOTUwMTMzOWEmdXRtX3NvdXJjZT1zaGFyZV9wZXRpdGlvbiZ1dG1fbWVkaXVtPWNvcHlsaW5rJnV0bV9jYW1wYWlnbj1wc2ZfY29tYm9fc2hhcmVfaW5pdGlhbCZ1dG1fdGVybT1zaGFyZV9wZXRpdGlvblwiXG4gICAgICAgICAgICAgICAgICB0YXJnZXQ9XCJfYmxhbmtcIlxuICAgICAgICAgICAgICAgID5cbiAgICAgICAgICAgICAgICAgIG1ha2luZyBvdXJzZWx2ZXMgaGVhcmRcbiAgICAgICAgICAgICAgICA8L2E+XG4gICAgICAgICAgICAgICAgLlxuICAgICAgICAgICAgICA8L3A+XG4gICAgICAgICAgICApfVxuICAgICAgICAgIDwvUmVhY3QuRnJhZ21lbnQ+XG4gICAgICAgICkgOiAhaXNTdWJzY3JpYmVkID8gKFxuICAgICAgICAgIDxSZWFjdC5GcmFnbWVudD5cbiAgICAgICAgICAgIDxCdXR0b25cbiAgICAgICAgICAgICAgaWNvbj1cIm1kaS9iZWxsXCJcbiAgICAgICAgICAgICAgb25DbGljaz17KCkgPT4gc3Vic2NyaWJlKCl9XG4gICAgICAgICAgICAgIGNvbG9yPVwicmVkXCJcbiAgICAgICAgICAgICAgbG9hZGluZz17bG9hZGluZ31cbiAgICAgICAgICAgID5cbiAgICAgICAgICAgICAgU3Vic2NyaWJlXG4gICAgICAgICAgICA8L0J1dHRvbj5cbiAgICAgICAgICAgIDxiciAvPlxuICAgICAgICAgICAgPHAgY2xhc3NOYW1lPVwiZnMtLXhzbWFsbFwiPlxuICAgICAgICAgICAgICBGcm9tIHRoZSBmaXJzdCB0byB0aGUgMjR0aCBvZiBkZWNlbWJlciAyMDIwIHdlIHdpbGwgc2VuZCB5b3UgYVxuICAgICAgICAgICAgICBsaW5rIHRvIHRoZSBsYXRlc3QgYXJ0aWNsZSBldmVyeSBtb3JuaW5nLiBZb3UgYXJlIGFibGUgdG9cbiAgICAgICAgICAgICAgdW5zdWJzY3JpYmUgYXQgYW55IHRpbWUgaGVyZVxuICAgICAgICAgICAgPC9wPlxuICAgICAgICAgIDwvUmVhY3QuRnJhZ21lbnQ+XG4gICAgICAgICkgOiAoXG4gICAgICAgICAgPFJlYWN0LkZyYWdtZW50PlxuICAgICAgICAgICAgPHAgY2xhc3NOYW1lPXtzdHlsZXMuY2hlY2tlZH0+XG4gICAgICAgICAgICAgIDxTVkcgcGF0aD1cImljb24vbWRpL2NoZWNrLnN2Z1wiIGlubGluZSAvPnsnICd9XG4gICAgICAgICAgICAgIDxiPlB1c2ggbm90aWZpY2F0aW9ucyBhcmUgYWN0aXZhdGVkPC9iPlxuICAgICAgICAgICAgPC9wPlxuICAgICAgICAgICAgPEJ1dHRvblxuICAgICAgICAgICAgICBsYXlvdXQ9XCJnaG9zdFwiXG4gICAgICAgICAgICAgIHNpemU9XCJzbWFsbFwiXG4gICAgICAgICAgICAgIGljb249XCJtZGkvYmVsbC1vdXRsaW5lXCJcbiAgICAgICAgICAgICAgcm91bmRcbiAgICAgICAgICAgICAgb25DbGljaz17KCkgPT4gdW5zdWJzY3JpYmUoKX1cbiAgICAgICAgICAgICAgbG9hZGluZz17bG9hZGluZ31cbiAgICAgICAgICAgICAgZm9udFdlaWdodD1cIm5vcm1hbFwiXG4gICAgICAgICAgICA+XG4gICAgICAgICAgICAgIFVuc3Vic2NyaWJlXG4gICAgICAgICAgICA8L0J1dHRvbj5cbiAgICAgICAgICA8L1JlYWN0LkZyYWdtZW50PlxuICAgICAgICApfVxuICAgICAgPC9kaXY+XG4gICAgPC9kaXY+XG4gICk7XG59O1xuXG5leHBvcnQgZGVmYXVsdCBQdXNoTm90aWZpY2F0aW9ucztcbiIsInZhciBhcGkgPSByZXF1aXJlKFwiIS4uLy4uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvYnVpbGQvd2VicGFjay9sb2FkZXJzL25leHQtc3R5bGUtbG9hZGVyL3J1bnRpbWUvaW5qZWN0U3R5bGVzSW50b1N0eWxlVGFnLmpzXCIpO1xuICAgICAgICAgICAgdmFyIGNvbnRlbnQgPSByZXF1aXJlKFwiISEuLi8uLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NvbXBpbGVkL2Nzcy1sb2FkZXIvY2pzLmpzPz9yZWYtLTUtb25lT2YtMi0xIS4uLy4uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvcG9zdGNzcy1sb2FkZXIvY2pzLmpzPz9yZWYtLTUtb25lT2YtMi0yIS4vQ2FsZW5kYXIubW9kdWxlLmNzc1wiKTtcblxuICAgICAgICAgICAgY29udGVudCA9IGNvbnRlbnQuX19lc01vZHVsZSA/IGNvbnRlbnQuZGVmYXVsdCA6IGNvbnRlbnQ7XG5cbiAgICAgICAgICAgIGlmICh0eXBlb2YgY29udGVudCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgY29udGVudCA9IFtbbW9kdWxlLmlkLCBjb250ZW50LCAnJ11dO1xuICAgICAgICAgICAgfVxuXG52YXIgb3B0aW9ucyA9IHt9O1xuXG5vcHRpb25zLmluc2VydCA9IGZ1bmN0aW9uKGVsZW1lbnQpey8vIFRoZXNlIGVsZW1lbnRzIHNob3VsZCBhbHdheXMgZXhpc3QuIElmIHRoZXkgZG8gbm90LFxuLy8gdGhpcyBjb2RlIHNob3VsZCBmYWlsLlxudmFyIGFuY2hvckVsZW1lbnQ9ZG9jdW1lbnQucXVlcnlTZWxlY3RvcignI19fbmV4dF9jc3NfX0RPX05PVF9VU0VfXycpO3ZhciBwYXJlbnROb2RlPWFuY2hvckVsZW1lbnQucGFyZW50Tm9kZTsvLyBOb3JtYWxseSA8aGVhZD5cbi8vIEVhY2ggc3R5bGUgdGFnIHNob3VsZCBiZSBwbGFjZWQgcmlnaHQgYmVmb3JlIG91clxuLy8gYW5jaG9yLiBCeSBpbnNlcnRpbmcgYmVmb3JlIGFuZCBub3QgYWZ0ZXIsIHdlIGRvIG5vdFxuLy8gbmVlZCB0byB0cmFjayB0aGUgbGFzdCBpbnNlcnRlZCBlbGVtZW50LlxucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUoZWxlbWVudCxhbmNob3JFbGVtZW50KTt9O1xub3B0aW9ucy5zaW5nbGV0b24gPSBmYWxzZTtcblxudmFyIHVwZGF0ZSA9IGFwaShjb250ZW50LCBvcHRpb25zKTtcblxuXG5pZiAobW9kdWxlLmhvdCkge1xuICBpZiAoIWNvbnRlbnQubG9jYWxzIHx8IG1vZHVsZS5ob3QuaW52YWxpZGF0ZSkge1xuICAgIHZhciBpc0VxdWFsTG9jYWxzID0gZnVuY3Rpb24gaXNFcXVhbExvY2FscyhhLGIsaXNOYW1lZEV4cG9ydCl7aWYoIWEmJmJ8fGEmJiFiKXtyZXR1cm4gZmFsc2U7fWxldCBwO2ZvcihwIGluIGEpe2lmKGlzTmFtZWRFeHBvcnQmJnA9PT0nZGVmYXVsdCcpey8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb250aW51ZVxuY29udGludWU7fWlmKGFbcF0hPT1iW3BdKXtyZXR1cm4gZmFsc2U7fX1mb3IocCBpbiBiKXtpZihpc05hbWVkRXhwb3J0JiZwPT09J2RlZmF1bHQnKXsvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29udGludWVcbmNvbnRpbnVlO31pZighYVtwXSl7cmV0dXJuIGZhbHNlO319cmV0dXJuIHRydWU7fTtcbiAgICB2YXIgb2xkTG9jYWxzID0gY29udGVudC5sb2NhbHM7XG5cbiAgICBtb2R1bGUuaG90LmFjY2VwdChcbiAgICAgIFwiISEuLi8uLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NvbXBpbGVkL2Nzcy1sb2FkZXIvY2pzLmpzPz9yZWYtLTUtb25lT2YtMi0xIS4uLy4uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvcG9zdGNzcy1sb2FkZXIvY2pzLmpzPz9yZWYtLTUtb25lT2YtMi0yIS4vQ2FsZW5kYXIubW9kdWxlLmNzc1wiLFxuICAgICAgZnVuY3Rpb24gKCkge1xuICAgICAgICBjb250ZW50ID0gcmVxdWlyZShcIiEhLi4vLi4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jb21waWxlZC9jc3MtbG9hZGVyL2Nqcy5qcz8/cmVmLS01LW9uZU9mLTItMSEuLi8uLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NvbXBpbGVkL3Bvc3Rjc3MtbG9hZGVyL2Nqcy5qcz8/cmVmLS01LW9uZU9mLTItMiEuL0NhbGVuZGFyLm1vZHVsZS5jc3NcIik7XG5cbiAgICAgICAgICAgICAgY29udGVudCA9IGNvbnRlbnQuX19lc01vZHVsZSA/IGNvbnRlbnQuZGVmYXVsdCA6IGNvbnRlbnQ7XG5cbiAgICAgICAgICAgICAgaWYgKHR5cGVvZiBjb250ZW50ID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIGNvbnRlbnQgPSBbW21vZHVsZS5pZCwgY29udGVudCwgJyddXTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGlmICghaXNFcXVhbExvY2FscyhvbGRMb2NhbHMsIGNvbnRlbnQubG9jYWxzKSkge1xuICAgICAgICAgICAgICAgIG1vZHVsZS5ob3QuaW52YWxpZGF0ZSgpO1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgb2xkTG9jYWxzID0gY29udGVudC5sb2NhbHM7XG5cbiAgICAgICAgICAgICAgdXBkYXRlKGNvbnRlbnQpO1xuICAgICAgfVxuICAgIClcbiAgfVxuXG4gIG1vZHVsZS5ob3QuZGlzcG9zZShmdW5jdGlvbigpIHtcbiAgICB1cGRhdGUoKTtcbiAgfSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gY29udGVudC5sb2NhbHMgfHwge307IiwiaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IHVzZVN0b3JlU3RhdGUsIHVzZUFjdGlvbnMgfSBmcm9tICd1bmlzdG9yZS1ob29rcyc7XG5pbXBvcnQgeyBpbnNwZWN0IH0gZnJvbSAndXRpbCc7XG5pbXBvcnQgQ2FsZW5kYXJEYXkgZnJvbSAnQGNvbXBzL0NhbGVuZGFyL0NhbGVuZGFyRGF5JztcbmltcG9ydCBDYWxlbmRhckRheUxpc3QgZnJvbSAnQGNvbXBzL0NhbGVuZGFyL0NhbGVuZGFyRGF5TGlzdCc7XG5pbXBvcnQgQ2FsZW5kYXJIZWFkZXIgZnJvbSAnQGNvbXBzL0NhbGVuZGFyL0NhbGVuZGFySGVhZGVyJztcbmltcG9ydCB1c2VXaW5kb3dTaXplIGZyb20gJ0Bjb21wcy9ob29rcy91c2VXaW5kb3dTaXplJztcbmltcG9ydCB7IHNldHRpbmdzREIgfSBmcm9tICdAc3RvcmUvaWRiJztcbmltcG9ydCB7IGFjdGlvbnMgfSBmcm9tICdAc3RvcmUvaW5kZXgnO1xuaW1wb3J0IHsgU3RhdGUgfSBmcm9tICdAc3RvcmUvdHlwZXMnO1xuaW1wb3J0IHsgREFURV9FTkQsIERBVEVfVE9EQVkgfSBmcm9tICdAdXRpbHMvY2FsZW5kYXInO1xuaW1wb3J0IGNuIGZyb20gJ0B1dGlscy9jbGFzc25hbWVzJztcbmltcG9ydCB7IGRheXNPcmRlciwgZGF5c09yZGVyQ29ycmVjdCwgVklFV19UWVBFUyB9IGZyb20gJ0B1dGlscy9jb25zdGFudHMnO1xuaW1wb3J0IHN0eWxlcyBmcm9tICcuL0NhbGVuZGFyLm1vZHVsZS5jc3MnO1xuXG5jb25zdCBDYWxlbmRhciA9ICh7IGNsYXNzTmFtZSA9ICcnIH06IHsgY2xhc3NOYW1lPzogc3RyaW5nIH0pID0+IHtcbiAgY29uc3QgW3ZpZXcsIHNldFZpZXddID0gUmVhY3QudXNlU3RhdGUobnVsbCk7XG4gIGNvbnN0IHdpbmRvdyA9IHVzZVdpbmRvd1NpemUoKTtcbiAgY29uc3QgY2FsZW5kYXJSZWYgPSBSZWFjdC51c2VSZWYobnVsbCk7XG4gIGNvbnN0IFtoZWlnaHQsIHNldEhlaWdodF0gPSBSZWFjdC51c2VTdGF0ZTxudW1iZXI+KG51bGwpO1xuICBjb25zdCBbb3BhY2l0eSwgc2V0T3BhY2l0eV0gPSBSZWFjdC51c2VTdGF0ZTxudW1iZXI+KDApO1xuICBjb25zdCB7IHNldE1lbnVPcGVuIH0gPSB1c2VBY3Rpb25zKGFjdGlvbnMpO1xuICBjb25zdCB7IG1lbnVPcGVuIH0gPSB1c2VTdG9yZVN0YXRlPFN0YXRlPihbJ21lbnVPcGVuJ10pO1xuICBjb25zdCBpc0NhbGVuZGFyID0gUmVhY3QudXNlTWVtbygoKSA9PiB2aWV3ID09PSBWSUVXX1RZUEVTLkNBTEVOREFSLCBbdmlld10pO1xuXG4gIFJlYWN0LnVzZUVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKCFEQVRFX1RPREFZLmlzQWZ0ZXIoREFURV9FTkQpKSB7XG4gICAgICBzZXRWaWV3KFZJRVdfVFlQRVMuQ0FMRU5EQVIpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoIXZpZXcpIHtcbiAgICAgIHNldHRpbmdzREIuZ2V0KCd2aWV3JykudGhlbigodikgPT4gc2V0Vmlldyh2IHx8IFZJRVdfVFlQRVMuQ0FMRU5EQVIpKTtcbiAgICB9XG4gICAgc2V0dGluZ3NEQi5zZXQoJ3ZpZXcnLCB2aWV3KTtcbiAgfSwgW3ZpZXddKTtcblxuICBSZWFjdC51c2VFZmZlY3QoKCkgPT4ge1xuICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgaWYgKGNhbGVuZGFyUmVmLmN1cnJlbnQgJiYgd2luZG93LndpZHRoKSB7XG4gICAgICAgIGlmICghaXNDYWxlbmRhcikge1xuICAgICAgICAgIHNldEhlaWdodCh3aW5kb3cuaGVpZ2h0IC0gMjIwKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBpc1BvcnRyYWl0ID0gd2luZG93LmhlaWdodCAvIHdpbmRvdy53aWR0aCA+PSAxO1xuICAgICAgICBjb25zdCBtYXhIZWlnaHQgPSB3aW5kb3cuaGVpZ2h0IC0gMjAwO1xuXG4gICAgICAgIGxldCBoZWlnaHQgPSBNYXRoLnJvdW5kKFxuICAgICAgICAgIGNhbGVuZGFyUmVmLmN1cnJlbnQuY2xpZW50V2lkdGggKiAoaXNQb3J0cmFpdCA/IDEuMyA6IDAuOSlcbiAgICAgICAgKTtcblxuICAgICAgICBpZiAoaGVpZ2h0ID49IG1heEhlaWdodCkge1xuICAgICAgICAgIGhlaWdodCA9IG1heEhlaWdodDtcbiAgICAgICAgfVxuXG4gICAgICAgIHNldEhlaWdodChoZWlnaHQpO1xuICAgICAgfVxuICAgIH0sIDEpO1xuICB9LCBbd2luZG93LCBjYWxlbmRhclJlZiwgdmlld10pO1xuXG4gIFJlYWN0LnVzZUVmZmVjdCgoKSA9PiB7XG4gICAgaGVpZ2h0ICYmIHNldE9wYWNpdHkoMSk7XG4gIH0sIFtoZWlnaHRdKTtcblxuICByZXR1cm4gKFxuICAgIDxkaXYgY2xhc3NOYW1lPXtjbihzdHlsZXMucm9vdCwgY2xhc3NOYW1lKX0+XG4gICAgICB7bWVudU9wZW4gJiYgKFxuICAgICAgICA8YnV0dG9uXG4gICAgICAgICAgY2xhc3NOYW1lPXtzdHlsZXMuYnV0dG9uT3ZlcmxheX1cbiAgICAgICAgICBvbkNsaWNrPXsoKSA9PiBzZXRNZW51T3BlbihmYWxzZSl9XG4gICAgICAgID5cbiAgICAgICAgICBjbG9zZVxuICAgICAgICA8L2J1dHRvbj5cbiAgICAgICl9XG4gICAgICA8Q2FsZW5kYXJIZWFkZXIgY2xhc3NOYW1lPXtzdHlsZXMuaGVhZGVyfSBzZXRWaWV3PXtzZXRWaWV3fSB2aWV3PXt2aWV3fSAvPlxuICAgICAgPGRpdlxuICAgICAgICBjbGFzc05hbWU9e2lzQ2FsZW5kYXIgPyBzdHlsZXMuY2FsZW5kYXIgOiBzdHlsZXMubGlzdH1cbiAgICAgICAgc3R5bGU9e3tcbiAgICAgICAgICAvL2hlaWdodDogaXNDYWxlbmRhciA/IGhlaWdodCA6ICdhdXRvJyxcbiAgICAgICAgICBoZWlnaHQsXG4gICAgICAgICAgb3BhY2l0eSxcbiAgICAgICAgfX1cbiAgICAgICAgcmVmPXtjYWxlbmRhclJlZn1cbiAgICAgID5cbiAgICAgICAgeyhpc0NhbGVuZGFyID8gZGF5c09yZGVyIDogZGF5c09yZGVyQ29ycmVjdCkubWFwKChkYXkpID0+IChcbiAgICAgICAgICA8ZGl2XG4gICAgICAgICAgICBjbGFzc05hbWU9e2NuKFxuICAgICAgICAgICAgICBzdHlsZXMuaXRlbSxcbiAgICAgICAgICAgICAgc3R5bGVzW2BpdGVtLS0ke2RheX1gXSxcbiAgICAgICAgICAgICAgc3R5bGVzW2BpdGVtLS0ke3ZpZXd9YF1cbiAgICAgICAgICAgICl9XG4gICAgICAgICAgPlxuICAgICAgICAgICAge2lzQ2FsZW5kYXIgPyAoXG4gICAgICAgICAgICAgIDxDYWxlbmRhckRheSBkYXk9e3BhcnNlSW50KGRheSl9IC8+XG4gICAgICAgICAgICApIDogKFxuICAgICAgICAgICAgICA8Q2FsZW5kYXJEYXlMaXN0IGRheT17cGFyc2VJbnQoZGF5KX0gLz5cbiAgICAgICAgICAgICl9XG4gICAgICAgICAgPC9kaXY+XG4gICAgICAgICkpfVxuICAgICAgPC9kaXY+XG4gICAgPC9kaXY+XG4gICk7XG59O1xuXG5leHBvcnQgZGVmYXVsdCBDYWxlbmRhcjtcbiIsInZhciBhcGkgPSByZXF1aXJlKFwiIS4uLy4uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvYnVpbGQvd2VicGFjay9sb2FkZXJzL25leHQtc3R5bGUtbG9hZGVyL3J1bnRpbWUvaW5qZWN0U3R5bGVzSW50b1N0eWxlVGFnLmpzXCIpO1xuICAgICAgICAgICAgdmFyIGNvbnRlbnQgPSByZXF1aXJlKFwiISEuLi8uLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NvbXBpbGVkL2Nzcy1sb2FkZXIvY2pzLmpzPz9yZWYtLTUtb25lT2YtMi0xIS4uLy4uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvcG9zdGNzcy1sb2FkZXIvY2pzLmpzPz9yZWYtLTUtb25lT2YtMi0yIS4vQ2FsZW5kYXJEYXkubW9kdWxlLmNzc1wiKTtcblxuICAgICAgICAgICAgY29udGVudCA9IGNvbnRlbnQuX19lc01vZHVsZSA/IGNvbnRlbnQuZGVmYXVsdCA6IGNvbnRlbnQ7XG5cbiAgICAgICAgICAgIGlmICh0eXBlb2YgY29udGVudCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgY29udGVudCA9IFtbbW9kdWxlLmlkLCBjb250ZW50LCAnJ11dO1xuICAgICAgICAgICAgfVxuXG52YXIgb3B0aW9ucyA9IHt9O1xuXG5vcHRpb25zLmluc2VydCA9IGZ1bmN0aW9uKGVsZW1lbnQpey8vIFRoZXNlIGVsZW1lbnRzIHNob3VsZCBhbHdheXMgZXhpc3QuIElmIHRoZXkgZG8gbm90LFxuLy8gdGhpcyBjb2RlIHNob3VsZCBmYWlsLlxudmFyIGFuY2hvckVsZW1lbnQ9ZG9jdW1lbnQucXVlcnlTZWxlY3RvcignI19fbmV4dF9jc3NfX0RPX05PVF9VU0VfXycpO3ZhciBwYXJlbnROb2RlPWFuY2hvckVsZW1lbnQucGFyZW50Tm9kZTsvLyBOb3JtYWxseSA8aGVhZD5cbi8vIEVhY2ggc3R5bGUgdGFnIHNob3VsZCBiZSBwbGFjZWQgcmlnaHQgYmVmb3JlIG91clxuLy8gYW5jaG9yLiBCeSBpbnNlcnRpbmcgYmVmb3JlIGFuZCBub3QgYWZ0ZXIsIHdlIGRvIG5vdFxuLy8gbmVlZCB0byB0cmFjayB0aGUgbGFzdCBpbnNlcnRlZCBlbGVtZW50LlxucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUoZWxlbWVudCxhbmNob3JFbGVtZW50KTt9O1xub3B0aW9ucy5zaW5nbGV0b24gPSBmYWxzZTtcblxudmFyIHVwZGF0ZSA9IGFwaShjb250ZW50LCBvcHRpb25zKTtcblxuXG5pZiAobW9kdWxlLmhvdCkge1xuICBpZiAoIWNvbnRlbnQubG9jYWxzIHx8IG1vZHVsZS5ob3QuaW52YWxpZGF0ZSkge1xuICAgIHZhciBpc0VxdWFsTG9jYWxzID0gZnVuY3Rpb24gaXNFcXVhbExvY2FscyhhLGIsaXNOYW1lZEV4cG9ydCl7aWYoIWEmJmJ8fGEmJiFiKXtyZXR1cm4gZmFsc2U7fWxldCBwO2ZvcihwIGluIGEpe2lmKGlzTmFtZWRFeHBvcnQmJnA9PT0nZGVmYXVsdCcpey8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb250aW51ZVxuY29udGludWU7fWlmKGFbcF0hPT1iW3BdKXtyZXR1cm4gZmFsc2U7fX1mb3IocCBpbiBiKXtpZihpc05hbWVkRXhwb3J0JiZwPT09J2RlZmF1bHQnKXsvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29udGludWVcbmNvbnRpbnVlO31pZighYVtwXSl7cmV0dXJuIGZhbHNlO319cmV0dXJuIHRydWU7fTtcbiAgICB2YXIgb2xkTG9jYWxzID0gY29udGVudC5sb2NhbHM7XG5cbiAgICBtb2R1bGUuaG90LmFjY2VwdChcbiAgICAgIFwiISEuLi8uLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NvbXBpbGVkL2Nzcy1sb2FkZXIvY2pzLmpzPz9yZWYtLTUtb25lT2YtMi0xIS4uLy4uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvcG9zdGNzcy1sb2FkZXIvY2pzLmpzPz9yZWYtLTUtb25lT2YtMi0yIS4vQ2FsZW5kYXJEYXkubW9kdWxlLmNzc1wiLFxuICAgICAgZnVuY3Rpb24gKCkge1xuICAgICAgICBjb250ZW50ID0gcmVxdWlyZShcIiEhLi4vLi4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jb21waWxlZC9jc3MtbG9hZGVyL2Nqcy5qcz8/cmVmLS01LW9uZU9mLTItMSEuLi8uLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NvbXBpbGVkL3Bvc3Rjc3MtbG9hZGVyL2Nqcy5qcz8/cmVmLS01LW9uZU9mLTItMiEuL0NhbGVuZGFyRGF5Lm1vZHVsZS5jc3NcIik7XG5cbiAgICAgICAgICAgICAgY29udGVudCA9IGNvbnRlbnQuX19lc01vZHVsZSA/IGNvbnRlbnQuZGVmYXVsdCA6IGNvbnRlbnQ7XG5cbiAgICAgICAgICAgICAgaWYgKHR5cGVvZiBjb250ZW50ID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIGNvbnRlbnQgPSBbW21vZHVsZS5pZCwgY29udGVudCwgJyddXTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGlmICghaXNFcXVhbExvY2FscyhvbGRMb2NhbHMsIGNvbnRlbnQubG9jYWxzKSkge1xuICAgICAgICAgICAgICAgIG1vZHVsZS5ob3QuaW52YWxpZGF0ZSgpO1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgb2xkTG9jYWxzID0gY29udGVudC5sb2NhbHM7XG5cbiAgICAgICAgICAgICAgdXBkYXRlKGNvbnRlbnQpO1xuICAgICAgfVxuICAgIClcbiAgfVxuXG4gIG1vZHVsZS5ob3QuZGlzcG9zZShmdW5jdGlvbigpIHtcbiAgICB1cGRhdGUoKTtcbiAgfSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gY29udGVudC5sb2NhbHMgfHwge307IiwiaW1wb3J0IExpbmsgZnJvbSAnbmV4dC9saW5rJztcbmltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyB1c2VTdG9yZVN0YXRlIH0gZnJvbSAndW5pc3RvcmUtaG9va3MnO1xuaW1wb3J0IHsgU1ZHIH0gZnJvbSAnQHRoZW1lJztcbmltcG9ydCB7IFN0YXRlIH0gZnJvbSAnQHN0b3JlL3R5cGVzJztcbmltcG9ydCB7IERBVEVfVE9EQVkgfSBmcm9tICdAdXRpbHMvY2FsZW5kYXInO1xuaW1wb3J0IGNuIGZyb20gJ0B1dGlscy9jbGFzc25hbWVzJztcbmltcG9ydCBkYXlqcyBmcm9tICdAdXRpbHMvZGF5anMnO1xuaW1wb3J0IHsgemVyb1BhZCB9IGZyb20gJ0B1dGlscy9oZWxwZXJzJztcbmltcG9ydCBzdHlsZXMgZnJvbSAnLi9DYWxlbmRhckRheS5tb2R1bGUuY3NzJztcblxuY29uc3QgQ2FsZW5kYXJEYXkgPSAoe1xuICBkYXksXG4gIGNsYXNzTmFtZSA9ICcnLFxufToge1xuICBkYXk6IG51bWJlcjtcbiAgY2xhc3NOYW1lPzogc3RyaW5nO1xufSkgPT4ge1xuICBjb25zdCB7IGRheXM6IHN0b3JlRGF5cyB9ID0gdXNlU3RvcmVTdGF0ZTxTdGF0ZT4oWydkYXlzJ10pO1xuXG4gIGNvbnN0IGRheU9iamVjdCA9IFJlYWN0LnVzZU1lbW8oKCkgPT4gc3RvcmVEYXlzW2RheV0sIFtzdG9yZURheXNbZGF5XSwgZGF5XSk7XG4gIGNvbnN0IGlzQWN0aXZlID0gUmVhY3QudXNlTWVtbyhcbiAgICAoKSA9PiAhZGF5anMoZGF5T2JqZWN0LmRhdGEuZGF0ZSkuaXNBZnRlcihEQVRFX1RPREFZKSxcbiAgICBbZGF5T2JqZWN0XVxuICApO1xuXG4gIGNvbnN0IFdyYXBwZXIgPSAoe1xuICAgIGNoaWxkcmVuLFxuICAgIC4uLnByb3BzXG4gIH06IHtcbiAgICBjaGlsZHJlbjogYW55O1xuICAgIFtrZXk6IHN0cmluZ106IGFueTtcbiAgfSkgPT5cbiAgICBpc0FjdGl2ZSA/IChcbiAgICAgIDxMaW5rIGhyZWY9e2AvZGF5LyR7ZGF5fS9gfT5cbiAgICAgICAgPGEgey4uLnByb3BzfT57Y2hpbGRyZW59PC9hPlxuICAgICAgPC9MaW5rPlxuICAgICkgOiAoXG4gICAgICA8ZGl2IHsuLi5wcm9wc30+e2NoaWxkcmVufTwvZGl2PlxuICAgICk7XG5cbiAgcmV0dXJuIChcbiAgICA8V3JhcHBlclxuICAgICAgY2xhc3NOYW1lPXtjbihjbGFzc05hbWUsIHN0eWxlcy5kYXksIHtcbiAgICAgICAgW3N0eWxlcy5kYXlBY3RpdmVdOiBpc0FjdGl2ZSxcbiAgICAgIH0pfVxuICAgID5cbiAgICAgIDxkaXYgY2xhc3NOYW1lPXtzdHlsZXMuaW5uZXJ9PntkYXl9PC9kaXY+XG4gICAgPC9XcmFwcGVyPlxuICApO1xufTtcblxuY29uc3QgQ2FsZW5kYXJEYXlXcmFwcGVyID0gKHtcbiAgZGF5LFxuICBjbGFzc05hbWUgPSAnJyxcbn06IHtcbiAgZGF5OiBudW1iZXI7XG4gIGNsYXNzTmFtZT86IHN0cmluZztcbn0pID0+IChcbiAgPGRpdiBjbGFzc05hbWU9e2NuKGNsYXNzTmFtZSwgc3R5bGVzLndyYXBwZXIpfT5cbiAgICA8U1ZHXG4gICAgICBjbGFzc05hbWU9e2NuKHN0eWxlcy5zbm93LCBzdHlsZXNbYHNub3ctLSR7ZGF5fWBdKX1cbiAgICAgIHBhdGg9e2Bzbm93d2FsbC0ke3plcm9QYWQoZGF5LCAyKX0uc3ZnYH1cbiAgICAvPlxuICAgIDxDYWxlbmRhckRheSBkYXk9e2RheX0gY2xhc3NOYW1lPXtjbihzdHlsZXMuaW5uZXIpfSAvPlxuICA8L2Rpdj5cbik7XG5cbmV4cG9ydCBkZWZhdWx0IENhbGVuZGFyRGF5V3JhcHBlcjtcbiIsInZhciBhcGkgPSByZXF1aXJlKFwiIS4uLy4uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvYnVpbGQvd2VicGFjay9sb2FkZXJzL25leHQtc3R5bGUtbG9hZGVyL3J1bnRpbWUvaW5qZWN0U3R5bGVzSW50b1N0eWxlVGFnLmpzXCIpO1xuICAgICAgICAgICAgdmFyIGNvbnRlbnQgPSByZXF1aXJlKFwiISEuLi8uLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NvbXBpbGVkL2Nzcy1sb2FkZXIvY2pzLmpzPz9yZWYtLTUtb25lT2YtMi0xIS4uLy4uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvcG9zdGNzcy1sb2FkZXIvY2pzLmpzPz9yZWYtLTUtb25lT2YtMi0yIS4vQ2FsZW5kYXJEYXlMaXN0Lm1vZHVsZS5jc3NcIik7XG5cbiAgICAgICAgICAgIGNvbnRlbnQgPSBjb250ZW50Ll9fZXNNb2R1bGUgPyBjb250ZW50LmRlZmF1bHQgOiBjb250ZW50O1xuXG4gICAgICAgICAgICBpZiAodHlwZW9mIGNvbnRlbnQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgIGNvbnRlbnQgPSBbW21vZHVsZS5pZCwgY29udGVudCwgJyddXTtcbiAgICAgICAgICAgIH1cblxudmFyIG9wdGlvbnMgPSB7fTtcblxub3B0aW9ucy5pbnNlcnQgPSBmdW5jdGlvbihlbGVtZW50KXsvLyBUaGVzZSBlbGVtZW50cyBzaG91bGQgYWx3YXlzIGV4aXN0LiBJZiB0aGV5IGRvIG5vdCxcbi8vIHRoaXMgY29kZSBzaG91bGQgZmFpbC5cbnZhciBhbmNob3JFbGVtZW50PWRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJyNfX25leHRfY3NzX19ET19OT1RfVVNFX18nKTt2YXIgcGFyZW50Tm9kZT1hbmNob3JFbGVtZW50LnBhcmVudE5vZGU7Ly8gTm9ybWFsbHkgPGhlYWQ+XG4vLyBFYWNoIHN0eWxlIHRhZyBzaG91bGQgYmUgcGxhY2VkIHJpZ2h0IGJlZm9yZSBvdXJcbi8vIGFuY2hvci4gQnkgaW5zZXJ0aW5nIGJlZm9yZSBhbmQgbm90IGFmdGVyLCB3ZSBkbyBub3Rcbi8vIG5lZWQgdG8gdHJhY2sgdGhlIGxhc3QgaW5zZXJ0ZWQgZWxlbWVudC5cbnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKGVsZW1lbnQsYW5jaG9yRWxlbWVudCk7fTtcbm9wdGlvbnMuc2luZ2xldG9uID0gZmFsc2U7XG5cbnZhciB1cGRhdGUgPSBhcGkoY29udGVudCwgb3B0aW9ucyk7XG5cblxuaWYgKG1vZHVsZS5ob3QpIHtcbiAgaWYgKCFjb250ZW50LmxvY2FscyB8fCBtb2R1bGUuaG90LmludmFsaWRhdGUpIHtcbiAgICB2YXIgaXNFcXVhbExvY2FscyA9IGZ1bmN0aW9uIGlzRXF1YWxMb2NhbHMoYSxiLGlzTmFtZWRFeHBvcnQpe2lmKCFhJiZifHxhJiYhYil7cmV0dXJuIGZhbHNlO31sZXQgcDtmb3IocCBpbiBhKXtpZihpc05hbWVkRXhwb3J0JiZwPT09J2RlZmF1bHQnKXsvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29udGludWVcbmNvbnRpbnVlO31pZihhW3BdIT09YltwXSl7cmV0dXJuIGZhbHNlO319Zm9yKHAgaW4gYil7aWYoaXNOYW1lZEV4cG9ydCYmcD09PSdkZWZhdWx0Jyl7Ly8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnRpbnVlXG5jb250aW51ZTt9aWYoIWFbcF0pe3JldHVybiBmYWxzZTt9fXJldHVybiB0cnVlO307XG4gICAgdmFyIG9sZExvY2FscyA9IGNvbnRlbnQubG9jYWxzO1xuXG4gICAgbW9kdWxlLmhvdC5hY2NlcHQoXG4gICAgICBcIiEhLi4vLi4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jb21waWxlZC9jc3MtbG9hZGVyL2Nqcy5qcz8/cmVmLS01LW9uZU9mLTItMSEuLi8uLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NvbXBpbGVkL3Bvc3Rjc3MtbG9hZGVyL2Nqcy5qcz8/cmVmLS01LW9uZU9mLTItMiEuL0NhbGVuZGFyRGF5TGlzdC5tb2R1bGUuY3NzXCIsXG4gICAgICBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGNvbnRlbnQgPSByZXF1aXJlKFwiISEuLi8uLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NvbXBpbGVkL2Nzcy1sb2FkZXIvY2pzLmpzPz9yZWYtLTUtb25lT2YtMi0xIS4uLy4uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvcG9zdGNzcy1sb2FkZXIvY2pzLmpzPz9yZWYtLTUtb25lT2YtMi0yIS4vQ2FsZW5kYXJEYXlMaXN0Lm1vZHVsZS5jc3NcIik7XG5cbiAgICAgICAgICAgICAgY29udGVudCA9IGNvbnRlbnQuX19lc01vZHVsZSA/IGNvbnRlbnQuZGVmYXVsdCA6IGNvbnRlbnQ7XG5cbiAgICAgICAgICAgICAgaWYgKHR5cGVvZiBjb250ZW50ID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIGNvbnRlbnQgPSBbW21vZHVsZS5pZCwgY29udGVudCwgJyddXTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGlmICghaXNFcXVhbExvY2FscyhvbGRMb2NhbHMsIGNvbnRlbnQubG9jYWxzKSkge1xuICAgICAgICAgICAgICAgIG1vZHVsZS5ob3QuaW52YWxpZGF0ZSgpO1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgb2xkTG9jYWxzID0gY29udGVudC5sb2NhbHM7XG5cbiAgICAgICAgICAgICAgdXBkYXRlKGNvbnRlbnQpO1xuICAgICAgfVxuICAgIClcbiAgfVxuXG4gIG1vZHVsZS5ob3QuZGlzcG9zZShmdW5jdGlvbigpIHtcbiAgICB1cGRhdGUoKTtcbiAgfSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gY29udGVudC5sb2NhbHMgfHwge307IiwiaW1wb3J0IExpbmsgZnJvbSAnbmV4dC9saW5rJztcbmltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyB1c2VTdG9yZVN0YXRlIH0gZnJvbSAndW5pc3RvcmUtaG9va3MnO1xuaW1wb3J0IHsgU3RhdGUgfSBmcm9tICdAc3RvcmUvdHlwZXMnO1xuaW1wb3J0IHsgREFURV9UT0RBWSB9IGZyb20gJ0B1dGlscy9jYWxlbmRhcic7XG5pbXBvcnQgY24gZnJvbSAnQHV0aWxzL2NsYXNzbmFtZXMnO1xuaW1wb3J0IHsgU1VCSkVDVFMgfSBmcm9tICdAdXRpbHMvY29uc3RhbnRzJztcbmltcG9ydCBkYXlqcyBmcm9tICdAdXRpbHMvZGF5anMnO1xuaW1wb3J0IHN0eWxlcyBmcm9tICcuL0NhbGVuZGFyRGF5TGlzdC5tb2R1bGUuY3NzJztcblxuY29uc3QgQ2FsZW5kYXJEYXkgPSAoe1xuICBkYXksXG4gIGNsYXNzTmFtZSA9ICcnLFxufToge1xuICBkYXk6IG51bWJlcjtcbiAgY2xhc3NOYW1lPzogc3RyaW5nO1xufSkgPT4ge1xuICBjb25zdCB7IGRheXM6IHN0b3JlRGF5cyB9ID0gdXNlU3RvcmVTdGF0ZTxTdGF0ZT4oWydkYXlzJ10pO1xuXG4gIGNvbnN0IGRheU9iamVjdCA9IFJlYWN0LnVzZU1lbW8oKCkgPT4gc3RvcmVEYXlzW2RheV0sIFtzdG9yZURheXNbZGF5XSwgZGF5XSk7XG4gIGNvbnN0IGlzQWN0aXZlID0gUmVhY3QudXNlTWVtbyhcbiAgICAoKSA9PiAhZGF5anMoZGF5T2JqZWN0LmRhdGEuZGF0ZSkuaXNBZnRlcihEQVRFX1RPREFZKSxcbiAgICBbZGF5T2JqZWN0XVxuICApO1xuXG4gIGNvbnN0IFdyYXBwZXIgPSAoe1xuICAgIGNoaWxkcmVuLFxuICAgIC4uLnByb3BzXG4gIH06IHtcbiAgICBjaGlsZHJlbjogYW55O1xuICAgIFtrZXk6IHN0cmluZ106IGFueTtcbiAgfSkgPT4ge1xuICAgIGlmIChpc0FjdGl2ZSkge1xuICAgICAgcmV0dXJuIChcbiAgICAgICAgPExpbmsgaHJlZj17YC9kYXkvJHtkYXl9L2B9PlxuICAgICAgICAgIDxhIHsuLi5wcm9wc30+e2NoaWxkcmVufTwvYT5cbiAgICAgICAgPC9MaW5rPlxuICAgICAgKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIDxkaXYgey4uLnByb3BzfT57Y2hpbGRyZW59PC9kaXY+O1xuICAgIH1cbiAgfTtcblxuICByZXR1cm4gKFxuICAgIDxXcmFwcGVyXG4gICAgICBjbGFzc05hbWU9e2NuKGNsYXNzTmFtZSwgc3R5bGVzLnJvb3QsIHtcbiAgICAgICAgW3N0eWxlcy5yb290QWN0aXZlXTogaXNBY3RpdmUsXG4gICAgICB9KX1cbiAgICA+XG4gICAgICA8c3BhbiBjbGFzc05hbWU9e3N0eWxlcy5udW1iZXJ9PntkYXl9PC9zcGFuPlxuICAgICAgPHNwYW4gY2xhc3NOYW1lPXtzdHlsZXMudGl0bGV9PntTVUJKRUNUU1tkYXkgLSAxXX08L3NwYW4+XG4gICAgPC9XcmFwcGVyPlxuICApO1xufTtcblxuY29uc3QgQ2FsZW5kYXJEYXlXcmFwcGVyID0gKHtcbiAgZGF5LFxuICBjbGFzc05hbWUgPSAnJyxcbn06IHtcbiAgZGF5OiBudW1iZXI7XG4gIGNsYXNzTmFtZT86IHN0cmluZztcbn0pID0+IChcbiAgPGRpdiBjbGFzc05hbWU9e2NuKGNsYXNzTmFtZSwgc3R5bGVzLndyYXBwZXIpfT5cbiAgICA8Q2FsZW5kYXJEYXkgZGF5PXtkYXl9IGNsYXNzTmFtZT17Y24oc3R5bGVzLndyYXBwZXJJbm5lcil9IC8+XG4gIDwvZGl2PlxuKTtcblxuZXhwb3J0IGRlZmF1bHQgQ2FsZW5kYXJEYXlXcmFwcGVyO1xuIiwidmFyIGFwaSA9IHJlcXVpcmUoXCIhLi4vLi4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9idWlsZC93ZWJwYWNrL2xvYWRlcnMvbmV4dC1zdHlsZS1sb2FkZXIvcnVudGltZS9pbmplY3RTdHlsZXNJbnRvU3R5bGVUYWcuanNcIik7XG4gICAgICAgICAgICB2YXIgY29udGVudCA9IHJlcXVpcmUoXCIhIS4uLy4uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvY3NzLWxvYWRlci9janMuanM/P3JlZi0tNS1vbmVPZi0yLTEhLi4vLi4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jb21waWxlZC9wb3N0Y3NzLWxvYWRlci9janMuanM/P3JlZi0tNS1vbmVPZi0yLTIhLi9DYWxlbmRhckhlYWRlci5tb2R1bGUuY3NzXCIpO1xuXG4gICAgICAgICAgICBjb250ZW50ID0gY29udGVudC5fX2VzTW9kdWxlID8gY29udGVudC5kZWZhdWx0IDogY29udGVudDtcblxuICAgICAgICAgICAgaWYgKHR5cGVvZiBjb250ZW50ID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICBjb250ZW50ID0gW1ttb2R1bGUuaWQsIGNvbnRlbnQsICcnXV07XG4gICAgICAgICAgICB9XG5cbnZhciBvcHRpb25zID0ge307XG5cbm9wdGlvbnMuaW5zZXJ0ID0gZnVuY3Rpb24oZWxlbWVudCl7Ly8gVGhlc2UgZWxlbWVudHMgc2hvdWxkIGFsd2F5cyBleGlzdC4gSWYgdGhleSBkbyBub3QsXG4vLyB0aGlzIGNvZGUgc2hvdWxkIGZhaWwuXG52YXIgYW5jaG9yRWxlbWVudD1kb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcjX19uZXh0X2Nzc19fRE9fTk9UX1VTRV9fJyk7dmFyIHBhcmVudE5vZGU9YW5jaG9yRWxlbWVudC5wYXJlbnROb2RlOy8vIE5vcm1hbGx5IDxoZWFkPlxuLy8gRWFjaCBzdHlsZSB0YWcgc2hvdWxkIGJlIHBsYWNlZCByaWdodCBiZWZvcmUgb3VyXG4vLyBhbmNob3IuIEJ5IGluc2VydGluZyBiZWZvcmUgYW5kIG5vdCBhZnRlciwgd2UgZG8gbm90XG4vLyBuZWVkIHRvIHRyYWNrIHRoZSBsYXN0IGluc2VydGVkIGVsZW1lbnQuXG5wYXJlbnROb2RlLmluc2VydEJlZm9yZShlbGVtZW50LGFuY2hvckVsZW1lbnQpO307XG5vcHRpb25zLnNpbmdsZXRvbiA9IGZhbHNlO1xuXG52YXIgdXBkYXRlID0gYXBpKGNvbnRlbnQsIG9wdGlvbnMpO1xuXG5cbmlmIChtb2R1bGUuaG90KSB7XG4gIGlmICghY29udGVudC5sb2NhbHMgfHwgbW9kdWxlLmhvdC5pbnZhbGlkYXRlKSB7XG4gICAgdmFyIGlzRXF1YWxMb2NhbHMgPSBmdW5jdGlvbiBpc0VxdWFsTG9jYWxzKGEsYixpc05hbWVkRXhwb3J0KXtpZighYSYmYnx8YSYmIWIpe3JldHVybiBmYWxzZTt9bGV0IHA7Zm9yKHAgaW4gYSl7aWYoaXNOYW1lZEV4cG9ydCYmcD09PSdkZWZhdWx0Jyl7Ly8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnRpbnVlXG5jb250aW51ZTt9aWYoYVtwXSE9PWJbcF0pe3JldHVybiBmYWxzZTt9fWZvcihwIGluIGIpe2lmKGlzTmFtZWRFeHBvcnQmJnA9PT0nZGVmYXVsdCcpey8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb250aW51ZVxuY29udGludWU7fWlmKCFhW3BdKXtyZXR1cm4gZmFsc2U7fX1yZXR1cm4gdHJ1ZTt9O1xuICAgIHZhciBvbGRMb2NhbHMgPSBjb250ZW50LmxvY2FscztcblxuICAgIG1vZHVsZS5ob3QuYWNjZXB0KFxuICAgICAgXCIhIS4uLy4uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvY3NzLWxvYWRlci9janMuanM/P3JlZi0tNS1vbmVPZi0yLTEhLi4vLi4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jb21waWxlZC9wb3N0Y3NzLWxvYWRlci9janMuanM/P3JlZi0tNS1vbmVPZi0yLTIhLi9DYWxlbmRhckhlYWRlci5tb2R1bGUuY3NzXCIsXG4gICAgICBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGNvbnRlbnQgPSByZXF1aXJlKFwiISEuLi8uLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NvbXBpbGVkL2Nzcy1sb2FkZXIvY2pzLmpzPz9yZWYtLTUtb25lT2YtMi0xIS4uLy4uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvcG9zdGNzcy1sb2FkZXIvY2pzLmpzPz9yZWYtLTUtb25lT2YtMi0yIS4vQ2FsZW5kYXJIZWFkZXIubW9kdWxlLmNzc1wiKTtcblxuICAgICAgICAgICAgICBjb250ZW50ID0gY29udGVudC5fX2VzTW9kdWxlID8gY29udGVudC5kZWZhdWx0IDogY29udGVudDtcblxuICAgICAgICAgICAgICBpZiAodHlwZW9mIGNvbnRlbnQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgY29udGVudCA9IFtbbW9kdWxlLmlkLCBjb250ZW50LCAnJ11dO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgaWYgKCFpc0VxdWFsTG9jYWxzKG9sZExvY2FscywgY29udGVudC5sb2NhbHMpKSB7XG4gICAgICAgICAgICAgICAgbW9kdWxlLmhvdC5pbnZhbGlkYXRlKCk7XG5cbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBvbGRMb2NhbHMgPSBjb250ZW50LmxvY2FscztcblxuICAgICAgICAgICAgICB1cGRhdGUoY29udGVudCk7XG4gICAgICB9XG4gICAgKVxuICB9XG5cbiAgbW9kdWxlLmhvdC5kaXNwb3NlKGZ1bmN0aW9uKCkge1xuICAgIHVwZGF0ZSgpO1xuICB9KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjb250ZW50LmxvY2FscyB8fCB7fTsiLCJpbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsgdXNlQWN0aW9ucyB9IGZyb20gJ3VuaXN0b3JlLWhvb2tzJztcbmltcG9ydCB7IEJ1dHRvbiwgTG9nbyB9IGZyb20gJ0B0aGVtZSc7XG5pbXBvcnQgeyBhY3Rpb25zIH0gZnJvbSAnQHN0b3JlL2luZGV4JztcbmltcG9ydCB7IERBVEVfRU5ELCBEQVRFX1RPREFZIH0gZnJvbSAnQHV0aWxzL2NhbGVuZGFyJztcbmltcG9ydCBjbiBmcm9tICdAdXRpbHMvY2xhc3NuYW1lcyc7XG5pbXBvcnQgeyBWSUVXX1RZUEVTIH0gZnJvbSAnQHV0aWxzL2NvbnN0YW50cyc7XG5pbXBvcnQgc3R5bGVzIGZyb20gJy4vQ2FsZW5kYXJIZWFkZXIubW9kdWxlLmNzcyc7XG5cbmNvbnN0IENhbGVuZGFySGVhZGVyID0gKHtcbiAgY2xhc3NOYW1lID0gJycsXG4gIHNldFZpZXcsXG4gIHZpZXcsXG59OiB7XG4gIGNsYXNzTmFtZT86IHN0cmluZztcbiAgc2V0VmlldzogRnVuY3Rpb247XG4gIHZpZXc6IHN0cmluZztcbn0pID0+IHtcbiAgY29uc3QgeyBzZXRNZW51T3BlbiB9ID0gdXNlQWN0aW9ucyhhY3Rpb25zKTtcblxuICByZXR1cm4gKFxuICAgIDxoZWFkZXIgY2xhc3NOYW1lPXtjbihjbGFzc05hbWUsIHN0eWxlcy5yb290KX0+XG4gICAgICA8TG9nb1xuICAgICAgICBjbGFzc05hbWU9e3N0eWxlcy5sb2dvfVxuICAgICAgICB0aXRsZT1cIlBXQWR2ZW50IExvZ29cIlxuICAgICAgICBhbHQ9XCJQV0FkdmVudCBMb2dvXCJcbiAgICAgICAgc2FtZWhlaWdodFxuICAgICAgLz5cbiAgICAgIDxCdXR0b25cbiAgICAgICAgY2xhc3NOYW1lPXtzdHlsZXMuYnV0dG9ufVxuICAgICAgICBvbkNsaWNrPXsoKSA9PiBzZXRNZW51T3Blbih0cnVlKX1cbiAgICAgICAgaWNvbj1cIm1kaS9tZW51XCJcbiAgICAgICAgbGF5b3V0PVwiZ2hvc3RcIlxuICAgICAgICByb3VuZFxuICAgICAgICBzaXplPVwic21hbGxcIlxuICAgICAgPlxuICAgICAgICBBYm91dFxuICAgICAgPC9CdXR0b24+XG4gICAgICB7REFURV9UT0RBWS5pc0FmdGVyKERBVEVfRU5EKSAmJiAoXG4gICAgICAgIDxkaXYgY2xhc3NOYW1lPXtzdHlsZXMudmlld30+XG4gICAgICAgICAge09iamVjdC52YWx1ZXMoVklFV19UWVBFUykubWFwKCh0eXBlKSA9PiAoXG4gICAgICAgICAgICA8QnV0dG9uXG4gICAgICAgICAgICAgIG9uQ2xpY2s9eygpID0+IHNldFZpZXcodHlwZSl9XG4gICAgICAgICAgICAgIGNsYXNzTmFtZT17Y24oc3R5bGVzLnZpZXdCdXR0b24sIHtcbiAgICAgICAgICAgICAgICBbc3R5bGVzLnZpZXdCdXR0b25BY3RpdmVdOiB0eXBlID09PSB2aWV3LFxuICAgICAgICAgICAgICB9KX1cbiAgICAgICAgICAgICAgc2l6ZT1cInNtYWxsXCJcbiAgICAgICAgICAgICAgbGF5b3V0PXt0eXBlID09PSB2aWV3ID8gJ3NvbGlkJyA6ICdnaG9zdCd9XG4gICAgICAgICAgICAgIGljb249e2BtZGkvJHt0eXBlfWB9XG4gICAgICAgICAgICAgIHJvdW5kXG4gICAgICAgICAgICAgIGNvbG9yPXt0eXBlID09PSB2aWV3ID8gJ3JlZCcgOiAnYmxhY2snfVxuICAgICAgICAgICAgPlxuICAgICAgICAgICAgICB7dHlwZSA9PT0gVklFV19UWVBFUy5DQUxFTkRBUiA/ICdDYWxlbmRhcicgOiAnTGlzdCd9XG4gICAgICAgICAgICA8L0J1dHRvbj5cbiAgICAgICAgICApKX1cbiAgICAgICAgPC9kaXY+XG4gICAgICApfVxuICAgIDwvaGVhZGVyPlxuICApO1xufTtcblxuZXhwb3J0IGRlZmF1bHQgQ2FsZW5kYXJIZWFkZXI7XG4iLCIvL2ltcG9ydCB7IHVzZVBhcmFtcywgdXNlSGlzdG9yeSwgUm91dGUsIFN3aXRjaCB9IGZyb20gJ3JlYWN0LXJvdXRlci1kb20nO1xuaW1wb3J0IEhlYWQgZnJvbSAnbmV4dC9oZWFkJztcbmltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyB1c2VTdG9yZVN0YXRlLCB1c2VBY3Rpb25zIH0gZnJvbSAndW5pc3RvcmUtaG9va3MnO1xuaW1wb3J0IHsgQ29udGVudE1vZGFsIH0gZnJvbSAnQHRoZW1lJztcbmltcG9ydCB7IGFjdGlvbnMgfSBmcm9tICdAc3RvcmUvaW5kZXgnO1xuaW1wb3J0IHsgU3RhdGUgfSBmcm9tICdAc3RvcmUvdHlwZXMnO1xuaW1wb3J0IHsgRGF5IH0gZnJvbSAnQGFwcC90eXBlcyc7XG5pbXBvcnQgeyBtZXRhVGl0bGUgfSBmcm9tICdAdXRpbHMvbWV0YXMnO1xuaW1wb3J0IHN0eWxlcyBmcm9tICcuL0NvbnRlbnQubW9kdWxlLmNzcyc7XG5pbXBvcnQgQ29udGVudENhbGVuZGFyIGZyb20gJy4vQ29udGVudENhbGVuZGFyJztcbmltcG9ydCBDb250ZW50UGFnZSBmcm9tICcuL0NvbnRlbnRQYWdlJztcblxuY29uc3QgQ29udGVudCA9ICh7IGNsYXNzTmFtZSA9ICcnIH06IHsgY2xhc3NOYW1lPzogc3RyaW5nIH0pID0+IHtcbiAgY29uc3QgeyBsb2FkRGF5IH0gPSB1c2VBY3Rpb25zKGFjdGlvbnMpO1xuICBjb25zdCB7IHBhZ2UgPSBudWxsLCBzbHVnID0gbnVsbCB9ID0gdXNlUGFyYW1zKCk7XG4gIGNvbnN0IHsgcHVzaCB9ID0gdXNlSGlzdG9yeSgpO1xuXG4gIGNvbnN0IHsgZGF5czogc3RvcmVEYXlzIH0gPSB1c2VTdG9yZVN0YXRlPFN0YXRlPihbJ2RheXMnXSk7XG5cbiAgY29uc3QgYWN0aXZlOiBib29sZWFuID0gUmVhY3QudXNlTWVtbygoKSA9PiAhIXBhZ2UsIFtwYWdlXSk7XG4gIGNvbnN0IGFjdGl2ZURheTogRGF5ID0gUmVhY3QudXNlTWVtbyhcbiAgICAoKSA9PiAoYWN0aXZlICE9PSBmYWxzZSAmJiBwYWdlID09PSAnZGF5JyAmJiBzdG9yZURheXNbc2x1Z10pIHx8IGZhbHNlLFxuICAgIFthY3RpdmUsIHN0b3JlRGF5c1tzbHVnXSwgc2x1Z11cbiAgKTtcblxuICBSZWFjdC51c2VFZmZlY3QoKCkgPT4ge1xuICAgIGFjdGl2ZURheSAmJiBsb2FkRGF5KHNsdWcpO1xuICB9LCBbc2x1Z10pO1xuXG4gIGlmICghYWN0aXZlKSB7XG4gICAgcmV0dXJuIChcbiAgICAgIDxIZWFkPlxuICAgICAgICA8dGl0bGU+e21ldGFUaXRsZSgpfTwvdGl0bGU+XG4gICAgICA8L0hlYWQ+XG4gICAgKTtcbiAgfVxuXG4gIGlmIChhY3RpdmVEYXkpIHtcbiAgICByZXR1cm4gKFxuICAgICAgPENvbnRlbnRNb2RhbFxuICAgICAgICB0aXRsZT17XG4gICAgICAgICAgYWN0aXZlRGF5LmVycm9yICE9PSAnJyA/IGBEYXkgJHtzbHVnfWAgOiBhY3RpdmVEYXkuZGF0YS50aXRsZSB8fCAnJ1xuICAgICAgICB9XG4gICAgICAgIG9uQ2xvc2U9eygpID0+IHB1c2goJy8nKX1cbiAgICAgICAgbG9hZGluZz17YWN0aXZlRGF5LmxvYWRpbmd9XG4gICAgICA+XG4gICAgICAgIDxDb250ZW50Q2FsZW5kYXJcbiAgICAgICAgICBkYXk9e2FjdGl2ZURheS5kYXRhfVxuICAgICAgICAgIG51bWJlcj17c2x1Z31cbiAgICAgICAgICBlcnJvcj17YWN0aXZlRGF5LmVycm9yfVxuICAgICAgICAvPlxuICAgICAgPC9Db250ZW50TW9kYWw+XG4gICAgKTtcbiAgfVxuXG4gIGlmIChwYWdlID09PSAnZW1haWwtbm90aWZpY2F0aW9uJykge1xuICAgIHJldHVybiAoXG4gICAgICA8Q29udGVudE1vZGFsXG4gICAgICAgIGNsYXNzTmFtZT17Y2xhc3NOYW1lfVxuICAgICAgICBvbkNsb3NlPXsoKSA9PiBwdXNoKCcvJyl9XG4gICAgICAgIHRpdGxlPVwiRW1haWwgTm90aWZpY2F0aW9uXCJcbiAgICAgICAgZnVsbD17ZmFsc2V9XG4gICAgICA+XG4gICAgICAgIHtzbHVnID09PSAnc3VjY2VzcycgPyAoXG4gICAgICAgICAgPHA+XG4gICAgICAgICAgICBUaGFuayB5b3UgdmVyeSBtdWNoLiBZb3VyIGVtYWlsIGFkZHJlc3MgaGFzIGJlZW4gc3VjY2Vzc2Z1bGx5XG4gICAgICAgICAgICB2ZXJpZmllZC5cbiAgICAgICAgICA8L3A+XG4gICAgICAgICkgOiBzbHVnID09PSAndW5zdWJzY3JpYmUnID8gKFxuICAgICAgICAgIDxwPllvdSBoYXZlIGJlZW4gc3VjY2Vzc2Z1bGx5IHNpZ25lZCBvdXQuPC9wPlxuICAgICAgICApIDogKFxuICAgICAgICAgIDxwPk9vb3BzLi4gU29tZXRoaW5nIHdlbnQgd3JvbmcuPC9wPlxuICAgICAgICApfVxuICAgICAgPC9Db250ZW50TW9kYWw+XG4gICAgKTtcbiAgfVxuXG4gIHJldHVybiAoXG4gICAgPENvbnRlbnRQYWdlIGNsYXNzTmFtZT17Y2xhc3NOYW1lfSBzbHVnPXtwYWdlfSBvbkNsb3NlPXsoKSA9PiBwdXNoKCcvJyl9IC8+XG4gICk7XG59O1xuXG5leHBvcnQgZGVmYXVsdCAocHJvcHMpID0+IChcbiAgPFN3aXRjaD5cbiAgICA8Um91dGUgcGF0aD1cIi86cGFnZT8vOnNsdWc/L1wiPlxuICAgICAgPENvbnRlbnQgey4uLnByb3BzfSAvPlxuICAgIDwvUm91dGU+XG4gIDwvU3dpdGNoPlxuKTtcbiIsInZhciBhcGkgPSByZXF1aXJlKFwiIS4uLy4uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvYnVpbGQvd2VicGFjay9sb2FkZXJzL25leHQtc3R5bGUtbG9hZGVyL3J1bnRpbWUvaW5qZWN0U3R5bGVzSW50b1N0eWxlVGFnLmpzXCIpO1xuICAgICAgICAgICAgdmFyIGNvbnRlbnQgPSByZXF1aXJlKFwiISEuLi8uLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NvbXBpbGVkL2Nzcy1sb2FkZXIvY2pzLmpzPz9yZWYtLTUtb25lT2YtMi0xIS4uLy4uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvcG9zdGNzcy1sb2FkZXIvY2pzLmpzPz9yZWYtLTUtb25lT2YtMi0yIS4vQ29udGVudEF1dGhvci5tb2R1bGUuY3NzXCIpO1xuXG4gICAgICAgICAgICBjb250ZW50ID0gY29udGVudC5fX2VzTW9kdWxlID8gY29udGVudC5kZWZhdWx0IDogY29udGVudDtcblxuICAgICAgICAgICAgaWYgKHR5cGVvZiBjb250ZW50ID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICBjb250ZW50ID0gW1ttb2R1bGUuaWQsIGNvbnRlbnQsICcnXV07XG4gICAgICAgICAgICB9XG5cbnZhciBvcHRpb25zID0ge307XG5cbm9wdGlvbnMuaW5zZXJ0ID0gZnVuY3Rpb24oZWxlbWVudCl7Ly8gVGhlc2UgZWxlbWVudHMgc2hvdWxkIGFsd2F5cyBleGlzdC4gSWYgdGhleSBkbyBub3QsXG4vLyB0aGlzIGNvZGUgc2hvdWxkIGZhaWwuXG52YXIgYW5jaG9yRWxlbWVudD1kb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcjX19uZXh0X2Nzc19fRE9fTk9UX1VTRV9fJyk7dmFyIHBhcmVudE5vZGU9YW5jaG9yRWxlbWVudC5wYXJlbnROb2RlOy8vIE5vcm1hbGx5IDxoZWFkPlxuLy8gRWFjaCBzdHlsZSB0YWcgc2hvdWxkIGJlIHBsYWNlZCByaWdodCBiZWZvcmUgb3VyXG4vLyBhbmNob3IuIEJ5IGluc2VydGluZyBiZWZvcmUgYW5kIG5vdCBhZnRlciwgd2UgZG8gbm90XG4vLyBuZWVkIHRvIHRyYWNrIHRoZSBsYXN0IGluc2VydGVkIGVsZW1lbnQuXG5wYXJlbnROb2RlLmluc2VydEJlZm9yZShlbGVtZW50LGFuY2hvckVsZW1lbnQpO307XG5vcHRpb25zLnNpbmdsZXRvbiA9IGZhbHNlO1xuXG52YXIgdXBkYXRlID0gYXBpKGNvbnRlbnQsIG9wdGlvbnMpO1xuXG5cbmlmIChtb2R1bGUuaG90KSB7XG4gIGlmICghY29udGVudC5sb2NhbHMgfHwgbW9kdWxlLmhvdC5pbnZhbGlkYXRlKSB7XG4gICAgdmFyIGlzRXF1YWxMb2NhbHMgPSBmdW5jdGlvbiBpc0VxdWFsTG9jYWxzKGEsYixpc05hbWVkRXhwb3J0KXtpZighYSYmYnx8YSYmIWIpe3JldHVybiBmYWxzZTt9bGV0IHA7Zm9yKHAgaW4gYSl7aWYoaXNOYW1lZEV4cG9ydCYmcD09PSdkZWZhdWx0Jyl7Ly8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnRpbnVlXG5jb250aW51ZTt9aWYoYVtwXSE9PWJbcF0pe3JldHVybiBmYWxzZTt9fWZvcihwIGluIGIpe2lmKGlzTmFtZWRFeHBvcnQmJnA9PT0nZGVmYXVsdCcpey8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb250aW51ZVxuY29udGludWU7fWlmKCFhW3BdKXtyZXR1cm4gZmFsc2U7fX1yZXR1cm4gdHJ1ZTt9O1xuICAgIHZhciBvbGRMb2NhbHMgPSBjb250ZW50LmxvY2FscztcblxuICAgIG1vZHVsZS5ob3QuYWNjZXB0KFxuICAgICAgXCIhIS4uLy4uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvY3NzLWxvYWRlci9janMuanM/P3JlZi0tNS1vbmVPZi0yLTEhLi4vLi4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jb21waWxlZC9wb3N0Y3NzLWxvYWRlci9janMuanM/P3JlZi0tNS1vbmVPZi0yLTIhLi9Db250ZW50QXV0aG9yLm1vZHVsZS5jc3NcIixcbiAgICAgIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgY29udGVudCA9IHJlcXVpcmUoXCIhIS4uLy4uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvY3NzLWxvYWRlci9janMuanM/P3JlZi0tNS1vbmVPZi0yLTEhLi4vLi4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jb21waWxlZC9wb3N0Y3NzLWxvYWRlci9janMuanM/P3JlZi0tNS1vbmVPZi0yLTIhLi9Db250ZW50QXV0aG9yLm1vZHVsZS5jc3NcIik7XG5cbiAgICAgICAgICAgICAgY29udGVudCA9IGNvbnRlbnQuX19lc01vZHVsZSA/IGNvbnRlbnQuZGVmYXVsdCA6IGNvbnRlbnQ7XG5cbiAgICAgICAgICAgICAgaWYgKHR5cGVvZiBjb250ZW50ID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIGNvbnRlbnQgPSBbW21vZHVsZS5pZCwgY29udGVudCwgJyddXTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGlmICghaXNFcXVhbExvY2FscyhvbGRMb2NhbHMsIGNvbnRlbnQubG9jYWxzKSkge1xuICAgICAgICAgICAgICAgIG1vZHVsZS5ob3QuaW52YWxpZGF0ZSgpO1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgb2xkTG9jYWxzID0gY29udGVudC5sb2NhbHM7XG5cbiAgICAgICAgICAgICAgdXBkYXRlKGNvbnRlbnQpO1xuICAgICAgfVxuICAgIClcbiAgfVxuXG4gIG1vZHVsZS5ob3QuZGlzcG9zZShmdW5jdGlvbigpIHtcbiAgICB1cGRhdGUoKTtcbiAgfSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gY29udGVudC5sb2NhbHMgfHwge307IiwiaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IEF1dGhvciB9IGZyb20gJ0BhcHAvdHlwZXMnO1xuaW1wb3J0IGNuIGZyb20gJ0B1dGlscy9jbGFzc25hbWVzJztcbmltcG9ydCBzdHlsZXMgZnJvbSAnLi9Db250ZW50QXV0aG9yLm1vZHVsZS5jc3MnO1xuXG5jb25zdCBsaW5rTGlzdCA9IHtcbiAgdHdpdHRlcjogJ1R3aXR0ZXInLFxuICBkZXZ0bzogJ0Rldi50bycsXG4gIHdlYmRldjogJ1dlYi5kZXYnLFxufTtcblxuY29uc3QgQ29udGVudEF1dGhvciA9ICh7XG4gIGF1dGhvcixcbiAgY2xhc3NOYW1lID0gJycsXG4gIHNtYWxsID0gZmFsc2UsXG59OiB7XG4gIGF1dGhvcjogQXV0aG9yO1xuICBjbGFzc05hbWU/OiBzdHJpbmc7XG4gIHNtYWxsPzogYm9vbGVhbjtcbn0pID0+IHtcbiAgY29uc3QgbGlua3M6IEFycmF5PHtcbiAgICB0aXRsZTogc3RyaW5nO1xuICAgIGxpbms6IHN0cmluZztcbiAgfT4gPSBSZWFjdC51c2VNZW1vKFxuICAgICgpID0+XG4gICAgICBPYmplY3QuZW50cmllcyhsaW5rTGlzdClcbiAgICAgICAgLm1hcCgoW2tleSwgdGl0bGVdKSA9PlxuICAgICAgICAgIGtleSBpbiBhdXRob3IgJiYgYXV0aG9yW2tleV0gIT09ICcnXG4gICAgICAgICAgICA/IHtcbiAgICAgICAgICAgICAgICB0aXRsZSxcbiAgICAgICAgICAgICAgICBsaW5rOiBhdXRob3Jba2V5XSxcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgOiBudWxsXG4gICAgICAgIClcbiAgICAgICAgLmZpbHRlcigoZSkgPT4gISFlKSxcbiAgICBbYXV0aG9yXVxuICApO1xuXG4gIHJldHVybiAoXG4gICAgPGRpdiBjbGFzc05hbWU9e2NuKHN0eWxlcy5yb290LCBjbGFzc05hbWUpfT5cbiAgICAgIHthdXRob3IuaW1hZ2Uuc3JjICE9PSAnJyAmJiAoXG4gICAgICAgIDxpbWdcbiAgICAgICAgICBjbGFzc05hbWU9e2NuKHN0eWxlcy5pbWFnZSl9XG4gICAgICAgICAgYWx0PXthdXRob3IubmFtZX1cbiAgICAgICAgICBzcmM9e2F1dGhvci5pbWFnZS5zcmN9XG4gICAgICAgICAgd2lkdGg9e3NtYWxsID8gNTAgOiBhdXRob3IuaW1hZ2Uud2lkdGh9XG4gICAgICAgICAgaGVpZ2h0PXtzbWFsbCA/IDUwIDogYXV0aG9yLmltYWdlLndpZHRofVxuICAgICAgICAvPlxuICAgICAgKX1cbiAgICAgIDxkaXYgY2xhc3NOYW1lPXtjbihzdHlsZXMuYWJvdXQpfT5cbiAgICAgICAgPHAgY2xhc3NOYW1lPXtjbihzdHlsZXMubmFtZSl9PlxuICAgICAgICAgIHsncGVyc29uYWwnIGluIGF1dGhvciAmJiBhdXRob3IucGVyc29uYWwgIT09ICcnID8gKFxuICAgICAgICAgICAgPGEgaHJlZj17YXV0aG9yLnBlcnNvbmFsfSB0YXJnZXQ9XCJfYmxhbmtcIj5cbiAgICAgICAgICAgICAge2F1dGhvci5uYW1lfVxuICAgICAgICAgICAgPC9hPlxuICAgICAgICAgICkgOiAoXG4gICAgICAgICAgICBhdXRob3IubmFtZVxuICAgICAgICAgICl9XG4gICAgICAgIDwvcD5cbiAgICAgICAge2xpbmtzLmxlbmd0aCAhPT0gMCAmJiAoXG4gICAgICAgICAgPHVsIGNsYXNzTmFtZT17Y24oc3R5bGVzLmxpbmtzKX0+XG4gICAgICAgICAgICB7bGlua3MubWFwKCh7IHRpdGxlLCBsaW5rIH0pID0+IChcbiAgICAgICAgICAgICAgPGxpIGNsYXNzTmFtZT17Y24oc3R5bGVzLmxpbmtzSXRlbSl9PlxuICAgICAgICAgICAgICAgIDxhIHRhcmdldD1cIl9ibGFua1wiIGhyZWY9e2xpbmt9IGNsYXNzTmFtZT17Y24oc3R5bGVzLmxpbmtzSXRlbSl9PlxuICAgICAgICAgICAgICAgICAge3RpdGxlfVxuICAgICAgICAgICAgICAgIDwvYT5cbiAgICAgICAgICAgICAgPC9saT5cbiAgICAgICAgICAgICkpfVxuICAgICAgICAgIDwvdWw+XG4gICAgICAgICl9XG4gICAgICA8L2Rpdj5cbiAgICA8L2Rpdj5cbiAgKTtcbn07XG5cbmV4cG9ydCBkZWZhdWx0IENvbnRlbnRBdXRob3I7XG4iLCJ2YXIgYXBpID0gcmVxdWlyZShcIiEuLi8uLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2J1aWxkL3dlYnBhY2svbG9hZGVycy9uZXh0LXN0eWxlLWxvYWRlci9ydW50aW1lL2luamVjdFN0eWxlc0ludG9TdHlsZVRhZy5qc1wiKTtcbiAgICAgICAgICAgIHZhciBjb250ZW50ID0gcmVxdWlyZShcIiEhLi4vLi4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jb21waWxlZC9jc3MtbG9hZGVyL2Nqcy5qcz8/cmVmLS01LW9uZU9mLTItMSEuLi8uLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NvbXBpbGVkL3Bvc3Rjc3MtbG9hZGVyL2Nqcy5qcz8/cmVmLS01LW9uZU9mLTItMiEuL0NvbnRlbnRDYWxlbmRhci5tb2R1bGUuY3NzXCIpO1xuXG4gICAgICAgICAgICBjb250ZW50ID0gY29udGVudC5fX2VzTW9kdWxlID8gY29udGVudC5kZWZhdWx0IDogY29udGVudDtcblxuICAgICAgICAgICAgaWYgKHR5cGVvZiBjb250ZW50ID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICBjb250ZW50ID0gW1ttb2R1bGUuaWQsIGNvbnRlbnQsICcnXV07XG4gICAgICAgICAgICB9XG5cbnZhciBvcHRpb25zID0ge307XG5cbm9wdGlvbnMuaW5zZXJ0ID0gZnVuY3Rpb24oZWxlbWVudCl7Ly8gVGhlc2UgZWxlbWVudHMgc2hvdWxkIGFsd2F5cyBleGlzdC4gSWYgdGhleSBkbyBub3QsXG4vLyB0aGlzIGNvZGUgc2hvdWxkIGZhaWwuXG52YXIgYW5jaG9yRWxlbWVudD1kb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcjX19uZXh0X2Nzc19fRE9fTk9UX1VTRV9fJyk7dmFyIHBhcmVudE5vZGU9YW5jaG9yRWxlbWVudC5wYXJlbnROb2RlOy8vIE5vcm1hbGx5IDxoZWFkPlxuLy8gRWFjaCBzdHlsZSB0YWcgc2hvdWxkIGJlIHBsYWNlZCByaWdodCBiZWZvcmUgb3VyXG4vLyBhbmNob3IuIEJ5IGluc2VydGluZyBiZWZvcmUgYW5kIG5vdCBhZnRlciwgd2UgZG8gbm90XG4vLyBuZWVkIHRvIHRyYWNrIHRoZSBsYXN0IGluc2VydGVkIGVsZW1lbnQuXG5wYXJlbnROb2RlLmluc2VydEJlZm9yZShlbGVtZW50LGFuY2hvckVsZW1lbnQpO307XG5vcHRpb25zLnNpbmdsZXRvbiA9IGZhbHNlO1xuXG52YXIgdXBkYXRlID0gYXBpKGNvbnRlbnQsIG9wdGlvbnMpO1xuXG5cbmlmIChtb2R1bGUuaG90KSB7XG4gIGlmICghY29udGVudC5sb2NhbHMgfHwgbW9kdWxlLmhvdC5pbnZhbGlkYXRlKSB7XG4gICAgdmFyIGlzRXF1YWxMb2NhbHMgPSBmdW5jdGlvbiBpc0VxdWFsTG9jYWxzKGEsYixpc05hbWVkRXhwb3J0KXtpZighYSYmYnx8YSYmIWIpe3JldHVybiBmYWxzZTt9bGV0IHA7Zm9yKHAgaW4gYSl7aWYoaXNOYW1lZEV4cG9ydCYmcD09PSdkZWZhdWx0Jyl7Ly8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnRpbnVlXG5jb250aW51ZTt9aWYoYVtwXSE9PWJbcF0pe3JldHVybiBmYWxzZTt9fWZvcihwIGluIGIpe2lmKGlzTmFtZWRFeHBvcnQmJnA9PT0nZGVmYXVsdCcpey8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb250aW51ZVxuY29udGludWU7fWlmKCFhW3BdKXtyZXR1cm4gZmFsc2U7fX1yZXR1cm4gdHJ1ZTt9O1xuICAgIHZhciBvbGRMb2NhbHMgPSBjb250ZW50LmxvY2FscztcblxuICAgIG1vZHVsZS5ob3QuYWNjZXB0KFxuICAgICAgXCIhIS4uLy4uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvY3NzLWxvYWRlci9janMuanM/P3JlZi0tNS1vbmVPZi0yLTEhLi4vLi4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jb21waWxlZC9wb3N0Y3NzLWxvYWRlci9janMuanM/P3JlZi0tNS1vbmVPZi0yLTIhLi9Db250ZW50Q2FsZW5kYXIubW9kdWxlLmNzc1wiLFxuICAgICAgZnVuY3Rpb24gKCkge1xuICAgICAgICBjb250ZW50ID0gcmVxdWlyZShcIiEhLi4vLi4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jb21waWxlZC9jc3MtbG9hZGVyL2Nqcy5qcz8/cmVmLS01LW9uZU9mLTItMSEuLi8uLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NvbXBpbGVkL3Bvc3Rjc3MtbG9hZGVyL2Nqcy5qcz8/cmVmLS01LW9uZU9mLTItMiEuL0NvbnRlbnRDYWxlbmRhci5tb2R1bGUuY3NzXCIpO1xuXG4gICAgICAgICAgICAgIGNvbnRlbnQgPSBjb250ZW50Ll9fZXNNb2R1bGUgPyBjb250ZW50LmRlZmF1bHQgOiBjb250ZW50O1xuXG4gICAgICAgICAgICAgIGlmICh0eXBlb2YgY29udGVudCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICBjb250ZW50ID0gW1ttb2R1bGUuaWQsIGNvbnRlbnQsICcnXV07XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBpZiAoIWlzRXF1YWxMb2NhbHMob2xkTG9jYWxzLCBjb250ZW50LmxvY2FscykpIHtcbiAgICAgICAgICAgICAgICBtb2R1bGUuaG90LmludmFsaWRhdGUoKTtcblxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIG9sZExvY2FscyA9IGNvbnRlbnQubG9jYWxzO1xuXG4gICAgICAgICAgICAgIHVwZGF0ZShjb250ZW50KTtcbiAgICAgIH1cbiAgICApXG4gIH1cblxuICBtb2R1bGUuaG90LmRpc3Bvc2UoZnVuY3Rpb24oKSB7XG4gICAgdXBkYXRlKCk7XG4gIH0pO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNvbnRlbnQubG9jYWxzIHx8IHt9OyIsImltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyBCdXR0b24sIExhenlJbWFnZSwgTm90aWZpY2F0aW9uIH0gZnJvbSAnQHRoZW1lJztcbmltcG9ydCBDb250ZW50QXV0aG9yIGZyb20gJ0Bjb21wcy9Db250ZW50L0NvbnRlbnRBdXRob3InO1xuaW1wb3J0IHVzZVdpbmRvd1NpemUgZnJvbSAnQGNvbXBzL2hvb2tzL3VzZVdpbmRvd1NpemUnO1xuaW1wb3J0IHsgRGF5RGF0YSB9IGZyb20gJ0Bjb21wcy90eXBlcyc7XG5pbXBvcnQgY24gZnJvbSAnQHV0aWxzL2NsYXNzbmFtZXMnO1xuaW1wb3J0IGRheWpzIGZyb20gJ0B1dGlscy9kYXlqcyc7XG5pbXBvcnQgUHJpc20gZnJvbSAnQHV0aWxzL3ByaXNtJztcbmltcG9ydCBzdHlsZXMgZnJvbSAnLi9Db250ZW50Q2FsZW5kYXIubW9kdWxlLmNzcyc7XG5cbmNvbnN0IENvbnRlbnRDYWxlbmRhciA9ICh7XG4gIGRheSxcbiAgbnVtYmVyLFxuICBjbGFzc05hbWUgPSAnJyxcbiAgZXJyb3IgPSAnJyxcbn06IHtcbiAgZGF5OiBEYXlEYXRhO1xuICBudW1iZXI6IG51bWJlcjtcbiAgY2xhc3NOYW1lPzogc3RyaW5nO1xuICBlcnJvcj86IHN0cmluZztcbn0pID0+IHtcbiAgY29uc3QgY29udGVudFJlZiA9IFJlYWN0LnVzZVJlZihudWxsKTtcbiAgY29uc3QgZGF0ZSA9IFJlYWN0LnVzZU1lbW8oKCkgPT4gZGF5anMoZGF5LmRhdGUpLCBbZGF5LmRhdGVdKTtcbiAgY29uc3QgeyB3aWR0aCB9ID0gdXNlV2luZG93U2l6ZSgpO1xuXG4gIGNvbnN0IG9yaWdpbmFsU291cmNlID0gUmVhY3QudXNlTWVtbyhcbiAgICAoKSA9PiAoZGF5LnNvdXJjZSA/IG5ldyBVUkwoZGF5LnNvdXJjZSkgOiBudWxsKSxcbiAgICBbZGF5LnNvdXJjZV1cbiAgKTtcblxuICBjb25zdCBjb250ZW50ID0gUmVhY3QudXNlTWVtbygoKSA9PiB7XG4gICAgY29uc3QgcmVnZXggPSAvPGNvZGUgY2xhc3M9XCJsYW5ndWFnZS1tYXJrdXBcIj4oKC58XFxuKSo/KTxcXC9jb2RlPi9nbTtcbiAgICBsZXQgbTtcbiAgICBsZXQgYyA9IGRheS5jb250ZW50O1xuXG4gICAgd2hpbGUgKChtID0gcmVnZXguZXhlYyhjKSkgIT09IG51bGwpIHtcbiAgICAgIGlmIChtLmluZGV4ID09PSByZWdleC5sYXN0SW5kZXgpIHtcbiAgICAgICAgcmVnZXgubGFzdEluZGV4Kys7XG4gICAgICB9XG5cbiAgICAgIGMgPSBjLnJlcGxhY2UobVsxXSwgbVsxXS5yZXBsYWNlKC88L2csICcmbHQ7JykpO1xuICAgIH1cblxuICAgIHJldHVybiBjO1xuICB9LCBbZGF5LmNvbnRlbnRdKTtcblxuICBSZWFjdC51c2VFZmZlY3QoKCkgPT4ge1xuICAgIFByaXNtLmhpZ2hsaWdodEFsbCgpO1xuICB9LCBbY29udGVudFJlZiwgY29udGVudF0pO1xuXG4gIGlmIChlcnJvciAhPT0gJycpIHtcbiAgICByZXR1cm4gKFxuICAgICAgPGRpdiBjbGFzc05hbWU9e2NsYXNzTmFtZX0+XG4gICAgICAgIDxwIGNsYXNzTmFtZT17Y24oc3R5bGVzLmVycm9yKX0+e2Vycm9yfTwvcD5cbiAgICAgIDwvZGl2PlxuICAgICk7XG4gIH1cblxuICByZXR1cm4gKFxuICAgIDxkaXYgY2xhc3NOYW1lPXtjbGFzc05hbWV9PlxuICAgICAgPHAgY2xhc3NOYW1lPXtjbihzdHlsZXMuZGF0ZSl9PlxuICAgICAgICA8Yj5EYXkge251bWJlcn06PC9iPiB7ZGF0ZSAmJiBkYXRlLmZvcm1hdCgnTCcpfVxuICAgICAgPC9wPlxuICAgICAge2RheS5leGNlcnB0ICYmIDxwIGNsYXNzTmFtZT17Y24oc3R5bGVzLmV4Y2VycHQpfT57ZGF5LmV4Y2VycHR9PC9wPn1cbiAgICAgIHtkYXkuaW1hZ2UgJiYgKFxuICAgICAgICA8TGF6eUltYWdlIGltYWdlPXtkYXkuaW1hZ2V9IGNsYXNzTmFtZT17Y24oc3R5bGVzLmltYWdlKX0gLz5cbiAgICAgICl9XG4gICAgICB7ZGF5LmF1dGhvciAmJiAoXG4gICAgICAgIDxkaXYgY2xhc3NOYW1lPXtjbihzdHlsZXMubWV0YSl9PlxuICAgICAgICAgIDxDb250ZW50QXV0aG9yXG4gICAgICAgICAgICBhdXRob3I9e2RheS5hdXRob3J9XG4gICAgICAgICAgICBjbGFzc05hbWU9e2NuKHN0eWxlcy5hdXRob3IpfVxuICAgICAgICAgICAgc21hbGw9e3dpZHRoIDw9IDcwMH1cbiAgICAgICAgICAvPlxuICAgICAgICAgIHsnc2hhcmUnIGluIG5hdmlnYXRvciAmJiAoXG4gICAgICAgICAgICA8QnV0dG9uXG4gICAgICAgICAgICAgIGNsYXNzTmFtZT17YGNvbnRlbnQtc2hhcmUgJHtjbGFzc05hbWV9YH1cbiAgICAgICAgICAgICAgb25DbGljaz17KCkgPT5cbiAgICAgICAgICAgICAgICBuYXZpZ2F0b3Iuc2hhcmUoe1xuICAgICAgICAgICAgICAgICAgdXJsOiB3aW5kb3cubG9jYXRpb24uaHJlZixcbiAgICAgICAgICAgICAgICAgIHRleHQ6ICdIYXZlIGEgbG9vayBhdCB0aGUgYXdlc29tZSBhcnRpY2xlIG9uIFBXQWR2ZW50LmRldicsXG4gICAgICAgICAgICAgICAgICB0aXRsZTogYCR7ZGF5LnRpdGxlfSAtIFBXQWR2ZW50YCxcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGxheW91dD1cImdob3N0XCJcbiAgICAgICAgICAgICAgcm91bmRcbiAgICAgICAgICAgICAgaWNvbj1cIm1kaS9zaGFyZVwiXG4gICAgICAgICAgICAgIGljb25SaWdodFxuICAgICAgICAgICAgICBzaXplPXt3aWR0aCA8PSA3MDAgPyAnc21hbGwnIDogJ21lZGl1bSd9XG4gICAgICAgICAgICA+XG4gICAgICAgICAgICAgIFNoYXJlXG4gICAgICAgICAgICA8L0J1dHRvbj5cbiAgICAgICAgICApfVxuICAgICAgICA8L2Rpdj5cbiAgICAgICl9XG4gICAgICA8ZGl2XG4gICAgICAgIHJlZj17Y29udGVudFJlZn1cbiAgICAgICAgY2xhc3NOYW1lPVwiZ3V0ZW5iZXJnLWNvbnRlbnRcIlxuICAgICAgICBkYW5nZXJvdXNseVNldElubmVySFRNTD17e1xuICAgICAgICAgIF9faHRtbDogY29udGVudCxcbiAgICAgICAgfX1cbiAgICAgIC8+XG4gICAgICB7b3JpZ2luYWxTb3VyY2UgJiYgKFxuICAgICAgICA8Tm90aWZpY2F0aW9uIGNsYXNzTmFtZT17Y24oc3R5bGVzLmNhbm5vbmljYWwpfT5cbiAgICAgICAgICBUaGlzIGFydGljbGUgd2FzIG9yaWdpbmFsbHkgcHVibGlzaGVkIG9ueycgJ31cbiAgICAgICAgICA8YSBocmVmPXtvcmlnaW5hbFNvdXJjZS5ocmVmfSB0YXJnZXQ9XCJfYmxhbmtcIj5cbiAgICAgICAgICAgIHtvcmlnaW5hbFNvdXJjZS5ob3N0fVxuICAgICAgICAgIDwvYT5cbiAgICAgICAgPC9Ob3RpZmljYXRpb24+XG4gICAgICApfVxuICAgIDwvZGl2PlxuICApO1xufTtcblxuZXhwb3J0IGRlZmF1bHQgQ29udGVudENhbGVuZGFyO1xuIiwiaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IHVzZVN0b3JlU3RhdGUsIHVzZUFjdGlvbnMgfSBmcm9tICd1bmlzdG9yZS1ob29rcyc7XG5pbXBvcnQgeyBDb250ZW50TW9kYWwgfSBmcm9tICdAdGhlbWUnO1xuaW1wb3J0IHsgYWN0aW9ucyB9IGZyb20gJ0BzdG9yZS9pbmRleCc7XG5pbXBvcnQgeyBTdGF0ZSB9IGZyb20gJ0BzdG9yZS90eXBlcyc7XG5pbXBvcnQgeyBQYWdlIH0gZnJvbSAnQGFwcC90eXBlcyc7XG5pbXBvcnQgY24gZnJvbSAnQHV0aWxzL2NsYXNzbmFtZXMnO1xuaW1wb3J0IHN0eWxlcyBmcm9tICcuL0NvbnRlbnQubW9kdWxlLmNzcyc7XG5cbmNvbnN0IENvbnRlbnRQYWdlID0gKHtcbiAgY2xhc3NOYW1lID0gJycsXG4gIG9uQ2xvc2UsXG4gIHNsdWcsXG59OiB7XG4gIGNsYXNzTmFtZT86IHN0cmluZztcbiAgb25DbG9zZTogRnVuY3Rpb247XG4gIHNsdWc6IHN0cmluZztcbn0pID0+IHtcbiAgY29uc3QgeyBsb2FkUGFnZSB9ID0gdXNlQWN0aW9ucyhhY3Rpb25zKTtcbiAgY29uc3QgeyBwYWdlIH0gPSB1c2VTdG9yZVN0YXRlPFN0YXRlPihbJ3BhZ2UnXSk7XG5cbiAgUmVhY3QudXNlRWZmZWN0KCgpID0+IHtcbiAgICBsb2FkUGFnZShzbHVnKTtcbiAgfSwgW3NsdWddKTtcblxuICByZXR1cm4gKFxuICAgIDxDb250ZW50TW9kYWxcbiAgICAgIGNsYXNzTmFtZT17Y24oY2xhc3NOYW1lLCAnY29udGVudC1wYWdlJyl9XG4gICAgICBvbkNsb3NlPXtvbkNsb3NlfVxuICAgICAgdGl0bGU9e3BhZ2UuZGF0YS50aXRsZX1cbiAgICAgIGxvYWRpbmc9e3BhZ2UubG9hZGluZ31cbiAgICA+XG4gICAgICA8ZGl2XG4gICAgICAgIGNsYXNzTmFtZT1cImd1dGVuYmVyZy1jb250ZW50XCJcbiAgICAgICAgZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUw9e3sgX19odG1sOiBwYWdlLmRhdGEuY29udGVudCB9fVxuICAgICAgLz5cbiAgICA8L0NvbnRlbnRNb2RhbD5cbiAgKTtcbn07XG5cbmV4cG9ydCBkZWZhdWx0IENvbnRlbnRQYWdlO1xuIiwiaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0JztcblxuY29uc3QgdXNlV2luZG93U2l6ZSA9ICgpOiB7IHdpZHRoOiBudW1iZXI7IGhlaWdodDogbnVtYmVyIH0gPT4ge1xuICBjb25zdCBbd2luZG93U2l6ZSwgc2V0V2luZG93U2l6ZV0gPSBSZWFjdC51c2VTdGF0ZSh7XG4gICAgd2lkdGg6IG51bGwsXG4gICAgaGVpZ2h0OiBudWxsLFxuICB9KTtcblxuICBSZWFjdC51c2VFZmZlY3QoKCkgPT4ge1xuICAgIGNvbnN0IGhhbmRsZVJlc2l6ZSA9ICgpID0+XG4gICAgICBzZXRXaW5kb3dTaXplKHtcbiAgICAgICAgd2lkdGg6IHdpbmRvdy5pbm5lcldpZHRoLFxuICAgICAgICBoZWlnaHQ6IHdpbmRvdy5pbm5lckhlaWdodCxcbiAgICAgIH0pO1xuXG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIGhhbmRsZVJlc2l6ZSk7XG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ29yaWVudGF0aW9uY2hhbmdlJywgaGFuZGxlUmVzaXplKTtcbiAgICB3aW5kb3cuc2V0VGltZW91dCgoKSA9PiBoYW5kbGVSZXNpemUoKSwgMTAwMCk7XG4gICAgaGFuZGxlUmVzaXplKCk7XG5cbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIGhhbmRsZVJlc2l6ZSk7XG4gICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcignb3JpZW50YXRpb25jaGFuZ2UnLCBoYW5kbGVSZXNpemUpO1xuICAgIH07XG4gIH0sIFtdKTtcblxuICByZXR1cm4gd2luZG93U2l6ZTtcbn07XG5cbmV4cG9ydCBkZWZhdWx0IHVzZVdpbmRvd1NpemU7XG4iLCJmdW5jdGlvbiBfYXJyYXlMaWtlVG9BcnJheShhcnIsIGxlbikge1xuICBpZiAobGVuID09IG51bGwgfHwgbGVuID4gYXJyLmxlbmd0aCkgbGVuID0gYXJyLmxlbmd0aDtcblxuICBmb3IgKHZhciBpID0gMCwgYXJyMiA9IG5ldyBBcnJheShsZW4pOyBpIDwgbGVuOyBpKyspIHtcbiAgICBhcnIyW2ldID0gYXJyW2ldO1xuICB9XG5cbiAgcmV0dXJuIGFycjI7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gX2FycmF5TGlrZVRvQXJyYXk7IiwiZnVuY3Rpb24gX2FycmF5V2l0aEhvbGVzKGFycikge1xuICBpZiAoQXJyYXkuaXNBcnJheShhcnIpKSByZXR1cm4gYXJyO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IF9hcnJheVdpdGhIb2xlczsiLCJ2YXIgYXJyYXlMaWtlVG9BcnJheSA9IHJlcXVpcmUoXCIuL2FycmF5TGlrZVRvQXJyYXlcIik7XG5cbmZ1bmN0aW9uIF9hcnJheVdpdGhvdXRIb2xlcyhhcnIpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkoYXJyKSkgcmV0dXJuIGFycmF5TGlrZVRvQXJyYXkoYXJyKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBfYXJyYXlXaXRob3V0SG9sZXM7IiwiZnVuY3Rpb24gX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKSB7XG4gIGlmIChzZWxmID09PSB2b2lkIDApIHtcbiAgICB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7XG4gIH1cblxuICByZXR1cm4gc2VsZjtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBfYXNzZXJ0VGhpc0luaXRpYWxpemVkOyIsImZ1bmN0aW9uIGFzeW5jR2VuZXJhdG9yU3RlcChnZW4sIHJlc29sdmUsIHJlamVjdCwgX25leHQsIF90aHJvdywga2V5LCBhcmcpIHtcbiAgdHJ5IHtcbiAgICB2YXIgaW5mbyA9IGdlbltrZXldKGFyZyk7XG4gICAgdmFyIHZhbHVlID0gaW5mby52YWx1ZTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICByZWplY3QoZXJyb3IpO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGlmIChpbmZvLmRvbmUpIHtcbiAgICByZXNvbHZlKHZhbHVlKTtcbiAgfSBlbHNlIHtcbiAgICBQcm9taXNlLnJlc29sdmUodmFsdWUpLnRoZW4oX25leHQsIF90aHJvdyk7XG4gIH1cbn1cblxuZnVuY3Rpb24gX2FzeW5jVG9HZW5lcmF0b3IoZm4pIHtcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXMsXG4gICAgICAgIGFyZ3MgPSBhcmd1bWVudHM7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgIHZhciBnZW4gPSBmbi5hcHBseShzZWxmLCBhcmdzKTtcblxuICAgICAgZnVuY3Rpb24gX25leHQodmFsdWUpIHtcbiAgICAgICAgYXN5bmNHZW5lcmF0b3JTdGVwKGdlbiwgcmVzb2x2ZSwgcmVqZWN0LCBfbmV4dCwgX3Rocm93LCBcIm5leHRcIiwgdmFsdWUpO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBfdGhyb3coZXJyKSB7XG4gICAgICAgIGFzeW5jR2VuZXJhdG9yU3RlcChnZW4sIHJlc29sdmUsIHJlamVjdCwgX25leHQsIF90aHJvdywgXCJ0aHJvd1wiLCBlcnIpO1xuICAgICAgfVxuXG4gICAgICBfbmV4dCh1bmRlZmluZWQpO1xuICAgIH0pO1xuICB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IF9hc3luY1RvR2VuZXJhdG9yOyIsImZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHtcbiAgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gX2NsYXNzQ2FsbENoZWNrOyIsInZhciBzZXRQcm90b3R5cGVPZiA9IHJlcXVpcmUoXCIuL3NldFByb3RvdHlwZU9mXCIpO1xuXG52YXIgaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0ID0gcmVxdWlyZShcIi4vaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0XCIpO1xuXG5mdW5jdGlvbiBfY29uc3RydWN0KFBhcmVudCwgYXJncywgQ2xhc3MpIHtcbiAgaWYgKGlzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpKSB7XG4gICAgbW9kdWxlLmV4cG9ydHMgPSBfY29uc3RydWN0ID0gUmVmbGVjdC5jb25zdHJ1Y3Q7XG4gIH0gZWxzZSB7XG4gICAgbW9kdWxlLmV4cG9ydHMgPSBfY29uc3RydWN0ID0gZnVuY3Rpb24gX2NvbnN0cnVjdChQYXJlbnQsIGFyZ3MsIENsYXNzKSB7XG4gICAgICB2YXIgYSA9IFtudWxsXTtcbiAgICAgIGEucHVzaC5hcHBseShhLCBhcmdzKTtcbiAgICAgIHZhciBDb25zdHJ1Y3RvciA9IEZ1bmN0aW9uLmJpbmQuYXBwbHkoUGFyZW50LCBhKTtcbiAgICAgIHZhciBpbnN0YW5jZSA9IG5ldyBDb25zdHJ1Y3RvcigpO1xuICAgICAgaWYgKENsYXNzKSBzZXRQcm90b3R5cGVPZihpbnN0YW5jZSwgQ2xhc3MucHJvdG90eXBlKTtcbiAgICAgIHJldHVybiBpbnN0YW5jZTtcbiAgICB9O1xuICB9XG5cbiAgcmV0dXJuIF9jb25zdHJ1Y3QuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBfY29uc3RydWN0OyIsImZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07XG4gICAgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlO1xuICAgIGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTtcbiAgICBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBfY3JlYXRlQ2xhc3MoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7XG4gIGlmIChwcm90b1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpO1xuICBpZiAoc3RhdGljUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7XG4gIHJldHVybiBDb25zdHJ1Y3Rvcjtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBfY3JlYXRlQ2xhc3M7IiwiZnVuY3Rpb24gX2RlZmluZVByb3BlcnR5KG9iaiwga2V5LCB2YWx1ZSkge1xuICBpZiAoa2V5IGluIG9iaikge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwge1xuICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgIHdyaXRhYmxlOiB0cnVlXG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgb2JqW2tleV0gPSB2YWx1ZTtcbiAgfVxuXG4gIHJldHVybiBvYmo7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gX2RlZmluZVByb3BlcnR5OyIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIF9hcnJheUxpa2VUb0FycmF5KGFyciwgbGVuKSB7XG4gIGlmIChsZW4gPT0gbnVsbCB8fCBsZW4gPiBhcnIubGVuZ3RoKSBsZW4gPSBhcnIubGVuZ3RoO1xuXG4gIGZvciAodmFyIGkgPSAwLCBhcnIyID0gbmV3IEFycmF5KGxlbik7IGkgPCBsZW47IGkrKykge1xuICAgIGFycjJbaV0gPSBhcnJbaV07XG4gIH1cblxuICByZXR1cm4gYXJyMjtcbn0iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBfYXJyYXlXaXRoSG9sZXMoYXJyKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KGFycikpIHJldHVybiBhcnI7XG59IiwiaW1wb3J0IGFycmF5TGlrZVRvQXJyYXkgZnJvbSBcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL2FycmF5TGlrZVRvQXJyYXlcIjtcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIF9hcnJheVdpdGhvdXRIb2xlcyhhcnIpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkoYXJyKSkgcmV0dXJuIGFycmF5TGlrZVRvQXJyYXkoYXJyKTtcbn0iLCJmdW5jdGlvbiBhc3luY0dlbmVyYXRvclN0ZXAoZ2VuLCByZXNvbHZlLCByZWplY3QsIF9uZXh0LCBfdGhyb3csIGtleSwgYXJnKSB7XG4gIHRyeSB7XG4gICAgdmFyIGluZm8gPSBnZW5ba2V5XShhcmcpO1xuICAgIHZhciB2YWx1ZSA9IGluZm8udmFsdWU7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgcmVqZWN0KGVycm9yKTtcbiAgICByZXR1cm47XG4gIH1cblxuICBpZiAoaW5mby5kb25lKSB7XG4gICAgcmVzb2x2ZSh2YWx1ZSk7XG4gIH0gZWxzZSB7XG4gICAgUHJvbWlzZS5yZXNvbHZlKHZhbHVlKS50aGVuKF9uZXh0LCBfdGhyb3cpO1xuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIF9hc3luY1RvR2VuZXJhdG9yKGZuKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzLFxuICAgICAgICBhcmdzID0gYXJndW1lbnRzO1xuICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICB2YXIgZ2VuID0gZm4uYXBwbHkoc2VsZiwgYXJncyk7XG5cbiAgICAgIGZ1bmN0aW9uIF9uZXh0KHZhbHVlKSB7XG4gICAgICAgIGFzeW5jR2VuZXJhdG9yU3RlcChnZW4sIHJlc29sdmUsIHJlamVjdCwgX25leHQsIF90aHJvdywgXCJuZXh0XCIsIHZhbHVlKTtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gX3Rocm93KGVycikge1xuICAgICAgICBhc3luY0dlbmVyYXRvclN0ZXAoZ2VuLCByZXNvbHZlLCByZWplY3QsIF9uZXh0LCBfdGhyb3csIFwidGhyb3dcIiwgZXJyKTtcbiAgICAgIH1cblxuICAgICAgX25leHQodW5kZWZpbmVkKTtcbiAgICB9KTtcbiAgfTtcbn0iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBfZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHZhbHVlKSB7XG4gIGlmIChrZXkgaW4gb2JqKSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7XG4gICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgd3JpdGFibGU6IHRydWVcbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICBvYmpba2V5XSA9IHZhbHVlO1xuICB9XG5cbiAgcmV0dXJuIG9iajtcbn0iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBfZXh0ZW5kcygpIHtcbiAgX2V4dGVuZHMgPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uICh0YXJnZXQpIHtcbiAgICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTtcblxuICAgICAgZm9yICh2YXIga2V5IGluIHNvdXJjZSkge1xuICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkge1xuICAgICAgICAgIHRhcmdldFtrZXldID0gc291cmNlW2tleV07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdGFyZ2V0O1xuICB9O1xuXG4gIHJldHVybiBfZXh0ZW5kcy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufSIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIF9pdGVyYWJsZVRvQXJyYXkoaXRlcikge1xuICBpZiAodHlwZW9mIFN5bWJvbCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBTeW1ib2wuaXRlcmF0b3IgaW4gT2JqZWN0KGl0ZXIpKSByZXR1cm4gQXJyYXkuZnJvbShpdGVyKTtcbn0iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBfaXRlcmFibGVUb0FycmF5TGltaXQoYXJyLCBpKSB7XG4gIGlmICh0eXBlb2YgU3ltYm9sID09PSBcInVuZGVmaW5lZFwiIHx8ICEoU3ltYm9sLml0ZXJhdG9yIGluIE9iamVjdChhcnIpKSkgcmV0dXJuO1xuICB2YXIgX2FyciA9IFtdO1xuICB2YXIgX24gPSB0cnVlO1xuICB2YXIgX2QgPSBmYWxzZTtcbiAgdmFyIF9lID0gdW5kZWZpbmVkO1xuXG4gIHRyeSB7XG4gICAgZm9yICh2YXIgX2kgPSBhcnJbU3ltYm9sLml0ZXJhdG9yXSgpLCBfczsgIShfbiA9IChfcyA9IF9pLm5leHQoKSkuZG9uZSk7IF9uID0gdHJ1ZSkge1xuICAgICAgX2Fyci5wdXNoKF9zLnZhbHVlKTtcblxuICAgICAgaWYgKGkgJiYgX2Fyci5sZW5ndGggPT09IGkpIGJyZWFrO1xuICAgIH1cbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgX2QgPSB0cnVlO1xuICAgIF9lID0gZXJyO1xuICB9IGZpbmFsbHkge1xuICAgIHRyeSB7XG4gICAgICBpZiAoIV9uICYmIF9pW1wicmV0dXJuXCJdICE9IG51bGwpIF9pW1wicmV0dXJuXCJdKCk7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIGlmIChfZCkgdGhyb3cgX2U7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIF9hcnI7XG59IiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gX25vbkl0ZXJhYmxlUmVzdCgpIHtcbiAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXR0ZW1wdCB0byBkZXN0cnVjdHVyZSBub24taXRlcmFibGUgaW5zdGFuY2UuXFxuSW4gb3JkZXIgdG8gYmUgaXRlcmFibGUsIG5vbi1hcnJheSBvYmplY3RzIG11c3QgaGF2ZSBhIFtTeW1ib2wuaXRlcmF0b3JdKCkgbWV0aG9kLlwiKTtcbn0iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBfbm9uSXRlcmFibGVTcHJlYWQoKSB7XG4gIHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGF0dGVtcHQgdG8gc3ByZWFkIG5vbi1pdGVyYWJsZSBpbnN0YW5jZS5cXG5JbiBvcmRlciB0byBiZSBpdGVyYWJsZSwgbm9uLWFycmF5IG9iamVjdHMgbXVzdCBoYXZlIGEgW1N5bWJvbC5pdGVyYXRvcl0oKSBtZXRob2QuXCIpO1xufSIsImltcG9ydCBvYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlIGZyb20gXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlXCI7XG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMoc291cmNlLCBleGNsdWRlZCkge1xuICBpZiAoc291cmNlID09IG51bGwpIHJldHVybiB7fTtcbiAgdmFyIHRhcmdldCA9IG9iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2Uoc291cmNlLCBleGNsdWRlZCk7XG4gIHZhciBrZXksIGk7XG5cbiAgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHtcbiAgICB2YXIgc291cmNlU3ltYm9sS2V5cyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMoc291cmNlKTtcblxuICAgIGZvciAoaSA9IDA7IGkgPCBzb3VyY2VTeW1ib2xLZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBrZXkgPSBzb3VyY2VTeW1ib2xLZXlzW2ldO1xuICAgICAgaWYgKGV4Y2x1ZGVkLmluZGV4T2Yoa2V5KSA+PSAwKSBjb250aW51ZTtcbiAgICAgIGlmICghT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKHNvdXJjZSwga2V5KSkgY29udGludWU7XG4gICAgICB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0YXJnZXQ7XG59IiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2Uoc291cmNlLCBleGNsdWRlZCkge1xuICBpZiAoc291cmNlID09IG51bGwpIHJldHVybiB7fTtcbiAgdmFyIHRhcmdldCA9IHt9O1xuICB2YXIgc291cmNlS2V5cyA9IE9iamVjdC5rZXlzKHNvdXJjZSk7XG4gIHZhciBrZXksIGk7XG5cbiAgZm9yIChpID0gMDsgaSA8IHNvdXJjZUtleXMubGVuZ3RoOyBpKyspIHtcbiAgICBrZXkgPSBzb3VyY2VLZXlzW2ldO1xuICAgIGlmIChleGNsdWRlZC5pbmRleE9mKGtleSkgPj0gMCkgY29udGludWU7XG4gICAgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTtcbiAgfVxuXG4gIHJldHVybiB0YXJnZXQ7XG59IiwiaW1wb3J0IGFycmF5V2l0aEhvbGVzIGZyb20gXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9hcnJheVdpdGhIb2xlc1wiO1xuaW1wb3J0IGl0ZXJhYmxlVG9BcnJheUxpbWl0IGZyb20gXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9pdGVyYWJsZVRvQXJyYXlMaW1pdFwiO1xuaW1wb3J0IHVuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5IGZyb20gXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheVwiO1xuaW1wb3J0IG5vbkl0ZXJhYmxlUmVzdCBmcm9tIFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vbm9uSXRlcmFibGVSZXN0XCI7XG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBfc2xpY2VkVG9BcnJheShhcnIsIGkpIHtcbiAgcmV0dXJuIGFycmF5V2l0aEhvbGVzKGFycikgfHwgaXRlcmFibGVUb0FycmF5TGltaXQoYXJyLCBpKSB8fCB1bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShhcnIsIGkpIHx8IG5vbkl0ZXJhYmxlUmVzdCgpO1xufSIsImltcG9ydCBhcnJheVdpdGhvdXRIb2xlcyBmcm9tIFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vYXJyYXlXaXRob3V0SG9sZXNcIjtcbmltcG9ydCBpdGVyYWJsZVRvQXJyYXkgZnJvbSBcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL2l0ZXJhYmxlVG9BcnJheVwiO1xuaW1wb3J0IHVuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5IGZyb20gXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheVwiO1xuaW1wb3J0IG5vbkl0ZXJhYmxlU3ByZWFkIGZyb20gXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9ub25JdGVyYWJsZVNwcmVhZFwiO1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gX3RvQ29uc3VtYWJsZUFycmF5KGFycikge1xuICByZXR1cm4gYXJyYXlXaXRob3V0SG9sZXMoYXJyKSB8fCBpdGVyYWJsZVRvQXJyYXkoYXJyKSB8fCB1bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShhcnIpIHx8IG5vbkl0ZXJhYmxlU3ByZWFkKCk7XG59IiwiaW1wb3J0IGFycmF5TGlrZVRvQXJyYXkgZnJvbSBcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL2FycmF5TGlrZVRvQXJyYXlcIjtcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShvLCBtaW5MZW4pIHtcbiAgaWYgKCFvKSByZXR1cm47XG4gIGlmICh0eXBlb2YgbyA9PT0gXCJzdHJpbmdcIikgcmV0dXJuIGFycmF5TGlrZVRvQXJyYXkobywgbWluTGVuKTtcbiAgdmFyIG4gPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobykuc2xpY2UoOCwgLTEpO1xuICBpZiAobiA9PT0gXCJPYmplY3RcIiAmJiBvLmNvbnN0cnVjdG9yKSBuID0gby5jb25zdHJ1Y3Rvci5uYW1lO1xuICBpZiAobiA9PT0gXCJNYXBcIiB8fCBuID09PSBcIlNldFwiKSByZXR1cm4gQXJyYXkuZnJvbShvKTtcbiAgaWYgKG4gPT09IFwiQXJndW1lbnRzXCIgfHwgL14oPzpVaXxJKW50KD86OHwxNnwzMikoPzpDbGFtcGVkKT9BcnJheSQvLnRlc3QobikpIHJldHVybiBhcnJheUxpa2VUb0FycmF5KG8sIG1pbkxlbik7XG59IiwiZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mKG8pIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSBfZ2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3QuZ2V0UHJvdG90eXBlT2YgOiBmdW5jdGlvbiBfZ2V0UHJvdG90eXBlT2Yobykge1xuICAgIHJldHVybiBvLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2Yobyk7XG4gIH07XG4gIHJldHVybiBfZ2V0UHJvdG90eXBlT2Yobyk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gX2dldFByb3RvdHlwZU9mOyIsInZhciBzZXRQcm90b3R5cGVPZiA9IHJlcXVpcmUoXCIuL3NldFByb3RvdHlwZU9mXCIpO1xuXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHtcbiAgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvblwiKTtcbiAgfVxuXG4gIHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwge1xuICAgIGNvbnN0cnVjdG9yOiB7XG4gICAgICB2YWx1ZTogc3ViQ2xhc3MsXG4gICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH1cbiAgfSk7XG4gIGlmIChzdXBlckNsYXNzKSBzZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcyk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gX2luaGVyaXRzOyIsImZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7XG4gIHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7XG4gICAgXCJkZWZhdWx0XCI6IG9ialxuICB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQ7IiwidmFyIF90eXBlb2YgPSByZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy90eXBlb2ZcIik7XG5cbmZ1bmN0aW9uIF9nZXRSZXF1aXJlV2lsZGNhcmRDYWNoZSgpIHtcbiAgaWYgKHR5cGVvZiBXZWFrTWFwICE9PSBcImZ1bmN0aW9uXCIpIHJldHVybiBudWxsO1xuICB2YXIgY2FjaGUgPSBuZXcgV2Vha01hcCgpO1xuXG4gIF9nZXRSZXF1aXJlV2lsZGNhcmRDYWNoZSA9IGZ1bmN0aW9uIF9nZXRSZXF1aXJlV2lsZGNhcmRDYWNoZSgpIHtcbiAgICByZXR1cm4gY2FjaGU7XG4gIH07XG5cbiAgcmV0dXJuIGNhY2hlO1xufVxuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChvYmopIHtcbiAgaWYgKG9iaiAmJiBvYmouX19lc01vZHVsZSkge1xuICAgIHJldHVybiBvYmo7XG4gIH1cblxuICBpZiAob2JqID09PSBudWxsIHx8IF90eXBlb2Yob2JqKSAhPT0gXCJvYmplY3RcIiAmJiB0eXBlb2Ygb2JqICE9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICByZXR1cm4ge1xuICAgICAgXCJkZWZhdWx0XCI6IG9ialxuICAgIH07XG4gIH1cblxuICB2YXIgY2FjaGUgPSBfZ2V0UmVxdWlyZVdpbGRjYXJkQ2FjaGUoKTtcblxuICBpZiAoY2FjaGUgJiYgY2FjaGUuaGFzKG9iaikpIHtcbiAgICByZXR1cm4gY2FjaGUuZ2V0KG9iaik7XG4gIH1cblxuICB2YXIgbmV3T2JqID0ge307XG4gIHZhciBoYXNQcm9wZXJ0eURlc2NyaXB0b3IgPSBPYmplY3QuZGVmaW5lUHJvcGVydHkgJiYgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcjtcblxuICBmb3IgKHZhciBrZXkgaW4gb2JqKSB7XG4gICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGtleSkpIHtcbiAgICAgIHZhciBkZXNjID0gaGFzUHJvcGVydHlEZXNjcmlwdG9yID8gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmosIGtleSkgOiBudWxsO1xuXG4gICAgICBpZiAoZGVzYyAmJiAoZGVzYy5nZXQgfHwgZGVzYy5zZXQpKSB7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShuZXdPYmosIGtleSwgZGVzYyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBuZXdPYmpba2V5XSA9IG9ialtrZXldO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIG5ld09ialtcImRlZmF1bHRcIl0gPSBvYmo7XG5cbiAgaWYgKGNhY2hlKSB7XG4gICAgY2FjaGUuc2V0KG9iaiwgbmV3T2JqKTtcbiAgfVxuXG4gIHJldHVybiBuZXdPYmo7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQ7IiwiZnVuY3Rpb24gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpIHtcbiAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcInVuZGVmaW5lZFwiIHx8ICFSZWZsZWN0LmNvbnN0cnVjdCkgcmV0dXJuIGZhbHNlO1xuICBpZiAoUmVmbGVjdC5jb25zdHJ1Y3Quc2hhbSkgcmV0dXJuIGZhbHNlO1xuICBpZiAodHlwZW9mIFByb3h5ID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiB0cnVlO1xuXG4gIHRyeSB7XG4gICAgRGF0ZS5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChSZWZsZWN0LmNvbnN0cnVjdChEYXRlLCBbXSwgZnVuY3Rpb24gKCkge30pKTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3Q7IiwiZnVuY3Rpb24gX2l0ZXJhYmxlVG9BcnJheShpdGVyKSB7XG4gIGlmICh0eXBlb2YgU3ltYm9sICE9PSBcInVuZGVmaW5lZFwiICYmIFN5bWJvbC5pdGVyYXRvciBpbiBPYmplY3QoaXRlcikpIHJldHVybiBBcnJheS5mcm9tKGl0ZXIpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IF9pdGVyYWJsZVRvQXJyYXk7IiwiZnVuY3Rpb24gX2l0ZXJhYmxlVG9BcnJheUxpbWl0KGFyciwgaSkge1xuICBpZiAodHlwZW9mIFN5bWJvbCA9PT0gXCJ1bmRlZmluZWRcIiB8fCAhKFN5bWJvbC5pdGVyYXRvciBpbiBPYmplY3QoYXJyKSkpIHJldHVybjtcbiAgdmFyIF9hcnIgPSBbXTtcbiAgdmFyIF9uID0gdHJ1ZTtcbiAgdmFyIF9kID0gZmFsc2U7XG4gIHZhciBfZSA9IHVuZGVmaW5lZDtcblxuICB0cnkge1xuICAgIGZvciAodmFyIF9pID0gYXJyW1N5bWJvbC5pdGVyYXRvcl0oKSwgX3M7ICEoX24gPSAoX3MgPSBfaS5uZXh0KCkpLmRvbmUpOyBfbiA9IHRydWUpIHtcbiAgICAgIF9hcnIucHVzaChfcy52YWx1ZSk7XG5cbiAgICAgIGlmIChpICYmIF9hcnIubGVuZ3RoID09PSBpKSBicmVhaztcbiAgICB9XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIF9kID0gdHJ1ZTtcbiAgICBfZSA9IGVycjtcbiAgfSBmaW5hbGx5IHtcbiAgICB0cnkge1xuICAgICAgaWYgKCFfbiAmJiBfaVtcInJldHVyblwiXSAhPSBudWxsKSBfaVtcInJldHVyblwiXSgpO1xuICAgIH0gZmluYWxseSB7XG4gICAgICBpZiAoX2QpIHRocm93IF9lO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBfYXJyO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IF9pdGVyYWJsZVRvQXJyYXlMaW1pdDsiLCJmdW5jdGlvbiBfbm9uSXRlcmFibGVSZXN0KCkge1xuICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBhdHRlbXB0IHRvIGRlc3RydWN0dXJlIG5vbi1pdGVyYWJsZSBpbnN0YW5jZS5cXG5JbiBvcmRlciB0byBiZSBpdGVyYWJsZSwgbm9uLWFycmF5IG9iamVjdHMgbXVzdCBoYXZlIGEgW1N5bWJvbC5pdGVyYXRvcl0oKSBtZXRob2QuXCIpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IF9ub25JdGVyYWJsZVJlc3Q7IiwiZnVuY3Rpb24gX25vbkl0ZXJhYmxlU3ByZWFkKCkge1xuICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBhdHRlbXB0IHRvIHNwcmVhZCBub24taXRlcmFibGUgaW5zdGFuY2UuXFxuSW4gb3JkZXIgdG8gYmUgaXRlcmFibGUsIG5vbi1hcnJheSBvYmplY3RzIG11c3QgaGF2ZSBhIFtTeW1ib2wuaXRlcmF0b3JdKCkgbWV0aG9kLlwiKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBfbm9uSXRlcmFibGVTcHJlYWQ7IiwidmFyIF90eXBlb2YgPSByZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy90eXBlb2ZcIik7XG5cbnZhciBhc3NlcnRUaGlzSW5pdGlhbGl6ZWQgPSByZXF1aXJlKFwiLi9hc3NlcnRUaGlzSW5pdGlhbGl6ZWRcIik7XG5cbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHtcbiAgaWYgKGNhbGwgJiYgKF90eXBlb2YoY2FsbCkgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikpIHtcbiAgICByZXR1cm4gY2FsbDtcbiAgfVxuXG4gIHJldHVybiBhc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZik7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm47IiwiZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSBfc2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHwgZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHtcbiAgICBvLl9fcHJvdG9fXyA9IHA7XG4gICAgcmV0dXJuIG87XG4gIH07XG5cbiAgcmV0dXJuIF9zZXRQcm90b3R5cGVPZihvLCBwKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBfc2V0UHJvdG90eXBlT2Y7IiwidmFyIGFycmF5V2l0aEhvbGVzID0gcmVxdWlyZShcIi4vYXJyYXlXaXRoSG9sZXNcIik7XG5cbnZhciBpdGVyYWJsZVRvQXJyYXlMaW1pdCA9IHJlcXVpcmUoXCIuL2l0ZXJhYmxlVG9BcnJheUxpbWl0XCIpO1xuXG52YXIgdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkgPSByZXF1aXJlKFwiLi91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheVwiKTtcblxudmFyIG5vbkl0ZXJhYmxlUmVzdCA9IHJlcXVpcmUoXCIuL25vbkl0ZXJhYmxlUmVzdFwiKTtcblxuZnVuY3Rpb24gX3NsaWNlZFRvQXJyYXkoYXJyLCBpKSB7XG4gIHJldHVybiBhcnJheVdpdGhIb2xlcyhhcnIpIHx8IGl0ZXJhYmxlVG9BcnJheUxpbWl0KGFyciwgaSkgfHwgdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkoYXJyLCBpKSB8fCBub25JdGVyYWJsZVJlc3QoKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBfc2xpY2VkVG9BcnJheTsiLCJ2YXIgYXJyYXlXaXRob3V0SG9sZXMgPSByZXF1aXJlKFwiLi9hcnJheVdpdGhvdXRIb2xlc1wiKTtcblxudmFyIGl0ZXJhYmxlVG9BcnJheSA9IHJlcXVpcmUoXCIuL2l0ZXJhYmxlVG9BcnJheVwiKTtcblxudmFyIHVuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5ID0gcmVxdWlyZShcIi4vdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXlcIik7XG5cbnZhciBub25JdGVyYWJsZVNwcmVhZCA9IHJlcXVpcmUoXCIuL25vbkl0ZXJhYmxlU3ByZWFkXCIpO1xuXG5mdW5jdGlvbiBfdG9Db25zdW1hYmxlQXJyYXkoYXJyKSB7XG4gIHJldHVybiBhcnJheVdpdGhvdXRIb2xlcyhhcnIpIHx8IGl0ZXJhYmxlVG9BcnJheShhcnIpIHx8IHVuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KGFycikgfHwgbm9uSXRlcmFibGVTcHJlYWQoKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBfdG9Db25zdW1hYmxlQXJyYXk7IiwiZnVuY3Rpb24gX3R5cGVvZihvYmopIHtcbiAgXCJAYmFiZWwvaGVscGVycyAtIHR5cGVvZlwiO1xuXG4gIGlmICh0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIikge1xuICAgIG1vZHVsZS5leHBvcnRzID0gX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7XG4gICAgICByZXR1cm4gdHlwZW9mIG9iajtcbiAgICB9O1xuICB9IGVsc2Uge1xuICAgIG1vZHVsZS5leHBvcnRzID0gX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7XG4gICAgICByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajtcbiAgICB9O1xuICB9XG5cbiAgcmV0dXJuIF90eXBlb2Yob2JqKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBfdHlwZW9mOyIsInZhciBhcnJheUxpa2VUb0FycmF5ID0gcmVxdWlyZShcIi4vYXJyYXlMaWtlVG9BcnJheVwiKTtcblxuZnVuY3Rpb24gX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KG8sIG1pbkxlbikge1xuICBpZiAoIW8pIHJldHVybjtcbiAgaWYgKHR5cGVvZiBvID09PSBcInN0cmluZ1wiKSByZXR1cm4gYXJyYXlMaWtlVG9BcnJheShvLCBtaW5MZW4pO1xuICB2YXIgbiA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvKS5zbGljZSg4LCAtMSk7XG4gIGlmIChuID09PSBcIk9iamVjdFwiICYmIG8uY29uc3RydWN0b3IpIG4gPSBvLmNvbnN0cnVjdG9yLm5hbWU7XG4gIGlmIChuID09PSBcIk1hcFwiIHx8IG4gPT09IFwiU2V0XCIpIHJldHVybiBBcnJheS5mcm9tKG8pO1xuICBpZiAobiA9PT0gXCJBcmd1bWVudHNcIiB8fCAvXig/OlVpfEkpbnQoPzo4fDE2fDMyKSg/OkNsYW1wZWQpP0FycmF5JC8udGVzdChuKSkgcmV0dXJuIGFycmF5TGlrZVRvQXJyYXkobywgbWluTGVuKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXk7IiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwicmVnZW5lcmF0b3ItcnVudGltZVwiKTtcbiIsImltcG9ydCB7IHNpZ25hdHVyZXNGb3JUeXBlIH0gZnJvbSAnLi9ydW50aW1lL3NpZ25hdHVyZXNGb3JUeXBlJztcclxuXHJcbi8qKlxyXG4gKlxyXG4gKiBUaGlzIHBhcnQgaGFzIGJlZW4gdmVuZG9yZWQgZnJvbSBcInJlYWN0LXJlZnJlc2hcIlxyXG4gKiBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvYmxvYi9tYXN0ZXIvcGFja2FnZXMvcmVhY3QtcmVmcmVzaC9zcmMvUmVhY3RGcmVzaFJ1bnRpbWUuanMjTDgzXHJcbiAqL1xyXG5leHBvcnQgY29uc3QgY29tcHV0ZUtleSA9IHNpZ25hdHVyZSA9PiB7XHJcbiAgbGV0IGZ1bGxLZXkgPSBzaWduYXR1cmUua2V5O1xyXG4gIGxldCBob29rcztcclxuXHJcbiAgdHJ5IHtcclxuICAgIGhvb2tzID0gc2lnbmF0dXJlLmdldEN1c3RvbUhvb2tzKCk7XHJcbiAgfSBjYXRjaCAoZXJyKSB7XHJcbiAgICBzaWduYXR1cmUuZm9yY2VSZXNldCA9IHRydWU7XHJcbiAgICByZXR1cm4gZnVsbEtleTtcclxuICB9XHJcblxyXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgaG9va3MubGVuZ3RoOyBpKyspIHtcclxuICAgIGNvbnN0IGhvb2sgPSBob29rc1tpXTtcclxuICAgIGlmICh0eXBlb2YgaG9vayAhPT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICBzaWduYXR1cmUuZm9yY2VSZXNldCA9IHRydWU7XHJcbiAgICAgIHJldHVybiBmdWxsS2V5O1xyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IG5lc3RlZEhvb2tTaWduYXR1cmUgPSBzaWduYXR1cmVzRm9yVHlwZS5nZXQoaG9vayk7XHJcbiAgICBpZiAobmVzdGVkSG9va1NpZ25hdHVyZSA9PT0gdW5kZWZpbmVkKSBjb250aW51ZTtcclxuXHJcbiAgICBjb25zdCBuZXN0ZWRIb29rS2V5ID0gY29tcHV0ZUtleShuZXN0ZWRIb29rU2lnbmF0dXJlKTtcclxuICAgIGlmIChuZXN0ZWRIb29rU2lnbmF0dXJlLmZvcmNlUmVzZXQpIHNpZ25hdHVyZS5mb3JjZVJlc2V0ID0gdHJ1ZTtcclxuXHJcbiAgICBmdWxsS2V5ICs9ICdcXG4tLS1cXG4nICsgbmVzdGVkSG9va0tleTtcclxuICB9XHJcblxyXG4gIHJldHVybiBmdWxsS2V5O1xyXG59O1xyXG4iLCJleHBvcnQgY29uc3QgVk5PREVfQ09NUE9ORU5UID0gJ19fYyc7XHJcbmV4cG9ydCBjb25zdCBOQU1FU1BBQ0UgPSAnX19QUkVGUkVTSF9fJztcclxuZXhwb3J0IGNvbnN0IENPTVBPTkVOVF9IT09LUyA9ICdfX0gnO1xyXG5leHBvcnQgY29uc3QgSE9PS1NfTElTVCA9ICdfXyc7XHJcbmV4cG9ydCBjb25zdCBFRkZFQ1RTX0xJU1QgPSAnX19oJztcclxuZXhwb3J0IGNvbnN0IFJFUkVOREVSX0NPVU5UID0gJ19fcic7XHJcbmV4cG9ydCBjb25zdCBDQVRDSF9FUlJPUl9PUFRJT04gPSAnX19lJztcclxuZXhwb3J0IGNvbnN0IENPTVBPTkVOVF9ESVJUWSA9ICdfX2QnO1xyXG5leHBvcnQgY29uc3QgVk5PREVfRE9NID0gJ19fZSc7XHJcbmV4cG9ydCBjb25zdCBWTk9ERV9DSElMRFJFTiA9ICdfX2snO1xyXG5leHBvcnQgY29uc3QgSE9PS19WQUxVRSA9ICdfXyc7XHJcbmV4cG9ydCBjb25zdCBIT09LX0FSR1MgPSAnX19IJztcclxuZXhwb3J0IGNvbnN0IEhPT0tfQ0xFQU5VUCA9ICdfX2MnO1xyXG4iLCIvLyBPcHRpb25zIGZvciBQcmVhY3QuXHJcbmltcG9ydCAnLi9ydW50aW1lL2NhdGNoRXJyb3InO1xyXG5pbXBvcnQgJy4vcnVudGltZS9kZWJvdW5jZVJlbmRlcmluZyc7XHJcbmltcG9ydCAnLi9ydW50aW1lL3Zub2RlJztcclxuaW1wb3J0ICcuL3J1bnRpbWUvdW5tb3VudCc7XHJcblxyXG5pbXBvcnQgeyBDb21wb25lbnQgfSBmcm9tICdwcmVhY3QnO1xyXG5cclxuaW1wb3J0IHtcclxuICBWTk9ERV9DT01QT05FTlQsXHJcbiAgTkFNRVNQQUNFLFxyXG4gIEhPT0tTX0xJU1QsXHJcbiAgRUZGRUNUU19MSVNULFxyXG4gIENPTVBPTkVOVF9IT09LUyxcclxuICBWTk9ERV9ET00sXHJcbiAgVk5PREVfQ0hJTERSRU4sXHJcbiAgSE9PS19BUkdTLFxyXG4gIEhPT0tfVkFMVUUsXHJcbiAgSE9PS19DTEVBTlVQLFxyXG59IGZyb20gJy4vY29uc3RhbnRzJztcclxuaW1wb3J0IHsgY29tcHV0ZUtleSB9IGZyb20gJy4vY29tcHV0ZUtleSc7XHJcbmltcG9ydCB7IHZub2Rlc0ZvckNvbXBvbmVudCwgbWFwcGVkVk5vZGVzIH0gZnJvbSAnLi9ydW50aW1lL3Zub2Rlc0ZvckNvbXBvbmVudCc7XHJcbmltcG9ydCB7IHNpZ25hdHVyZXNGb3JUeXBlIH0gZnJvbSAnLi9ydW50aW1lL3NpZ25hdHVyZXNGb3JUeXBlJztcclxuXHJcbmxldCB0eXBlc0J5SWQgPSBuZXcgTWFwKCk7XHJcbmxldCBwZW5kaW5nVXBkYXRlcyA9IFtdO1xyXG5cclxuZnVuY3Rpb24gc2lnbih0eXBlLCBrZXksIGZvcmNlUmVzZXQsIGdldEN1c3RvbUhvb2tzLCBzdGF0dXMpIHtcclxuICBpZiAodHlwZSkge1xyXG4gICAgbGV0IHNpZ25hdHVyZSA9IHNpZ25hdHVyZXNGb3JUeXBlLmdldCh0eXBlKTtcclxuICAgIGlmIChzdGF0dXMgPT09ICdiZWdpbicpIHtcclxuICAgICAgc2lnbmF0dXJlc0ZvclR5cGUuc2V0KHR5cGUsIHtcclxuICAgICAgICB0eXBlLFxyXG4gICAgICAgIGtleSxcclxuICAgICAgICBmb3JjZVJlc2V0LFxyXG4gICAgICAgIGdldEN1c3RvbUhvb2tzOiBnZXRDdXN0b21Ib29rcyB8fCAoKCkgPT4gW10pLFxyXG4gICAgICB9KTtcclxuXHJcbiAgICAgIHJldHVybiAnbmVlZHNIb29rcyc7XHJcbiAgICB9IGVsc2UgaWYgKHN0YXR1cyA9PT0gJ25lZWRzSG9va3MnKSB7XHJcbiAgICAgIHNpZ25hdHVyZS5mdWxsS2V5ID0gY29tcHV0ZUtleShzaWduYXR1cmUpO1xyXG4gICAgfVxyXG4gIH1cclxufVxyXG5cclxuZnVuY3Rpb24gcmVwbGFjZUNvbXBvbmVudChPbGRUeXBlLCBOZXdUeXBlLCByZXNldEhvb2tTdGF0ZSkge1xyXG4gIGNvbnN0IHZub2RlcyA9IHZub2Rlc0ZvckNvbXBvbmVudC5nZXQoT2xkVHlwZSk7XHJcbiAgaWYgKCF2bm9kZXMpIHJldHVybjtcclxuXHJcbiAgLy8gbWlncmF0ZSB0aGUgbGlzdCB0byBvdXIgbmV3IGNvbnN0cnVjdG9yIHJlZmVyZW5jZVxyXG4gIHZub2Rlc0ZvckNvbXBvbmVudC5kZWxldGUoT2xkVHlwZSk7XHJcbiAgdm5vZGVzRm9yQ29tcG9uZW50LnNldChOZXdUeXBlLCB2bm9kZXMpO1xyXG5cclxuICBtYXBwZWRWTm9kZXMuc2V0KE9sZFR5cGUsIE5ld1R5cGUpO1xyXG5cclxuICBwZW5kaW5nVXBkYXRlcyA9IHBlbmRpbmdVcGRhdGVzLmZpbHRlcihwID0+IHBbMF0gIT09IE9sZFR5cGUpO1xyXG5cclxuICB2bm9kZXMuZm9yRWFjaCh2bm9kZSA9PiB7XHJcbiAgICAvLyB1cGRhdGUgdGhlIHR5cGUgaW4tcGxhY2UgdG8gcmVmZXJlbmNlIHRoZSBuZXcgY29tcG9uZW50XHJcbiAgICB2bm9kZS50eXBlID0gTmV3VHlwZTtcclxuXHJcbiAgICBpZiAodm5vZGVbVk5PREVfQ09NUE9ORU5UXSkge1xyXG4gICAgICB2bm9kZVtWTk9ERV9DT01QT05FTlRdLmNvbnN0cnVjdG9yID0gdm5vZGUudHlwZTtcclxuXHJcbiAgICAgIHRyeSB7XHJcbiAgICAgICAgaWYgKHZub2RlW1ZOT0RFX0NPTVBPTkVOVF0gaW5zdGFuY2VvZiBPbGRUeXBlKSB7XHJcbiAgICAgICAgICBjb25zdCBvbGRJbnN0ID0gdm5vZGVbVk5PREVfQ09NUE9ORU5UXTtcclxuXHJcbiAgICAgICAgICBjb25zdCBuZXdJbnN0ID0gbmV3IE5ld1R5cGUoXHJcbiAgICAgICAgICAgIHZub2RlW1ZOT0RFX0NPTVBPTkVOVF0ucHJvcHMsXHJcbiAgICAgICAgICAgIHZub2RlW1ZOT0RFX0NPTVBPTkVOVF0uY29udGV4dFxyXG4gICAgICAgICAgKTtcclxuXHJcbiAgICAgICAgICB2bm9kZVtWTk9ERV9DT01QT05FTlRdID0gbmV3SW5zdDtcclxuICAgICAgICAgIC8vIGNvcHkgb2xkIHByb3BlcnRpZXMgb250byB0aGUgbmV3IGluc3RhbmNlLlxyXG4gICAgICAgICAgLy8gICAtIE9iamVjdHMgKGluY2x1ZGluZyByZWZzKSBpbiB0aGUgbmV3IGluc3RhbmNlIGFyZSB1cGRhdGVkIHdpdGggdGhlaXIgb2xkIHZhbHVlc1xyXG4gICAgICAgICAgLy8gICAtIE1pc3Npbmcgb3IgbnVsbCBwcm9wZXJ0aWVzIGFyZSByZXN0b3JlZCB0byB0aGVpciBvbGQgdmFsdWVzXHJcbiAgICAgICAgICAvLyAgIC0gVXBkYXRlZCBGdW5jdGlvbnMgYXJlIG5vdCByZXZlcnRlZFxyXG4gICAgICAgICAgLy8gICAtIFNjYWxhcnMgYXJlIGNvcGllZFxyXG4gICAgICAgICAgZm9yIChsZXQgaSBpbiBvbGRJbnN0KSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHR5cGUgPSB0eXBlb2Ygb2xkSW5zdFtpXTtcclxuICAgICAgICAgICAgaWYgKCEoaSBpbiBuZXdJbnN0KSkge1xyXG4gICAgICAgICAgICAgIG5ld0luc3RbaV0gPSBvbGRJbnN0W2ldO1xyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKHR5cGUgIT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIG5ld0luc3RbaV0gPT09IHR5cGUpIHtcclxuICAgICAgICAgICAgICBpZiAoXHJcbiAgICAgICAgICAgICAgICB0eXBlID09PSAnb2JqZWN0JyAmJlxyXG4gICAgICAgICAgICAgICAgbmV3SW5zdFtpXSAhPSBudWxsICYmXHJcbiAgICAgICAgICAgICAgICBuZXdJbnN0W2ldLmNvbnN0cnVjdG9yID09PSBvbGRJbnN0W2ldLmNvbnN0cnVjdG9yXHJcbiAgICAgICAgICAgICAgKSB7XHJcbiAgICAgICAgICAgICAgICBPYmplY3QuYXNzaWduKG5ld0luc3RbaV0sIG9sZEluc3RbaV0pO1xyXG4gICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBuZXdJbnN0W2ldID0gb2xkSW5zdFtpXTtcclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgIH0gY2F0Y2ggKGUpIHtcclxuICAgICAgICAvKiBGdW5jdGlvbmFsIGNvbXBvbmVudCAqL1xyXG4gICAgICAgIHZub2RlW1ZOT0RFX0NPTVBPTkVOVF0uY29uc3RydWN0b3IgPSBOZXdUeXBlO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBpZiAocmVzZXRIb29rU3RhdGUpIHtcclxuICAgICAgICBpZiAoXHJcbiAgICAgICAgICB2bm9kZVtWTk9ERV9DT01QT05FTlRdW0NPTVBPTkVOVF9IT09LU10gJiZcclxuICAgICAgICAgIHZub2RlW1ZOT0RFX0NPTVBPTkVOVF1bQ09NUE9ORU5UX0hPT0tTXVtIT09LU19MSVNUXSAmJlxyXG4gICAgICAgICAgdm5vZGVbVk5PREVfQ09NUE9ORU5UXVtDT01QT05FTlRfSE9PS1NdW0hPT0tTX0xJU1RdLmxlbmd0aFxyXG4gICAgICAgICkge1xyXG4gICAgICAgICAgdm5vZGVbVk5PREVfQ09NUE9ORU5UXVtDT01QT05FTlRfSE9PS1NdW0hPT0tTX0xJU1RdLmZvckVhY2goXHJcbiAgICAgICAgICAgIHBvc3NpYmxlRWZmZWN0ID0+IHtcclxuICAgICAgICAgICAgICBpZiAoXHJcbiAgICAgICAgICAgICAgICBwb3NzaWJsZUVmZmVjdFtIT09LX0NMRUFOVVBdICYmXHJcbiAgICAgICAgICAgICAgICB0eXBlb2YgcG9zc2libGVFZmZlY3RbSE9PS19DTEVBTlVQXSA9PT0gJ2Z1bmN0aW9uJ1xyXG4gICAgICAgICAgICAgICkge1xyXG4gICAgICAgICAgICAgICAgcG9zc2libGVFZmZlY3RbSE9PS19DTEVBTlVQXSgpO1xyXG4gICAgICAgICAgICAgIH0gZWxzZSBpZiAoXHJcbiAgICAgICAgICAgICAgICBwb3NzaWJsZUVmZmVjdFtIT09LX0FSR1NdICYmXHJcbiAgICAgICAgICAgICAgICBwb3NzaWJsZUVmZmVjdFtIT09LX1ZBTFVFXSAmJlxyXG4gICAgICAgICAgICAgICAgT2JqZWN0LmtleXMocG9zc2libGVFZmZlY3QpLmxlbmd0aCA9PT0gM1xyXG4gICAgICAgICAgICAgICkge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgY2xlYW51cEtleSA9IE9iamVjdC5rZXlzKHBvc3NpYmxlRWZmZWN0KS5maW5kKFxyXG4gICAgICAgICAgICAgICAgICBrZXkgPT4ga2V5ICE9PSBIT09LX0FSR1MgJiYga2V5ICE9PSBIT09LX1ZBTFVFXHJcbiAgICAgICAgICAgICAgICApO1xyXG4gICAgICAgICAgICAgICAgaWYgKFxyXG4gICAgICAgICAgICAgICAgICBjbGVhbnVwS2V5ICYmXHJcbiAgICAgICAgICAgICAgICAgIHR5cGVvZiBwb3NzaWJsZUVmZmVjdFtjbGVhbnVwS2V5XSA9PSAnZnVuY3Rpb24nXHJcbiAgICAgICAgICAgICAgICApXHJcbiAgICAgICAgICAgICAgICAgIHBvc3NpYmxlRWZmZWN0W2NsZWFudXBLZXldKCk7XHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICApO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdm5vZGVbVk5PREVfQ09NUE9ORU5UXVtDT01QT05FTlRfSE9PS1NdID0ge1xyXG4gICAgICAgICAgW0hPT0tTX0xJU1RdOiBbXSxcclxuICAgICAgICAgIFtFRkZFQ1RTX0xJU1RdOiBbXSxcclxuICAgICAgICB9O1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIGlmIChcclxuICAgICAgICAgIHZub2RlW1ZOT0RFX0NPTVBPTkVOVF1bQ09NUE9ORU5UX0hPT0tTXSAmJlxyXG4gICAgICAgICAgdm5vZGVbVk5PREVfQ09NUE9ORU5UXVtDT01QT05FTlRfSE9PS1NdW0hPT0tTX0xJU1RdICYmXHJcbiAgICAgICAgICB2bm9kZVtWTk9ERV9DT01QT05FTlRdW0NPTVBPTkVOVF9IT09LU11bSE9PS1NfTElTVF0ubGVuZ3RoXHJcbiAgICAgICAgKSB7XHJcbiAgICAgICAgICB2bm9kZVtWTk9ERV9DT01QT05FTlRdW0NPTVBPTkVOVF9IT09LU11bSE9PS1NfTElTVF0uZm9yRWFjaChcclxuICAgICAgICAgICAgcG9zc2libGVFZmZlY3QgPT4ge1xyXG4gICAgICAgICAgICAgIGlmIChcclxuICAgICAgICAgICAgICAgIHBvc3NpYmxlRWZmZWN0W0hPT0tfQ0xFQU5VUF0gJiZcclxuICAgICAgICAgICAgICAgIHR5cGVvZiBwb3NzaWJsZUVmZmVjdFtIT09LX0NMRUFOVVBdID09PSAnZnVuY3Rpb24nXHJcbiAgICAgICAgICAgICAgKSB7XHJcbiAgICAgICAgICAgICAgICBwb3NzaWJsZUVmZmVjdFtIT09LX0NMRUFOVVBdKCk7XHJcbiAgICAgICAgICAgICAgfSBlbHNlIGlmIChcclxuICAgICAgICAgICAgICAgIHBvc3NpYmxlRWZmZWN0W0hPT0tfQVJHU10gJiZcclxuICAgICAgICAgICAgICAgIHBvc3NpYmxlRWZmZWN0W0hPT0tfVkFMVUVdICYmXHJcbiAgICAgICAgICAgICAgICBPYmplY3Qua2V5cyhwb3NzaWJsZUVmZmVjdCkubGVuZ3RoID09PSAzXHJcbiAgICAgICAgICAgICAgKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBjbGVhbnVwS2V5ID0gT2JqZWN0LmtleXMocG9zc2libGVFZmZlY3QpLmZpbmQoXHJcbiAgICAgICAgICAgICAgICAgIGtleSA9PiBrZXkgIT09IEhPT0tfQVJHUyAmJiBrZXkgIT09IEhPT0tfVkFMVUVcclxuICAgICAgICAgICAgICAgICk7XHJcbiAgICAgICAgICAgICAgICBpZiAoXHJcbiAgICAgICAgICAgICAgICAgIGNsZWFudXBLZXkgJiZcclxuICAgICAgICAgICAgICAgICAgdHlwZW9mIHBvc3NpYmxlRWZmZWN0W2NsZWFudXBLZXldID09ICdmdW5jdGlvbidcclxuICAgICAgICAgICAgICAgIClcclxuICAgICAgICAgICAgICAgICAgcG9zc2libGVFZmZlY3RbY2xlYW51cEtleV0oKTtcclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICk7XHJcblxyXG4gICAgICAgICAgdm5vZGVbVk5PREVfQ09NUE9ORU5UXVtDT01QT05FTlRfSE9PS1NdW0hPT0tTX0xJU1RdLmZvckVhY2goXHJcbiAgICAgICAgICAgIGhvb2sgPT4ge1xyXG4gICAgICAgICAgICAgIGlmIChcclxuICAgICAgICAgICAgICAgIGhvb2suX19IICYmXHJcbiAgICAgICAgICAgICAgICBBcnJheS5pc0FycmF5KGhvb2suX19IKVxyXG4gICAgICAgICAgICAgICkge1xyXG4gICAgICAgICAgICAgICAgaG9vay5fX0ggPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICApO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gQ2xlYW51cCB3aGVuIGFuIGFzeW5jIGNvbXBvbmVudCBoYXMgdGhyb3duLlxyXG4gICAgICBpZiAoXHJcbiAgICAgICAgKHZub2RlW1ZOT0RFX0RPTV0gJiYgIWRvY3VtZW50LmNvbnRhaW5zKHZub2RlW1ZOT0RFX0RPTV0pKSB8fFxyXG4gICAgICAgICghdm5vZGVbVk5PREVfRE9NXSAmJiAhdm5vZGVbVk5PREVfQ0hJTERSRU5dKVxyXG4gICAgICApIHtcclxuICAgICAgICBsb2NhdGlvbi5yZWxvYWQoKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgQ29tcG9uZW50LnByb3RvdHlwZS5mb3JjZVVwZGF0ZS5jYWxsKHZub2RlW1ZOT0RFX0NPTVBPTkVOVF0pO1xyXG4gICAgfVxyXG4gIH0pO1xyXG59XHJcblxyXG5zZWxmW05BTUVTUEFDRV0gPSB7XHJcbiAgZ2V0U2lnbmF0dXJlOiB0eXBlID0+IHNpZ25hdHVyZXNGb3JUeXBlLmdldCh0eXBlKSxcclxuICByZWdpc3RlcjogKHR5cGUsIGlkKSA9PiB7XHJcbiAgICBpZiAodHlwZW9mIHR5cGUgIT09ICdmdW5jdGlvbicpIHJldHVybjtcclxuXHJcbiAgICBpZiAodHlwZXNCeUlkLmhhcyhpZCkpIHtcclxuICAgICAgY29uc3QgZXhpc3RpbmcgPSB0eXBlc0J5SWQuZ2V0KGlkKTtcclxuICAgICAgaWYgKGV4aXN0aW5nICE9PSB0eXBlKSB7XHJcbiAgICAgICAgcGVuZGluZ1VwZGF0ZXMucHVzaChbZXhpc3RpbmcsIHR5cGVdKTtcclxuICAgICAgICB0eXBlc0J5SWQuc2V0KGlkLCB0eXBlKTtcclxuICAgICAgfVxyXG4gICAgfSBlbHNlIHtcclxuICAgICAgdHlwZXNCeUlkLnNldChpZCwgdHlwZSk7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKCFzaWduYXR1cmVzRm9yVHlwZS5oYXModHlwZSkpIHtcclxuICAgICAgc2lnbmF0dXJlc0ZvclR5cGUuc2V0KHR5cGUsIHtcclxuICAgICAgICBnZXRDdXN0b21Ib29rczogKCkgPT4gW10sXHJcbiAgICAgICAgdHlwZSxcclxuICAgICAgfSk7XHJcbiAgICB9XHJcbiAgfSxcclxuICBnZXRQZW5kaW5nVXBkYXRlczogKCkgPT4gcGVuZGluZ1VwZGF0ZXMsXHJcbiAgZmx1c2g6ICgpID0+IHtcclxuICAgIHBlbmRpbmdVcGRhdGVzID0gW107XHJcbiAgfSxcclxuICByZXBsYWNlQ29tcG9uZW50LFxyXG4gIHNpZ24sXHJcbiAgY29tcHV0ZUtleSxcclxufTtcclxuIiwiaW1wb3J0IHsgb3B0aW9ucyB9IGZyb20gJ3ByZWFjdCc7XHJcbmltcG9ydCB7XHJcbiAgQ0FUQ0hfRVJST1JfT1BUSU9OLFxyXG4gIENPTVBPTkVOVF9ESVJUWSxcclxuICBWTk9ERV9DT01QT05FTlQsXHJcbn0gZnJvbSAnLi4vY29uc3RhbnRzJztcclxuXHJcbmNvbnN0IG9sZENhdGNoRXJyb3IgPSBvcHRpb25zW0NBVENIX0VSUk9SX09QVElPTl07XHJcbm9wdGlvbnNbQ0FUQ0hfRVJST1JfT1BUSU9OXSA9IChlcnJvciwgdm5vZGUsIG9sZFZOb2RlKSA9PiB7XHJcbiAgaWYgKHZub2RlW1ZOT0RFX0NPTVBPTkVOVF0gJiYgdm5vZGVbVk5PREVfQ09NUE9ORU5UXVtDT01QT05FTlRfRElSVFldKSB7XHJcbiAgICB2bm9kZVtWTk9ERV9DT01QT05FTlRdW0NPTVBPTkVOVF9ESVJUWV0gPSBmYWxzZTtcclxuICB9XHJcblxyXG4gIGlmIChvbGRDYXRjaEVycm9yKSBvbGRDYXRjaEVycm9yKGVycm9yLCB2bm9kZSwgb2xkVk5vZGUpO1xyXG59O1xyXG4iLCJpbXBvcnQgeyBvcHRpb25zIH0gZnJvbSAncHJlYWN0JztcclxuXHJcbmltcG9ydCB7IFJFUkVOREVSX0NPVU5UIH0gZnJvbSAnLi4vY29uc3RhbnRzJztcclxuXHJcbmNvbnN0IGRlZmVyID1cclxuICB0eXBlb2YgUHJvbWlzZSA9PSAnZnVuY3Rpb24nXHJcbiAgICA/IFByb21pc2UucHJvdG90eXBlLnRoZW4uYmluZChQcm9taXNlLnJlc29sdmUoKSlcclxuICAgIDogc2V0VGltZW91dDtcclxuXHJcbm9wdGlvbnMuZGVib3VuY2VSZW5kZXJpbmcgPSBwcm9jZXNzID0+IHtcclxuICBkZWZlcigoKSA9PiB7XHJcbiAgICB0cnkge1xyXG4gICAgICBwcm9jZXNzKCk7XHJcbiAgICB9IGNhdGNoIChlKSB7XHJcbiAgICAgIHByb2Nlc3NbUkVSRU5ERVJfQ09VTlRdID0gMDtcclxuICAgICAgdGhyb3cgZTtcclxuICAgIH1cclxuICB9KTtcclxufTtcclxuIiwiLy8gU2lnbmF0dXJlcyBmb3IgZnVuY3Rpb25hbCBjb21wb25lbnRzIGFuZCBjdXN0b20gaG9va3MuXHJcbmV4cG9ydCBjb25zdCBzaWduYXR1cmVzRm9yVHlwZSA9IG5ldyBXZWFrTWFwKCk7XHJcbiIsImltcG9ydCB7IG9wdGlvbnMgfSBmcm9tICdwcmVhY3QnO1xuaW1wb3J0IHsgdm5vZGVzRm9yQ29tcG9uZW50IH0gZnJvbSAnLi92bm9kZXNGb3JDb21wb25lbnQnO1xuXG5jb25zdCBvbGRVbm1vdW50ID0gb3B0aW9ucy51bm1vdW50O1xub3B0aW9ucy51bm1vdW50ID0gdm5vZGUgPT4ge1xuICBjb25zdCB0eXBlID0gKHZub2RlIHx8IHt9KS50eXBlO1xuICBpZiAodHlwZW9mIHR5cGUgPT09ICdmdW5jdGlvbicgJiYgdm5vZGVzRm9yQ29tcG9uZW50Lmhhcyh0eXBlKSkge1xuICAgIGNvbnN0IHZub2RlcyA9IHZub2Rlc0ZvckNvbXBvbmVudC5nZXQodHlwZSk7XG4gICAgaWYgKHZub2Rlcykge1xuICAgICAgY29uc3QgaW5kZXggPSB2bm9kZXMuaW5kZXhPZih2bm9kZSk7XG4gICAgICBpZiAoaW5kZXggIT09IC0xKSB7XG4gICAgICAgIHZub2Rlcy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGlmIChvbGRVbm1vdW50KSBvbGRVbm1vdW50KHZub2RlKTtcbn07XG4iLCJpbXBvcnQgeyBvcHRpb25zIH0gZnJvbSAncHJlYWN0JztcbmltcG9ydCB7IHZub2Rlc0ZvckNvbXBvbmVudCwgbWFwcGVkVk5vZGVzIH0gZnJvbSAnLi92bm9kZXNGb3JDb21wb25lbnQnO1xuaW1wb3J0IHsgVk5PREVfQ09NUE9ORU5UIH0gZnJvbSAnLi4vY29uc3RhbnRzJztcblxuY29uc3QgZ2V0TWFwcGVkVm5vZGUgPSB0eXBlID0+IHtcbiAgaWYgKG1hcHBlZFZOb2Rlcy5oYXModHlwZSkpIHtcbiAgICByZXR1cm4gZ2V0TWFwcGVkVm5vZGUobWFwcGVkVk5vZGVzLmdldCh0eXBlKSk7XG4gIH1cblxuICByZXR1cm4gdHlwZTtcbn07XG5cbmNvbnN0IG9sZFZub2RlID0gb3B0aW9ucy52bm9kZTtcbm9wdGlvbnMudm5vZGUgPSB2bm9kZSA9PiB7XG4gIGlmICh2bm9kZSAmJiB0eXBlb2Ygdm5vZGUudHlwZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGNvbnN0IHZub2RlcyA9IHZub2Rlc0ZvckNvbXBvbmVudC5nZXQodm5vZGUudHlwZSk7XG4gICAgaWYgKCF2bm9kZXMpIHtcbiAgICAgIHZub2Rlc0ZvckNvbXBvbmVudC5zZXQodm5vZGUudHlwZSwgW3Zub2RlXSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZub2Rlcy5wdXNoKHZub2RlKTtcbiAgICB9XG5cbiAgICBjb25zdCBmb3VuZFR5cGUgPSBnZXRNYXBwZWRWbm9kZSh2bm9kZS50eXBlKTtcbiAgICB2bm9kZS50eXBlID0gZm91bmRUeXBlO1xuICAgIGlmICh2bm9kZVtWTk9ERV9DT01QT05FTlRdKSB7XG4gICAgICB2bm9kZVtWTk9ERV9DT01QT05FTlRdLmNvbnN0cnVjdG9yID0gZm91bmRUeXBlO1xuICAgIH1cbiAgfVxuXG4gIGlmIChvbGRWbm9kZSkgb2xkVm5vZGUodm5vZGUpO1xufTtcbiIsIi8vIGFsbCB2bm9kZXMgcmVmZXJlbmNpbmcgYSBnaXZlbiBjb25zdHJ1Y3RvclxyXG5leHBvcnQgY29uc3Qgdm5vZGVzRm9yQ29tcG9uZW50ID0gbmV3IFdlYWtNYXAoKTtcclxuZXhwb3J0IGNvbnN0IG1hcHBlZFZOb2RlcyA9IG5ldyBXZWFrTWFwKCk7XHJcbiIsImNvbnN0IGNvbXBhcmVTaWduYXR1cmVzID0gKHByZXYsIG5leHQpID0+IHtcclxuICBjb25zdCBwcmV2U2lnbmF0dXJlID0gc2VsZi5fX1BSRUZSRVNIX18uZ2V0U2lnbmF0dXJlKHByZXYpIHx8IHt9O1xyXG4gIGNvbnN0IG5leHRTaWduYXR1cmUgPSBzZWxmLl9fUFJFRlJFU0hfXy5nZXRTaWduYXR1cmUobmV4dCkgfHwge307XHJcblxyXG4gIGlmIChcclxuICAgIHByZXZTaWduYXR1cmUua2V5ICE9PSBuZXh0U2lnbmF0dXJlLmtleSB8fFxyXG4gICAgc2VsZi5fX1BSRUZSRVNIX18uY29tcHV0ZUtleShwcmV2U2lnbmF0dXJlKSAhPT1cclxuICAgICAgc2VsZi5fX1BSRUZSRVNIX18uY29tcHV0ZUtleShuZXh0U2lnbmF0dXJlKSB8fFxyXG4gICAgbmV4dFNpZ25hdHVyZS5mb3JjZVJlc2V0XHJcbiAgKSB7XHJcbiAgICBzZWxmLl9fUFJFRlJFU0hfXy5yZXBsYWNlQ29tcG9uZW50KHByZXYsIG5leHQsIHRydWUpO1xyXG4gIH0gZWxzZSB7XHJcbiAgICBzZWxmLl9fUFJFRlJFU0hfXy5yZXBsYWNlQ29tcG9uZW50KHByZXYsIG5leHQsIGZhbHNlKTtcclxuICB9XHJcbn07XHJcblxyXG5leHBvcnQgY29uc3QgZmx1c2ggPSAoKSA9PiB7XHJcbiAgY29uc3QgcGVuZGluZyA9IFsuLi5zZWxmLl9fUFJFRlJFU0hfXy5nZXRQZW5kaW5nVXBkYXRlcygpXTtcclxuICBzZWxmLl9fUFJFRlJFU0hfXy5mbHVzaCgpO1xyXG5cclxuICBpZiAocGVuZGluZy5sZW5ndGggPiAwKSB7XHJcbiAgICBwZW5kaW5nLmZvckVhY2goKFtwcmV2LCBuZXh0XSkgPT4ge1xyXG4gICAgICBjb21wYXJlU2lnbmF0dXJlcyhwcmV2LCBuZXh0KTtcclxuICAgIH0pO1xyXG4gIH1cclxufTtcclxuXHJcbmV4cG9ydCBjb25zdCBpc0NvbXBvbmVudCA9IGV4cG9ydFZhbHVlID0+IHtcclxuICBpZiAodHlwZW9mIGV4cG9ydFZhbHVlID09PSAnZnVuY3Rpb24nKSB7XHJcbiAgICBpZiAoXHJcbiAgICAgIGV4cG9ydFZhbHVlLnByb3RvdHlwZSAhPSBudWxsICYmXHJcbiAgICAgIGV4cG9ydFZhbHVlLnByb3RvdHlwZS5pc1JlYWN0Q29tcG9uZW50XHJcbiAgICApIHtcclxuICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9XHJcblxyXG4gICAgY29uc3QgbmFtZSA9IGV4cG9ydFZhbHVlLm5hbWUgfHwgZXhwb3J0VmFsdWUuZGlzcGxheU5hbWU7XHJcbiAgICByZXR1cm4gKFxyXG4gICAgICB0eXBlb2YgbmFtZSA9PT0gJ3N0cmluZycgJiYgbmFtZVswXSAmJiBuYW1lWzBdID09IG5hbWVbMF0udG9VcHBlckNhc2UoKVxyXG4gICAgKTtcclxuICB9XHJcbiAgcmV0dXJuIGZhbHNlO1xyXG59O1xyXG4iLCJjb25zdCB7IGlzQ29tcG9uZW50LCBmbHVzaCB9ID0gcmVxdWlyZSgnQHByZWZyZXNoL3V0aWxzJyk7XG5cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZVxuY29uc3QgZ2V0RXhwb3J0cyA9IG0gPT4gbS5leHBvcnRzIHx8IG0uX19wcm90b19fLmV4cG9ydHM7XG5cbmZ1bmN0aW9uIGlzU2FmZUV4cG9ydChrZXkpIHtcbiAgcmV0dXJuIChcbiAgICBrZXkgPT09ICdfX2VzTW9kdWxlJyB8fFxuICAgIGtleSA9PT0gJ19fTl9TU0cnIHx8XG4gICAga2V5ID09PSAnX19OX1NTUCcgfHxcbiAgICBrZXkgPT09ICdjb25maWcnXG4gICk7XG59XG5cbmZ1bmN0aW9uIHJlZ2lzdGVyRXhwb3J0cyhtb2R1bGVFeHBvcnRzLCBtb2R1bGVJZCkge1xuICBzZWxmWydfX1BSRUZSRVNIX18nXS5yZWdpc3Rlcihtb2R1bGVFeHBvcnRzLCBtb2R1bGVJZCArICcgJWV4cG9ydHMlJyk7XG4gIGlmIChtb2R1bGVFeHBvcnRzID09IG51bGwgfHwgdHlwZW9mIG1vZHVsZUV4cG9ydHMgIT09ICdvYmplY3QnKSByZXR1cm47XG5cbiAgZm9yIChjb25zdCBrZXkgaW4gbW9kdWxlRXhwb3J0cykge1xuICAgIGlmIChpc1NhZmVFeHBvcnQoa2V5KSkgY29udGludWU7XG4gICAgY29uc3QgZXhwb3J0VmFsdWUgPSBtb2R1bGVFeHBvcnRzW2tleV07XG4gICAgY29uc3QgdHlwZUlEID0gbW9kdWxlSWQgKyAnICVleHBvcnRzJSAnICsga2V5O1xuICAgIHNlbGZbJ19fUFJFRlJFU0hfXyddLnJlZ2lzdGVyKGV4cG9ydFZhbHVlLCB0eXBlSUQpO1xuICB9XG59XG5cbmNvbnN0IHNob3VsZEJpbmQgPSBtID0+IHtcbiAgbGV0IGlzQ2l0aXplbiA9IGZhbHNlO1xuICBjb25zdCBtb2R1bGVFeHBvcnRzID0gZ2V0RXhwb3J0cyhtKTtcblxuICBpZiAoaXNDb21wb25lbnQobW9kdWxlRXhwb3J0cykpIHtcbiAgICBpc0NpdGl6ZW4gPSB0cnVlO1xuICB9XG5cbiAgaWYgKFxuICAgIG1vZHVsZUV4cG9ydHMgPT09IHVuZGVmaW5lZCB8fFxuICAgIG1vZHVsZUV4cG9ydHMgPT09IG51bGwgfHxcbiAgICB0eXBlb2YgbW9kdWxlRXhwb3J0cyAhPT0gJ29iamVjdCdcbiAgKSB7XG4gICAgaXNDaXRpemVuID0gaXNDaXRpemVuIHx8IGZhbHNlO1xuICB9IGVsc2Uge1xuICAgIGZvciAoY29uc3Qga2V5IGluIG1vZHVsZUV4cG9ydHMpIHtcbiAgICAgIGlmIChrZXkgPT09ICdfX2VzTW9kdWxlJykgY29udGludWU7XG5cbiAgICAgIGNvbnN0IGV4cG9ydFZhbHVlID0gbW9kdWxlRXhwb3J0c1trZXldO1xuICAgICAgaWYgKGlzQ29tcG9uZW50KGV4cG9ydFZhbHVlKSkge1xuICAgICAgICBpc0NpdGl6ZW4gPSBpc0NpdGl6ZW4gfHwgdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gaXNDaXRpemVuO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBPYmplY3QuZnJlZXplKHtcbiAgZ2V0RXhwb3J0cyxcbiAgc2hvdWxkQmluZCxcbiAgZmx1c2gsXG4gIHJlZ2lzdGVyRXhwb3J0cyxcbn0pO1xuIiwiIWZ1bmN0aW9uKHQsZSl7XCJvYmplY3RcIj09dHlwZW9mIGV4cG9ydHMmJlwidW5kZWZpbmVkXCIhPXR5cGVvZiBtb2R1bGU/bW9kdWxlLmV4cG9ydHM9ZSgpOlwiZnVuY3Rpb25cIj09dHlwZW9mIGRlZmluZSYmZGVmaW5lLmFtZD9kZWZpbmUoZSk6dC5kYXlqcz1lKCl9KHRoaXMsZnVuY3Rpb24oKXtcInVzZSBzdHJpY3RcIjt2YXIgdD1cIm1pbGxpc2Vjb25kXCIsZT1cInNlY29uZFwiLG49XCJtaW51dGVcIixyPVwiaG91clwiLGk9XCJkYXlcIixzPVwid2Vla1wiLHU9XCJtb250aFwiLGE9XCJxdWFydGVyXCIsbz1cInllYXJcIixmPVwiZGF0ZVwiLGg9L14oXFxkezR9KVstL10/KFxcZHsxLDJ9KT9bLS9dPyhcXGR7MCwyfSlbXjAtOV0qKFxcZHsxLDJ9KT86PyhcXGR7MSwyfSk/Oj8oXFxkezEsMn0pPy4/KFxcZCspPyQvLGM9L1xcWyhbXlxcXV0rKV18WXsyLDR9fE17MSw0fXxEezEsMn18ZHsxLDR9fEh7MSwyfXxoezEsMn18YXxBfG17MSwyfXxzezEsMn18WnsxLDJ9fFNTUy9nLGQ9e25hbWU6XCJlblwiLHdlZWtkYXlzOlwiU3VuZGF5X01vbmRheV9UdWVzZGF5X1dlZG5lc2RheV9UaHVyc2RheV9GcmlkYXlfU2F0dXJkYXlcIi5zcGxpdChcIl9cIiksbW9udGhzOlwiSmFudWFyeV9GZWJydWFyeV9NYXJjaF9BcHJpbF9NYXlfSnVuZV9KdWx5X0F1Z3VzdF9TZXB0ZW1iZXJfT2N0b2Jlcl9Ob3ZlbWJlcl9EZWNlbWJlclwiLnNwbGl0KFwiX1wiKX0sJD1mdW5jdGlvbih0LGUsbil7dmFyIHI9U3RyaW5nKHQpO3JldHVybiFyfHxyLmxlbmd0aD49ZT90OlwiXCIrQXJyYXkoZSsxLXIubGVuZ3RoKS5qb2luKG4pK3R9LGw9e3M6JCx6OmZ1bmN0aW9uKHQpe3ZhciBlPS10LnV0Y09mZnNldCgpLG49TWF0aC5hYnMoZSkscj1NYXRoLmZsb29yKG4vNjApLGk9biU2MDtyZXR1cm4oZTw9MD9cIitcIjpcIi1cIikrJChyLDIsXCIwXCIpK1wiOlwiKyQoaSwyLFwiMFwiKX0sbTpmdW5jdGlvbiB0KGUsbil7aWYoZS5kYXRlKCk8bi5kYXRlKCkpcmV0dXJuLXQobixlKTt2YXIgcj0xMioobi55ZWFyKCktZS55ZWFyKCkpKyhuLm1vbnRoKCktZS5tb250aCgpKSxpPWUuY2xvbmUoKS5hZGQocix1KSxzPW4taTwwLGE9ZS5jbG9uZSgpLmFkZChyKyhzPy0xOjEpLHUpO3JldHVybisoLShyKyhuLWkpLyhzP2ktYTphLWkpKXx8MCl9LGE6ZnVuY3Rpb24odCl7cmV0dXJuIHQ8MD9NYXRoLmNlaWwodCl8fDA6TWF0aC5mbG9vcih0KX0scDpmdW5jdGlvbihoKXtyZXR1cm57TTp1LHk6byx3OnMsZDppLEQ6ZixoOnIsbTpuLHM6ZSxtczp0LFE6YX1baF18fFN0cmluZyhofHxcIlwiKS50b0xvd2VyQ2FzZSgpLnJlcGxhY2UoL3MkLyxcIlwiKX0sdTpmdW5jdGlvbih0KXtyZXR1cm4gdm9pZCAwPT09dH19LHk9XCJlblwiLE09e307TVt5XT1kO3ZhciBtPWZ1bmN0aW9uKHQpe3JldHVybiB0IGluc3RhbmNlb2YgU30sRD1mdW5jdGlvbih0LGUsbil7dmFyIHI7aWYoIXQpcmV0dXJuIHk7aWYoXCJzdHJpbmdcIj09dHlwZW9mIHQpTVt0XSYmKHI9dCksZSYmKE1bdF09ZSxyPXQpO2Vsc2V7dmFyIGk9dC5uYW1lO01baV09dCxyPWl9cmV0dXJuIW4mJnImJih5PXIpLHJ8fCFuJiZ5fSx2PWZ1bmN0aW9uKHQsZSl7aWYobSh0KSlyZXR1cm4gdC5jbG9uZSgpO3ZhciBuPVwib2JqZWN0XCI9PXR5cGVvZiBlP2U6e307cmV0dXJuIG4uZGF0ZT10LG4uYXJncz1hcmd1bWVudHMsbmV3IFMobil9LGc9bDtnLmw9RCxnLmk9bSxnLnc9ZnVuY3Rpb24odCxlKXtyZXR1cm4gdih0LHtsb2NhbGU6ZS4kTCx1dGM6ZS4kdSx4OmUuJHgsJG9mZnNldDplLiRvZmZzZXR9KX07dmFyIFM9ZnVuY3Rpb24oKXtmdW5jdGlvbiBkKHQpe3RoaXMuJEw9RCh0LmxvY2FsZSxudWxsLCEwKSx0aGlzLnBhcnNlKHQpfXZhciAkPWQucHJvdG90eXBlO3JldHVybiAkLnBhcnNlPWZ1bmN0aW9uKHQpe3RoaXMuJGQ9ZnVuY3Rpb24odCl7dmFyIGU9dC5kYXRlLG49dC51dGM7aWYobnVsbD09PWUpcmV0dXJuIG5ldyBEYXRlKE5hTik7aWYoZy51KGUpKXJldHVybiBuZXcgRGF0ZTtpZihlIGluc3RhbmNlb2YgRGF0ZSlyZXR1cm4gbmV3IERhdGUoZSk7aWYoXCJzdHJpbmdcIj09dHlwZW9mIGUmJiEvWiQvaS50ZXN0KGUpKXt2YXIgcj1lLm1hdGNoKGgpO2lmKHIpe3ZhciBpPXJbMl0tMXx8MCxzPShyWzddfHxcIjBcIikuc3Vic3RyaW5nKDAsMyk7cmV0dXJuIG4/bmV3IERhdGUoRGF0ZS5VVEMoclsxXSxpLHJbM118fDEscls0XXx8MCxyWzVdfHwwLHJbNl18fDAscykpOm5ldyBEYXRlKHJbMV0saSxyWzNdfHwxLHJbNF18fDAscls1XXx8MCxyWzZdfHwwLHMpfX1yZXR1cm4gbmV3IERhdGUoZSl9KHQpLHRoaXMuJHg9dC54fHx7fSx0aGlzLmluaXQoKX0sJC5pbml0PWZ1bmN0aW9uKCl7dmFyIHQ9dGhpcy4kZDt0aGlzLiR5PXQuZ2V0RnVsbFllYXIoKSx0aGlzLiRNPXQuZ2V0TW9udGgoKSx0aGlzLiREPXQuZ2V0RGF0ZSgpLHRoaXMuJFc9dC5nZXREYXkoKSx0aGlzLiRIPXQuZ2V0SG91cnMoKSx0aGlzLiRtPXQuZ2V0TWludXRlcygpLHRoaXMuJHM9dC5nZXRTZWNvbmRzKCksdGhpcy4kbXM9dC5nZXRNaWxsaXNlY29uZHMoKX0sJC4kdXRpbHM9ZnVuY3Rpb24oKXtyZXR1cm4gZ30sJC5pc1ZhbGlkPWZ1bmN0aW9uKCl7cmV0dXJuIShcIkludmFsaWQgRGF0ZVwiPT09dGhpcy4kZC50b1N0cmluZygpKX0sJC5pc1NhbWU9ZnVuY3Rpb24odCxlKXt2YXIgbj12KHQpO3JldHVybiB0aGlzLnN0YXJ0T2YoZSk8PW4mJm48PXRoaXMuZW5kT2YoZSl9LCQuaXNBZnRlcj1mdW5jdGlvbih0LGUpe3JldHVybiB2KHQpPHRoaXMuc3RhcnRPZihlKX0sJC5pc0JlZm9yZT1mdW5jdGlvbih0LGUpe3JldHVybiB0aGlzLmVuZE9mKGUpPHYodCl9LCQuJGc9ZnVuY3Rpb24odCxlLG4pe3JldHVybiBnLnUodCk/dGhpc1tlXTp0aGlzLnNldChuLHQpfSwkLnVuaXg9ZnVuY3Rpb24oKXtyZXR1cm4gTWF0aC5mbG9vcih0aGlzLnZhbHVlT2YoKS8xZTMpfSwkLnZhbHVlT2Y9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy4kZC5nZXRUaW1lKCl9LCQuc3RhcnRPZj1mdW5jdGlvbih0LGEpe3ZhciBoPXRoaXMsYz0hIWcudShhKXx8YSxkPWcucCh0KSwkPWZ1bmN0aW9uKHQsZSl7dmFyIG49Zy53KGguJHU/RGF0ZS5VVEMoaC4keSxlLHQpOm5ldyBEYXRlKGguJHksZSx0KSxoKTtyZXR1cm4gYz9uOm4uZW5kT2YoaSl9LGw9ZnVuY3Rpb24odCxlKXtyZXR1cm4gZy53KGgudG9EYXRlKClbdF0uYXBwbHkoaC50b0RhdGUoXCJzXCIpLChjP1swLDAsMCwwXTpbMjMsNTksNTksOTk5XSkuc2xpY2UoZSkpLGgpfSx5PXRoaXMuJFcsTT10aGlzLiRNLG09dGhpcy4kRCxEPVwic2V0XCIrKHRoaXMuJHU/XCJVVENcIjpcIlwiKTtzd2l0Y2goZCl7Y2FzZSBvOnJldHVybiBjPyQoMSwwKTokKDMxLDExKTtjYXNlIHU6cmV0dXJuIGM/JCgxLE0pOiQoMCxNKzEpO2Nhc2Ugczp2YXIgdj10aGlzLiRsb2NhbGUoKS53ZWVrU3RhcnR8fDAsUz0oeTx2P3krNzp5KS12O3JldHVybiAkKGM/bS1TOm0rKDYtUyksTSk7Y2FzZSBpOmNhc2UgZjpyZXR1cm4gbChEK1wiSG91cnNcIiwwKTtjYXNlIHI6cmV0dXJuIGwoRCtcIk1pbnV0ZXNcIiwxKTtjYXNlIG46cmV0dXJuIGwoRCtcIlNlY29uZHNcIiwyKTtjYXNlIGU6cmV0dXJuIGwoRCtcIk1pbGxpc2Vjb25kc1wiLDMpO2RlZmF1bHQ6cmV0dXJuIHRoaXMuY2xvbmUoKX19LCQuZW5kT2Y9ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMuc3RhcnRPZih0LCExKX0sJC4kc2V0PWZ1bmN0aW9uKHMsYSl7dmFyIGgsYz1nLnAocyksZD1cInNldFwiKyh0aGlzLiR1P1wiVVRDXCI6XCJcIiksJD0oaD17fSxoW2ldPWQrXCJEYXRlXCIsaFtmXT1kK1wiRGF0ZVwiLGhbdV09ZCtcIk1vbnRoXCIsaFtvXT1kK1wiRnVsbFllYXJcIixoW3JdPWQrXCJIb3Vyc1wiLGhbbl09ZCtcIk1pbnV0ZXNcIixoW2VdPWQrXCJTZWNvbmRzXCIsaFt0XT1kK1wiTWlsbGlzZWNvbmRzXCIsaClbY10sbD1jPT09aT90aGlzLiREKyhhLXRoaXMuJFcpOmE7aWYoYz09PXV8fGM9PT1vKXt2YXIgeT10aGlzLmNsb25lKCkuc2V0KGYsMSk7eS4kZFskXShsKSx5LmluaXQoKSx0aGlzLiRkPXkuc2V0KGYsTWF0aC5taW4odGhpcy4kRCx5LmRheXNJbk1vbnRoKCkpKS4kZH1lbHNlICQmJnRoaXMuJGRbJF0obCk7cmV0dXJuIHRoaXMuaW5pdCgpLHRoaXN9LCQuc2V0PWZ1bmN0aW9uKHQsZSl7cmV0dXJuIHRoaXMuY2xvbmUoKS4kc2V0KHQsZSl9LCQuZ2V0PWZ1bmN0aW9uKHQpe3JldHVybiB0aGlzW2cucCh0KV0oKX0sJC5hZGQ9ZnVuY3Rpb24odCxhKXt2YXIgZixoPXRoaXM7dD1OdW1iZXIodCk7dmFyIGM9Zy5wKGEpLGQ9ZnVuY3Rpb24oZSl7dmFyIG49dihoKTtyZXR1cm4gZy53KG4uZGF0ZShuLmRhdGUoKStNYXRoLnJvdW5kKGUqdCkpLGgpfTtpZihjPT09dSlyZXR1cm4gdGhpcy5zZXQodSx0aGlzLiRNK3QpO2lmKGM9PT1vKXJldHVybiB0aGlzLnNldChvLHRoaXMuJHkrdCk7aWYoYz09PWkpcmV0dXJuIGQoMSk7aWYoYz09PXMpcmV0dXJuIGQoNyk7dmFyICQ9KGY9e30sZltuXT02ZTQsZltyXT0zNmU1LGZbZV09MWUzLGYpW2NdfHwxLGw9dGhpcy4kZC5nZXRUaW1lKCkrdCokO3JldHVybiBnLncobCx0aGlzKX0sJC5zdWJ0cmFjdD1mdW5jdGlvbih0LGUpe3JldHVybiB0aGlzLmFkZCgtMSp0LGUpfSwkLmZvcm1hdD1mdW5jdGlvbih0KXt2YXIgZT10aGlzO2lmKCF0aGlzLmlzVmFsaWQoKSlyZXR1cm5cIkludmFsaWQgRGF0ZVwiO3ZhciBuPXR8fFwiWVlZWS1NTS1ERFRISDptbTpzc1pcIixyPWcueih0aGlzKSxpPXRoaXMuJGxvY2FsZSgpLHM9dGhpcy4kSCx1PXRoaXMuJG0sYT10aGlzLiRNLG89aS53ZWVrZGF5cyxmPWkubW9udGhzLGg9ZnVuY3Rpb24odCxyLGkscyl7cmV0dXJuIHQmJih0W3JdfHx0KGUsbikpfHxpW3JdLnN1YnN0cigwLHMpfSxkPWZ1bmN0aW9uKHQpe3JldHVybiBnLnMocyUxMnx8MTIsdCxcIjBcIil9LCQ9aS5tZXJpZGllbXx8ZnVuY3Rpb24odCxlLG4pe3ZhciByPXQ8MTI/XCJBTVwiOlwiUE1cIjtyZXR1cm4gbj9yLnRvTG93ZXJDYXNlKCk6cn0sbD17WVk6U3RyaW5nKHRoaXMuJHkpLnNsaWNlKC0yKSxZWVlZOnRoaXMuJHksTTphKzEsTU06Zy5zKGErMSwyLFwiMFwiKSxNTU06aChpLm1vbnRoc1Nob3J0LGEsZiwzKSxNTU1NOmgoZixhKSxEOnRoaXMuJEQsREQ6Zy5zKHRoaXMuJEQsMixcIjBcIiksZDpTdHJpbmcodGhpcy4kVyksZGQ6aChpLndlZWtkYXlzTWluLHRoaXMuJFcsbywyKSxkZGQ6aChpLndlZWtkYXlzU2hvcnQsdGhpcy4kVyxvLDMpLGRkZGQ6b1t0aGlzLiRXXSxIOlN0cmluZyhzKSxISDpnLnMocywyLFwiMFwiKSxoOmQoMSksaGg6ZCgyKSxhOiQocyx1LCEwKSxBOiQocyx1LCExKSxtOlN0cmluZyh1KSxtbTpnLnModSwyLFwiMFwiKSxzOlN0cmluZyh0aGlzLiRzKSxzczpnLnModGhpcy4kcywyLFwiMFwiKSxTU1M6Zy5zKHRoaXMuJG1zLDMsXCIwXCIpLFo6cn07cmV0dXJuIG4ucmVwbGFjZShjLGZ1bmN0aW9uKHQsZSl7cmV0dXJuIGV8fGxbdF18fHIucmVwbGFjZShcIjpcIixcIlwiKX0pfSwkLnV0Y09mZnNldD1mdW5jdGlvbigpe3JldHVybiAxNSotTWF0aC5yb3VuZCh0aGlzLiRkLmdldFRpbWV6b25lT2Zmc2V0KCkvMTUpfSwkLmRpZmY9ZnVuY3Rpb24odCxmLGgpe3ZhciBjLGQ9Zy5wKGYpLCQ9dih0KSxsPTZlNCooJC51dGNPZmZzZXQoKS10aGlzLnV0Y09mZnNldCgpKSx5PXRoaXMtJCxNPWcubSh0aGlzLCQpO3JldHVybiBNPShjPXt9LGNbb109TS8xMixjW3VdPU0sY1thXT1NLzMsY1tzXT0oeS1sKS82MDQ4ZTUsY1tpXT0oeS1sKS84NjRlNSxjW3JdPXkvMzZlNSxjW25dPXkvNmU0LGNbZV09eS8xZTMsYylbZF18fHksaD9NOmcuYShNKX0sJC5kYXlzSW5Nb250aD1mdW5jdGlvbigpe3JldHVybiB0aGlzLmVuZE9mKHUpLiREfSwkLiRsb2NhbGU9ZnVuY3Rpb24oKXtyZXR1cm4gTVt0aGlzLiRMXX0sJC5sb2NhbGU9ZnVuY3Rpb24odCxlKXtpZighdClyZXR1cm4gdGhpcy4kTDt2YXIgbj10aGlzLmNsb25lKCkscj1EKHQsZSwhMCk7cmV0dXJuIHImJihuLiRMPXIpLG59LCQuY2xvbmU9ZnVuY3Rpb24oKXtyZXR1cm4gZy53KHRoaXMuJGQsdGhpcyl9LCQudG9EYXRlPWZ1bmN0aW9uKCl7cmV0dXJuIG5ldyBEYXRlKHRoaXMudmFsdWVPZigpKX0sJC50b0pTT049ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5pc1ZhbGlkKCk/dGhpcy50b0lTT1N0cmluZygpOm51bGx9LCQudG9JU09TdHJpbmc9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy4kZC50b0lTT1N0cmluZygpfSwkLnRvU3RyaW5nPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuJGQudG9VVENTdHJpbmcoKX0sZH0oKSxwPVMucHJvdG90eXBlO3JldHVybiB2LnByb3RvdHlwZT1wLFtbXCIkbXNcIix0XSxbXCIkc1wiLGVdLFtcIiRtXCIsbl0sW1wiJEhcIixyXSxbXCIkV1wiLGldLFtcIiRNXCIsdV0sW1wiJHlcIixvXSxbXCIkRFwiLGZdXS5mb3JFYWNoKGZ1bmN0aW9uKHQpe3BbdFsxXV09ZnVuY3Rpb24oZSl7cmV0dXJuIHRoaXMuJGcoZSx0WzBdLHRbMV0pfX0pLHYuZXh0ZW5kPWZ1bmN0aW9uKHQsZSl7cmV0dXJuIHQoZSxTLHYpLHZ9LHYubG9jYWxlPUQsdi5pc0RheWpzPW0sdi51bml4PWZ1bmN0aW9uKHQpe3JldHVybiB2KDFlMyp0KX0sdi5lbj1NW3ldLHYuTHM9TSx2LnA9e30sdn0pO1xuIiwiIWZ1bmN0aW9uKGUsdCl7XCJvYmplY3RcIj09dHlwZW9mIGV4cG9ydHMmJlwidW5kZWZpbmVkXCIhPXR5cGVvZiBtb2R1bGU/bW9kdWxlLmV4cG9ydHM9dCgpOlwiZnVuY3Rpb25cIj09dHlwZW9mIGRlZmluZSYmZGVmaW5lLmFtZD9kZWZpbmUodCk6ZS5kYXlqc19wbHVnaW5fbG9jYWxpemVkRm9ybWF0PXQoKX0odGhpcyxmdW5jdGlvbigpe1widXNlIHN0cmljdFwiO3ZhciBlPXtMVFM6XCJoOm1tOnNzIEFcIixMVDpcImg6bW0gQVwiLEw6XCJNTS9ERC9ZWVlZXCIsTEw6XCJNTU1NIEQsIFlZWVlcIixMTEw6XCJNTU1NIEQsIFlZWVkgaDptbSBBXCIsTExMTDpcImRkZGQsIE1NTU0gRCwgWVlZWSBoOm1tIEFcIn07cmV0dXJuIGZ1bmN0aW9uKHQsbixvKXt2YXIgcj1uLnByb3RvdHlwZSxNPXIuZm9ybWF0O28uZW4uZm9ybWF0cz1lLHIuZm9ybWF0PWZ1bmN0aW9uKHQpe3ZvaWQgMD09PXQmJih0PVwiWVlZWS1NTS1ERFRISDptbTpzc1pcIik7dmFyIG49dGhpcy4kbG9jYWxlKCkuZm9ybWF0cyxvPWZ1bmN0aW9uKHQsbil7cmV0dXJuIHQucmVwbGFjZSgvKFxcW1teXFxdXStdKXwoTFRTP3xsezEsNH18THsxLDR9KS9nLGZ1bmN0aW9uKHQsbyxyKXt2YXIgTT1yJiZyLnRvVXBwZXJDYXNlKCk7cmV0dXJuIG98fG5bcl18fGVbcl18fG5bTV0ucmVwbGFjZSgvKFxcW1teXFxdXStdKXwoTU1NTXxNTXxERHxkZGRkKS9nLGZ1bmN0aW9uKGUsdCxuKXtyZXR1cm4gdHx8bi5zbGljZSgxKX0pfSl9KHQsdm9pZCAwPT09bj97fTpuKTtyZXR1cm4gTS5jYWxsKHRoaXMsbyl9fX0pO1xuIiwiIWZ1bmN0aW9uKHQsZSl7XCJvYmplY3RcIj09dHlwZW9mIGV4cG9ydHMmJlwidW5kZWZpbmVkXCIhPXR5cGVvZiBtb2R1bGU/bW9kdWxlLmV4cG9ydHM9ZSgpOlwiZnVuY3Rpb25cIj09dHlwZW9mIGRlZmluZSYmZGVmaW5lLmFtZD9kZWZpbmUoZSk6dC5kYXlqc19wbHVnaW5fdGltZXpvbmU9ZSgpfSh0aGlzLGZ1bmN0aW9uKCl7XCJ1c2Ugc3RyaWN0XCI7dmFyIHQ9e3llYXI6MCxtb250aDoxLGRheToyLGhvdXI6MyxtaW51dGU6NCxzZWNvbmQ6NX0sZT17fTtyZXR1cm4gZnVuY3Rpb24obixpLG8pe3ZhciByLHU9bygpLnV0Y09mZnNldCgpLGE9ZnVuY3Rpb24odCxuLGkpe3ZvaWQgMD09PWkmJihpPXt9KTt2YXIgbz1uZXcgRGF0ZSh0KTtyZXR1cm4gZnVuY3Rpb24odCxuKXt2b2lkIDA9PT1uJiYobj17fSk7dmFyIGk9bi50aW1lWm9uZU5hbWV8fFwic2hvcnRcIixvPXQrXCJ8XCIraSxyPWVbb107cmV0dXJuIHJ8fChyPW5ldyBJbnRsLkRhdGVUaW1lRm9ybWF0KFwiZW4tVVNcIix7aG91cjEyOiExLHRpbWVab25lOnQseWVhcjpcIm51bWVyaWNcIixtb250aDpcIjItZGlnaXRcIixkYXk6XCIyLWRpZ2l0XCIsaG91cjpcIjItZGlnaXRcIixtaW51dGU6XCIyLWRpZ2l0XCIsc2Vjb25kOlwiMi1kaWdpdFwiLHRpbWVab25lTmFtZTppfSksZVtvXT1yKSxyfShuLGkpLmZvcm1hdFRvUGFydHMobyl9LGY9ZnVuY3Rpb24oZSxuKXtmb3IodmFyIGk9YShlLG4pLHI9W10sdT0wO3U8aS5sZW5ndGg7dSs9MSl7dmFyIGY9aVt1XSxzPWYudHlwZSxtPWYudmFsdWUsYz10W3NdO2M+PTAmJihyW2NdPXBhcnNlSW50KG0sMTApKX12YXIgZD1yWzNdLHY9MjQ9PT1kPzA6ZCxoPXJbMF0rXCItXCIrclsxXStcIi1cIityWzJdK1wiIFwiK3YrXCI6XCIrcls0XStcIjpcIityWzVdK1wiOjAwMFwiLGw9K2U7cmV0dXJuKG8udXRjKGgpLnZhbHVlT2YoKS0obC09bCUxZTMpKS82ZTR9LHM9aS5wcm90b3R5cGU7cy50ej1mdW5jdGlvbih0LGUpe3ZvaWQgMD09PXQmJih0PXIpO3ZhciBuPXRoaXMudXRjT2Zmc2V0KCksaT10aGlzLnRvRGF0ZSgpLnRvTG9jYWxlU3RyaW5nKFwiZW4tVVNcIix7dGltZVpvbmU6dH0pLGE9TWF0aC5yb3VuZCgodGhpcy50b0RhdGUoKS1uZXcgRGF0ZShpKSkvMWUzLzYwKSxmPW8oaSkuJHNldChcIm1pbGxpc2Vjb25kXCIsdGhpcy4kbXMpLnV0Y09mZnNldCh1LWEsITApO2lmKGUpe3ZhciBzPWYudXRjT2Zmc2V0KCk7Zj1mLmFkZChuLXMsXCJtaW51dGVcIil9cmV0dXJuIGYuJHguJHRpbWV6b25lPXQsZn0scy5vZmZzZXROYW1lPWZ1bmN0aW9uKHQpe3ZhciBlPXRoaXMuJHguJHRpbWV6b25lfHxvLnR6Lmd1ZXNzKCksbj1hKHRoaXMudmFsdWVPZigpLGUse3RpbWVab25lTmFtZTp0fSkuZmluZChmdW5jdGlvbih0KXtyZXR1cm5cInRpbWV6b25lbmFtZVwiPT09dC50eXBlLnRvTG93ZXJDYXNlKCl9KTtyZXR1cm4gbiYmbi52YWx1ZX0sby50ej1mdW5jdGlvbih0LGUsbil7dmFyIGk9biYmZSx1PW58fGV8fHIsYT1mKCtvKCksdSk7aWYoXCJzdHJpbmdcIiE9dHlwZW9mIHQpcmV0dXJuIG8odCkudHoodSk7dmFyIHM9ZnVuY3Rpb24odCxlLG4pe3ZhciBpPXQtNjAqZSoxZTMsbz1mKGksbik7aWYoZT09PW8pcmV0dXJuW2ksZV07dmFyIHI9ZihpLT02MCooby1lKSoxZTMsbik7cmV0dXJuIG89PT1yP1tpLG9dOlt0LTYwKk1hdGgubWluKG8scikqMWUzLE1hdGgubWF4KG8scildfShvLnV0Yyh0LGkpLnZhbHVlT2YoKSxhLHUpLG09c1swXSxjPXNbMV0sZD1vKG0pLnV0Y09mZnNldChjKTtyZXR1cm4gZC4keC4kdGltZXpvbmU9dSxkfSxvLnR6Lmd1ZXNzPWZ1bmN0aW9uKCl7cmV0dXJuIEludGwuRGF0ZVRpbWVGb3JtYXQoKS5yZXNvbHZlZE9wdGlvbnMoKS50aW1lWm9uZX0sby50ei5zZXREZWZhdWx0PWZ1bmN0aW9uKHQpe3I9dH19fSk7XG4iLCIhZnVuY3Rpb24odCxpKXtcIm9iamVjdFwiPT10eXBlb2YgZXhwb3J0cyYmXCJ1bmRlZmluZWRcIiE9dHlwZW9mIG1vZHVsZT9tb2R1bGUuZXhwb3J0cz1pKCk6XCJmdW5jdGlvblwiPT10eXBlb2YgZGVmaW5lJiZkZWZpbmUuYW1kP2RlZmluZShpKTp0LmRheWpzX3BsdWdpbl91dGM9aSgpfSh0aGlzLGZ1bmN0aW9uKCl7XCJ1c2Ugc3RyaWN0XCI7cmV0dXJuIGZ1bmN0aW9uKHQsaSxlKXt2YXIgcz1pLnByb3RvdHlwZTtlLnV0Yz1mdW5jdGlvbih0KXtyZXR1cm4gbmV3IGkoe2RhdGU6dCx1dGM6ITAsYXJnczphcmd1bWVudHN9KX0scy51dGM9ZnVuY3Rpb24odCl7dmFyIGk9ZSh0aGlzLnRvRGF0ZSgpLHtsb2NhbGU6dGhpcy4kTCx1dGM6ITB9KTtyZXR1cm4gdD9pLmFkZCh0aGlzLnV0Y09mZnNldCgpLFwibWludXRlXCIpOml9LHMubG9jYWw9ZnVuY3Rpb24oKXtyZXR1cm4gZSh0aGlzLnRvRGF0ZSgpLHtsb2NhbGU6dGhpcy4kTCx1dGM6ITF9KX07dmFyIGY9cy5wYXJzZTtzLnBhcnNlPWZ1bmN0aW9uKHQpe3QudXRjJiYodGhpcy4kdT0hMCksdGhpcy4kdXRpbHMoKS51KHQuJG9mZnNldCl8fCh0aGlzLiRvZmZzZXQ9dC4kb2Zmc2V0KSxmLmNhbGwodGhpcyx0KX07dmFyIG49cy5pbml0O3MuaW5pdD1mdW5jdGlvbigpe2lmKHRoaXMuJHUpe3ZhciB0PXRoaXMuJGQ7dGhpcy4keT10LmdldFVUQ0Z1bGxZZWFyKCksdGhpcy4kTT10LmdldFVUQ01vbnRoKCksdGhpcy4kRD10LmdldFVUQ0RhdGUoKSx0aGlzLiRXPXQuZ2V0VVRDRGF5KCksdGhpcy4kSD10LmdldFVUQ0hvdXJzKCksdGhpcy4kbT10LmdldFVUQ01pbnV0ZXMoKSx0aGlzLiRzPXQuZ2V0VVRDU2Vjb25kcygpLHRoaXMuJG1zPXQuZ2V0VVRDTWlsbGlzZWNvbmRzKCl9ZWxzZSBuLmNhbGwodGhpcyl9O3ZhciB1PXMudXRjT2Zmc2V0O3MudXRjT2Zmc2V0PWZ1bmN0aW9uKHQsaSl7dmFyIGU9dGhpcy4kdXRpbHMoKS51O2lmKGUodCkpcmV0dXJuIHRoaXMuJHU/MDplKHRoaXMuJG9mZnNldCk/dS5jYWxsKHRoaXMpOnRoaXMuJG9mZnNldDt2YXIgcz1NYXRoLmFicyh0KTw9MTY/NjAqdDp0LGY9dGhpcztpZihpKXJldHVybiBmLiRvZmZzZXQ9cyxmLiR1PTA9PT10LGY7aWYoMCE9PXQpe3ZhciBuPXRoaXMuJHU/dGhpcy50b0RhdGUoKS5nZXRUaW1lem9uZU9mZnNldCgpOi0xKnRoaXMudXRjT2Zmc2V0KCk7KGY9dGhpcy5sb2NhbCgpLmFkZChzK24sXCJtaW51dGVcIikpLiRvZmZzZXQ9cyxmLiR4LiRsb2NhbE9mZnNldD1ufWVsc2UgZj10aGlzLnV0YygpO3JldHVybiBmfTt2YXIgbz1zLmZvcm1hdDtzLmZvcm1hdD1mdW5jdGlvbih0KXt2YXIgaT10fHwodGhpcy4kdT9cIllZWVktTU0tRERUSEg6bW06c3NbWl1cIjpcIlwiKTtyZXR1cm4gby5jYWxsKHRoaXMsaSl9LHMudmFsdWVPZj1mdW5jdGlvbigpe3ZhciB0PXRoaXMuJHV0aWxzKCkudSh0aGlzLiRvZmZzZXQpPzA6dGhpcy4kb2Zmc2V0Kyh0aGlzLiR4LiRsb2NhbE9mZnNldHx8KG5ldyBEYXRlKS5nZXRUaW1lem9uZU9mZnNldCgpKTtyZXR1cm4gdGhpcy4kZC52YWx1ZU9mKCktNmU0KnR9LHMuaXNVVEM9ZnVuY3Rpb24oKXtyZXR1cm4hIXRoaXMuJHV9LHMudG9JU09TdHJpbmc9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy50b0RhdGUoKS50b0lTT1N0cmluZygpfSxzLnRvU3RyaW5nPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMudG9EYXRlKCkudG9VVENTdHJpbmcoKX07dmFyIHI9cy50b0RhdGU7cy50b0RhdGU9ZnVuY3Rpb24odCl7cmV0dXJuXCJzXCI9PT10JiZ0aGlzLiRvZmZzZXQ/ZSh0aGlzLmZvcm1hdChcIllZWVktTU0tREQgSEg6bW06c3M6U1NTXCIpKS50b0RhdGUoKTpyLmNhbGwodGhpcyl9O3ZhciBhPXMuZGlmZjtzLmRpZmY9ZnVuY3Rpb24odCxpLHMpe2lmKHRoaXMuJHU9PT10LiR1KXJldHVybiBhLmNhbGwodGhpcyx0LGkscyk7dmFyIGY9dGhpcy5sb2NhbCgpLG49ZSh0KS5sb2NhbCgpO3JldHVybiBhLmNhbGwoZixuLGkscyl9fX0pO1xuIiwiaW1wb3J0IHsgdyBhcyB3cmFwLCByIGFzIHJlcGxhY2VUcmFwcyB9IGZyb20gJy4vd3JhcC1pZGItdmFsdWUuanMnO1xuZXhwb3J0IHsgdSBhcyB1bndyYXAsIHcgYXMgd3JhcCB9IGZyb20gJy4vd3JhcC1pZGItdmFsdWUuanMnO1xuXG4vKipcbiAqIE9wZW4gYSBkYXRhYmFzZS5cbiAqXG4gKiBAcGFyYW0gbmFtZSBOYW1lIG9mIHRoZSBkYXRhYmFzZS5cbiAqIEBwYXJhbSB2ZXJzaW9uIFNjaGVtYSB2ZXJzaW9uLlxuICogQHBhcmFtIGNhbGxiYWNrcyBBZGRpdGlvbmFsIGNhbGxiYWNrcy5cbiAqL1xuZnVuY3Rpb24gb3BlbkRCKG5hbWUsIHZlcnNpb24sIHsgYmxvY2tlZCwgdXBncmFkZSwgYmxvY2tpbmcsIHRlcm1pbmF0ZWQgfSA9IHt9KSB7XG4gICAgY29uc3QgcmVxdWVzdCA9IGluZGV4ZWREQi5vcGVuKG5hbWUsIHZlcnNpb24pO1xuICAgIGNvbnN0IG9wZW5Qcm9taXNlID0gd3JhcChyZXF1ZXN0KTtcbiAgICBpZiAodXBncmFkZSkge1xuICAgICAgICByZXF1ZXN0LmFkZEV2ZW50TGlzdGVuZXIoJ3VwZ3JhZGVuZWVkZWQnLCAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgIHVwZ3JhZGUod3JhcChyZXF1ZXN0LnJlc3VsdCksIGV2ZW50Lm9sZFZlcnNpb24sIGV2ZW50Lm5ld1ZlcnNpb24sIHdyYXAocmVxdWVzdC50cmFuc2FjdGlvbikpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgaWYgKGJsb2NrZWQpXG4gICAgICAgIHJlcXVlc3QuYWRkRXZlbnRMaXN0ZW5lcignYmxvY2tlZCcsICgpID0+IGJsb2NrZWQoKSk7XG4gICAgb3BlblByb21pc2VcbiAgICAgICAgLnRoZW4oKGRiKSA9PiB7XG4gICAgICAgIGlmICh0ZXJtaW5hdGVkKVxuICAgICAgICAgICAgZGIuYWRkRXZlbnRMaXN0ZW5lcignY2xvc2UnLCAoKSA9PiB0ZXJtaW5hdGVkKCkpO1xuICAgICAgICBpZiAoYmxvY2tpbmcpXG4gICAgICAgICAgICBkYi5hZGRFdmVudExpc3RlbmVyKCd2ZXJzaW9uY2hhbmdlJywgKCkgPT4gYmxvY2tpbmcoKSk7XG4gICAgfSlcbiAgICAgICAgLmNhdGNoKCgpID0+IHsgfSk7XG4gICAgcmV0dXJuIG9wZW5Qcm9taXNlO1xufVxuLyoqXG4gKiBEZWxldGUgYSBkYXRhYmFzZS5cbiAqXG4gKiBAcGFyYW0gbmFtZSBOYW1lIG9mIHRoZSBkYXRhYmFzZS5cbiAqL1xuZnVuY3Rpb24gZGVsZXRlREIobmFtZSwgeyBibG9ja2VkIH0gPSB7fSkge1xuICAgIGNvbnN0IHJlcXVlc3QgPSBpbmRleGVkREIuZGVsZXRlRGF0YWJhc2UobmFtZSk7XG4gICAgaWYgKGJsb2NrZWQpXG4gICAgICAgIHJlcXVlc3QuYWRkRXZlbnRMaXN0ZW5lcignYmxvY2tlZCcsICgpID0+IGJsb2NrZWQoKSk7XG4gICAgcmV0dXJuIHdyYXAocmVxdWVzdCkudGhlbigoKSA9PiB1bmRlZmluZWQpO1xufVxuXG5jb25zdCByZWFkTWV0aG9kcyA9IFsnZ2V0JywgJ2dldEtleScsICdnZXRBbGwnLCAnZ2V0QWxsS2V5cycsICdjb3VudCddO1xuY29uc3Qgd3JpdGVNZXRob2RzID0gWydwdXQnLCAnYWRkJywgJ2RlbGV0ZScsICdjbGVhciddO1xuY29uc3QgY2FjaGVkTWV0aG9kcyA9IG5ldyBNYXAoKTtcbmZ1bmN0aW9uIGdldE1ldGhvZCh0YXJnZXQsIHByb3ApIHtcbiAgICBpZiAoISh0YXJnZXQgaW5zdGFuY2VvZiBJREJEYXRhYmFzZSAmJlxuICAgICAgICAhKHByb3AgaW4gdGFyZ2V0KSAmJlxuICAgICAgICB0eXBlb2YgcHJvcCA9PT0gJ3N0cmluZycpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKGNhY2hlZE1ldGhvZHMuZ2V0KHByb3ApKVxuICAgICAgICByZXR1cm4gY2FjaGVkTWV0aG9kcy5nZXQocHJvcCk7XG4gICAgY29uc3QgdGFyZ2V0RnVuY05hbWUgPSBwcm9wLnJlcGxhY2UoL0Zyb21JbmRleCQvLCAnJyk7XG4gICAgY29uc3QgdXNlSW5kZXggPSBwcm9wICE9PSB0YXJnZXRGdW5jTmFtZTtcbiAgICBjb25zdCBpc1dyaXRlID0gd3JpdGVNZXRob2RzLmluY2x1ZGVzKHRhcmdldEZ1bmNOYW1lKTtcbiAgICBpZiAoXG4gICAgLy8gQmFpbCBpZiB0aGUgdGFyZ2V0IGRvZXNuJ3QgZXhpc3Qgb24gdGhlIHRhcmdldC4gRWcsIGdldEFsbCBpc24ndCBpbiBFZGdlLlxuICAgICEodGFyZ2V0RnVuY05hbWUgaW4gKHVzZUluZGV4ID8gSURCSW5kZXggOiBJREJPYmplY3RTdG9yZSkucHJvdG90eXBlKSB8fFxuICAgICAgICAhKGlzV3JpdGUgfHwgcmVhZE1ldGhvZHMuaW5jbHVkZXModGFyZ2V0RnVuY05hbWUpKSkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IG1ldGhvZCA9IGFzeW5jIGZ1bmN0aW9uIChzdG9yZU5hbWUsIC4uLmFyZ3MpIHtcbiAgICAgICAgLy8gaXNXcml0ZSA/ICdyZWFkd3JpdGUnIDogdW5kZWZpbmVkIGd6aXBwcyBiZXR0ZXIsIGJ1dCBmYWlscyBpbiBFZGdlIDooXG4gICAgICAgIGNvbnN0IHR4ID0gdGhpcy50cmFuc2FjdGlvbihzdG9yZU5hbWUsIGlzV3JpdGUgPyAncmVhZHdyaXRlJyA6ICdyZWFkb25seScpO1xuICAgICAgICBsZXQgdGFyZ2V0ID0gdHguc3RvcmU7XG4gICAgICAgIGlmICh1c2VJbmRleClcbiAgICAgICAgICAgIHRhcmdldCA9IHRhcmdldC5pbmRleChhcmdzLnNoaWZ0KCkpO1xuICAgICAgICBjb25zdCByZXR1cm5WYWwgPSBhd2FpdCB0YXJnZXRbdGFyZ2V0RnVuY05hbWVdKC4uLmFyZ3MpO1xuICAgICAgICBpZiAoaXNXcml0ZSlcbiAgICAgICAgICAgIGF3YWl0IHR4LmRvbmU7XG4gICAgICAgIHJldHVybiByZXR1cm5WYWw7XG4gICAgfTtcbiAgICBjYWNoZWRNZXRob2RzLnNldChwcm9wLCBtZXRob2QpO1xuICAgIHJldHVybiBtZXRob2Q7XG59XG5yZXBsYWNlVHJhcHMoKG9sZFRyYXBzKSA9PiAoe1xuICAgIC4uLm9sZFRyYXBzLFxuICAgIGdldDogKHRhcmdldCwgcHJvcCwgcmVjZWl2ZXIpID0+IGdldE1ldGhvZCh0YXJnZXQsIHByb3ApIHx8IG9sZFRyYXBzLmdldCh0YXJnZXQsIHByb3AsIHJlY2VpdmVyKSxcbiAgICBoYXM6ICh0YXJnZXQsIHByb3ApID0+ICEhZ2V0TWV0aG9kKHRhcmdldCwgcHJvcCkgfHwgb2xkVHJhcHMuaGFzKHRhcmdldCwgcHJvcCksXG59KSk7XG5cbmV4cG9ydCB7IGRlbGV0ZURCLCBvcGVuREIgfTtcbiIsImNvbnN0IGluc3RhbmNlT2ZBbnkgPSAob2JqZWN0LCBjb25zdHJ1Y3RvcnMpID0+IGNvbnN0cnVjdG9ycy5zb21lKChjKSA9PiBvYmplY3QgaW5zdGFuY2VvZiBjKTtcblxubGV0IGlkYlByb3h5YWJsZVR5cGVzO1xubGV0IGN1cnNvckFkdmFuY2VNZXRob2RzO1xuLy8gVGhpcyBpcyBhIGZ1bmN0aW9uIHRvIHByZXZlbnQgaXQgdGhyb3dpbmcgdXAgaW4gbm9kZSBlbnZpcm9ubWVudHMuXG5mdW5jdGlvbiBnZXRJZGJQcm94eWFibGVUeXBlcygpIHtcbiAgICByZXR1cm4gKGlkYlByb3h5YWJsZVR5cGVzIHx8XG4gICAgICAgIChpZGJQcm94eWFibGVUeXBlcyA9IFtcbiAgICAgICAgICAgIElEQkRhdGFiYXNlLFxuICAgICAgICAgICAgSURCT2JqZWN0U3RvcmUsXG4gICAgICAgICAgICBJREJJbmRleCxcbiAgICAgICAgICAgIElEQkN1cnNvcixcbiAgICAgICAgICAgIElEQlRyYW5zYWN0aW9uLFxuICAgICAgICBdKSk7XG59XG4vLyBUaGlzIGlzIGEgZnVuY3Rpb24gdG8gcHJldmVudCBpdCB0aHJvd2luZyB1cCBpbiBub2RlIGVudmlyb25tZW50cy5cbmZ1bmN0aW9uIGdldEN1cnNvckFkdmFuY2VNZXRob2RzKCkge1xuICAgIHJldHVybiAoY3Vyc29yQWR2YW5jZU1ldGhvZHMgfHxcbiAgICAgICAgKGN1cnNvckFkdmFuY2VNZXRob2RzID0gW1xuICAgICAgICAgICAgSURCQ3Vyc29yLnByb3RvdHlwZS5hZHZhbmNlLFxuICAgICAgICAgICAgSURCQ3Vyc29yLnByb3RvdHlwZS5jb250aW51ZSxcbiAgICAgICAgICAgIElEQkN1cnNvci5wcm90b3R5cGUuY29udGludWVQcmltYXJ5S2V5LFxuICAgICAgICBdKSk7XG59XG5jb25zdCBjdXJzb3JSZXF1ZXN0TWFwID0gbmV3IFdlYWtNYXAoKTtcbmNvbnN0IHRyYW5zYWN0aW9uRG9uZU1hcCA9IG5ldyBXZWFrTWFwKCk7XG5jb25zdCB0cmFuc2FjdGlvblN0b3JlTmFtZXNNYXAgPSBuZXcgV2Vha01hcCgpO1xuY29uc3QgdHJhbnNmb3JtQ2FjaGUgPSBuZXcgV2Vha01hcCgpO1xuY29uc3QgcmV2ZXJzZVRyYW5zZm9ybUNhY2hlID0gbmV3IFdlYWtNYXAoKTtcbmZ1bmN0aW9uIHByb21pc2lmeVJlcXVlc3QocmVxdWVzdCkge1xuICAgIGNvbnN0IHByb21pc2UgPSBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgIGNvbnN0IHVubGlzdGVuID0gKCkgPT4ge1xuICAgICAgICAgICAgcmVxdWVzdC5yZW1vdmVFdmVudExpc3RlbmVyKCdzdWNjZXNzJywgc3VjY2Vzcyk7XG4gICAgICAgICAgICByZXF1ZXN0LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2Vycm9yJywgZXJyb3IpO1xuICAgICAgICB9O1xuICAgICAgICBjb25zdCBzdWNjZXNzID0gKCkgPT4ge1xuICAgICAgICAgICAgcmVzb2x2ZSh3cmFwKHJlcXVlc3QucmVzdWx0KSk7XG4gICAgICAgICAgICB1bmxpc3RlbigpO1xuICAgICAgICB9O1xuICAgICAgICBjb25zdCBlcnJvciA9ICgpID0+IHtcbiAgICAgICAgICAgIHJlamVjdChyZXF1ZXN0LmVycm9yKTtcbiAgICAgICAgICAgIHVubGlzdGVuKCk7XG4gICAgICAgIH07XG4gICAgICAgIHJlcXVlc3QuYWRkRXZlbnRMaXN0ZW5lcignc3VjY2VzcycsIHN1Y2Nlc3MpO1xuICAgICAgICByZXF1ZXN0LmFkZEV2ZW50TGlzdGVuZXIoJ2Vycm9yJywgZXJyb3IpO1xuICAgIH0pO1xuICAgIHByb21pc2VcbiAgICAgICAgLnRoZW4oKHZhbHVlKSA9PiB7XG4gICAgICAgIC8vIFNpbmNlIGN1cnNvcmluZyByZXVzZXMgdGhlIElEQlJlcXVlc3QgKCpzaWdoKiksIHdlIGNhY2hlIGl0IGZvciBsYXRlciByZXRyaWV2YWxcbiAgICAgICAgLy8gKHNlZSB3cmFwRnVuY3Rpb24pLlxuICAgICAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBJREJDdXJzb3IpIHtcbiAgICAgICAgICAgIGN1cnNvclJlcXVlc3RNYXAuc2V0KHZhbHVlLCByZXF1ZXN0KTtcbiAgICAgICAgfVxuICAgICAgICAvLyBDYXRjaGluZyB0byBhdm9pZCBcIlVuY2F1Z2h0IFByb21pc2UgZXhjZXB0aW9uc1wiXG4gICAgfSlcbiAgICAgICAgLmNhdGNoKCgpID0+IHsgfSk7XG4gICAgLy8gVGhpcyBtYXBwaW5nIGV4aXN0cyBpbiByZXZlcnNlVHJhbnNmb3JtQ2FjaGUgYnV0IGRvZXNuJ3QgZG9lc24ndCBleGlzdCBpbiB0cmFuc2Zvcm1DYWNoZS4gVGhpc1xuICAgIC8vIGlzIGJlY2F1c2Ugd2UgY3JlYXRlIG1hbnkgcHJvbWlzZXMgZnJvbSBhIHNpbmdsZSBJREJSZXF1ZXN0LlxuICAgIHJldmVyc2VUcmFuc2Zvcm1DYWNoZS5zZXQocHJvbWlzZSwgcmVxdWVzdCk7XG4gICAgcmV0dXJuIHByb21pc2U7XG59XG5mdW5jdGlvbiBjYWNoZURvbmVQcm9taXNlRm9yVHJhbnNhY3Rpb24odHgpIHtcbiAgICAvLyBFYXJseSBiYWlsIGlmIHdlJ3ZlIGFscmVhZHkgY3JlYXRlZCBhIGRvbmUgcHJvbWlzZSBmb3IgdGhpcyB0cmFuc2FjdGlvbi5cbiAgICBpZiAodHJhbnNhY3Rpb25Eb25lTWFwLmhhcyh0eCkpXG4gICAgICAgIHJldHVybjtcbiAgICBjb25zdCBkb25lID0gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICBjb25zdCB1bmxpc3RlbiA9ICgpID0+IHtcbiAgICAgICAgICAgIHR4LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2NvbXBsZXRlJywgY29tcGxldGUpO1xuICAgICAgICAgICAgdHgucmVtb3ZlRXZlbnRMaXN0ZW5lcignZXJyb3InLCBlcnJvcik7XG4gICAgICAgICAgICB0eC5yZW1vdmVFdmVudExpc3RlbmVyKCdhYm9ydCcsIGVycm9yKTtcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgY29tcGxldGUgPSAoKSA9PiB7XG4gICAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgICAgICB1bmxpc3RlbigpO1xuICAgICAgICB9O1xuICAgICAgICBjb25zdCBlcnJvciA9ICgpID0+IHtcbiAgICAgICAgICAgIHJlamVjdCh0eC5lcnJvciB8fCBuZXcgRE9NRXhjZXB0aW9uKCdBYm9ydEVycm9yJywgJ0Fib3J0RXJyb3InKSk7XG4gICAgICAgICAgICB1bmxpc3RlbigpO1xuICAgICAgICB9O1xuICAgICAgICB0eC5hZGRFdmVudExpc3RlbmVyKCdjb21wbGV0ZScsIGNvbXBsZXRlKTtcbiAgICAgICAgdHguYWRkRXZlbnRMaXN0ZW5lcignZXJyb3InLCBlcnJvcik7XG4gICAgICAgIHR4LmFkZEV2ZW50TGlzdGVuZXIoJ2Fib3J0JywgZXJyb3IpO1xuICAgIH0pO1xuICAgIC8vIENhY2hlIGl0IGZvciBsYXRlciByZXRyaWV2YWwuXG4gICAgdHJhbnNhY3Rpb25Eb25lTWFwLnNldCh0eCwgZG9uZSk7XG59XG5sZXQgaWRiUHJveHlUcmFwcyA9IHtcbiAgICBnZXQodGFyZ2V0LCBwcm9wLCByZWNlaXZlcikge1xuICAgICAgICBpZiAodGFyZ2V0IGluc3RhbmNlb2YgSURCVHJhbnNhY3Rpb24pIHtcbiAgICAgICAgICAgIC8vIFNwZWNpYWwgaGFuZGxpbmcgZm9yIHRyYW5zYWN0aW9uLmRvbmUuXG4gICAgICAgICAgICBpZiAocHJvcCA9PT0gJ2RvbmUnKVxuICAgICAgICAgICAgICAgIHJldHVybiB0cmFuc2FjdGlvbkRvbmVNYXAuZ2V0KHRhcmdldCk7XG4gICAgICAgICAgICAvLyBQb2x5ZmlsbCBmb3Igb2JqZWN0U3RvcmVOYW1lcyBiZWNhdXNlIG9mIEVkZ2UuXG4gICAgICAgICAgICBpZiAocHJvcCA9PT0gJ29iamVjdFN0b3JlTmFtZXMnKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRhcmdldC5vYmplY3RTdG9yZU5hbWVzIHx8IHRyYW5zYWN0aW9uU3RvcmVOYW1lc01hcC5nZXQodGFyZ2V0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIE1ha2UgdHguc3RvcmUgcmV0dXJuIHRoZSBvbmx5IHN0b3JlIGluIHRoZSB0cmFuc2FjdGlvbiwgb3IgdW5kZWZpbmVkIGlmIHRoZXJlIGFyZSBtYW55LlxuICAgICAgICAgICAgaWYgKHByb3AgPT09ICdzdG9yZScpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVjZWl2ZXIub2JqZWN0U3RvcmVOYW1lc1sxXVxuICAgICAgICAgICAgICAgICAgICA/IHVuZGVmaW5lZFxuICAgICAgICAgICAgICAgICAgICA6IHJlY2VpdmVyLm9iamVjdFN0b3JlKHJlY2VpdmVyLm9iamVjdFN0b3JlTmFtZXNbMF0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIEVsc2UgdHJhbnNmb3JtIHdoYXRldmVyIHdlIGdldCBiYWNrLlxuICAgICAgICByZXR1cm4gd3JhcCh0YXJnZXRbcHJvcF0pO1xuICAgIH0sXG4gICAgc2V0KHRhcmdldCwgcHJvcCwgdmFsdWUpIHtcbiAgICAgICAgdGFyZ2V0W3Byb3BdID0gdmFsdWU7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH0sXG4gICAgaGFzKHRhcmdldCwgcHJvcCkge1xuICAgICAgICBpZiAodGFyZ2V0IGluc3RhbmNlb2YgSURCVHJhbnNhY3Rpb24gJiZcbiAgICAgICAgICAgIChwcm9wID09PSAnZG9uZScgfHwgcHJvcCA9PT0gJ3N0b3JlJykpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwcm9wIGluIHRhcmdldDtcbiAgICB9LFxufTtcbmZ1bmN0aW9uIHJlcGxhY2VUcmFwcyhjYWxsYmFjaykge1xuICAgIGlkYlByb3h5VHJhcHMgPSBjYWxsYmFjayhpZGJQcm94eVRyYXBzKTtcbn1cbmZ1bmN0aW9uIHdyYXBGdW5jdGlvbihmdW5jKSB7XG4gICAgLy8gRHVlIHRvIGV4cGVjdGVkIG9iamVjdCBlcXVhbGl0eSAod2hpY2ggaXMgZW5mb3JjZWQgYnkgdGhlIGNhY2hpbmcgaW4gYHdyYXBgKSwgd2VcbiAgICAvLyBvbmx5IGNyZWF0ZSBvbmUgbmV3IGZ1bmMgcGVyIGZ1bmMuXG4gICAgLy8gRWRnZSBkb2Vzbid0IHN1cHBvcnQgb2JqZWN0U3RvcmVOYW1lcyAoYm9vbyksIHNvIHdlIHBvbHlmaWxsIGl0IGhlcmUuXG4gICAgaWYgKGZ1bmMgPT09IElEQkRhdGFiYXNlLnByb3RvdHlwZS50cmFuc2FjdGlvbiAmJlxuICAgICAgICAhKCdvYmplY3RTdG9yZU5hbWVzJyBpbiBJREJUcmFuc2FjdGlvbi5wcm90b3R5cGUpKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoc3RvcmVOYW1lcywgLi4uYXJncykge1xuICAgICAgICAgICAgY29uc3QgdHggPSBmdW5jLmNhbGwodW53cmFwKHRoaXMpLCBzdG9yZU5hbWVzLCAuLi5hcmdzKTtcbiAgICAgICAgICAgIHRyYW5zYWN0aW9uU3RvcmVOYW1lc01hcC5zZXQodHgsIHN0b3JlTmFtZXMuc29ydCA/IHN0b3JlTmFtZXMuc29ydCgpIDogW3N0b3JlTmFtZXNdKTtcbiAgICAgICAgICAgIHJldHVybiB3cmFwKHR4KTtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgLy8gQ3Vyc29yIG1ldGhvZHMgYXJlIHNwZWNpYWwsIGFzIHRoZSBiZWhhdmlvdXIgaXMgYSBsaXR0bGUgbW9yZSBkaWZmZXJlbnQgdG8gc3RhbmRhcmQgSURCLiBJblxuICAgIC8vIElEQiwgeW91IGFkdmFuY2UgdGhlIGN1cnNvciBhbmQgd2FpdCBmb3IgYSBuZXcgJ3N1Y2Nlc3MnIG9uIHRoZSBJREJSZXF1ZXN0IHRoYXQgZ2F2ZSB5b3UgdGhlXG4gICAgLy8gY3Vyc29yLiBJdCdzIGtpbmRhIGxpa2UgYSBwcm9taXNlIHRoYXQgY2FuIHJlc29sdmUgd2l0aCBtYW55IHZhbHVlcy4gVGhhdCBkb2Vzbid0IG1ha2Ugc2Vuc2VcbiAgICAvLyB3aXRoIHJlYWwgcHJvbWlzZXMsIHNvIGVhY2ggYWR2YW5jZSBtZXRob2RzIHJldHVybnMgYSBuZXcgcHJvbWlzZSBmb3IgdGhlIGN1cnNvciBvYmplY3QsIG9yXG4gICAgLy8gdW5kZWZpbmVkIGlmIHRoZSBlbmQgb2YgdGhlIGN1cnNvciBoYXMgYmVlbiByZWFjaGVkLlxuICAgIGlmIChnZXRDdXJzb3JBZHZhbmNlTWV0aG9kcygpLmluY2x1ZGVzKGZ1bmMpKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoLi4uYXJncykge1xuICAgICAgICAgICAgLy8gQ2FsbGluZyB0aGUgb3JpZ2luYWwgZnVuY3Rpb24gd2l0aCB0aGUgcHJveHkgYXMgJ3RoaXMnIGNhdXNlcyBJTExFR0FMIElOVk9DQVRJT04sIHNvIHdlIHVzZVxuICAgICAgICAgICAgLy8gdGhlIG9yaWdpbmFsIG9iamVjdC5cbiAgICAgICAgICAgIGZ1bmMuYXBwbHkodW53cmFwKHRoaXMpLCBhcmdzKTtcbiAgICAgICAgICAgIHJldHVybiB3cmFwKGN1cnNvclJlcXVlc3RNYXAuZ2V0KHRoaXMpKTtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgcmV0dXJuIGZ1bmN0aW9uICguLi5hcmdzKSB7XG4gICAgICAgIC8vIENhbGxpbmcgdGhlIG9yaWdpbmFsIGZ1bmN0aW9uIHdpdGggdGhlIHByb3h5IGFzICd0aGlzJyBjYXVzZXMgSUxMRUdBTCBJTlZPQ0FUSU9OLCBzbyB3ZSB1c2VcbiAgICAgICAgLy8gdGhlIG9yaWdpbmFsIG9iamVjdC5cbiAgICAgICAgcmV0dXJuIHdyYXAoZnVuYy5hcHBseSh1bndyYXAodGhpcyksIGFyZ3MpKTtcbiAgICB9O1xufVxuZnVuY3Rpb24gdHJhbnNmb3JtQ2FjaGFibGVWYWx1ZSh2YWx1ZSkge1xuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdmdW5jdGlvbicpXG4gICAgICAgIHJldHVybiB3cmFwRnVuY3Rpb24odmFsdWUpO1xuICAgIC8vIFRoaXMgZG9lc24ndCByZXR1cm4sIGl0IGp1c3QgY3JlYXRlcyBhICdkb25lJyBwcm9taXNlIGZvciB0aGUgdHJhbnNhY3Rpb24sXG4gICAgLy8gd2hpY2ggaXMgbGF0ZXIgcmV0dXJuZWQgZm9yIHRyYW5zYWN0aW9uLmRvbmUgKHNlZSBpZGJPYmplY3RIYW5kbGVyKS5cbiAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBJREJUcmFuc2FjdGlvbilcbiAgICAgICAgY2FjaGVEb25lUHJvbWlzZUZvclRyYW5zYWN0aW9uKHZhbHVlKTtcbiAgICBpZiAoaW5zdGFuY2VPZkFueSh2YWx1ZSwgZ2V0SWRiUHJveHlhYmxlVHlwZXMoKSkpXG4gICAgICAgIHJldHVybiBuZXcgUHJveHkodmFsdWUsIGlkYlByb3h5VHJhcHMpO1xuICAgIC8vIFJldHVybiB0aGUgc2FtZSB2YWx1ZSBiYWNrIGlmIHdlJ3JlIG5vdCBnb2luZyB0byB0cmFuc2Zvcm0gaXQuXG4gICAgcmV0dXJuIHZhbHVlO1xufVxuZnVuY3Rpb24gd3JhcCh2YWx1ZSkge1xuICAgIC8vIFdlIHNvbWV0aW1lcyBnZW5lcmF0ZSBtdWx0aXBsZSBwcm9taXNlcyBmcm9tIGEgc2luZ2xlIElEQlJlcXVlc3QgKGVnIHdoZW4gY3Vyc29yaW5nKSwgYmVjYXVzZVxuICAgIC8vIElEQiBpcyB3ZWlyZCBhbmQgYSBzaW5nbGUgSURCUmVxdWVzdCBjYW4geWllbGQgbWFueSByZXNwb25zZXMsIHNvIHRoZXNlIGNhbid0IGJlIGNhY2hlZC5cbiAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBJREJSZXF1ZXN0KVxuICAgICAgICByZXR1cm4gcHJvbWlzaWZ5UmVxdWVzdCh2YWx1ZSk7XG4gICAgLy8gSWYgd2UndmUgYWxyZWFkeSB0cmFuc2Zvcm1lZCB0aGlzIHZhbHVlIGJlZm9yZSwgcmV1c2UgdGhlIHRyYW5zZm9ybWVkIHZhbHVlLlxuICAgIC8vIFRoaXMgaXMgZmFzdGVyLCBidXQgaXQgYWxzbyBwcm92aWRlcyBvYmplY3QgZXF1YWxpdHkuXG4gICAgaWYgKHRyYW5zZm9ybUNhY2hlLmhhcyh2YWx1ZSkpXG4gICAgICAgIHJldHVybiB0cmFuc2Zvcm1DYWNoZS5nZXQodmFsdWUpO1xuICAgIGNvbnN0IG5ld1ZhbHVlID0gdHJhbnNmb3JtQ2FjaGFibGVWYWx1ZSh2YWx1ZSk7XG4gICAgLy8gTm90IGFsbCB0eXBlcyBhcmUgdHJhbnNmb3JtZWQuXG4gICAgLy8gVGhlc2UgbWF5IGJlIHByaW1pdGl2ZSB0eXBlcywgc28gdGhleSBjYW4ndCBiZSBXZWFrTWFwIGtleXMuXG4gICAgaWYgKG5ld1ZhbHVlICE9PSB2YWx1ZSkge1xuICAgICAgICB0cmFuc2Zvcm1DYWNoZS5zZXQodmFsdWUsIG5ld1ZhbHVlKTtcbiAgICAgICAgcmV2ZXJzZVRyYW5zZm9ybUNhY2hlLnNldChuZXdWYWx1ZSwgdmFsdWUpO1xuICAgIH1cbiAgICByZXR1cm4gbmV3VmFsdWU7XG59XG5jb25zdCB1bndyYXAgPSAodmFsdWUpID0+IHJldmVyc2VUcmFuc2Zvcm1DYWNoZS5nZXQodmFsdWUpO1xuXG5leHBvcnQgeyByZXZlcnNlVHJhbnNmb3JtQ2FjaGUgYXMgYSwgaW5zdGFuY2VPZkFueSBhcyBpLCByZXBsYWNlVHJhcHMgYXMgciwgdW53cmFwIGFzIHUsIHdyYXAgYXMgdyB9O1xuIiwiXG4gICAgKHdpbmRvdy5fX05FWFRfUCA9IHdpbmRvdy5fX05FWFRfUCB8fCBbXSkucHVzaChbXG4gICAgICBcIi9fYXBwXCIsXG4gICAgICBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiByZXF1aXJlKFwicHJpdmF0ZS1uZXh0LXBhZ2VzL19hcHAudHN4XCIpO1xuICAgICAgfVxuICAgIF0pO1xuICAiLCJcInVzZSBzdHJpY3RcIjtjb25zdCBpc09sZElFPWZ1bmN0aW9uIGlzT2xkSUUoKXtsZXQgbWVtbztyZXR1cm4gZnVuY3Rpb24gbWVtb3JpemUoKXtpZih0eXBlb2YgbWVtbz09PSd1bmRlZmluZWQnKXsvLyBUZXN0IGZvciBJRSA8PSA5IGFzIHByb3Bvc2VkIGJ5IEJyb3dzZXJoYWNrc1xuLy8gQHNlZSBodHRwOi8vYnJvd3NlcmhhY2tzLmNvbS8jaGFjay1lNzFkODY5MmY2NTMzNDE3M2ZlZTcxNWMyMjJjYjgwNVxuLy8gVGVzdHMgZm9yIGV4aXN0ZW5jZSBvZiBzdGFuZGFyZCBnbG9iYWxzIGlzIHRvIGFsbG93IHN0eWxlLWxvYWRlclxuLy8gdG8gb3BlcmF0ZSBjb3JyZWN0bHkgaW50byBub24tc3RhbmRhcmQgZW52aXJvbm1lbnRzXG4vLyBAc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS93ZWJwYWNrLWNvbnRyaWIvc3R5bGUtbG9hZGVyL2lzc3Vlcy8xNzdcbm1lbW89Qm9vbGVhbih3aW5kb3cmJmRvY3VtZW50JiZkb2N1bWVudC5hbGwmJiF3aW5kb3cuYXRvYik7fXJldHVybiBtZW1vO307fSgpO2NvbnN0IGdldFRhcmdldD1mdW5jdGlvbiBnZXRUYXJnZXQoKXtjb25zdCBtZW1vPXt9O3JldHVybiBmdW5jdGlvbiBtZW1vcml6ZSh0YXJnZXQpe2lmKHR5cGVvZiBtZW1vW3RhcmdldF09PT0ndW5kZWZpbmVkJyl7bGV0IHN0eWxlVGFyZ2V0PWRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IodGFyZ2V0KTsvLyBTcGVjaWFsIGNhc2UgdG8gcmV0dXJuIGhlYWQgb2YgaWZyYW1lIGluc3RlYWQgb2YgaWZyYW1lIGl0c2VsZlxuaWYod2luZG93LkhUTUxJRnJhbWVFbGVtZW50JiZzdHlsZVRhcmdldCBpbnN0YW5jZW9mIHdpbmRvdy5IVE1MSUZyYW1lRWxlbWVudCl7dHJ5ey8vIFRoaXMgd2lsbCB0aHJvdyBhbiBleGNlcHRpb24gaWYgYWNjZXNzIHRvIGlmcmFtZSBpcyBibG9ja2VkXG4vLyBkdWUgdG8gY3Jvc3Mtb3JpZ2luIHJlc3RyaWN0aW9uc1xuc3R5bGVUYXJnZXQ9c3R5bGVUYXJnZXQuY29udGVudERvY3VtZW50LmhlYWQ7fWNhdGNoKGUpey8vIGlzdGFuYnVsIGlnbm9yZSBuZXh0XG5zdHlsZVRhcmdldD1udWxsO319bWVtb1t0YXJnZXRdPXN0eWxlVGFyZ2V0O31yZXR1cm4gbWVtb1t0YXJnZXRdO307fSgpO2NvbnN0IHN0eWxlc0luRG9tPVtdO2Z1bmN0aW9uIGdldEluZGV4QnlJZGVudGlmaWVyKGlkZW50aWZpZXIpe2xldCByZXN1bHQ9LTE7Zm9yKGxldCBpPTA7aTxzdHlsZXNJbkRvbS5sZW5ndGg7aSsrKXtpZihzdHlsZXNJbkRvbVtpXS5pZGVudGlmaWVyPT09aWRlbnRpZmllcil7cmVzdWx0PWk7YnJlYWs7fX1yZXR1cm4gcmVzdWx0O31mdW5jdGlvbiBtb2R1bGVzVG9Eb20obGlzdCxvcHRpb25zKXtjb25zdCBpZENvdW50TWFwPXt9O2NvbnN0IGlkZW50aWZpZXJzPVtdO2ZvcihsZXQgaT0wO2k8bGlzdC5sZW5ndGg7aSsrKXtjb25zdCBpdGVtPWxpc3RbaV07Y29uc3QgaWQ9b3B0aW9ucy5iYXNlP2l0ZW1bMF0rb3B0aW9ucy5iYXNlOml0ZW1bMF07Y29uc3QgY291bnQ9aWRDb3VudE1hcFtpZF18fDA7Y29uc3QgaWRlbnRpZmllcj1pZCsnICcrY291bnQudG9TdHJpbmcoKTtpZENvdW50TWFwW2lkXT1jb3VudCsxO2NvbnN0IGluZGV4PWdldEluZGV4QnlJZGVudGlmaWVyKGlkZW50aWZpZXIpO2NvbnN0IG9iaj17Y3NzOml0ZW1bMV0sbWVkaWE6aXRlbVsyXSxzb3VyY2VNYXA6aXRlbVszXX07aWYoaW5kZXghPT0tMSl7c3R5bGVzSW5Eb21baW5kZXhdLnJlZmVyZW5jZXMrKztzdHlsZXNJbkRvbVtpbmRleF0udXBkYXRlcihvYmopO31lbHNle3N0eWxlc0luRG9tLnB1c2goe2lkZW50aWZpZXI6aWRlbnRpZmllcix1cGRhdGVyOmFkZFN0eWxlKG9iaixvcHRpb25zKSxyZWZlcmVuY2VzOjF9KTt9aWRlbnRpZmllcnMucHVzaChpZGVudGlmaWVyKTt9cmV0dXJuIGlkZW50aWZpZXJzO31mdW5jdGlvbiBpbnNlcnRTdHlsZUVsZW1lbnQob3B0aW9ucyl7Y29uc3Qgc3R5bGU9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc3R5bGUnKTtjb25zdCBhdHRyaWJ1dGVzPW9wdGlvbnMuYXR0cmlidXRlc3x8e307aWYodHlwZW9mIGF0dHJpYnV0ZXMubm9uY2U9PT0ndW5kZWZpbmVkJyl7Y29uc3Qgbm9uY2U9Ly8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVuZGVmXG50eXBlb2YgX193ZWJwYWNrX25vbmNlX18hPT0ndW5kZWZpbmVkJz9fX3dlYnBhY2tfbm9uY2VfXzpudWxsO2lmKG5vbmNlKXthdHRyaWJ1dGVzLm5vbmNlPW5vbmNlO319T2JqZWN0LmtleXMoYXR0cmlidXRlcykuZm9yRWFjaChmdW5jdGlvbihrZXkpe3N0eWxlLnNldEF0dHJpYnV0ZShrZXksYXR0cmlidXRlc1trZXldKTt9KTtpZih0eXBlb2Ygb3B0aW9ucy5pbnNlcnQ9PT0nZnVuY3Rpb24nKXtvcHRpb25zLmluc2VydChzdHlsZSk7fWVsc2V7Y29uc3QgdGFyZ2V0PWdldFRhcmdldChvcHRpb25zLmluc2VydHx8J2hlYWQnKTtpZighdGFyZ2V0KXt0aHJvdyBuZXcgRXJyb3IoXCJDb3VsZG4ndCBmaW5kIGEgc3R5bGUgdGFyZ2V0LiBUaGlzIHByb2JhYmx5IG1lYW5zIHRoYXQgdGhlIHZhbHVlIGZvciB0aGUgJ2luc2VydCcgcGFyYW1ldGVyIGlzIGludmFsaWQuXCIpO310YXJnZXQuYXBwZW5kQ2hpbGQoc3R5bGUpO31yZXR1cm4gc3R5bGU7fWZ1bmN0aW9uIHJlbW92ZVN0eWxlRWxlbWVudChzdHlsZSl7Ly8gaXN0YW5idWwgaWdub3JlIGlmXG5pZihzdHlsZS5wYXJlbnROb2RlPT09bnVsbCl7cmV0dXJuIGZhbHNlO31zdHlsZS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHN0eWxlKTt9LyogaXN0YW5idWwgaWdub3JlIG5leHQgICovY29uc3QgcmVwbGFjZVRleHQ9ZnVuY3Rpb24gcmVwbGFjZVRleHQoKXtjb25zdCB0ZXh0U3RvcmU9W107cmV0dXJuIGZ1bmN0aW9uIHJlcGxhY2UoaW5kZXgscmVwbGFjZW1lbnQpe3RleHRTdG9yZVtpbmRleF09cmVwbGFjZW1lbnQ7cmV0dXJuIHRleHRTdG9yZS5maWx0ZXIoQm9vbGVhbikuam9pbignXFxuJyk7fTt9KCk7ZnVuY3Rpb24gYXBwbHlUb1NpbmdsZXRvblRhZyhzdHlsZSxpbmRleCxyZW1vdmUsb2JqKXtjb25zdCBjc3M9cmVtb3ZlPycnOm9iai5tZWRpYT8nQG1lZGlhICcrb2JqLm1lZGlhKycgeycrb2JqLmNzcysnfSc6b2JqLmNzczsvLyBGb3Igb2xkIElFXG4vKiBpc3RhbmJ1bCBpZ25vcmUgaWYgICovaWYoc3R5bGUuc3R5bGVTaGVldCl7c3R5bGUuc3R5bGVTaGVldC5jc3NUZXh0PXJlcGxhY2VUZXh0KGluZGV4LGNzcyk7fWVsc2V7Y29uc3QgY3NzTm9kZT1kb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShjc3MpO2NvbnN0IGNoaWxkTm9kZXM9c3R5bGUuY2hpbGROb2RlcztpZihjaGlsZE5vZGVzW2luZGV4XSl7c3R5bGUucmVtb3ZlQ2hpbGQoY2hpbGROb2Rlc1tpbmRleF0pO31pZihjaGlsZE5vZGVzLmxlbmd0aCl7c3R5bGUuaW5zZXJ0QmVmb3JlKGNzc05vZGUsY2hpbGROb2Rlc1tpbmRleF0pO31lbHNle3N0eWxlLmFwcGVuZENoaWxkKGNzc05vZGUpO319fWZ1bmN0aW9uIGFwcGx5VG9UYWcoc3R5bGUsb3B0aW9ucyxvYmope2xldCBjc3M9b2JqLmNzcztjb25zdCBtZWRpYT1vYmoubWVkaWE7Y29uc3Qgc291cmNlTWFwPW9iai5zb3VyY2VNYXA7aWYobWVkaWEpe3N0eWxlLnNldEF0dHJpYnV0ZSgnbWVkaWEnLG1lZGlhKTt9ZWxzZXtzdHlsZS5yZW1vdmVBdHRyaWJ1dGUoJ21lZGlhJyk7fWlmKHNvdXJjZU1hcCYmdHlwZW9mIGJ0b2EhPT0ndW5kZWZpbmVkJyl7Y3NzKz0nXFxuLyojIHNvdXJjZU1hcHBpbmdVUkw9ZGF0YTphcHBsaWNhdGlvbi9qc29uO2Jhc2U2NCwnK2J0b2EodW5lc2NhcGUoZW5jb2RlVVJJQ29tcG9uZW50KEpTT04uc3RyaW5naWZ5KHNvdXJjZU1hcCkpKSkrJyAqLyc7fS8vIEZvciBvbGQgSUVcbi8qIGlzdGFuYnVsIGlnbm9yZSBpZiAgKi9pZihzdHlsZS5zdHlsZVNoZWV0KXtzdHlsZS5zdHlsZVNoZWV0LmNzc1RleHQ9Y3NzO31lbHNle3doaWxlKHN0eWxlLmZpcnN0Q2hpbGQpe3N0eWxlLnJlbW92ZUNoaWxkKHN0eWxlLmZpcnN0Q2hpbGQpO31zdHlsZS5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShjc3MpKTt9fWxldCBzaW5nbGV0b249bnVsbDtsZXQgc2luZ2xldG9uQ291bnRlcj0wO2Z1bmN0aW9uIGFkZFN0eWxlKG9iaixvcHRpb25zKXtsZXQgc3R5bGU7bGV0IHVwZGF0ZTtsZXQgcmVtb3ZlO2lmKG9wdGlvbnMuc2luZ2xldG9uKXtjb25zdCBzdHlsZUluZGV4PXNpbmdsZXRvbkNvdW50ZXIrKztzdHlsZT1zaW5nbGV0b258fChzaW5nbGV0b249aW5zZXJ0U3R5bGVFbGVtZW50KG9wdGlvbnMpKTt1cGRhdGU9YXBwbHlUb1NpbmdsZXRvblRhZy5iaW5kKG51bGwsc3R5bGUsc3R5bGVJbmRleCxmYWxzZSk7cmVtb3ZlPWFwcGx5VG9TaW5nbGV0b25UYWcuYmluZChudWxsLHN0eWxlLHN0eWxlSW5kZXgsdHJ1ZSk7fWVsc2V7c3R5bGU9aW5zZXJ0U3R5bGVFbGVtZW50KG9wdGlvbnMpO3VwZGF0ZT1hcHBseVRvVGFnLmJpbmQobnVsbCxzdHlsZSxvcHRpb25zKTtyZW1vdmU9ZnVuY3Rpb24oKXtyZW1vdmVTdHlsZUVsZW1lbnQoc3R5bGUpO307fXVwZGF0ZShvYmopO3JldHVybiBmdW5jdGlvbiB1cGRhdGVTdHlsZShuZXdPYmope2lmKG5ld09iail7aWYobmV3T2JqLmNzcz09PW9iai5jc3MmJm5ld09iai5tZWRpYT09PW9iai5tZWRpYSYmbmV3T2JqLnNvdXJjZU1hcD09PW9iai5zb3VyY2VNYXApe3JldHVybjt9dXBkYXRlKG9iaj1uZXdPYmopO31lbHNle3JlbW92ZSgpO319O31tb2R1bGUuZXhwb3J0cz1mdW5jdGlvbihsaXN0LG9wdGlvbnMpe29wdGlvbnM9b3B0aW9uc3x8e307Ly8gRm9yY2Ugc2luZ2xlLXRhZyBzb2x1dGlvbiBvbiBJRTYtOSwgd2hpY2ggaGFzIGEgaGFyZCBsaW1pdCBvbiB0aGUgIyBvZiA8c3R5bGU+XG4vLyB0YWdzIGl0IHdpbGwgYWxsb3cgb24gYSBwYWdlXG5pZighb3B0aW9ucy5zaW5nbGV0b24mJnR5cGVvZiBvcHRpb25zLnNpbmdsZXRvbiE9PSdib29sZWFuJyl7b3B0aW9ucy5zaW5nbGV0b249aXNPbGRJRSgpO31saXN0PWxpc3R8fFtdO2xldCBsYXN0SWRlbnRpZmllcnM9bW9kdWxlc1RvRG9tKGxpc3Qsb3B0aW9ucyk7cmV0dXJuIGZ1bmN0aW9uIHVwZGF0ZShuZXdMaXN0KXtuZXdMaXN0PW5ld0xpc3R8fFtdO2lmKE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChuZXdMaXN0KSE9PSdbb2JqZWN0IEFycmF5XScpe3JldHVybjt9Zm9yKGxldCBpPTA7aTxsYXN0SWRlbnRpZmllcnMubGVuZ3RoO2krKyl7Y29uc3QgaWRlbnRpZmllcj1sYXN0SWRlbnRpZmllcnNbaV07Y29uc3QgaW5kZXg9Z2V0SW5kZXhCeUlkZW50aWZpZXIoaWRlbnRpZmllcik7c3R5bGVzSW5Eb21baW5kZXhdLnJlZmVyZW5jZXMtLTt9Y29uc3QgbmV3TGFzdElkZW50aWZpZXJzPW1vZHVsZXNUb0RvbShuZXdMaXN0LG9wdGlvbnMpO2ZvcihsZXQgaT0wO2k8bGFzdElkZW50aWZpZXJzLmxlbmd0aDtpKyspe2NvbnN0IGlkZW50aWZpZXI9bGFzdElkZW50aWZpZXJzW2ldO2NvbnN0IGluZGV4PWdldEluZGV4QnlJZGVudGlmaWVyKGlkZW50aWZpZXIpO2lmKHN0eWxlc0luRG9tW2luZGV4XS5yZWZlcmVuY2VzPT09MCl7c3R5bGVzSW5Eb21baW5kZXhdLnVwZGF0ZXIoKTtzdHlsZXNJbkRvbS5zcGxpY2UoaW5kZXgsMSk7fX1sYXN0SWRlbnRpZmllcnM9bmV3TGFzdElkZW50aWZpZXJzO307fTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluamVjdFN0eWxlc0ludG9TdHlsZVRhZy5qcy5tYXAiLCJpbXBvcnQgUmVhY3QsIHsgQ2hpbGRyZW4sIHVzZUVmZmVjdCB9IGZyb20gJ3JlYWN0J1xuaW1wb3J0IHsgVXJsT2JqZWN0IH0gZnJvbSAndXJsJ1xuaW1wb3J0IHtcbiAgYWRkQmFzZVBhdGgsXG4gIGFkZExvY2FsZSxcbiAgZ2V0RG9tYWluTG9jYWxlLFxuICBpc0xvY2FsVVJMLFxuICBOZXh0Um91dGVyLFxuICBQcmVmZXRjaE9wdGlvbnMsXG4gIHJlc29sdmVIcmVmLFxufSBmcm9tICcuLi9uZXh0LXNlcnZlci9saWIvcm91dGVyL3JvdXRlcidcbmltcG9ydCB7IHVzZVJvdXRlciB9IGZyb20gJy4vcm91dGVyJ1xuaW1wb3J0IHsgdXNlSW50ZXJzZWN0aW9uIH0gZnJvbSAnLi91c2UtaW50ZXJzZWN0aW9uJ1xuXG50eXBlIFVybCA9IHN0cmluZyB8IFVybE9iamVjdFxudHlwZSBSZXF1aXJlZEtleXM8VD4gPSB7XG4gIFtLIGluIGtleW9mIFRdLT86IHt9IGV4dGVuZHMgUGljazxULCBLPiA/IG5ldmVyIDogS1xufVtrZXlvZiBUXVxudHlwZSBPcHRpb25hbEtleXM8VD4gPSB7XG4gIFtLIGluIGtleW9mIFRdLT86IHt9IGV4dGVuZHMgUGljazxULCBLPiA/IEsgOiBuZXZlclxufVtrZXlvZiBUXVxuXG5leHBvcnQgdHlwZSBMaW5rUHJvcHMgPSB7XG4gIGhyZWY6IFVybFxuICBhcz86IFVybFxuICByZXBsYWNlPzogYm9vbGVhblxuICBzY3JvbGw/OiBib29sZWFuXG4gIHNoYWxsb3c/OiBib29sZWFuXG4gIHBhc3NIcmVmPzogYm9vbGVhblxuICBwcmVmZXRjaD86IGJvb2xlYW5cbiAgbG9jYWxlPzogc3RyaW5nIHwgZmFsc2Vcbn1cbnR5cGUgTGlua1Byb3BzUmVxdWlyZWQgPSBSZXF1aXJlZEtleXM8TGlua1Byb3BzPlxudHlwZSBMaW5rUHJvcHNPcHRpb25hbCA9IE9wdGlvbmFsS2V5czxMaW5rUHJvcHM+XG5cbmNvbnN0IHByZWZldGNoZWQ6IHsgW2NhY2hlS2V5OiBzdHJpbmddOiBib29sZWFuIH0gPSB7fVxuXG5mdW5jdGlvbiBwcmVmZXRjaChcbiAgcm91dGVyOiBOZXh0Um91dGVyLFxuICBocmVmOiBzdHJpbmcsXG4gIGFzOiBzdHJpbmcsXG4gIG9wdGlvbnM/OiBQcmVmZXRjaE9wdGlvbnNcbik6IHZvaWQge1xuICBpZiAodHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcgfHwgIXJvdXRlcikgcmV0dXJuXG4gIGlmICghaXNMb2NhbFVSTChocmVmKSkgcmV0dXJuXG4gIC8vIFByZWZldGNoIHRoZSBKU09OIHBhZ2UgaWYgYXNrZWQgKG9ubHkgaW4gdGhlIGNsaWVudClcbiAgLy8gV2UgbmVlZCB0byBoYW5kbGUgYSBwcmVmZXRjaCBlcnJvciBoZXJlIHNpbmNlIHdlIG1heSBiZVxuICAvLyBsb2FkaW5nIHdpdGggcHJpb3JpdHkgd2hpY2ggY2FuIHJlamVjdCBidXQgd2UgZG9uJ3RcbiAgLy8gd2FudCB0byBmb3JjZSBuYXZpZ2F0aW9uIHNpbmNlIHRoaXMgaXMgb25seSBhIHByZWZldGNoXG4gIHJvdXRlci5wcmVmZXRjaChocmVmLCBhcywgb3B0aW9ucykuY2F0Y2goKGVycikgPT4ge1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAvLyByZXRocm93IHRvIHNob3cgaW52YWxpZCBVUkwgZXJyb3JzXG4gICAgICB0aHJvdyBlcnJcbiAgICB9XG4gIH0pXG4gIGNvbnN0IGN1ckxvY2FsZSA9XG4gICAgb3B0aW9ucyAmJiB0eXBlb2Ygb3B0aW9ucy5sb2NhbGUgIT09ICd1bmRlZmluZWQnXG4gICAgICA/IG9wdGlvbnMubG9jYWxlXG4gICAgICA6IHJvdXRlciAmJiByb3V0ZXIubG9jYWxlXG5cbiAgLy8gSm9pbiBvbiBhbiBpbnZhbGlkIFVSSSBjaGFyYWN0ZXJcbiAgcHJlZmV0Y2hlZFtocmVmICsgJyUnICsgYXMgKyAoY3VyTG9jYWxlID8gJyUnICsgY3VyTG9jYWxlIDogJycpXSA9IHRydWVcbn1cblxuZnVuY3Rpb24gaXNNb2RpZmllZEV2ZW50KGV2ZW50OiBSZWFjdC5Nb3VzZUV2ZW50KTogYm9vbGVhbiB7XG4gIGNvbnN0IHsgdGFyZ2V0IH0gPSBldmVudC5jdXJyZW50VGFyZ2V0IGFzIEhUTUxBbmNob3JFbGVtZW50XG4gIHJldHVybiAoXG4gICAgKHRhcmdldCAmJiB0YXJnZXQgIT09ICdfc2VsZicpIHx8XG4gICAgZXZlbnQubWV0YUtleSB8fFxuICAgIGV2ZW50LmN0cmxLZXkgfHxcbiAgICBldmVudC5zaGlmdEtleSB8fFxuICAgIGV2ZW50LmFsdEtleSB8fCAvLyB0cmlnZ2VycyByZXNvdXJjZSBkb3dubG9hZFxuICAgIChldmVudC5uYXRpdmVFdmVudCAmJiBldmVudC5uYXRpdmVFdmVudC53aGljaCA9PT0gMilcbiAgKVxufVxuXG5mdW5jdGlvbiBsaW5rQ2xpY2tlZChcbiAgZTogUmVhY3QuTW91c2VFdmVudCxcbiAgcm91dGVyOiBOZXh0Um91dGVyLFxuICBocmVmOiBzdHJpbmcsXG4gIGFzOiBzdHJpbmcsXG4gIHJlcGxhY2U/OiBib29sZWFuLFxuICBzaGFsbG93PzogYm9vbGVhbixcbiAgc2Nyb2xsPzogYm9vbGVhbixcbiAgbG9jYWxlPzogc3RyaW5nIHwgZmFsc2Vcbik6IHZvaWQge1xuICBjb25zdCB7IG5vZGVOYW1lIH0gPSBlLmN1cnJlbnRUYXJnZXRcblxuICBpZiAobm9kZU5hbWUgPT09ICdBJyAmJiAoaXNNb2RpZmllZEV2ZW50KGUpIHx8ICFpc0xvY2FsVVJMKGhyZWYpKSkge1xuICAgIC8vIGlnbm9yZSBjbGljayBmb3IgYnJvd3NlcuKAmXMgZGVmYXVsdCBiZWhhdmlvclxuICAgIHJldHVyblxuICB9XG5cbiAgZS5wcmV2ZW50RGVmYXVsdCgpXG5cbiAgLy8gIGF2b2lkIHNjcm9sbCBmb3IgdXJscyB3aXRoIGFuY2hvciByZWZzXG4gIGlmIChzY3JvbGwgPT0gbnVsbCkge1xuICAgIHNjcm9sbCA9IGFzLmluZGV4T2YoJyMnKSA8IDBcbiAgfVxuXG4gIC8vIHJlcGxhY2Ugc3RhdGUgaW5zdGVhZCBvZiBwdXNoIGlmIHByb3AgaXMgcHJlc2VudFxuICByb3V0ZXJbcmVwbGFjZSA/ICdyZXBsYWNlJyA6ICdwdXNoJ10oaHJlZiwgYXMsIHtcbiAgICBzaGFsbG93LFxuICAgIGxvY2FsZSxcbiAgICBzY3JvbGwsXG4gIH0pXG59XG5cbmZ1bmN0aW9uIExpbmsocHJvcHM6IFJlYWN0LlByb3BzV2l0aENoaWxkcmVuPExpbmtQcm9wcz4pIHtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICBmdW5jdGlvbiBjcmVhdGVQcm9wRXJyb3IoYXJnczoge1xuICAgICAga2V5OiBzdHJpbmdcbiAgICAgIGV4cGVjdGVkOiBzdHJpbmdcbiAgICAgIGFjdHVhbDogc3RyaW5nXG4gICAgfSkge1xuICAgICAgcmV0dXJuIG5ldyBFcnJvcihcbiAgICAgICAgYEZhaWxlZCBwcm9wIHR5cGU6IFRoZSBwcm9wIFxcYCR7YXJncy5rZXl9XFxgIGV4cGVjdHMgYSAke2FyZ3MuZXhwZWN0ZWR9IGluIFxcYDxMaW5rPlxcYCwgYnV0IGdvdCBcXGAke2FyZ3MuYWN0dWFsfVxcYCBpbnN0ZWFkLmAgK1xuICAgICAgICAgICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJ1xuICAgICAgICAgICAgPyBcIlxcbk9wZW4geW91ciBicm93c2VyJ3MgY29uc29sZSB0byB2aWV3IHRoZSBDb21wb25lbnQgc3RhY2sgdHJhY2UuXCJcbiAgICAgICAgICAgIDogJycpXG4gICAgICApXG4gICAgfVxuXG4gICAgLy8gVHlwZVNjcmlwdCB0cmljayBmb3IgdHlwZS1ndWFyZGluZzpcbiAgICBjb25zdCByZXF1aXJlZFByb3BzR3VhcmQ6IFJlY29yZDxMaW5rUHJvcHNSZXF1aXJlZCwgdHJ1ZT4gPSB7XG4gICAgICBocmVmOiB0cnVlLFxuICAgIH0gYXMgY29uc3RcbiAgICBjb25zdCByZXF1aXJlZFByb3BzOiBMaW5rUHJvcHNSZXF1aXJlZFtdID0gT2JqZWN0LmtleXMoXG4gICAgICByZXF1aXJlZFByb3BzR3VhcmRcbiAgICApIGFzIExpbmtQcm9wc1JlcXVpcmVkW11cbiAgICByZXF1aXJlZFByb3BzLmZvckVhY2goKGtleTogTGlua1Byb3BzUmVxdWlyZWQpID0+IHtcbiAgICAgIGlmIChrZXkgPT09ICdocmVmJykge1xuICAgICAgICBpZiAoXG4gICAgICAgICAgcHJvcHNba2V5XSA9PSBudWxsIHx8XG4gICAgICAgICAgKHR5cGVvZiBwcm9wc1trZXldICE9PSAnc3RyaW5nJyAmJiB0eXBlb2YgcHJvcHNba2V5XSAhPT0gJ29iamVjdCcpXG4gICAgICAgICkge1xuICAgICAgICAgIHRocm93IGNyZWF0ZVByb3BFcnJvcih7XG4gICAgICAgICAgICBrZXksXG4gICAgICAgICAgICBleHBlY3RlZDogJ2BzdHJpbmdgIG9yIGBvYmplY3RgJyxcbiAgICAgICAgICAgIGFjdHVhbDogcHJvcHNba2V5XSA9PT0gbnVsbCA/ICdudWxsJyA6IHR5cGVvZiBwcm9wc1trZXldLFxuICAgICAgICAgIH0pXG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIFR5cGVTY3JpcHQgdHJpY2sgZm9yIHR5cGUtZ3VhcmRpbmc6XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW51c2VkLXZhcnNcbiAgICAgICAgY29uc3QgXzogbmV2ZXIgPSBrZXlcbiAgICAgIH1cbiAgICB9KVxuXG4gICAgLy8gVHlwZVNjcmlwdCB0cmljayBmb3IgdHlwZS1ndWFyZGluZzpcbiAgICBjb25zdCBvcHRpb25hbFByb3BzR3VhcmQ6IFJlY29yZDxMaW5rUHJvcHNPcHRpb25hbCwgdHJ1ZT4gPSB7XG4gICAgICBhczogdHJ1ZSxcbiAgICAgIHJlcGxhY2U6IHRydWUsXG4gICAgICBzY3JvbGw6IHRydWUsXG4gICAgICBzaGFsbG93OiB0cnVlLFxuICAgICAgcGFzc0hyZWY6IHRydWUsXG4gICAgICBwcmVmZXRjaDogdHJ1ZSxcbiAgICAgIGxvY2FsZTogdHJ1ZSxcbiAgICB9IGFzIGNvbnN0XG4gICAgY29uc3Qgb3B0aW9uYWxQcm9wczogTGlua1Byb3BzT3B0aW9uYWxbXSA9IE9iamVjdC5rZXlzKFxuICAgICAgb3B0aW9uYWxQcm9wc0d1YXJkXG4gICAgKSBhcyBMaW5rUHJvcHNPcHRpb25hbFtdXG4gICAgb3B0aW9uYWxQcm9wcy5mb3JFYWNoKChrZXk6IExpbmtQcm9wc09wdGlvbmFsKSA9PiB7XG4gICAgICBjb25zdCB2YWxUeXBlID0gdHlwZW9mIHByb3BzW2tleV1cblxuICAgICAgaWYgKGtleSA9PT0gJ2FzJykge1xuICAgICAgICBpZiAocHJvcHNba2V5XSAmJiB2YWxUeXBlICE9PSAnc3RyaW5nJyAmJiB2YWxUeXBlICE9PSAnb2JqZWN0Jykge1xuICAgICAgICAgIHRocm93IGNyZWF0ZVByb3BFcnJvcih7XG4gICAgICAgICAgICBrZXksXG4gICAgICAgICAgICBleHBlY3RlZDogJ2BzdHJpbmdgIG9yIGBvYmplY3RgJyxcbiAgICAgICAgICAgIGFjdHVhbDogdmFsVHlwZSxcbiAgICAgICAgICB9KVxuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGtleSA9PT0gJ2xvY2FsZScpIHtcbiAgICAgICAgaWYgKHByb3BzW2tleV0gJiYgdmFsVHlwZSAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICB0aHJvdyBjcmVhdGVQcm9wRXJyb3Ioe1xuICAgICAgICAgICAga2V5LFxuICAgICAgICAgICAgZXhwZWN0ZWQ6ICdgc3RyaW5nYCcsXG4gICAgICAgICAgICBhY3R1YWw6IHZhbFR5cGUsXG4gICAgICAgICAgfSlcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChcbiAgICAgICAga2V5ID09PSAncmVwbGFjZScgfHxcbiAgICAgICAga2V5ID09PSAnc2Nyb2xsJyB8fFxuICAgICAgICBrZXkgPT09ICdzaGFsbG93JyB8fFxuICAgICAgICBrZXkgPT09ICdwYXNzSHJlZicgfHxcbiAgICAgICAga2V5ID09PSAncHJlZmV0Y2gnXG4gICAgICApIHtcbiAgICAgICAgaWYgKHByb3BzW2tleV0gIT0gbnVsbCAmJiB2YWxUeXBlICE9PSAnYm9vbGVhbicpIHtcbiAgICAgICAgICB0aHJvdyBjcmVhdGVQcm9wRXJyb3Ioe1xuICAgICAgICAgICAga2V5LFxuICAgICAgICAgICAgZXhwZWN0ZWQ6ICdgYm9vbGVhbmAnLFxuICAgICAgICAgICAgYWN0dWFsOiB2YWxUeXBlLFxuICAgICAgICAgIH0pXG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIFR5cGVTY3JpcHQgdHJpY2sgZm9yIHR5cGUtZ3VhcmRpbmc6XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW51c2VkLXZhcnNcbiAgICAgICAgY29uc3QgXzogbmV2ZXIgPSBrZXlcbiAgICAgIH1cbiAgICB9KVxuXG4gICAgLy8gVGhpcyBob29rIGlzIGluIGEgY29uZGl0aW9uYWwgYnV0IHRoYXQgaXMgb2sgYmVjYXVzZSBgcHJvY2Vzcy5lbnYuTk9ERV9FTlZgIG5ldmVyIGNoYW5nZXNcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaG9va3MvcnVsZXMtb2YtaG9va3NcbiAgICBjb25zdCBoYXNXYXJuZWQgPSBSZWFjdC51c2VSZWYoZmFsc2UpXG4gICAgaWYgKHByb3BzLnByZWZldGNoICYmICFoYXNXYXJuZWQuY3VycmVudCkge1xuICAgICAgaGFzV2FybmVkLmN1cnJlbnQgPSB0cnVlXG4gICAgICBjb25zb2xlLndhcm4oXG4gICAgICAgICdOZXh0LmpzIGF1dG8tcHJlZmV0Y2hlcyBhdXRvbWF0aWNhbGx5IGJhc2VkIG9uIHZpZXdwb3J0LiBUaGUgcHJlZmV0Y2ggYXR0cmlidXRlIGlzIG5vIGxvbmdlciBuZWVkZWQuIE1vcmU6IGh0dHBzOi8vbmV4dGpzLm9yZy9kb2NzL21lc3NhZ2VzL3ByZWZldGNoLXRydWUtZGVwcmVjYXRlZCdcbiAgICAgIClcbiAgICB9XG4gIH1cbiAgY29uc3QgcCA9IHByb3BzLnByZWZldGNoICE9PSBmYWxzZVxuXG4gIGNvbnN0IHJvdXRlciA9IHVzZVJvdXRlcigpXG4gIGNvbnN0IHBhdGhuYW1lID0gKHJvdXRlciAmJiByb3V0ZXIuYXNQYXRoKSB8fCAnLydcblxuICBjb25zdCB7IGhyZWYsIGFzIH0gPSBSZWFjdC51c2VNZW1vKCgpID0+IHtcbiAgICBjb25zdCBbcmVzb2x2ZWRIcmVmLCByZXNvbHZlZEFzXSA9IHJlc29sdmVIcmVmKHBhdGhuYW1lLCBwcm9wcy5ocmVmLCB0cnVlKVxuICAgIHJldHVybiB7XG4gICAgICBocmVmOiByZXNvbHZlZEhyZWYsXG4gICAgICBhczogcHJvcHMuYXNcbiAgICAgICAgPyByZXNvbHZlSHJlZihwYXRobmFtZSwgcHJvcHMuYXMpXG4gICAgICAgIDogcmVzb2x2ZWRBcyB8fCByZXNvbHZlZEhyZWYsXG4gICAgfVxuICB9LCBbcGF0aG5hbWUsIHByb3BzLmhyZWYsIHByb3BzLmFzXSlcblxuICBsZXQgeyBjaGlsZHJlbiwgcmVwbGFjZSwgc2hhbGxvdywgc2Nyb2xsLCBsb2NhbGUgfSA9IHByb3BzXG5cbiAgLy8gRGVwcmVjYXRlZC4gV2FybmluZyBzaG93biBieSBwcm9wVHlwZSBjaGVjay4gSWYgdGhlIGNoaWxkcmVuIHByb3ZpZGVkIGlzIGEgc3RyaW5nICg8TGluaz5leGFtcGxlPC9MaW5rPikgd2Ugd3JhcCBpdCBpbiBhbiA8YT4gdGFnXG4gIGlmICh0eXBlb2YgY2hpbGRyZW4gPT09ICdzdHJpbmcnKSB7XG4gICAgY2hpbGRyZW4gPSA8YT57Y2hpbGRyZW59PC9hPlxuICB9XG5cbiAgLy8gVGhpcyB3aWxsIHJldHVybiB0aGUgZmlyc3QgY2hpbGQsIGlmIG11bHRpcGxlIGFyZSBwcm92aWRlZCBpdCB3aWxsIHRocm93IGFuIGVycm9yXG4gIGNvbnN0IGNoaWxkOiBhbnkgPSBDaGlsZHJlbi5vbmx5KGNoaWxkcmVuKVxuICBjb25zdCBjaGlsZFJlZjogYW55ID0gY2hpbGQgJiYgdHlwZW9mIGNoaWxkID09PSAnb2JqZWN0JyAmJiBjaGlsZC5yZWZcblxuICBjb25zdCBbc2V0SW50ZXJzZWN0aW9uUmVmLCBpc1Zpc2libGVdID0gdXNlSW50ZXJzZWN0aW9uKHtcbiAgICByb290TWFyZ2luOiAnMjAwcHgnLFxuICB9KVxuICBjb25zdCBzZXRSZWYgPSBSZWFjdC51c2VDYWxsYmFjayhcbiAgICAoZWw6IEVsZW1lbnQpID0+IHtcbiAgICAgIHNldEludGVyc2VjdGlvblJlZihlbClcbiAgICAgIGlmIChjaGlsZFJlZikge1xuICAgICAgICBpZiAodHlwZW9mIGNoaWxkUmVmID09PSAnZnVuY3Rpb24nKSBjaGlsZFJlZihlbClcbiAgICAgICAgZWxzZSBpZiAodHlwZW9mIGNoaWxkUmVmID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgIGNoaWxkUmVmLmN1cnJlbnQgPSBlbFxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICBbY2hpbGRSZWYsIHNldEludGVyc2VjdGlvblJlZl1cbiAgKVxuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGNvbnN0IHNob3VsZFByZWZldGNoID0gaXNWaXNpYmxlICYmIHAgJiYgaXNMb2NhbFVSTChocmVmKVxuICAgIGNvbnN0IGN1ckxvY2FsZSA9XG4gICAgICB0eXBlb2YgbG9jYWxlICE9PSAndW5kZWZpbmVkJyA/IGxvY2FsZSA6IHJvdXRlciAmJiByb3V0ZXIubG9jYWxlXG4gICAgY29uc3QgaXNQcmVmZXRjaGVkID1cbiAgICAgIHByZWZldGNoZWRbaHJlZiArICclJyArIGFzICsgKGN1ckxvY2FsZSA/ICclJyArIGN1ckxvY2FsZSA6ICcnKV1cbiAgICBpZiAoc2hvdWxkUHJlZmV0Y2ggJiYgIWlzUHJlZmV0Y2hlZCkge1xuICAgICAgcHJlZmV0Y2gocm91dGVyLCBocmVmLCBhcywge1xuICAgICAgICBsb2NhbGU6IGN1ckxvY2FsZSxcbiAgICAgIH0pXG4gICAgfVxuICB9LCBbYXMsIGhyZWYsIGlzVmlzaWJsZSwgbG9jYWxlLCBwLCByb3V0ZXJdKVxuXG4gIGNvbnN0IGNoaWxkUHJvcHM6IHtcbiAgICBvbk1vdXNlRW50ZXI/OiBSZWFjdC5Nb3VzZUV2ZW50SGFuZGxlclxuICAgIG9uQ2xpY2s6IFJlYWN0Lk1vdXNlRXZlbnRIYW5kbGVyXG4gICAgaHJlZj86IHN0cmluZ1xuICAgIHJlZj86IGFueVxuICB9ID0ge1xuICAgIHJlZjogc2V0UmVmLFxuICAgIG9uQ2xpY2s6IChlOiBSZWFjdC5Nb3VzZUV2ZW50KSA9PiB7XG4gICAgICBpZiAoY2hpbGQucHJvcHMgJiYgdHlwZW9mIGNoaWxkLnByb3BzLm9uQ2xpY2sgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgY2hpbGQucHJvcHMub25DbGljayhlKVxuICAgICAgfVxuICAgICAgaWYgKCFlLmRlZmF1bHRQcmV2ZW50ZWQpIHtcbiAgICAgICAgbGlua0NsaWNrZWQoZSwgcm91dGVyLCBocmVmLCBhcywgcmVwbGFjZSwgc2hhbGxvdywgc2Nyb2xsLCBsb2NhbGUpXG4gICAgICB9XG4gICAgfSxcbiAgfVxuXG4gIGNoaWxkUHJvcHMub25Nb3VzZUVudGVyID0gKGU6IFJlYWN0Lk1vdXNlRXZlbnQpID0+IHtcbiAgICBpZiAoIWlzTG9jYWxVUkwoaHJlZikpIHJldHVyblxuICAgIGlmIChjaGlsZC5wcm9wcyAmJiB0eXBlb2YgY2hpbGQucHJvcHMub25Nb3VzZUVudGVyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBjaGlsZC5wcm9wcy5vbk1vdXNlRW50ZXIoZSlcbiAgICB9XG4gICAgcHJlZmV0Y2gocm91dGVyLCBocmVmLCBhcywgeyBwcmlvcml0eTogdHJ1ZSB9KVxuICB9XG5cbiAgLy8gSWYgY2hpbGQgaXMgYW4gPGE+IHRhZyBhbmQgZG9lc24ndCBoYXZlIGEgaHJlZiBhdHRyaWJ1dGUsIG9yIGlmIHRoZSAncGFzc0hyZWYnIHByb3BlcnR5IGlzXG4gIC8vIGRlZmluZWQsIHdlIHNwZWNpZnkgdGhlIGN1cnJlbnQgJ2hyZWYnLCBzbyB0aGF0IHJlcGV0aXRpb24gaXMgbm90IG5lZWRlZCBieSB0aGUgdXNlclxuICBpZiAocHJvcHMucGFzc0hyZWYgfHwgKGNoaWxkLnR5cGUgPT09ICdhJyAmJiAhKCdocmVmJyBpbiBjaGlsZC5wcm9wcykpKSB7XG4gICAgY29uc3QgY3VyTG9jYWxlID1cbiAgICAgIHR5cGVvZiBsb2NhbGUgIT09ICd1bmRlZmluZWQnID8gbG9jYWxlIDogcm91dGVyICYmIHJvdXRlci5sb2NhbGVcblxuICAgIC8vIHdlIG9ubHkgcmVuZGVyIGRvbWFpbiBsb2NhbGVzIGlmIHdlIGFyZSBjdXJyZW50bHkgb24gYSBkb21haW4gbG9jYWxlXG4gICAgLy8gc28gdGhhdCBsb2NhbGUgbGlua3MgYXJlIHN0aWxsIHZpc2l0YWJsZSBpbiBkZXZlbG9wbWVudC9wcmV2aWV3IGVudnNcbiAgICBjb25zdCBsb2NhbGVEb21haW4gPVxuICAgICAgcm91dGVyICYmXG4gICAgICByb3V0ZXIuaXNMb2NhbGVEb21haW4gJiZcbiAgICAgIGdldERvbWFpbkxvY2FsZShcbiAgICAgICAgYXMsXG4gICAgICAgIGN1ckxvY2FsZSxcbiAgICAgICAgcm91dGVyICYmIHJvdXRlci5sb2NhbGVzLFxuICAgICAgICByb3V0ZXIgJiYgcm91dGVyLmRvbWFpbkxvY2FsZXNcbiAgICAgIClcblxuICAgIGNoaWxkUHJvcHMuaHJlZiA9XG4gICAgICBsb2NhbGVEb21haW4gfHxcbiAgICAgIGFkZEJhc2VQYXRoKGFkZExvY2FsZShhcywgY3VyTG9jYWxlLCByb3V0ZXIgJiYgcm91dGVyLmRlZmF1bHRMb2NhbGUpKVxuICB9XG5cbiAgcmV0dXJuIFJlYWN0LmNsb25lRWxlbWVudChjaGlsZCwgY2hpbGRQcm9wcylcbn1cblxuZXhwb3J0IGRlZmF1bHQgTGlua1xuIiwiLyoqXG4gKiBSZW1vdmVzIHRoZSB0cmFpbGluZyBzbGFzaCBvZiBhIHBhdGggaWYgdGhlcmUgaXMgb25lLiBQcmVzZXJ2ZXMgdGhlIHJvb3QgcGF0aCBgL2AuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiByZW1vdmVQYXRoVHJhaWxpbmdTbGFzaChwYXRoOiBzdHJpbmcpOiBzdHJpbmcge1xuICByZXR1cm4gcGF0aC5lbmRzV2l0aCgnLycpICYmIHBhdGggIT09ICcvJyA/IHBhdGguc2xpY2UoMCwgLTEpIDogcGF0aFxufVxuXG4vKipcbiAqIE5vcm1hbGl6ZXMgdGhlIHRyYWlsaW5nIHNsYXNoIG9mIGEgcGF0aCBhY2NvcmRpbmcgdG8gdGhlIGB0cmFpbGluZ1NsYXNoYCBvcHRpb25cbiAqIGluIGBuZXh0LmNvbmZpZy5qc2AuXG4gKi9cbmV4cG9ydCBjb25zdCBub3JtYWxpemVQYXRoVHJhaWxpbmdTbGFzaCA9IHByb2Nlc3MuZW52Ll9fTkVYVF9UUkFJTElOR19TTEFTSFxuICA/IChwYXRoOiBzdHJpbmcpOiBzdHJpbmcgPT4ge1xuICAgICAgaWYgKC9cXC5bXi9dK1xcLz8kLy50ZXN0KHBhdGgpKSB7XG4gICAgICAgIHJldHVybiByZW1vdmVQYXRoVHJhaWxpbmdTbGFzaChwYXRoKVxuICAgICAgfSBlbHNlIGlmIChwYXRoLmVuZHNXaXRoKCcvJykpIHtcbiAgICAgICAgcmV0dXJuIHBhdGhcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBwYXRoICsgJy8nXG4gICAgICB9XG4gICAgfVxuICA6IHJlbW92ZVBhdGhUcmFpbGluZ1NsYXNoXG4iLCJ0eXBlIFJlcXVlc3RJZGxlQ2FsbGJhY2tIYW5kbGUgPSBhbnlcbnR5cGUgUmVxdWVzdElkbGVDYWxsYmFja09wdGlvbnMgPSB7XG4gIHRpbWVvdXQ6IG51bWJlclxufVxudHlwZSBSZXF1ZXN0SWRsZUNhbGxiYWNrRGVhZGxpbmUgPSB7XG4gIHJlYWRvbmx5IGRpZFRpbWVvdXQ6IGJvb2xlYW5cbiAgdGltZVJlbWFpbmluZzogKCkgPT4gbnVtYmVyXG59XG5cbmRlY2xhcmUgZ2xvYmFsIHtcbiAgaW50ZXJmYWNlIFdpbmRvdyB7XG4gICAgcmVxdWVzdElkbGVDYWxsYmFjazogKFxuICAgICAgY2FsbGJhY2s6IChkZWFkbGluZTogUmVxdWVzdElkbGVDYWxsYmFja0RlYWRsaW5lKSA9PiB2b2lkLFxuICAgICAgb3B0cz86IFJlcXVlc3RJZGxlQ2FsbGJhY2tPcHRpb25zXG4gICAgKSA9PiBSZXF1ZXN0SWRsZUNhbGxiYWNrSGFuZGxlXG4gICAgY2FuY2VsSWRsZUNhbGxiYWNrOiAoaWQ6IFJlcXVlc3RJZGxlQ2FsbGJhY2tIYW5kbGUpID0+IHZvaWRcbiAgfVxufVxuXG5leHBvcnQgY29uc3QgcmVxdWVzdElkbGVDYWxsYmFjayA9XG4gICh0eXBlb2Ygc2VsZiAhPT0gJ3VuZGVmaW5lZCcgJiYgc2VsZi5yZXF1ZXN0SWRsZUNhbGxiYWNrKSB8fFxuICBmdW5jdGlvbiAoXG4gICAgY2I6IChkZWFkbGluZTogUmVxdWVzdElkbGVDYWxsYmFja0RlYWRsaW5lKSA9PiB2b2lkXG4gICk6IE5vZGVKUy5UaW1lb3V0IHtcbiAgICBsZXQgc3RhcnQgPSBEYXRlLm5vdygpXG4gICAgcmV0dXJuIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgY2Ioe1xuICAgICAgICBkaWRUaW1lb3V0OiBmYWxzZSxcbiAgICAgICAgdGltZVJlbWFpbmluZzogZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHJldHVybiBNYXRoLm1heCgwLCA1MCAtIChEYXRlLm5vdygpIC0gc3RhcnQpKVxuICAgICAgICB9LFxuICAgICAgfSlcbiAgICB9LCAxKVxuICB9XG5cbmV4cG9ydCBjb25zdCBjYW5jZWxJZGxlQ2FsbGJhY2sgPVxuICAodHlwZW9mIHNlbGYgIT09ICd1bmRlZmluZWQnICYmIHNlbGYuY2FuY2VsSWRsZUNhbGxiYWNrKSB8fFxuICBmdW5jdGlvbiAoaWQ6IFJlcXVlc3RJZGxlQ2FsbGJhY2tIYW5kbGUpIHtcbiAgICByZXR1cm4gY2xlYXJUaW1lb3V0KGlkKVxuICB9XG4iLCJpbXBvcnQgeyBDb21wb25lbnRUeXBlIH0gZnJvbSAncmVhY3QnXG5pbXBvcnQgeyBDbGllbnRCdWlsZE1hbmlmZXN0IH0gZnJvbSAnLi4vYnVpbGQvd2VicGFjay9wbHVnaW5zL2J1aWxkLW1hbmlmZXN0LXBsdWdpbidcbmltcG9ydCBnZXRBc3NldFBhdGhGcm9tUm91dGUgZnJvbSAnLi4vbmV4dC1zZXJ2ZXIvbGliL3JvdXRlci91dGlscy9nZXQtYXNzZXQtcGF0aC1mcm9tLXJvdXRlJ1xuaW1wb3J0IHsgcmVxdWVzdElkbGVDYWxsYmFjayB9IGZyb20gJy4vcmVxdWVzdC1pZGxlLWNhbGxiYWNrJ1xuXG4vLyAzLjhzIHdhcyBhcmJpdHJhcmlseSBjaG9zZW4gYXMgaXQncyB3aGF0IGh0dHBzOi8vd2ViLmRldi9pbnRlcmFjdGl2ZVxuLy8gY29uc2lkZXJzIGFzIFwiR29vZFwiIHRpbWUtdG8taW50ZXJhY3RpdmUuIFdlIG11c3QgYXNzdW1lIHNvbWV0aGluZyB3ZW50XG4vLyB3cm9uZyBiZXlvbmQgdGhpcyBwb2ludCwgYW5kIHRoZW4gZmFsbC1iYWNrIHRvIGEgZnVsbCBwYWdlIHRyYW5zaXRpb24gdG9cbi8vIHNob3cgdGhlIHVzZXIgc29tZXRoaW5nIG9mIHZhbHVlLlxuY29uc3QgTVNfTUFYX0lETEVfREVMQVkgPSAzODAwXG5cbmRlY2xhcmUgZ2xvYmFsIHtcbiAgaW50ZXJmYWNlIFdpbmRvdyB7XG4gICAgX19CVUlMRF9NQU5JRkVTVD86IENsaWVudEJ1aWxkTWFuaWZlc3RcbiAgICBfX0JVSUxEX01BTklGRVNUX0NCPzogRnVuY3Rpb25cbiAgfVxufVxuXG5leHBvcnQgaW50ZXJmYWNlIExvYWRlZEVudHJ5cG9pbnRTdWNjZXNzIHtcbiAgY29tcG9uZW50OiBDb21wb25lbnRUeXBlXG4gIGV4cG9ydHM6IGFueVxufVxuZXhwb3J0IGludGVyZmFjZSBMb2FkZWRFbnRyeXBvaW50RmFpbHVyZSB7XG4gIGVycm9yOiB1bmtub3duXG59XG5leHBvcnQgdHlwZSBSb3V0ZUVudHJ5cG9pbnQgPSBMb2FkZWRFbnRyeXBvaW50U3VjY2VzcyB8IExvYWRlZEVudHJ5cG9pbnRGYWlsdXJlXG5cbmV4cG9ydCBpbnRlcmZhY2UgUm91dGVTdHlsZVNoZWV0IHtcbiAgaHJlZjogc3RyaW5nXG4gIGNvbnRlbnQ6IHN0cmluZ1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIExvYWRlZFJvdXRlU3VjY2VzcyBleHRlbmRzIExvYWRlZEVudHJ5cG9pbnRTdWNjZXNzIHtcbiAgc3R5bGVzOiBSb3V0ZVN0eWxlU2hlZXRbXVxufVxuZXhwb3J0IGludGVyZmFjZSBMb2FkZWRSb3V0ZUZhaWx1cmUge1xuICBlcnJvcjogdW5rbm93blxufVxuZXhwb3J0IHR5cGUgUm91dGVMb2FkZXJFbnRyeSA9IExvYWRlZFJvdXRlU3VjY2VzcyB8IExvYWRlZFJvdXRlRmFpbHVyZVxuXG5leHBvcnQgdHlwZSBGdXR1cmU8Vj4gPSB7XG4gIHJlc29sdmU6IChlbnRyeXBvaW50OiBWKSA9PiB2b2lkXG4gIGZ1dHVyZTogUHJvbWlzZTxWPlxufVxuZnVuY3Rpb24gd2l0aEZ1dHVyZTxUPihcbiAga2V5OiBzdHJpbmcsXG4gIG1hcDogTWFwPHN0cmluZywgRnV0dXJlPFQ+IHwgVD4sXG4gIGdlbmVyYXRvcj86ICgpID0+IFByb21pc2U8VD5cbik6IFByb21pc2U8VD4ge1xuICBsZXQgZW50cnk6IEZ1dHVyZTxUPiB8IFQgfCB1bmRlZmluZWQgPSBtYXAuZ2V0KGtleSlcbiAgaWYgKGVudHJ5KSB7XG4gICAgaWYgKCdmdXR1cmUnIGluIGVudHJ5KSB7XG4gICAgICByZXR1cm4gZW50cnkuZnV0dXJlXG4gICAgfVxuICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoZW50cnkpXG4gIH1cbiAgbGV0IHJlc29sdmVyOiAoZW50cnlwb2ludDogVCkgPT4gdm9pZFxuICBjb25zdCBwcm9tOiBQcm9taXNlPFQ+ID0gbmV3IFByb21pc2U8VD4oKHJlc29sdmUpID0+IHtcbiAgICByZXNvbHZlciA9IHJlc29sdmVcbiAgfSlcbiAgbWFwLnNldChrZXksIChlbnRyeSA9IHsgcmVzb2x2ZTogcmVzb2x2ZXIhLCBmdXR1cmU6IHByb20gfSkpXG4gIHJldHVybiBnZW5lcmF0b3JcbiAgICA/IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1zZXF1ZW5jZXNcbiAgICAgIGdlbmVyYXRvcigpLnRoZW4oKHZhbHVlKSA9PiAocmVzb2x2ZXIodmFsdWUpLCB2YWx1ZSkpXG4gICAgOiBwcm9tXG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgUm91dGVMb2FkZXIge1xuICB3aGVuRW50cnlwb2ludChyb3V0ZTogc3RyaW5nKTogUHJvbWlzZTxSb3V0ZUVudHJ5cG9pbnQ+XG4gIG9uRW50cnlwb2ludChyb3V0ZTogc3RyaW5nLCBleGVjdXRlOiAoKSA9PiB1bmtub3duKTogdm9pZFxuICBsb2FkUm91dGUocm91dGU6IHN0cmluZywgcHJlZmV0Y2g/OiBib29sZWFuKTogUHJvbWlzZTxSb3V0ZUxvYWRlckVudHJ5PlxuICBwcmVmZXRjaChyb3V0ZTogc3RyaW5nKTogUHJvbWlzZTx2b2lkPlxufVxuXG5mdW5jdGlvbiBoYXNQcmVmZXRjaChsaW5rPzogSFRNTExpbmtFbGVtZW50KTogYm9vbGVhbiB7XG4gIHRyeSB7XG4gICAgbGluayA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2xpbmsnKVxuICAgIHJldHVybiAoXG4gICAgICAvLyBkZXRlY3QgSUUxMSBzaW5jZSBpdCBzdXBwb3J0cyBwcmVmZXRjaCBidXQgaXNuJ3QgZGV0ZWN0ZWRcbiAgICAgIC8vIHdpdGggcmVsTGlzdC5zdXBwb3J0XG4gICAgICAoISF3aW5kb3cuTVNJbnB1dE1ldGhvZENvbnRleHQgJiYgISEoZG9jdW1lbnQgYXMgYW55KS5kb2N1bWVudE1vZGUpIHx8XG4gICAgICBsaW5rLnJlbExpc3Quc3VwcG9ydHMoJ3ByZWZldGNoJylcbiAgICApXG4gIH0gY2F0Y2gge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG59XG5cbmNvbnN0IGNhblByZWZldGNoOiBib29sZWFuID0gaGFzUHJlZmV0Y2goKVxuXG5mdW5jdGlvbiBwcmVmZXRjaFZpYURvbShcbiAgaHJlZjogc3RyaW5nLFxuICBhczogc3RyaW5nLFxuICBsaW5rPzogSFRNTExpbmtFbGVtZW50XG4pOiBQcm9taXNlPGFueT4ge1xuICByZXR1cm4gbmV3IFByb21pc2UoKHJlcywgcmVqKSA9PiB7XG4gICAgaWYgKGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoYGxpbmtbcmVsPVwicHJlZmV0Y2hcIl1baHJlZl49XCIke2hyZWZ9XCJdYCkpIHtcbiAgICAgIHJldHVybiByZXMoKVxuICAgIH1cblxuICAgIGxpbmsgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdsaW5rJylcblxuICAgIC8vIFRoZSBvcmRlciBvZiBwcm9wZXJ0eSBhc3NpZ25tZW50IGhlcmUgaXMgaW50ZW50aW9uYWw6XG4gICAgaWYgKGFzKSBsaW5rIS5hcyA9IGFzXG4gICAgbGluayEucmVsID0gYHByZWZldGNoYFxuICAgIGxpbmshLmNyb3NzT3JpZ2luID0gcHJvY2Vzcy5lbnYuX19ORVhUX0NST1NTX09SSUdJTiFcbiAgICBsaW5rIS5vbmxvYWQgPSByZXNcbiAgICBsaW5rIS5vbmVycm9yID0gcmVqXG5cbiAgICAvLyBgaHJlZmAgc2hvdWxkIGFsd2F5cyBiZSBsYXN0OlxuICAgIGxpbmshLmhyZWYgPSBocmVmXG5cbiAgICBkb2N1bWVudC5oZWFkLmFwcGVuZENoaWxkKGxpbmspXG4gIH0pXG59XG5cbmNvbnN0IEFTU0VUX0xPQURfRVJST1IgPSBTeW1ib2woJ0FTU0VUX0xPQURfRVJST1InKVxuLy8gVE9ETzogdW5leHBvcnRcbmV4cG9ydCBmdW5jdGlvbiBtYXJrQXNzZXRFcnJvcihlcnI6IEVycm9yKTogRXJyb3Ige1xuICByZXR1cm4gT2JqZWN0LmRlZmluZVByb3BlcnR5KGVyciwgQVNTRVRfTE9BRF9FUlJPUiwge30pXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBpc0Fzc2V0RXJyb3IoZXJyPzogRXJyb3IpOiBib29sZWFuIHwgdW5kZWZpbmVkIHtcbiAgcmV0dXJuIGVyciAmJiBBU1NFVF9MT0FEX0VSUk9SIGluIGVyclxufVxuXG5mdW5jdGlvbiBhcHBlbmRTY3JpcHQoXG4gIHNyYzogc3RyaW5nLFxuICBzY3JpcHQ/OiBIVE1MU2NyaXB0RWxlbWVudFxuKTogUHJvbWlzZTx1bmtub3duPiB7XG4gIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgc2NyaXB0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc2NyaXB0JylcblxuICAgIC8vIFRoZSBvcmRlciBvZiBwcm9wZXJ0eSBhc3NpZ25tZW50IGhlcmUgaXMgaW50ZW50aW9uYWwuXG4gICAgLy8gMS4gU2V0dXAgc3VjY2Vzcy9mYWlsdXJlIGhvb2tzIGluIGNhc2UgdGhlIGJyb3dzZXIgc3luY2hyb25vdXNseVxuICAgIC8vICAgIGV4ZWN1dGVzIHdoZW4gYHNyY2AgaXMgc2V0LlxuICAgIHNjcmlwdC5vbmxvYWQgPSByZXNvbHZlXG4gICAgc2NyaXB0Lm9uZXJyb3IgPSAoKSA9PlxuICAgICAgcmVqZWN0KG1hcmtBc3NldEVycm9yKG5ldyBFcnJvcihgRmFpbGVkIHRvIGxvYWQgc2NyaXB0OiAke3NyY31gKSkpXG5cbiAgICAvLyAyLiBDb25maWd1cmUgdGhlIGNyb3NzLW9yaWdpbiBhdHRyaWJ1dGUgYmVmb3JlIHNldHRpbmcgYHNyY2AgaW4gY2FzZSB0aGVcbiAgICAvLyAgICBicm93c2VyIGJlZ2lucyB0byBmZXRjaC5cbiAgICBzY3JpcHQuY3Jvc3NPcmlnaW4gPSBwcm9jZXNzLmVudi5fX05FWFRfQ1JPU1NfT1JJR0lOIVxuXG4gICAgLy8gMy4gRmluYWxseSwgc2V0IHRoZSBzb3VyY2UgYW5kIGluamVjdCBpbnRvIHRoZSBET00gaW4gY2FzZSB0aGUgY2hpbGRcbiAgICAvLyAgICBtdXN0IGJlIGFwcGVuZGVkIGZvciBmZXRjaGluZyB0byBzdGFydC5cbiAgICBzY3JpcHQuc3JjID0gc3JjXG4gICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChzY3JpcHQpXG4gIH0pXG59XG5cbi8vIFJlc29sdmUgYSBwcm9taXNlIHRoYXQgdGltZXMgb3V0IGFmdGVyIGdpdmVuIGFtb3VudCBvZiBtaWxsaXNlY29uZHMuXG5mdW5jdGlvbiByZXNvbHZlUHJvbWlzZVdpdGhUaW1lb3V0PFQ+KFxuICBwOiBQcm9taXNlPFQ+LFxuICBtczogbnVtYmVyLFxuICBlcnI6IEVycm9yXG4pOiBQcm9taXNlPFQ+IHtcbiAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICBsZXQgY2FuY2VsbGVkID0gZmFsc2VcblxuICAgIHAudGhlbigocikgPT4ge1xuICAgICAgLy8gUmVzb2x2ZWQsIGNhbmNlbCB0aGUgdGltZW91dFxuICAgICAgY2FuY2VsbGVkID0gdHJ1ZVxuICAgICAgcmVzb2x2ZShyKVxuICAgIH0pLmNhdGNoKHJlamVjdClcblxuICAgIHJlcXVlc3RJZGxlQ2FsbGJhY2soKCkgPT5cbiAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICBpZiAoIWNhbmNlbGxlZCkge1xuICAgICAgICAgIHJlamVjdChlcnIpXG4gICAgICAgIH1cbiAgICAgIH0sIG1zKVxuICAgIClcbiAgfSlcbn1cblxuLy8gVE9ETzogc3RvcCBleHBvcnRpbmcgb3IgY2FjaGUgdGhlIGZhaWx1cmVcbi8vIEl0J2QgYmUgYmVzdCB0byBzdG9wIGV4cG9ydGluZyB0aGlzLiBJdCdzIGFuIGltcGxlbWVudGF0aW9uIGRldGFpbC4gV2UncmVcbi8vIG9ubHkgZXhwb3J0aW5nIGl0IGZvciBiYWNrd2FyZHMgY29tcGF0aWJpbHR5IHdpdGggdGhlIGBwYWdlLWxvYWRlcmAuXG4vLyBPbmx5IGNhY2hlIHRoaXMgcmVzcG9uc2UgYXMgYSBsYXN0IHJlc29ydCBpZiB3ZSBjYW5ub3QgZWxpbWluYXRlIGFsbCBvdGhlclxuLy8gY29kZSBicmFuY2hlcyB0aGF0IHVzZSB0aGUgQnVpbGQgTWFuaWZlc3QgQ2FsbGJhY2sgYW5kIHB1c2ggdGhlbSB0aHJvdWdoXG4vLyB0aGUgUm91dGUgTG9hZGVyIGludGVyZmFjZS5cbmV4cG9ydCBmdW5jdGlvbiBnZXRDbGllbnRCdWlsZE1hbmlmZXN0KCk6IFByb21pc2U8Q2xpZW50QnVpbGRNYW5pZmVzdD4ge1xuICBpZiAoc2VsZi5fX0JVSUxEX01BTklGRVNUKSB7XG4gICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShzZWxmLl9fQlVJTERfTUFOSUZFU1QpXG4gIH1cblxuICBjb25zdCBvbkJ1aWxkTWFuaWZlc3Q6IFByb21pc2U8Q2xpZW50QnVpbGRNYW5pZmVzdD4gPSBuZXcgUHJvbWlzZTxcbiAgICBDbGllbnRCdWlsZE1hbmlmZXN0XG4gID4oKHJlc29sdmUpID0+IHtcbiAgICAvLyBNYW5kYXRvcnkgYmVjYXVzZSB0aGlzIGlzIG5vdCBjb25jdXJyZW50IHNhZmU6XG4gICAgY29uc3QgY2IgPSBzZWxmLl9fQlVJTERfTUFOSUZFU1RfQ0JcbiAgICBzZWxmLl9fQlVJTERfTUFOSUZFU1RfQ0IgPSAoKSA9PiB7XG4gICAgICByZXNvbHZlKHNlbGYuX19CVUlMRF9NQU5JRkVTVCEpXG4gICAgICBjYiAmJiBjYigpXG4gICAgfVxuICB9KVxuXG4gIHJldHVybiByZXNvbHZlUHJvbWlzZVdpdGhUaW1lb3V0PENsaWVudEJ1aWxkTWFuaWZlc3Q+KFxuICAgIG9uQnVpbGRNYW5pZmVzdCxcbiAgICBNU19NQVhfSURMRV9ERUxBWSxcbiAgICBtYXJrQXNzZXRFcnJvcihuZXcgRXJyb3IoJ0ZhaWxlZCB0byBsb2FkIGNsaWVudCBidWlsZCBtYW5pZmVzdCcpKVxuICApXG59XG5cbmludGVyZmFjZSBSb3V0ZUZpbGVzIHtcbiAgc2NyaXB0czogc3RyaW5nW11cbiAgY3NzOiBzdHJpbmdbXVxufVxuZnVuY3Rpb24gZ2V0RmlsZXNGb3JSb3V0ZShcbiAgYXNzZXRQcmVmaXg6IHN0cmluZyxcbiAgcm91dGU6IHN0cmluZ1xuKTogUHJvbWlzZTxSb3V0ZUZpbGVzPiB7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ2RldmVsb3BtZW50Jykge1xuICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoe1xuICAgICAgc2NyaXB0czogW1xuICAgICAgICBhc3NldFByZWZpeCArXG4gICAgICAgICAgJy9fbmV4dC9zdGF0aWMvY2h1bmtzL3BhZ2VzJyArXG4gICAgICAgICAgZW5jb2RlVVJJKGdldEFzc2V0UGF0aEZyb21Sb3V0ZShyb3V0ZSwgJy5qcycpKSxcbiAgICAgIF0sXG4gICAgICAvLyBTdHlsZXMgYXJlIGhhbmRsZWQgYnkgYHN0eWxlLWxvYWRlcmAgaW4gZGV2ZWxvcG1lbnQ6XG4gICAgICBjc3M6IFtdLFxuICAgIH0pXG4gIH1cbiAgcmV0dXJuIGdldENsaWVudEJ1aWxkTWFuaWZlc3QoKS50aGVuKChtYW5pZmVzdCkgPT4ge1xuICAgIGlmICghKHJvdXRlIGluIG1hbmlmZXN0KSkge1xuICAgICAgdGhyb3cgbWFya0Fzc2V0RXJyb3IobmV3IEVycm9yKGBGYWlsZWQgdG8gbG9va3VwIHJvdXRlOiAke3JvdXRlfWApKVxuICAgIH1cbiAgICBjb25zdCBhbGxGaWxlcyA9IG1hbmlmZXN0W3JvdXRlXS5tYXAoXG4gICAgICAoZW50cnkpID0+IGFzc2V0UHJlZml4ICsgJy9fbmV4dC8nICsgZW5jb2RlVVJJKGVudHJ5KVxuICAgIClcbiAgICByZXR1cm4ge1xuICAgICAgc2NyaXB0czogYWxsRmlsZXMuZmlsdGVyKCh2KSA9PiB2LmVuZHNXaXRoKCcuanMnKSksXG4gICAgICBjc3M6IGFsbEZpbGVzLmZpbHRlcigodikgPT4gdi5lbmRzV2l0aCgnLmNzcycpKSxcbiAgICB9XG4gIH0pXG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVJvdXRlTG9hZGVyKGFzc2V0UHJlZml4OiBzdHJpbmcpOiBSb3V0ZUxvYWRlciB7XG4gIGNvbnN0IGVudHJ5cG9pbnRzOiBNYXA8XG4gICAgc3RyaW5nLFxuICAgIEZ1dHVyZTxSb3V0ZUVudHJ5cG9pbnQ+IHwgUm91dGVFbnRyeXBvaW50XG4gID4gPSBuZXcgTWFwKClcbiAgY29uc3QgbG9hZGVkU2NyaXB0czogTWFwPHN0cmluZywgUHJvbWlzZTx1bmtub3duPj4gPSBuZXcgTWFwKClcbiAgY29uc3Qgc3R5bGVTaGVldHM6IE1hcDxzdHJpbmcsIFByb21pc2U8Um91dGVTdHlsZVNoZWV0Pj4gPSBuZXcgTWFwKClcbiAgY29uc3Qgcm91dGVzOiBNYXA8XG4gICAgc3RyaW5nLFxuICAgIEZ1dHVyZTxSb3V0ZUxvYWRlckVudHJ5PiB8IFJvdXRlTG9hZGVyRW50cnlcbiAgPiA9IG5ldyBNYXAoKVxuXG4gIGZ1bmN0aW9uIG1heWJlRXhlY3V0ZVNjcmlwdChzcmM6IHN0cmluZyk6IFByb21pc2U8dW5rbm93bj4ge1xuICAgIGxldCBwcm9tOiBQcm9taXNlPHVua25vd24+IHwgdW5kZWZpbmVkID0gbG9hZGVkU2NyaXB0cy5nZXQoc3JjKVxuICAgIGlmIChwcm9tKSB7XG4gICAgICByZXR1cm4gcHJvbVxuICAgIH1cblxuICAgIC8vIFNraXAgZXhlY3V0aW5nIHNjcmlwdCBpZiBpdCdzIGFscmVhZHkgaW4gdGhlIERPTTpcbiAgICBpZiAoZG9jdW1lbnQucXVlcnlTZWxlY3Rvcihgc2NyaXB0W3NyY149XCIke3NyY31cIl1gKSkge1xuICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpXG4gICAgfVxuXG4gICAgbG9hZGVkU2NyaXB0cy5zZXQoc3JjLCAocHJvbSA9IGFwcGVuZFNjcmlwdChzcmMpKSlcbiAgICByZXR1cm4gcHJvbVxuICB9XG5cbiAgZnVuY3Rpb24gZmV0Y2hTdHlsZVNoZWV0KGhyZWY6IHN0cmluZyk6IFByb21pc2U8Um91dGVTdHlsZVNoZWV0PiB7XG4gICAgbGV0IHByb206IFByb21pc2U8Um91dGVTdHlsZVNoZWV0PiB8IHVuZGVmaW5lZCA9IHN0eWxlU2hlZXRzLmdldChocmVmKVxuICAgIGlmIChwcm9tKSB7XG4gICAgICByZXR1cm4gcHJvbVxuICAgIH1cblxuICAgIHN0eWxlU2hlZXRzLnNldChcbiAgICAgIGhyZWYsXG4gICAgICAocHJvbSA9IGZldGNoKGhyZWYpXG4gICAgICAgIC50aGVuKChyZXMpID0+IHtcbiAgICAgICAgICBpZiAoIXJlcy5vaykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBGYWlsZWQgdG8gbG9hZCBzdHlsZXNoZWV0OiAke2hyZWZ9YClcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHJlcy50ZXh0KCkudGhlbigodGV4dCkgPT4gKHsgaHJlZjogaHJlZiwgY29udGVudDogdGV4dCB9KSlcbiAgICAgICAgfSlcbiAgICAgICAgLmNhdGNoKChlcnIpID0+IHtcbiAgICAgICAgICB0aHJvdyBtYXJrQXNzZXRFcnJvcihlcnIpXG4gICAgICAgIH0pKVxuICAgIClcbiAgICByZXR1cm4gcHJvbVxuICB9XG5cbiAgcmV0dXJuIHtcbiAgICB3aGVuRW50cnlwb2ludChyb3V0ZTogc3RyaW5nKSB7XG4gICAgICByZXR1cm4gd2l0aEZ1dHVyZShyb3V0ZSwgZW50cnlwb2ludHMpXG4gICAgfSxcbiAgICBvbkVudHJ5cG9pbnQocm91dGU6IHN0cmluZywgZXhlY3V0ZTogKCkgPT4gdW5rbm93bikge1xuICAgICAgUHJvbWlzZS5yZXNvbHZlKGV4ZWN1dGUpXG4gICAgICAgIC50aGVuKChmbikgPT4gZm4oKSlcbiAgICAgICAgLnRoZW4oXG4gICAgICAgICAgKGV4cG9ydHM6IGFueSkgPT4gKHtcbiAgICAgICAgICAgIGNvbXBvbmVudDogKGV4cG9ydHMgJiYgZXhwb3J0cy5kZWZhdWx0KSB8fCBleHBvcnRzLFxuICAgICAgICAgICAgZXhwb3J0czogZXhwb3J0cyxcbiAgICAgICAgICB9KSxcbiAgICAgICAgICAoZXJyKSA9PiAoeyBlcnJvcjogZXJyIH0pXG4gICAgICAgIClcbiAgICAgICAgLnRoZW4oKGlucHV0OiBSb3V0ZUVudHJ5cG9pbnQpID0+IHtcbiAgICAgICAgICBjb25zdCBvbGQgPSBlbnRyeXBvaW50cy5nZXQocm91dGUpXG4gICAgICAgICAgZW50cnlwb2ludHMuc2V0KHJvdXRlLCBpbnB1dClcbiAgICAgICAgICBpZiAob2xkICYmICdyZXNvbHZlJyBpbiBvbGQpIG9sZC5yZXNvbHZlKGlucHV0KVxuICAgICAgICB9KVxuICAgIH0sXG4gICAgbG9hZFJvdXRlKHJvdXRlOiBzdHJpbmcsIHByZWZldGNoPzogYm9vbGVhbikge1xuICAgICAgcmV0dXJuIHdpdGhGdXR1cmU8Um91dGVMb2FkZXJFbnRyeT4ocm91dGUsIHJvdXRlcywgKCkgPT4ge1xuICAgICAgICByZXR1cm4gcmVzb2x2ZVByb21pc2VXaXRoVGltZW91dChcbiAgICAgICAgICBnZXRGaWxlc0ZvclJvdXRlKGFzc2V0UHJlZml4LCByb3V0ZSlcbiAgICAgICAgICAgIC50aGVuKCh7IHNjcmlwdHMsIGNzcyB9KSA9PiB7XG4gICAgICAgICAgICAgIHJldHVybiBQcm9taXNlLmFsbChbXG4gICAgICAgICAgICAgICAgZW50cnlwb2ludHMuaGFzKHJvdXRlKVxuICAgICAgICAgICAgICAgICAgPyBbXVxuICAgICAgICAgICAgICAgICAgOiBQcm9taXNlLmFsbChzY3JpcHRzLm1hcChtYXliZUV4ZWN1dGVTY3JpcHQpKSxcbiAgICAgICAgICAgICAgICBQcm9taXNlLmFsbChjc3MubWFwKGZldGNoU3R5bGVTaGVldCkpLFxuICAgICAgICAgICAgICBdIGFzIGNvbnN0KVxuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIC50aGVuKChyZXMpID0+IHtcbiAgICAgICAgICAgICAgcmV0dXJuIHRoaXMud2hlbkVudHJ5cG9pbnQocm91dGUpLnRoZW4oKGVudHJ5cG9pbnQpID0+ICh7XG4gICAgICAgICAgICAgICAgZW50cnlwb2ludCxcbiAgICAgICAgICAgICAgICBzdHlsZXM6IHJlc1sxXSxcbiAgICAgICAgICAgICAgfSkpXG4gICAgICAgICAgICB9KSxcbiAgICAgICAgICBNU19NQVhfSURMRV9ERUxBWSxcbiAgICAgICAgICBtYXJrQXNzZXRFcnJvcihuZXcgRXJyb3IoYFJvdXRlIGRpZCBub3QgY29tcGxldGUgbG9hZGluZzogJHtyb3V0ZX1gKSlcbiAgICAgICAgKVxuICAgICAgICAgIC50aGVuKCh7IGVudHJ5cG9pbnQsIHN0eWxlcyB9KSA9PiB7XG4gICAgICAgICAgICBjb25zdCByZXM6IFJvdXRlTG9hZGVyRW50cnkgPSBPYmplY3QuYXNzaWduPFxuICAgICAgICAgICAgICB7IHN0eWxlczogUm91dGVTdHlsZVNoZWV0W10gfSxcbiAgICAgICAgICAgICAgUm91dGVFbnRyeXBvaW50XG4gICAgICAgICAgICA+KHsgc3R5bGVzOiBzdHlsZXMhIH0sIGVudHJ5cG9pbnQpXG4gICAgICAgICAgICByZXR1cm4gJ2Vycm9yJyBpbiBlbnRyeXBvaW50ID8gZW50cnlwb2ludCA6IHJlc1xuICAgICAgICAgIH0pXG4gICAgICAgICAgLmNhdGNoKChlcnIpID0+IHtcbiAgICAgICAgICAgIGlmIChwcmVmZXRjaCkge1xuICAgICAgICAgICAgICAvLyB3ZSBkb24ndCB3YW50IHRvIGNhY2hlIGVycm9ycyBkdXJpbmcgcHJlZmV0Y2hcbiAgICAgICAgICAgICAgdGhyb3cgZXJyXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4geyBlcnJvcjogZXJyIH1cbiAgICAgICAgICB9KVxuICAgICAgfSlcbiAgICB9LFxuICAgIHByZWZldGNoKHJvdXRlOiBzdHJpbmcpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9Hb29nbGVDaHJvbWVMYWJzL3F1aWNrbGluay9ibG9iLzQ1M2E2NjFmYTFmYTk0MGUyZDJlMDQ0NDUyMzk4ZTM4YzY3YTk4ZmIvc3JjL2luZGV4Lm1qcyNMMTE1LUwxMThcbiAgICAgIC8vIExpY2Vuc2U6IEFwYWNoZSAyLjBcbiAgICAgIGxldCBjblxuICAgICAgaWYgKChjbiA9IChuYXZpZ2F0b3IgYXMgYW55KS5jb25uZWN0aW9uKSkge1xuICAgICAgICAvLyBEb24ndCBwcmVmZXRjaCBpZiB1c2luZyAyRyBvciBpZiBTYXZlLURhdGEgaXMgZW5hYmxlZC5cbiAgICAgICAgaWYgKGNuLnNhdmVEYXRhIHx8IC8yZy8udGVzdChjbi5lZmZlY3RpdmVUeXBlKSkgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpXG4gICAgICB9XG4gICAgICByZXR1cm4gZ2V0RmlsZXNGb3JSb3V0ZShhc3NldFByZWZpeCwgcm91dGUpXG4gICAgICAgIC50aGVuKChvdXRwdXQpID0+XG4gICAgICAgICAgUHJvbWlzZS5hbGwoXG4gICAgICAgICAgICBjYW5QcmVmZXRjaFxuICAgICAgICAgICAgICA/IG91dHB1dC5zY3JpcHRzLm1hcCgoc2NyaXB0KSA9PiBwcmVmZXRjaFZpYURvbShzY3JpcHQsICdzY3JpcHQnKSlcbiAgICAgICAgICAgICAgOiBbXVxuICAgICAgICAgIClcbiAgICAgICAgKVxuICAgICAgICAudGhlbigoKSA9PiB7XG4gICAgICAgICAgcmVxdWVzdElkbGVDYWxsYmFjaygoKSA9PiB0aGlzLmxvYWRSb3V0ZShyb3V0ZSwgdHJ1ZSkuY2F0Y2goKCkgPT4ge30pKVxuICAgICAgICB9KVxuICAgICAgICAuY2F0Y2goXG4gICAgICAgICAgLy8gc3dhbGxvdyBwcmVmZXRjaCBlcnJvcnNcbiAgICAgICAgICAoKSA9PiB7fVxuICAgICAgICApXG4gICAgfSxcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBjcmVhdGVSb3V0ZUxvYWRlclxuIiwiLyogZ2xvYmFsIHdpbmRvdyAqL1xuaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0J1xuaW1wb3J0IFJvdXRlciwgeyBOZXh0Um91dGVyIH0gZnJvbSAnLi4vbmV4dC1zZXJ2ZXIvbGliL3JvdXRlci9yb3V0ZXInXG5pbXBvcnQgeyBSb3V0ZXJDb250ZXh0IH0gZnJvbSAnLi4vbmV4dC1zZXJ2ZXIvbGliL3JvdXRlci1jb250ZXh0J1xuXG50eXBlIENsYXNzQXJndW1lbnRzPFQ+ID0gVCBleHRlbmRzIG5ldyAoLi4uYXJnczogaW5mZXIgVSkgPT4gYW55ID8gVSA6IGFueVxuXG50eXBlIFJvdXRlckFyZ3MgPSBDbGFzc0FyZ3VtZW50czx0eXBlb2YgUm91dGVyPlxuXG50eXBlIFNpbmdsZXRvblJvdXRlckJhc2UgPSB7XG4gIHJvdXRlcjogUm91dGVyIHwgbnVsbFxuICByZWFkeUNhbGxiYWNrczogQXJyYXk8KCkgPT4gYW55PlxuICByZWFkeShjYjogKCkgPT4gYW55KTogdm9pZFxufVxuXG5leHBvcnQgeyBSb3V0ZXIsIE5leHRSb3V0ZXIgfVxuXG5leHBvcnQgdHlwZSBTaW5nbGV0b25Sb3V0ZXIgPSBTaW5nbGV0b25Sb3V0ZXJCYXNlICYgTmV4dFJvdXRlclxuXG5jb25zdCBzaW5nbGV0b25Sb3V0ZXI6IFNpbmdsZXRvblJvdXRlckJhc2UgPSB7XG4gIHJvdXRlcjogbnVsbCwgLy8gaG9sZHMgdGhlIGFjdHVhbCByb3V0ZXIgaW5zdGFuY2VcbiAgcmVhZHlDYWxsYmFja3M6IFtdLFxuICByZWFkeShjYjogKCkgPT4gdm9pZCkge1xuICAgIGlmICh0aGlzLnJvdXRlcikgcmV0dXJuIGNiKClcbiAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHRoaXMucmVhZHlDYWxsYmFja3MucHVzaChjYilcbiAgICB9XG4gIH0sXG59XG5cbi8vIENyZWF0ZSBwdWJsaWMgcHJvcGVydGllcyBhbmQgbWV0aG9kcyBvZiB0aGUgcm91dGVyIGluIHRoZSBzaW5nbGV0b25Sb3V0ZXJcbmNvbnN0IHVybFByb3BlcnR5RmllbGRzID0gW1xuICAncGF0aG5hbWUnLFxuICAncm91dGUnLFxuICAncXVlcnknLFxuICAnYXNQYXRoJyxcbiAgJ2NvbXBvbmVudHMnLFxuICAnaXNGYWxsYmFjaycsXG4gICdiYXNlUGF0aCcsXG4gICdsb2NhbGUnLFxuICAnbG9jYWxlcycsXG4gICdkZWZhdWx0TG9jYWxlJyxcbiAgJ2lzUmVhZHknLFxuICAnaXNQcmV2aWV3JyxcbiAgJ2lzTG9jYWxlRG9tYWluJyxcbl1cbmNvbnN0IHJvdXRlckV2ZW50cyA9IFtcbiAgJ3JvdXRlQ2hhbmdlU3RhcnQnLFxuICAnYmVmb3JlSGlzdG9yeUNoYW5nZScsXG4gICdyb3V0ZUNoYW5nZUNvbXBsZXRlJyxcbiAgJ3JvdXRlQ2hhbmdlRXJyb3InLFxuICAnaGFzaENoYW5nZVN0YXJ0JyxcbiAgJ2hhc2hDaGFuZ2VDb21wbGV0ZScsXG5dXG5jb25zdCBjb3JlTWV0aG9kRmllbGRzID0gW1xuICAncHVzaCcsXG4gICdyZXBsYWNlJyxcbiAgJ3JlbG9hZCcsXG4gICdiYWNrJyxcbiAgJ3ByZWZldGNoJyxcbiAgJ2JlZm9yZVBvcFN0YXRlJyxcbl1cblxuLy8gRXZlbnRzIGlzIGEgc3RhdGljIHByb3BlcnR5IG9uIHRoZSByb3V0ZXIsIHRoZSByb3V0ZXIgZG9lc24ndCBoYXZlIHRvIGJlIGluaXRpYWxpemVkIHRvIHVzZSBpdFxuT2JqZWN0LmRlZmluZVByb3BlcnR5KHNpbmdsZXRvblJvdXRlciwgJ2V2ZW50cycsIHtcbiAgZ2V0KCkge1xuICAgIHJldHVybiBSb3V0ZXIuZXZlbnRzXG4gIH0sXG59KVxuXG51cmxQcm9wZXJ0eUZpZWxkcy5mb3JFYWNoKChmaWVsZDogc3RyaW5nKSA9PiB7XG4gIC8vIEhlcmUgd2UgbmVlZCB0byB1c2UgT2JqZWN0LmRlZmluZVByb3BlcnR5IGJlY2F1c2UsIHdlIG5lZWQgdG8gcmV0dXJuXG4gIC8vIHRoZSBwcm9wZXJ0eSBhc3NpZ25lZCB0byB0aGUgYWN0dWFsIHJvdXRlclxuICAvLyBUaGUgdmFsdWUgbWlnaHQgZ2V0IGNoYW5nZWQgYXMgd2UgY2hhbmdlIHJvdXRlcyBhbmQgdGhpcyBpcyB0aGVcbiAgLy8gcHJvcGVyIHdheSB0byBhY2Nlc3MgaXRcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHNpbmdsZXRvblJvdXRlciwgZmllbGQsIHtcbiAgICBnZXQoKSB7XG4gICAgICBjb25zdCByb3V0ZXIgPSBnZXRSb3V0ZXIoKSBhcyBhbnlcbiAgICAgIHJldHVybiByb3V0ZXJbZmllbGRdIGFzIHN0cmluZ1xuICAgIH0sXG4gIH0pXG59KVxuXG5jb3JlTWV0aG9kRmllbGRzLmZvckVhY2goKGZpZWxkOiBzdHJpbmcpID0+IHtcbiAgLy8gV2UgZG9uJ3QgcmVhbGx5IGtub3cgdGhlIHR5cGVzIGhlcmUsIHNvIHdlIGFkZCB0aGVtIGxhdGVyIGluc3RlYWRcbiAgOyhzaW5nbGV0b25Sb3V0ZXIgYXMgYW55KVtmaWVsZF0gPSAoLi4uYXJnczogYW55W10pID0+IHtcbiAgICBjb25zdCByb3V0ZXIgPSBnZXRSb3V0ZXIoKSBhcyBhbnlcbiAgICByZXR1cm4gcm91dGVyW2ZpZWxkXSguLi5hcmdzKVxuICB9XG59KVxuXG5yb3V0ZXJFdmVudHMuZm9yRWFjaCgoZXZlbnQ6IHN0cmluZykgPT4ge1xuICBzaW5nbGV0b25Sb3V0ZXIucmVhZHkoKCkgPT4ge1xuICAgIFJvdXRlci5ldmVudHMub24oZXZlbnQsICguLi5hcmdzKSA9PiB7XG4gICAgICBjb25zdCBldmVudEZpZWxkID0gYG9uJHtldmVudC5jaGFyQXQoMCkudG9VcHBlckNhc2UoKX0ke2V2ZW50LnN1YnN0cmluZyhcbiAgICAgICAgMVxuICAgICAgKX1gXG4gICAgICBjb25zdCBfc2luZ2xldG9uUm91dGVyID0gc2luZ2xldG9uUm91dGVyIGFzIGFueVxuICAgICAgaWYgKF9zaW5nbGV0b25Sb3V0ZXJbZXZlbnRGaWVsZF0pIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBfc2luZ2xldG9uUm91dGVyW2V2ZW50RmllbGRdKC4uLmFyZ3MpXG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoYEVycm9yIHdoZW4gcnVubmluZyB0aGUgUm91dGVyIGV2ZW50OiAke2V2ZW50RmllbGR9YClcbiAgICAgICAgICBjb25zb2xlLmVycm9yKGAke2Vyci5tZXNzYWdlfVxcbiR7ZXJyLnN0YWNrfWApXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KVxuICB9KVxufSlcblxuZnVuY3Rpb24gZ2V0Um91dGVyKCk6IFJvdXRlciB7XG4gIGlmICghc2luZ2xldG9uUm91dGVyLnJvdXRlcikge1xuICAgIGNvbnN0IG1lc3NhZ2UgPVxuICAgICAgJ05vIHJvdXRlciBpbnN0YW5jZSBmb3VuZC5cXG4nICtcbiAgICAgICdZb3Ugc2hvdWxkIG9ubHkgdXNlIFwibmV4dC9yb3V0ZXJcIiBpbnNpZGUgdGhlIGNsaWVudCBzaWRlIG9mIHlvdXIgYXBwLlxcbidcbiAgICB0aHJvdyBuZXcgRXJyb3IobWVzc2FnZSlcbiAgfVxuICByZXR1cm4gc2luZ2xldG9uUm91dGVyLnJvdXRlclxufVxuXG4vLyBFeHBvcnQgdGhlIHNpbmdsZXRvblJvdXRlciBhbmQgdGhpcyBpcyB0aGUgcHVibGljIEFQSS5cbmV4cG9ydCBkZWZhdWx0IHNpbmdsZXRvblJvdXRlciBhcyBTaW5nbGV0b25Sb3V0ZXJcblxuLy8gUmVleHBvcnQgdGhlIHdpdGhSb3V0ZSBIT0NcbmV4cG9ydCB7IGRlZmF1bHQgYXMgd2l0aFJvdXRlciB9IGZyb20gJy4vd2l0aC1yb3V0ZXInXG5cbmV4cG9ydCBmdW5jdGlvbiB1c2VSb3V0ZXIoKTogTmV4dFJvdXRlciB7XG4gIHJldHVybiBSZWFjdC51c2VDb250ZXh0KFJvdXRlckNvbnRleHQpXG59XG5cbi8vIElOVEVSTkFMIEFQSVNcbi8vIC0tLS0tLS0tLS0tLS1cbi8vIChkbyBub3QgdXNlIGZvbGxvd2luZyBleHBvcnRzIGluc2lkZSB0aGUgYXBwKVxuXG4vLyBDcmVhdGUgYSByb3V0ZXIgYW5kIGFzc2lnbiBpdCBhcyB0aGUgc2luZ2xldG9uIGluc3RhbmNlLlxuLy8gVGhpcyBpcyB1c2VkIGluIGNsaWVudCBzaWRlIHdoZW4gd2UgYXJlIGluaXRpbGl6aW5nIHRoZSBhcHAuXG4vLyBUaGlzIHNob3VsZCAqKm5vdCoqIHVzZSBpbnNpZGUgdGhlIHNlcnZlci5cbmV4cG9ydCBjb25zdCBjcmVhdGVSb3V0ZXIgPSAoLi4uYXJnczogUm91dGVyQXJncyk6IFJvdXRlciA9PiB7XG4gIHNpbmdsZXRvblJvdXRlci5yb3V0ZXIgPSBuZXcgUm91dGVyKC4uLmFyZ3MpXG4gIHNpbmdsZXRvblJvdXRlci5yZWFkeUNhbGxiYWNrcy5mb3JFYWNoKChjYikgPT4gY2IoKSlcbiAgc2luZ2xldG9uUm91dGVyLnJlYWR5Q2FsbGJhY2tzID0gW11cblxuICByZXR1cm4gc2luZ2xldG9uUm91dGVyLnJvdXRlclxufVxuXG4vLyBUaGlzIGZ1bmN0aW9uIGlzIHVzZWQgdG8gY3JlYXRlIHRoZSBgd2l0aFJvdXRlcmAgcm91dGVyIGluc3RhbmNlXG5leHBvcnQgZnVuY3Rpb24gbWFrZVB1YmxpY1JvdXRlckluc3RhbmNlKHJvdXRlcjogUm91dGVyKTogTmV4dFJvdXRlciB7XG4gIGNvbnN0IF9yb3V0ZXIgPSByb3V0ZXIgYXMgYW55XG4gIGNvbnN0IGluc3RhbmNlID0ge30gYXMgYW55XG5cbiAgZm9yIChjb25zdCBwcm9wZXJ0eSBvZiB1cmxQcm9wZXJ0eUZpZWxkcykge1xuICAgIGlmICh0eXBlb2YgX3JvdXRlcltwcm9wZXJ0eV0gPT09ICdvYmplY3QnKSB7XG4gICAgICBpbnN0YW5jZVtwcm9wZXJ0eV0gPSBPYmplY3QuYXNzaWduKFxuICAgICAgICBBcnJheS5pc0FycmF5KF9yb3V0ZXJbcHJvcGVydHldKSA/IFtdIDoge30sXG4gICAgICAgIF9yb3V0ZXJbcHJvcGVydHldXG4gICAgICApIC8vIG1ha2VzIHN1cmUgcXVlcnkgaXMgbm90IHN0YXRlZnVsXG4gICAgICBjb250aW51ZVxuICAgIH1cblxuICAgIGluc3RhbmNlW3Byb3BlcnR5XSA9IF9yb3V0ZXJbcHJvcGVydHldXG4gIH1cblxuICAvLyBFdmVudHMgaXMgYSBzdGF0aWMgcHJvcGVydHkgb24gdGhlIHJvdXRlciwgdGhlIHJvdXRlciBkb2Vzbid0IGhhdmUgdG8gYmUgaW5pdGlhbGl6ZWQgdG8gdXNlIGl0XG4gIGluc3RhbmNlLmV2ZW50cyA9IFJvdXRlci5ldmVudHNcblxuICBjb3JlTWV0aG9kRmllbGRzLmZvckVhY2goKGZpZWxkKSA9PiB7XG4gICAgaW5zdGFuY2VbZmllbGRdID0gKC4uLmFyZ3M6IGFueVtdKSA9PiB7XG4gICAgICByZXR1cm4gX3JvdXRlcltmaWVsZF0oLi4uYXJncylcbiAgICB9XG4gIH0pXG5cbiAgcmV0dXJuIGluc3RhbmNlXG59XG4iLCJpbXBvcnQgeyB1c2VDYWxsYmFjaywgdXNlRWZmZWN0LCB1c2VSZWYsIHVzZVN0YXRlIH0gZnJvbSAncmVhY3QnXG5pbXBvcnQge1xuICByZXF1ZXN0SWRsZUNhbGxiYWNrLFxuICBjYW5jZWxJZGxlQ2FsbGJhY2ssXG59IGZyb20gJy4vcmVxdWVzdC1pZGxlLWNhbGxiYWNrJ1xuXG50eXBlIFVzZUludGVyc2VjdGlvbk9ic2VydmVySW5pdCA9IFBpY2s8SW50ZXJzZWN0aW9uT2JzZXJ2ZXJJbml0LCAncm9vdE1hcmdpbic+XG50eXBlIFVzZUludGVyc2VjdGlvbiA9IHsgZGlzYWJsZWQ/OiBib29sZWFuIH0gJiBVc2VJbnRlcnNlY3Rpb25PYnNlcnZlckluaXRcbnR5cGUgT2JzZXJ2ZUNhbGxiYWNrID0gKGlzVmlzaWJsZTogYm9vbGVhbikgPT4gdm9pZFxudHlwZSBPYnNlcnZlciA9IHtcbiAgaWQ6IHN0cmluZ1xuICBvYnNlcnZlcjogSW50ZXJzZWN0aW9uT2JzZXJ2ZXJcbiAgZWxlbWVudHM6IE1hcDxFbGVtZW50LCBPYnNlcnZlQ2FsbGJhY2s+XG59XG5cbmNvbnN0IGhhc0ludGVyc2VjdGlvbk9ic2VydmVyID0gdHlwZW9mIEludGVyc2VjdGlvbk9ic2VydmVyICE9PSAndW5kZWZpbmVkJ1xuXG5leHBvcnQgZnVuY3Rpb24gdXNlSW50ZXJzZWN0aW9uPFQgZXh0ZW5kcyBFbGVtZW50Pih7XG4gIHJvb3RNYXJnaW4sXG4gIGRpc2FibGVkLFxufTogVXNlSW50ZXJzZWN0aW9uKTogWyhlbGVtZW50OiBUIHwgbnVsbCkgPT4gdm9pZCwgYm9vbGVhbl0ge1xuICBjb25zdCBpc0Rpc2FibGVkOiBib29sZWFuID0gZGlzYWJsZWQgfHwgIWhhc0ludGVyc2VjdGlvbk9ic2VydmVyXG5cbiAgY29uc3QgdW5vYnNlcnZlID0gdXNlUmVmPEZ1bmN0aW9uPigpXG4gIGNvbnN0IFt2aXNpYmxlLCBzZXRWaXNpYmxlXSA9IHVzZVN0YXRlKGZhbHNlKVxuXG4gIGNvbnN0IHNldFJlZiA9IHVzZUNhbGxiYWNrKFxuICAgIChlbDogVCB8IG51bGwpID0+IHtcbiAgICAgIGlmICh1bm9ic2VydmUuY3VycmVudCkge1xuICAgICAgICB1bm9ic2VydmUuY3VycmVudCgpXG4gICAgICAgIHVub2JzZXJ2ZS5jdXJyZW50ID0gdW5kZWZpbmVkXG4gICAgICB9XG5cbiAgICAgIGlmIChpc0Rpc2FibGVkIHx8IHZpc2libGUpIHJldHVyblxuXG4gICAgICBpZiAoZWwgJiYgZWwudGFnTmFtZSkge1xuICAgICAgICB1bm9ic2VydmUuY3VycmVudCA9IG9ic2VydmUoXG4gICAgICAgICAgZWwsXG4gICAgICAgICAgKGlzVmlzaWJsZSkgPT4gaXNWaXNpYmxlICYmIHNldFZpc2libGUoaXNWaXNpYmxlKSxcbiAgICAgICAgICB7IHJvb3RNYXJnaW4gfVxuICAgICAgICApXG4gICAgICB9XG4gICAgfSxcbiAgICBbaXNEaXNhYmxlZCwgcm9vdE1hcmdpbiwgdmlzaWJsZV1cbiAgKVxuXG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKCFoYXNJbnRlcnNlY3Rpb25PYnNlcnZlcikge1xuICAgICAgaWYgKCF2aXNpYmxlKSB7XG4gICAgICAgIGNvbnN0IGlkbGVDYWxsYmFjayA9IHJlcXVlc3RJZGxlQ2FsbGJhY2soKCkgPT4gc2V0VmlzaWJsZSh0cnVlKSlcbiAgICAgICAgcmV0dXJuICgpID0+IGNhbmNlbElkbGVDYWxsYmFjayhpZGxlQ2FsbGJhY2spXG4gICAgICB9XG4gICAgfVxuICB9LCBbdmlzaWJsZV0pXG5cbiAgcmV0dXJuIFtzZXRSZWYsIHZpc2libGVdXG59XG5cbmZ1bmN0aW9uIG9ic2VydmUoXG4gIGVsZW1lbnQ6IEVsZW1lbnQsXG4gIGNhbGxiYWNrOiBPYnNlcnZlQ2FsbGJhY2ssXG4gIG9wdGlvbnM6IFVzZUludGVyc2VjdGlvbk9ic2VydmVySW5pdFxuKTogKCkgPT4gdm9pZCB7XG4gIGNvbnN0IHsgaWQsIG9ic2VydmVyLCBlbGVtZW50cyB9ID0gY3JlYXRlT2JzZXJ2ZXIob3B0aW9ucylcbiAgZWxlbWVudHMuc2V0KGVsZW1lbnQsIGNhbGxiYWNrKVxuXG4gIG9ic2VydmVyLm9ic2VydmUoZWxlbWVudClcbiAgcmV0dXJuIGZ1bmN0aW9uIHVub2JzZXJ2ZSgpOiB2b2lkIHtcbiAgICBlbGVtZW50cy5kZWxldGUoZWxlbWVudClcbiAgICBvYnNlcnZlci51bm9ic2VydmUoZWxlbWVudClcblxuICAgIC8vIERlc3Ryb3kgb2JzZXJ2ZXIgd2hlbiB0aGVyZSdzIG5vdGhpbmcgbGVmdCB0byB3YXRjaDpcbiAgICBpZiAoZWxlbWVudHMuc2l6ZSA9PT0gMCkge1xuICAgICAgb2JzZXJ2ZXIuZGlzY29ubmVjdCgpXG4gICAgICBvYnNlcnZlcnMuZGVsZXRlKGlkKVxuICAgIH1cbiAgfVxufVxuXG5jb25zdCBvYnNlcnZlcnMgPSBuZXcgTWFwPHN0cmluZywgT2JzZXJ2ZXI+KClcbmZ1bmN0aW9uIGNyZWF0ZU9ic2VydmVyKG9wdGlvbnM6IFVzZUludGVyc2VjdGlvbk9ic2VydmVySW5pdCk6IE9ic2VydmVyIHtcbiAgY29uc3QgaWQgPSBvcHRpb25zLnJvb3RNYXJnaW4gfHwgJydcbiAgbGV0IGluc3RhbmNlID0gb2JzZXJ2ZXJzLmdldChpZClcbiAgaWYgKGluc3RhbmNlKSB7XG4gICAgcmV0dXJuIGluc3RhbmNlXG4gIH1cblxuICBjb25zdCBlbGVtZW50cyA9IG5ldyBNYXA8RWxlbWVudCwgT2JzZXJ2ZUNhbGxiYWNrPigpXG4gIGNvbnN0IG9ic2VydmVyID0gbmV3IEludGVyc2VjdGlvbk9ic2VydmVyKChlbnRyaWVzKSA9PiB7XG4gICAgZW50cmllcy5mb3JFYWNoKChlbnRyeSkgPT4ge1xuICAgICAgY29uc3QgY2FsbGJhY2sgPSBlbGVtZW50cy5nZXQoZW50cnkudGFyZ2V0KVxuICAgICAgY29uc3QgaXNWaXNpYmxlID0gZW50cnkuaXNJbnRlcnNlY3RpbmcgfHwgZW50cnkuaW50ZXJzZWN0aW9uUmF0aW8gPiAwXG4gICAgICBpZiAoY2FsbGJhY2sgJiYgaXNWaXNpYmxlKSB7XG4gICAgICAgIGNhbGxiYWNrKGlzVmlzaWJsZSlcbiAgICAgIH1cbiAgICB9KVxuICB9LCBvcHRpb25zKVxuXG4gIG9ic2VydmVycy5zZXQoXG4gICAgaWQsXG4gICAgKGluc3RhbmNlID0ge1xuICAgICAgaWQsXG4gICAgICBvYnNlcnZlcixcbiAgICAgIGVsZW1lbnRzLFxuICAgIH0pXG4gIClcbiAgcmV0dXJuIGluc3RhbmNlXG59XG4iLCJpbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnXG5pbXBvcnQgeyBOZXh0Q29tcG9uZW50VHlwZSwgTmV4dFBhZ2VDb250ZXh0IH0gZnJvbSAnLi4vbmV4dC1zZXJ2ZXIvbGliL3V0aWxzJ1xuaW1wb3J0IHsgTmV4dFJvdXRlciwgdXNlUm91dGVyIH0gZnJvbSAnLi9yb3V0ZXInXG5cbmV4cG9ydCB0eXBlIFdpdGhSb3V0ZXJQcm9wcyA9IHtcbiAgcm91dGVyOiBOZXh0Um91dGVyXG59XG5cbmV4cG9ydCB0eXBlIEV4Y2x1ZGVSb3V0ZXJQcm9wczxQPiA9IFBpY2s8XG4gIFAsXG4gIEV4Y2x1ZGU8a2V5b2YgUCwga2V5b2YgV2l0aFJvdXRlclByb3BzPlxuPlxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiB3aXRoUm91dGVyPFxuICBQIGV4dGVuZHMgV2l0aFJvdXRlclByb3BzLFxuICBDID0gTmV4dFBhZ2VDb250ZXh0XG4+KFxuICBDb21wb3NlZENvbXBvbmVudDogTmV4dENvbXBvbmVudFR5cGU8QywgYW55LCBQPlxuKTogUmVhY3QuQ29tcG9uZW50VHlwZTxFeGNsdWRlUm91dGVyUHJvcHM8UD4+IHtcbiAgZnVuY3Rpb24gV2l0aFJvdXRlcldyYXBwZXIocHJvcHM6IGFueSk6IEpTWC5FbGVtZW50IHtcbiAgICByZXR1cm4gPENvbXBvc2VkQ29tcG9uZW50IHJvdXRlcj17dXNlUm91dGVyKCl9IHsuLi5wcm9wc30gLz5cbiAgfVxuXG4gIFdpdGhSb3V0ZXJXcmFwcGVyLmdldEluaXRpYWxQcm9wcyA9IENvbXBvc2VkQ29tcG9uZW50LmdldEluaXRpYWxQcm9wc1xuICAvLyBUaGlzIGlzIG5lZWRlZCB0byBhbGxvdyBjaGVja2luZyBmb3IgY3VzdG9tIGdldEluaXRpYWxQcm9wcyBpbiBfYXBwXG4gIDsoV2l0aFJvdXRlcldyYXBwZXIgYXMgYW55KS5vcmlnR2V0SW5pdGlhbFByb3BzID0gKENvbXBvc2VkQ29tcG9uZW50IGFzIGFueSkub3JpZ0dldEluaXRpYWxQcm9wc1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIGNvbnN0IG5hbWUgPVxuICAgICAgQ29tcG9zZWRDb21wb25lbnQuZGlzcGxheU5hbWUgfHwgQ29tcG9zZWRDb21wb25lbnQubmFtZSB8fCAnVW5rbm93bidcbiAgICBXaXRoUm91dGVyV3JhcHBlci5kaXNwbGF5TmFtZSA9IGB3aXRoUm91dGVyKCR7bmFtZX0pYFxuICB9XG5cbiAgcmV0dXJuIFdpdGhSb3V0ZXJXcmFwcGVyXG59XG4iLCJtb2R1bGUuZXhwb3J0cz1mdW5jdGlvbigpe1widXNlIHN0cmljdFwiO3ZhciBuPXs3NjI6ZnVuY3Rpb24obil7bi5leHBvcnRzPWZ1bmN0aW9uKG4pe3ZhciB0PVtdO3QudG9TdHJpbmc9ZnVuY3Rpb24gdG9TdHJpbmcoKXtyZXR1cm4gdGhpcy5tYXAoZnVuY3Rpb24odCl7dmFyIHI9Y3NzV2l0aE1hcHBpbmdUb1N0cmluZyh0LG4pO2lmKHRbMl0pe3JldHVyblwiQG1lZGlhIFwiLmNvbmNhdCh0WzJdLFwiIHtcIikuY29uY2F0KHIsXCJ9XCIpfXJldHVybiByfSkuam9pbihcIlwiKX07dC5pPWZ1bmN0aW9uKG4scixvKXtpZih0eXBlb2Ygbj09PVwic3RyaW5nXCIpe249W1tudWxsLG4sXCJcIl1dfXZhciBlPXt9O2lmKG8pe2Zvcih2YXIgYT0wO2E8dGhpcy5sZW5ndGg7YSsrKXt2YXIgYz10aGlzW2FdWzBdO2lmKGMhPW51bGwpe2VbY109dHJ1ZX19fWZvcih2YXIgaT0wO2k8bi5sZW5ndGg7aSsrKXt2YXIgdT1bXS5jb25jYXQobltpXSk7aWYobyYmZVt1WzBdXSl7Y29udGludWV9aWYocil7aWYoIXVbMl0pe3VbMl09cn1lbHNle3VbMl09XCJcIi5jb25jYXQocixcIiBhbmQgXCIpLmNvbmNhdCh1WzJdKX19dC5wdXNoKHUpfX07cmV0dXJuIHR9O2Z1bmN0aW9uIGNzc1dpdGhNYXBwaW5nVG9TdHJpbmcobix0KXt2YXIgcj1uWzFdfHxcIlwiO3ZhciBvPW5bM107aWYoIW8pe3JldHVybiByfWlmKHQmJnR5cGVvZiBidG9hPT09XCJmdW5jdGlvblwiKXt2YXIgZT10b0NvbW1lbnQobyk7dmFyIGE9by5zb3VyY2VzLm1hcChmdW5jdGlvbihuKXtyZXR1cm5cIi8qIyBzb3VyY2VVUkw9XCIuY29uY2F0KG8uc291cmNlUm9vdHx8XCJcIikuY29uY2F0KG4sXCIgKi9cIil9KTtyZXR1cm5bcl0uY29uY2F0KGEpLmNvbmNhdChbZV0pLmpvaW4oXCJcXG5cIil9cmV0dXJuW3JdLmpvaW4oXCJcXG5cIil9ZnVuY3Rpb24gdG9Db21tZW50KG4pe3ZhciB0PWJ0b2EodW5lc2NhcGUoZW5jb2RlVVJJQ29tcG9uZW50KEpTT04uc3RyaW5naWZ5KG4pKSkpO3ZhciByPVwic291cmNlTWFwcGluZ1VSTD1kYXRhOmFwcGxpY2F0aW9uL2pzb247Y2hhcnNldD11dGYtODtiYXNlNjQsXCIuY29uY2F0KHQpO3JldHVyblwiLyojIFwiLmNvbmNhdChyLFwiICovXCIpfX19O3ZhciB0PXt9O2Z1bmN0aW9uIF9fbmNjd3Bja19yZXF1aXJlX18ocil7aWYodFtyXSl7cmV0dXJuIHRbcl0uZXhwb3J0c312YXIgbz10W3JdPXtleHBvcnRzOnt9fTt2YXIgZT10cnVlO3RyeXtuW3JdKG8sby5leHBvcnRzLF9fbmNjd3Bja19yZXF1aXJlX18pO2U9ZmFsc2V9ZmluYWxseXtpZihlKWRlbGV0ZSB0W3JdfXJldHVybiBvLmV4cG9ydHN9X19uY2N3cGNrX3JlcXVpcmVfXy5hYj1fX2Rpcm5hbWUrXCIvXCI7cmV0dXJuIF9fbmNjd3Bja19yZXF1aXJlX18oNzYyKX0oKTsiLCIvLyBJbXBvcnRzXG52YXIgX19fQ1NTX0xPQURFUl9BUElfSU1QT1JUX19fID0gcmVxdWlyZShcIi4uLy4uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvY3NzLWxvYWRlci9hcGkuanNcIik7XG52YXIgX19fQ1NTX0xPQURFUl9FWFBPUlRfX18gPSBfX19DU1NfTE9BREVSX0FQSV9JTVBPUlRfX18odHJ1ZSk7XG4vLyBNb2R1bGVcbl9fX0NTU19MT0FERVJfRVhQT1JUX19fLnB1c2goW21vZHVsZS5pZCwgXCIuQWJvdXRfY29udHJvbHNfXzNVSnptLFxcbi5BYm91dF9uYXZpZ2F0aW9uX19qbV8zVyB7XFxuICAgIG1hcmdpbi10b3A6IHZhcigtLXNwYWNlLXhsKSAhaW1wb3J0YW50O1xcbn1cXG5cXG4uQWJvdXRfaGVhZGVyX18yQkE4QyB7XFxuICAgIGRpc3BsYXk6IGZsZXg7XFxuICAgIGFsaWduLWl0ZW1zOiBjZW50ZXI7XFxuICAgIG1hcmdpbi1ib3R0b206IHZhcigtLXNwYWNlLWwpO1xcbn1cXG5cXG4uQWJvdXRfbG9nb19fMmVBYUYge1xcbiAgICB3aWR0aDogNzAlO1xcbiAgICBwYWRkaW5nLXJpZ2h0OiB2YXIoLS1zcGFjZS1sKTtcXG59XFxuXFxuLkFib3V0X2Rlc2NyaXB0aW9uX18zbkg1VyA+ICogKyAqIHtcXG4gICAgbWFyZ2luLXRvcDogMC41ZW07XFxufVxcblxcbltkYXRhLWxheW91dD0nZGVza3RvcCddIC5BYm91dF9idXR0b25fXzF6TGxMIHtcXG4gICAgZGlzcGxheTogbm9uZTtcXG59XFxuXCIsIFwiXCIse1widmVyc2lvblwiOjMsXCJzb3VyY2VzXCI6W1wid2VicGFjazovL2NvbXBvbmVudHMvQWJvdXQvQWJvdXQubW9kdWxlLmNzc1wiXSxcIm5hbWVzXCI6W10sXCJtYXBwaW5nc1wiOlwiQUFBQTs7SUFFSSxzQ0FBc0M7QUFDMUM7O0FBRUE7SUFDSSxhQUFhO0lBQ2IsbUJBQW1CO0lBQ25CLDZCQUE2QjtBQUNqQzs7QUFFQTtJQUNJLFVBQVU7SUFDViw2QkFBNkI7QUFDakM7O0FBRUE7SUFDSSxpQkFBaUI7QUFDckI7O0FBRUE7SUFDSSxhQUFhO0FBQ2pCXCIsXCJzb3VyY2VzQ29udGVudFwiOltcIi5jb250cm9scyxcXG4ubmF2aWdhdGlvbiB7XFxuICAgIG1hcmdpbi10b3A6IHZhcigtLXNwYWNlLXhsKSAhaW1wb3J0YW50O1xcbn1cXG5cXG4uaGVhZGVyIHtcXG4gICAgZGlzcGxheTogZmxleDtcXG4gICAgYWxpZ24taXRlbXM6IGNlbnRlcjtcXG4gICAgbWFyZ2luLWJvdHRvbTogdmFyKC0tc3BhY2UtbCk7XFxufVxcblxcbi5sb2dvIHtcXG4gICAgd2lkdGg6IDcwJTtcXG4gICAgcGFkZGluZy1yaWdodDogdmFyKC0tc3BhY2UtbCk7XFxufVxcblxcbi5kZXNjcmlwdGlvbiA+ICogKyAqIHtcXG4gICAgbWFyZ2luLXRvcDogMC41ZW07XFxufVxcblxcbltkYXRhLWxheW91dD0nZGVza3RvcCddIC5idXR0b24ge1xcbiAgICBkaXNwbGF5OiBub25lO1xcbn1cXG5cIl0sXCJzb3VyY2VSb290XCI6XCJcIn1dKTtcbi8vIEV4cG9ydHNcbl9fX0NTU19MT0FERVJfRVhQT1JUX19fLmxvY2FscyA9IHtcblx0XCJjb250cm9sc1wiOiBcIkFib3V0X2NvbnRyb2xzX18zVUp6bVwiLFxuXHRcIm5hdmlnYXRpb25cIjogXCJBYm91dF9uYXZpZ2F0aW9uX19qbV8zV1wiLFxuXHRcImhlYWRlclwiOiBcIkFib3V0X2hlYWRlcl9fMkJBOENcIixcblx0XCJsb2dvXCI6IFwiQWJvdXRfbG9nb19fMmVBYUZcIixcblx0XCJkZXNjcmlwdGlvblwiOiBcIkFib3V0X2Rlc2NyaXB0aW9uX18zbkg1V1wiLFxuXHRcImJ1dHRvblwiOiBcIkFib3V0X2J1dHRvbl9fMXpMbExcIlxufTtcbm1vZHVsZS5leHBvcnRzID0gX19fQ1NTX0xPQURFUl9FWFBPUlRfX187XG4iLCIvLyBJbXBvcnRzXG52YXIgX19fQ1NTX0xPQURFUl9BUElfSU1QT1JUX19fID0gcmVxdWlyZShcIi4uLy4uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvY3NzLWxvYWRlci9hcGkuanNcIik7XG52YXIgX19fQ1NTX0xPQURFUl9FWFBPUlRfX18gPSBfX19DU1NfTE9BREVSX0FQSV9JTVBPUlRfX18odHJ1ZSk7XG4vLyBNb2R1bGVcbl9fX0NTU19MT0FERVJfRVhQT1JUX19fLnB1c2goW21vZHVsZS5pZCwgXCIuQWJvdXRDb250cm9sc19yb290X18xQmNMdiB7XFxyXFxuICAgIGxpc3Qtc3R5bGU6IG5vbmU7XFxyXFxuICAgIGJvcmRlci1ib3R0b206IDFweCBzb2xpZCB2YXIoLS1jLWJvcmRlcik7XFxyXFxufVxcclxcblxcclxcbi5BYm91dENvbnRyb2xzX2l0ZW1fX2xkUFUwIHtcXHJcXG4gICAgZGlzcGxheTogZmxleDtcXHJcXG4gICAganVzdGlmeS1jb250ZW50OiBmbGV4LWVuZDtcXHJcXG4gICAgYm9yZGVyLXRvcDogMXB4IHNvbGlkIHZhcigtLWMtYm9yZGVyKTtcXHJcXG59XFxyXFxuXFxyXFxuLkFib3V0Q29udHJvbHNfYnV0dG9uX18xOFA0bSB7XFxyXFxufVxcclxcblwiLCBcIlwiLHtcInZlcnNpb25cIjozLFwic291cmNlc1wiOltcIndlYnBhY2s6Ly9jb21wb25lbnRzL0Fib3V0L0Fib3V0Q29udHJvbHMubW9kdWxlLmNzc1wiXSxcIm5hbWVzXCI6W10sXCJtYXBwaW5nc1wiOlwiQUFBQTtJQUNJLGdCQUFnQjtJQUNoQix3Q0FBd0M7QUFDNUM7O0FBRUE7SUFDSSxhQUFhO0lBQ2IseUJBQXlCO0lBQ3pCLHFDQUFxQztBQUN6Qzs7QUFFQTtBQUNBXCIsXCJzb3VyY2VzQ29udGVudFwiOltcIi5yb290IHtcXHJcXG4gICAgbGlzdC1zdHlsZTogbm9uZTtcXHJcXG4gICAgYm9yZGVyLWJvdHRvbTogMXB4IHNvbGlkIHZhcigtLWMtYm9yZGVyKTtcXHJcXG59XFxyXFxuXFxyXFxuLml0ZW0ge1xcclxcbiAgICBkaXNwbGF5OiBmbGV4O1xcclxcbiAgICBqdXN0aWZ5LWNvbnRlbnQ6IGZsZXgtZW5kO1xcclxcbiAgICBib3JkZXItdG9wOiAxcHggc29saWQgdmFyKC0tYy1ib3JkZXIpO1xcclxcbn1cXHJcXG5cXHJcXG4uYnV0dG9uIHtcXHJcXG59XFxyXFxuXCJdLFwic291cmNlUm9vdFwiOlwiXCJ9XSk7XG4vLyBFeHBvcnRzXG5fX19DU1NfTE9BREVSX0VYUE9SVF9fXy5sb2NhbHMgPSB7XG5cdFwicm9vdFwiOiBcIkFib3V0Q29udHJvbHNfcm9vdF9fMUJjTHZcIixcblx0XCJpdGVtXCI6IFwiQWJvdXRDb250cm9sc19pdGVtX19sZFBVMFwiLFxuXHRcImJ1dHRvblwiOiBcIkFib3V0Q29udHJvbHNfYnV0dG9uX18xOFA0bVwiXG59O1xubW9kdWxlLmV4cG9ydHMgPSBfX19DU1NfTE9BREVSX0VYUE9SVF9fXztcbiIsIi8vIEltcG9ydHNcbnZhciBfX19DU1NfTE9BREVSX0FQSV9JTVBPUlRfX18gPSByZXF1aXJlKFwiLi4vLi4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jb21waWxlZC9jc3MtbG9hZGVyL2FwaS5qc1wiKTtcbnZhciBfX19DU1NfTE9BREVSX0VYUE9SVF9fXyA9IF9fX0NTU19MT0FERVJfQVBJX0lNUE9SVF9fXyh0cnVlKTtcbi8vIE1vZHVsZVxuX19fQ1NTX0xPQURFUl9FWFBPUlRfX18ucHVzaChbbW9kdWxlLmlkLCBcIi5BYm91dE5hdmlnYXRpb25fcm9vdF9fMjNzZDAge1xcclxcbiAgICBkaXNwbGF5OiBmbGV4O1xcclxcbiAgICBqdXN0aWZ5LWNvbnRlbnQ6IGNlbnRlcjtcXHJcXG59XFxyXFxuXFxyXFxuLkFib3V0TmF2aWdhdGlvbl9pdGVtX18xYS1EaiB7XFxyXFxuICAgIGNvbG9yOiB2YXIoLS1jLXApO1xcclxcbiAgICBmb250LXNpemU6IHZhcigtLWZzLXNtYWxsKVxcclxcbn1cXHJcXG5cXHJcXG4uQWJvdXROYXZpZ2F0aW9uX2l0ZW1fXzFhLURqICsgLkFib3V0TmF2aWdhdGlvbl9pdGVtX18xYS1EaiB7XFxyXFxuICAgICAgICBtYXJnaW4tbGVmdDogdmFyKC0tc3BhY2UpO1xcclxcbiAgICB9XFxyXFxuXCIsIFwiXCIse1widmVyc2lvblwiOjMsXCJzb3VyY2VzXCI6W1wid2VicGFjazovL2NvbXBvbmVudHMvQWJvdXQvQWJvdXROYXZpZ2F0aW9uLm1vZHVsZS5jc3NcIl0sXCJuYW1lc1wiOltdLFwibWFwcGluZ3NcIjpcIkFBQUE7SUFDSSxhQUFhO0lBQ2IsdUJBQXVCO0FBQzNCOztBQUVBO0lBQ0ksaUJBQWlCO0lBQ2pCO0FBS0o7O0FBSEk7UUFDSSx5QkFBeUI7SUFDN0JcIixcInNvdXJjZXNDb250ZW50XCI6W1wiLnJvb3Qge1xcclxcbiAgICBkaXNwbGF5OiBmbGV4O1xcclxcbiAgICBqdXN0aWZ5LWNvbnRlbnQ6IGNlbnRlcjtcXHJcXG59XFxyXFxuXFxyXFxuLml0ZW0ge1xcclxcbiAgICBjb2xvcjogdmFyKC0tYy1wKTtcXHJcXG4gICAgZm9udC1zaXplOiB2YXIoLS1mcy1zbWFsbCk7XFxyXFxuXFxyXFxuICAgICYgKyAuaXRlbSB7XFxyXFxuICAgICAgICBtYXJnaW4tbGVmdDogdmFyKC0tc3BhY2UpO1xcclxcbiAgICB9XFxyXFxufVxcclxcblwiXSxcInNvdXJjZVJvb3RcIjpcIlwifV0pO1xuLy8gRXhwb3J0c1xuX19fQ1NTX0xPQURFUl9FWFBPUlRfX18ubG9jYWxzID0ge1xuXHRcInJvb3RcIjogXCJBYm91dE5hdmlnYXRpb25fcm9vdF9fMjNzZDBcIixcblx0XCJpdGVtXCI6IFwiQWJvdXROYXZpZ2F0aW9uX2l0ZW1fXzFhLURqXCJcbn07XG5tb2R1bGUuZXhwb3J0cyA9IF9fX0NTU19MT0FERVJfRVhQT1JUX19fO1xuIiwiLy8gSW1wb3J0c1xudmFyIF9fX0NTU19MT0FERVJfQVBJX0lNUE9SVF9fXyA9IHJlcXVpcmUoXCIuLi8uLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NvbXBpbGVkL2Nzcy1sb2FkZXIvYXBpLmpzXCIpO1xudmFyIF9fX0NTU19MT0FERVJfRVhQT1JUX19fID0gX19fQ1NTX0xPQURFUl9BUElfSU1QT1JUX19fKHRydWUpO1xuLy8gTW9kdWxlXG5fX19DU1NfTE9BREVSX0VYUE9SVF9fXy5wdXNoKFttb2R1bGUuaWQsIFwiXFxyXFxuICAgIC5FbWFpbFNpZ251cF9jb250ZW50X18xVnlmcSA+ICogKyAqIHtcXHJcXG4gICAgICAgIG1hcmdpbi10b3A6IDAuNWVtO1xcclxcbiAgICB9XFxyXFxuXFxyXFxuLkVtYWlsU2lnbnVwX2Zvcm1fXzJCUmZUIHtcXHJcXG4gICAgbWFyZ2luLXRvcDogdmFyKC0tc3BhY2UpO1xcclxcbn1cXHJcXG5cXHJcXG4uRW1haWxTaWdudXBfbm90aWZpY2F0aW9uX19QVUJpRyB7XFxyXFxuICAgIG1hcmdpbi10b3A6IHZhcigtLXNwYWNlLXhsKTtcXHJcXG59XFxyXFxuXFxyXFxuLkVtYWlsU2lnbnVwX2Rpc2NsYWltZXJfX0xRN29GIHtcXHJcXG4gICAgbWFyZ2luLXRvcDogdmFyKC0tc3BhY2UpO1xcclxcbiAgICBmb250LXNpemU6IHZhcigtLWZzLXhzbWFsbCk7XFxyXFxufVxcclxcblwiLCBcIlwiLHtcInZlcnNpb25cIjozLFwic291cmNlc1wiOltcIndlYnBhY2s6Ly9jb21wb25lbnRzL0Fib3V0L0VtYWlsU2lnbnVwLm1vZHVsZS5jc3NcIl0sXCJuYW1lc1wiOltdLFwibWFwcGluZ3NcIjpcIjtJQUNJO1FBQ0ksaUJBQWlCO0lBQ3JCOztBQUdKO0lBQ0ksd0JBQXdCO0FBQzVCOztBQUVBO0lBQ0ksMkJBQTJCO0FBQy9COztBQUVBO0lBQ0ksd0JBQXdCO0lBQ3hCLDJCQUEyQjtBQUMvQlwiLFwic291cmNlc0NvbnRlbnRcIjpbXCIuY29udGVudCB7XFxyXFxuICAgICYgPiAqICsgKiB7XFxyXFxuICAgICAgICBtYXJnaW4tdG9wOiAwLjVlbTtcXHJcXG4gICAgfVxcclxcbn1cXHJcXG5cXHJcXG4uZm9ybSB7XFxyXFxuICAgIG1hcmdpbi10b3A6IHZhcigtLXNwYWNlKTtcXHJcXG59XFxyXFxuXFxyXFxuLm5vdGlmaWNhdGlvbiB7XFxyXFxuICAgIG1hcmdpbi10b3A6IHZhcigtLXNwYWNlLXhsKTtcXHJcXG59XFxyXFxuXFxyXFxuLmRpc2NsYWltZXIge1xcclxcbiAgICBtYXJnaW4tdG9wOiB2YXIoLS1zcGFjZSk7XFxyXFxuICAgIGZvbnQtc2l6ZTogdmFyKC0tZnMteHNtYWxsKTtcXHJcXG59XFxyXFxuXCJdLFwic291cmNlUm9vdFwiOlwiXCJ9XSk7XG4vLyBFeHBvcnRzXG5fX19DU1NfTE9BREVSX0VYUE9SVF9fXy5sb2NhbHMgPSB7XG5cdFwiY29udGVudFwiOiBcIkVtYWlsU2lnbnVwX2NvbnRlbnRfXzFWeWZxXCIsXG5cdFwiZm9ybVwiOiBcIkVtYWlsU2lnbnVwX2Zvcm1fXzJCUmZUXCIsXG5cdFwibm90aWZpY2F0aW9uXCI6IFwiRW1haWxTaWdudXBfbm90aWZpY2F0aW9uX19QVUJpR1wiLFxuXHRcImRpc2NsYWltZXJcIjogXCJFbWFpbFNpZ251cF9kaXNjbGFpbWVyX19MUTdvRlwiXG59O1xubW9kdWxlLmV4cG9ydHMgPSBfX19DU1NfTE9BREVSX0VYUE9SVF9fXztcbiIsIi8vIEltcG9ydHNcbnZhciBfX19DU1NfTE9BREVSX0FQSV9JTVBPUlRfX18gPSByZXF1aXJlKFwiLi4vLi4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jb21waWxlZC9jc3MtbG9hZGVyL2FwaS5qc1wiKTtcbnZhciBfX19DU1NfTE9BREVSX0VYUE9SVF9fXyA9IF9fX0NTU19MT0FERVJfQVBJX0lNUE9SVF9fXyh0cnVlKTtcbi8vIE1vZHVsZVxuX19fQ1NTX0xPQURFUl9FWFBPUlRfX18ucHVzaChbbW9kdWxlLmlkLCBcIi5QdXNoTm90aWZpY2F0aW9uc19hYm91dF9fb0hIRnUge1xcbn1cXG5cXG4uUHVzaE5vdGlmaWNhdGlvbnNfZmVlZGJhY2tfXzN3TWM1IHtcXG4gICAgbWFyZ2luLXRvcDogdmFyKC0tc3BhY2UpO1xcbn1cXG5cXG4uUHVzaE5vdGlmaWNhdGlvbnNfbG9hZGVyX18xajB0MSB7XFxuICAgIHdpZHRoOiAxMDAlO1xcbiAgICBmb250LXNpemU6IDEuNnJlbTtcXG4gICAgcGFkZGluZy10b3A6IHZhcigtLXNwYWNlKVxcbn1cXG5cXG4uUHVzaE5vdGlmaWNhdGlvbnNfbG9hZGVyX18xajB0MTphZnRlciB7XFxuICAgICAgICBtYXJnaW46IDAgYXV0bztcXG4gICAgfVxcblxcbi5QdXNoTm90aWZpY2F0aW9uc19jaGVja2VkX19WWFVNUSB7XFxuICAgIGRpc3BsYXk6IGZsZXg7XFxuICAgIGFsaWduLWl0ZW1zOiBjZW50ZXI7XFxuICAgIG1hcmdpbi1ib3R0b206IHZhcigtLXNwYWNlKTtcXG5cXG4gICAgLlB1c2hOb3RpZmljYXRpb25zX3N2Z19fMTZacFEge1xcbiAgICAgICAgbWFyZ2luLXJpZ2h0OiAwLjVyZW07XFxuICAgICAgICBjb2xvcjogdmFyKC0tYy1zZWNvbmRhcnkpO1xcbiAgICB9XFxufVxcblwiLCBcIlwiLHtcInZlcnNpb25cIjozLFwic291cmNlc1wiOltcIndlYnBhY2s6Ly9jb21wb25lbnRzL0Fib3V0L1B1c2hOb3RpZmljYXRpb25zLm1vZHVsZS5jc3NcIl0sXCJuYW1lc1wiOltdLFwibWFwcGluZ3NcIjpcIkFBQUE7QUFDQTs7QUFFQTtJQUNJLHdCQUF3QjtBQUM1Qjs7QUFFQTtJQUNJLFdBQVc7SUFDWCxpQkFBaUI7SUFDakI7QUFLSjs7QUFISTtRQUNJLGNBQWM7SUFDbEI7O0FBR0o7SUFDSSxhQUFhO0lBQ2IsbUJBQW1CO0lBQ25CLDJCQUEyQjs7SUFFM0I7UUFDSSxvQkFBb0I7UUFDcEIseUJBQXlCO0lBQzdCO0FBQ0pcIixcInNvdXJjZXNDb250ZW50XCI6W1wiLmFib3V0IHtcXG59XFxuXFxuLmZlZWRiYWNrIHtcXG4gICAgbWFyZ2luLXRvcDogdmFyKC0tc3BhY2UpO1xcbn1cXG5cXG4ubG9hZGVyIHtcXG4gICAgd2lkdGg6IDEwMCU7XFxuICAgIGZvbnQtc2l6ZTogMS42cmVtO1xcbiAgICBwYWRkaW5nLXRvcDogdmFyKC0tc3BhY2UpO1xcblxcbiAgICAmOmFmdGVyIHtcXG4gICAgICAgIG1hcmdpbjogMCBhdXRvO1xcbiAgICB9XFxufVxcblxcbi5jaGVja2VkIHtcXG4gICAgZGlzcGxheTogZmxleDtcXG4gICAgYWxpZ24taXRlbXM6IGNlbnRlcjtcXG4gICAgbWFyZ2luLWJvdHRvbTogdmFyKC0tc3BhY2UpO1xcblxcbiAgICAuc3ZnIHtcXG4gICAgICAgIG1hcmdpbi1yaWdodDogMC41cmVtO1xcbiAgICAgICAgY29sb3I6IHZhcigtLWMtc2Vjb25kYXJ5KTtcXG4gICAgfVxcbn1cXG5cIl0sXCJzb3VyY2VSb290XCI6XCJcIn1dKTtcbi8vIEV4cG9ydHNcbl9fX0NTU19MT0FERVJfRVhQT1JUX19fLmxvY2FscyA9IHtcblx0XCJhYm91dFwiOiBcIlB1c2hOb3RpZmljYXRpb25zX2Fib3V0X19vSEhGdVwiLFxuXHRcImZlZWRiYWNrXCI6IFwiUHVzaE5vdGlmaWNhdGlvbnNfZmVlZGJhY2tfXzN3TWM1XCIsXG5cdFwibG9hZGVyXCI6IFwiUHVzaE5vdGlmaWNhdGlvbnNfbG9hZGVyX18xajB0MVwiLFxuXHRcImNoZWNrZWRcIjogXCJQdXNoTm90aWZpY2F0aW9uc19jaGVja2VkX19WWFVNUVwiLFxuXHRcInN2Z1wiOiBcIlB1c2hOb3RpZmljYXRpb25zX3N2Z19fMTZacFFcIlxufTtcbm1vZHVsZS5leHBvcnRzID0gX19fQ1NTX0xPQURFUl9FWFBPUlRfX187XG4iLCIvLyBJbXBvcnRzXG52YXIgX19fQ1NTX0xPQURFUl9BUElfSU1QT1JUX19fID0gcmVxdWlyZShcIi4uLy4uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvY3NzLWxvYWRlci9hcGkuanNcIik7XG52YXIgX19fQ1NTX0xPQURFUl9FWFBPUlRfX18gPSBfX19DU1NfTE9BREVSX0FQSV9JTVBPUlRfX18odHJ1ZSk7XG4vLyBNb2R1bGVcbl9fX0NTU19MT0FERVJfRVhQT1JUX19fLnB1c2goW21vZHVsZS5pZCwgXCIuQ2FsZW5kYXJfcm9vdF9fM1JOeUMge1xcbiAgICBwb3NpdGlvbjogcmVsYXRpdmU7XFxufVxcblxcbi5DYWxlbmRhcl9oZWFkZXJfXzJVTzBrIHtcXG4gICAgcGFkZGluZy1ib3R0b206IHZhcigtLXNwYWNlLXhsKTtcXG59XFxuXFxuLkNhbGVuZGFyX2NhbGVuZGFyX18yNTNJRCB7XFxuICAgIGRpc3BsYXk6IGdyaWQ7XFxuICAgIGdyaWQtdGVtcGxhdGUtY29sdW1uczogMWZyIDFmciAxZnIgMWZyIDFmcjtcXG4gICAgZ3JpZC10ZW1wbGF0ZS1yb3dzOiAxZnIgMWZyIDFmciAxZnIgMWZyO1xcbiAgICBncmlkLWF1dG8tY29sdW1uczogMWZyO1xcbiAgICBncmlkLWF1dG8tcm93czogMWZyO1xcbiAgICBncmlkLWdhcDogdmFyKC0tc3BhY2UtcylcXG59XFxuXFxuQG1lZGlhIChvcmllbnRhdGlvbjogcG9ydHJhaXQpIHtcXG5cXG4uQ2FsZW5kYXJfY2FsZW5kYXJfXzI1M0lEIHtcXG4gICAgICAgIGdyaWQtdGVtcGxhdGUtY29sdW1uczogMWZyIDFmciAxZnIgMWZyO1xcbiAgICAgICAgZ3JpZC10ZW1wbGF0ZS1yb3dzOiAxZnIgMWZyIDFmciAxZnIgMWZyIDFmcjtcXG4gICAgICAgIGdyaWQtZ2FwOiB2YXIoLS1zcGFjZS14cylcXG59XFxuICAgIH1cXG5cXG4uQ2FsZW5kYXJfY2FsZW5kYXJfXzI1M0lEIHtcXG5cXG4gICAgLkNhbGVuZGFyX2l0ZW1fX0NieXRzIHtcXG4gICAgICAgIHBvc2l0aW9uOiByZWxhdGl2ZTtcXG4gICAgfVxcbn1cXG5cXG4uQ2FsZW5kYXJfaXRlbS0tMjRfXzJLdU5ZIHtcXG4gICAgZ3JpZC1jb2x1bW46IHNwYW4gMlxcbn1cXG5cXG5AbWVkaWEgKG9yaWVudGF0aW9uOiBwb3J0cmFpdCkge1xcblxcbi5DYWxlbmRhcl9pdGVtLS0yNF9fMkt1Tlkge1xcbiAgICAgICAgZ3JpZC1jb2x1bW46IHNwYW4gMVxcbn1cXG4gICAgfVxcblxcbi5DYWxlbmRhcl9pdGVtLS1saXN0X18zOHYtbCB7XFxuICAgIGdyaWQtY29sdW1uOiBzcGFuIDFcXG59XFxuXFxuQG1lZGlhIChvcmllbnRhdGlvbjogcG9ydHJhaXQpIHtcXG5cXG4uQ2FsZW5kYXJfaXRlbS0tbGlzdF9fMzh2LWwge1xcbiAgICAgICAgZ3JpZC1jb2x1bW46IHNwYW4gMVxcbn1cXG4gICAgfVxcblxcbi5DYWxlbmRhcl9saXN0X18xdExEdCB7XFxuICAgIGRpc3BsYXk6IGdyaWQ7XFxuICAgIGdyaWQtdGVtcGxhdGUtY29sdW1uczogMWZyIDFmcjtcXG59XFxuXFxuQG1lZGlhIChvcmllbnRhdGlvbjogcG9ydHJhaXQpIHtcXG5cXG4uQ2FsZW5kYXJfbGlzdF9fMXRMRHQge1xcbiAgICAgICAgZ3JpZC10ZW1wbGF0ZS1jb2x1bW5zOiAxZnI7XFxufVxcbiAgICB9XFxuXFxuLkNhbGVuZGFyX2xpc3RfXzF0TER0IHtcXG4gICAgZ3JpZC1hdXRvLWNvbHVtbnM6IDFmcjtcXG4gICAgZ3JpZC1hdXRvLXJvd3M6IDFmcjtcXG4gICAgZ3JpZC1nYXA6IHZhcigtLXNwYWNlLXMpO1xcbiAgICBtYXJnaW46IDAgY2FsYyh2YXIoLS1zcGFjZS14bCkgKiAyKTtcXG59XFxuXFxuQG1lZGlhIChvcmllbnRhdGlvbjogcG9ydHJhaXQpIHtcXG5cXG4uQ2FsZW5kYXJfbGlzdF9fMXRMRHQge1xcbiAgICAgICAgbWFyZ2luOiAwIDA7XFxufVxcbiAgICB9XFxuXFxuLkNhbGVuZGFyX2xpc3RfXzF0TER0IHtcXG5cXG4gICAgb3ZlcmZsb3cteTogYXV0bztcXG59XFxuXFxuLkNhbGVuZGFyX2xpc3RfXzF0TER0Ojotd2Via2l0LXNjcm9sbGJhciB7XFxuICAgIHdpZHRoOiA1cHg7XFxufVxcblxcbi5DYWxlbmRhcl9saXN0X18xdExEdDo6LXdlYmtpdC1zY3JvbGxiYXItdGh1bWIge1xcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiB0cmFuc3BhcmVudDtcXG4gICAgLXdlYmtpdC10cmFuc2l0aW9uOiBiYWNrZ3JvdW5kLWNvbG9yIDIwMG1zO1xcbiAgICB0cmFuc2l0aW9uOiBiYWNrZ3JvdW5kLWNvbG9yIDIwMG1zO1xcbiAgICB3aWxsLWNoYW5nZTogYmFja2dyb3VuZC1jb2xvcjtcXG4gICAgYm9yZGVyLXJhZGl1czogNXB4O1xcbn1cXG5cXG4uQ2FsZW5kYXJfbGlzdF9fMXRMRHQ6Oi13ZWJraXQtc2Nyb2xsYmFyLXRyYWNrIHtcXG4gICAgYmFja2dyb3VuZDogdHJhbnNwYXJlbnQ7XFxufVxcblxcbi5DYWxlbmRhcl9saXN0X18xdExEdDpob3ZlciA6Oi13ZWJraXQtc2Nyb2xsYmFyLXRodW1iIHtcXG4gICAgYmFja2dyb3VuZC1jb2xvcjogdmFyKC0tYy1ib3JkZXItZGFyayk7XFxufVxcblxcblxcbi5DYWxlbmRhcl9idXR0b25PdmVybGF5X19LRkJvbSB7XFxuICAgIGN1cnNvcjogcG9pbnRlcjtcXG4gICAgZGlzcGxheTogYmxvY2s7XFxuICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcXG4gICAgYm90dG9tOiAwO1xcbiAgICByaWdodDogMDtcXG4gICAgbGVmdDogMDtcXG4gICAgdG9wOiAwO1xcbiAgICB3aWR0aDogMTAwJTtcXG4gICAgei1pbmRleDogOTk5OTtcXG4gICAgdGV4dC1pbmRlbnQ6IC05OTk5cHg7XFxufVxcblxcbltkYXRhLWxheW91dD1cXFwiZGVza3RvcFxcXCJdIC5DYWxlbmRhcl9idXR0b25PdmVybGF5X19LRkJvbSB7XFxuICAgIGRpc3BsYXk6IG5vbmU7XFxufVxcblwiLCBcIlwiLHtcInZlcnNpb25cIjozLFwic291cmNlc1wiOltcIndlYnBhY2s6Ly9jb21wb25lbnRzL0NhbGVuZGFyL0NhbGVuZGFyLm1vZHVsZS5jc3NcIl0sXCJuYW1lc1wiOltdLFwibWFwcGluZ3NcIjpcIkFBQUE7SUFDSSxrQkFBa0I7QUFDdEI7O0FBRUE7SUFDSSwrQkFBK0I7QUFDbkM7O0FBRUE7SUFDSSxhQUFhO0lBQ2IsMENBQTBDO0lBQzFDLHVDQUF1QztJQUN2QyxzQkFBc0I7SUFDdEIsbUJBQW1CO0lBQ25CO0FBV0o7O0FBVEk7O0FBUko7UUFTUSxzQ0FBc0M7UUFDdEMsMkNBQTJDO1FBQzNDO0FBTVI7SUFMSTs7QUFaSjs7SUFjSTtRQUNJLGtCQUFrQjtJQUN0QjtBQUNKOztBQUVBO0lBQ0k7QUFJSjs7QUFISTs7QUFGSjtRQUdRO0FBRVI7SUFESTs7QUFHSjtJQUNJO0FBSUo7O0FBSEk7O0FBRko7UUFHUTtBQUVSO0lBREk7O0FBR0o7SUFDSSxhQUFhO0lBQ2IsOEJBQThCO0FBYWxDOztBQVpJOztBQUhKO1FBSVEsMEJBQTBCO0FBV2xDO0lBVkk7O0FBTEo7SUFNSSxzQkFBc0I7SUFDdEIsbUJBQW1CO0lBQ25CLHdCQUF3QjtJQUN4QixtQ0FBbUM7QUFNdkM7O0FBTEk7O0FBVko7UUFXUSxXQUFXO0FBSW5CO0lBSEk7O0FBWko7O0lBY0ksZ0JBQWdCO0FBQ3BCOztBQUVBO0lBQ0ksVUFBVTtBQUNkOztBQUVBO0lBQ0ksNkJBQTZCO0lBQzdCLDBDQUFrQztJQUFsQyxrQ0FBa0M7SUFDbEMsNkJBQTZCO0lBQzdCLGtCQUFrQjtBQUN0Qjs7QUFFQTtJQUNJLHVCQUF1QjtBQUMzQjs7QUFFQTtJQUNJLHNDQUFzQztBQUMxQzs7O0FBR0E7SUFDSSxlQUFlO0lBQ2YsY0FBYztJQUNkLGtCQUFrQjtJQUNsQixTQUFTO0lBQ1QsUUFBUTtJQUNSLE9BQU87SUFDUCxNQUFNO0lBQ04sV0FBVztJQUNYLGFBQWE7SUFDYixvQkFBb0I7QUFDeEI7O0FBRUE7SUFDSSxhQUFhO0FBQ2pCXCIsXCJzb3VyY2VzQ29udGVudFwiOltcIi5yb290IHtcXG4gICAgcG9zaXRpb246IHJlbGF0aXZlO1xcbn1cXG5cXG4uaGVhZGVyIHtcXG4gICAgcGFkZGluZy1ib3R0b206IHZhcigtLXNwYWNlLXhsKTtcXG59XFxuXFxuLmNhbGVuZGFyIHtcXG4gICAgZGlzcGxheTogZ3JpZDtcXG4gICAgZ3JpZC10ZW1wbGF0ZS1jb2x1bW5zOiAxZnIgMWZyIDFmciAxZnIgMWZyO1xcbiAgICBncmlkLXRlbXBsYXRlLXJvd3M6IDFmciAxZnIgMWZyIDFmciAxZnI7XFxuICAgIGdyaWQtYXV0by1jb2x1bW5zOiAxZnI7XFxuICAgIGdyaWQtYXV0by1yb3dzOiAxZnI7XFxuICAgIGdyaWQtZ2FwOiB2YXIoLS1zcGFjZS1zKTtcXG5cXG4gICAgQG1lZGlhIChvcmllbnRhdGlvbjogcG9ydHJhaXQpIHtcXG4gICAgICAgIGdyaWQtdGVtcGxhdGUtY29sdW1uczogMWZyIDFmciAxZnIgMWZyO1xcbiAgICAgICAgZ3JpZC10ZW1wbGF0ZS1yb3dzOiAxZnIgMWZyIDFmciAxZnIgMWZyIDFmcjtcXG4gICAgICAgIGdyaWQtZ2FwOiB2YXIoLS1zcGFjZS14cyk7XFxuICAgIH1cXG5cXG4gICAgLml0ZW0ge1xcbiAgICAgICAgcG9zaXRpb246IHJlbGF0aXZlO1xcbiAgICB9XFxufVxcblxcbi5pdGVtLS0yNCB7XFxuICAgIGdyaWQtY29sdW1uOiBzcGFuIDI7XFxuICAgIEBtZWRpYSAob3JpZW50YXRpb246IHBvcnRyYWl0KSB7XFxuICAgICAgICBncmlkLWNvbHVtbjogc3BhbiAxO1xcbiAgICB9XFxufVxcblxcbi5pdGVtLS1saXN0IHtcXG4gICAgZ3JpZC1jb2x1bW46IHNwYW4gMTtcXG4gICAgQG1lZGlhIChvcmllbnRhdGlvbjogcG9ydHJhaXQpIHtcXG4gICAgICAgIGdyaWQtY29sdW1uOiBzcGFuIDE7XFxuICAgIH1cXG59XFxuXFxuLmxpc3Qge1xcbiAgICBkaXNwbGF5OiBncmlkO1xcbiAgICBncmlkLXRlbXBsYXRlLWNvbHVtbnM6IDFmciAxZnI7XFxuICAgIEBtZWRpYSAob3JpZW50YXRpb246IHBvcnRyYWl0KSB7XFxuICAgICAgICBncmlkLXRlbXBsYXRlLWNvbHVtbnM6IDFmcjtcXG4gICAgfVxcbiAgICBncmlkLWF1dG8tY29sdW1uczogMWZyO1xcbiAgICBncmlkLWF1dG8tcm93czogMWZyO1xcbiAgICBncmlkLWdhcDogdmFyKC0tc3BhY2Utcyk7XFxuICAgIG1hcmdpbjogMCBjYWxjKHZhcigtLXNwYWNlLXhsKSAqIDIpO1xcbiAgICBAbWVkaWEgKG9yaWVudGF0aW9uOiBwb3J0cmFpdCkge1xcbiAgICAgICAgbWFyZ2luOiAwIDA7XFxuICAgIH1cXG5cXG4gICAgb3ZlcmZsb3cteTogYXV0bztcXG59XFxuXFxuLmxpc3Q6Oi13ZWJraXQtc2Nyb2xsYmFyIHtcXG4gICAgd2lkdGg6IDVweDtcXG59XFxuXFxuLmxpc3Q6Oi13ZWJraXQtc2Nyb2xsYmFyLXRodW1iIHtcXG4gICAgYmFja2dyb3VuZC1jb2xvcjogdHJhbnNwYXJlbnQ7XFxuICAgIHRyYW5zaXRpb246IGJhY2tncm91bmQtY29sb3IgMjAwbXM7XFxuICAgIHdpbGwtY2hhbmdlOiBiYWNrZ3JvdW5kLWNvbG9yO1xcbiAgICBib3JkZXItcmFkaXVzOiA1cHg7XFxufVxcblxcbi5saXN0Ojotd2Via2l0LXNjcm9sbGJhci10cmFjayB7XFxuICAgIGJhY2tncm91bmQ6IHRyYW5zcGFyZW50O1xcbn1cXG5cXG4ubGlzdDpob3ZlciA6Oi13ZWJraXQtc2Nyb2xsYmFyLXRodW1iIHtcXG4gICAgYmFja2dyb3VuZC1jb2xvcjogdmFyKC0tYy1ib3JkZXItZGFyayk7XFxufVxcblxcblxcbi5idXR0b25PdmVybGF5IHtcXG4gICAgY3Vyc29yOiBwb2ludGVyO1xcbiAgICBkaXNwbGF5OiBibG9jaztcXG4gICAgcG9zaXRpb246IGFic29sdXRlO1xcbiAgICBib3R0b206IDA7XFxuICAgIHJpZ2h0OiAwO1xcbiAgICBsZWZ0OiAwO1xcbiAgICB0b3A6IDA7XFxuICAgIHdpZHRoOiAxMDAlO1xcbiAgICB6LWluZGV4OiA5OTk5O1xcbiAgICB0ZXh0LWluZGVudDogLTk5OTlweDtcXG59XFxuXFxuW2RhdGEtbGF5b3V0PVxcXCJkZXNrdG9wXFxcIl0gLmJ1dHRvbk92ZXJsYXkge1xcbiAgICBkaXNwbGF5OiBub25lO1xcbn1cXG5cIl0sXCJzb3VyY2VSb290XCI6XCJcIn1dKTtcbi8vIEV4cG9ydHNcbl9fX0NTU19MT0FERVJfRVhQT1JUX19fLmxvY2FscyA9IHtcblx0XCJyb290XCI6IFwiQ2FsZW5kYXJfcm9vdF9fM1JOeUNcIixcblx0XCJoZWFkZXJcIjogXCJDYWxlbmRhcl9oZWFkZXJfXzJVTzBrXCIsXG5cdFwiY2FsZW5kYXJcIjogXCJDYWxlbmRhcl9jYWxlbmRhcl9fMjUzSURcIixcblx0XCJpdGVtXCI6IFwiQ2FsZW5kYXJfaXRlbV9fQ2J5dHNcIixcblx0XCJpdGVtLS0yNFwiOiBcIkNhbGVuZGFyX2l0ZW0tLTI0X18yS3VOWVwiLFxuXHRcIml0ZW0tLWxpc3RcIjogXCJDYWxlbmRhcl9pdGVtLS1saXN0X18zOHYtbFwiLFxuXHRcImxpc3RcIjogXCJDYWxlbmRhcl9saXN0X18xdExEdFwiLFxuXHRcImJ1dHRvbk92ZXJsYXlcIjogXCJDYWxlbmRhcl9idXR0b25PdmVybGF5X19LRkJvbVwiXG59O1xubW9kdWxlLmV4cG9ydHMgPSBfX19DU1NfTE9BREVSX0VYUE9SVF9fXztcbiIsIi8vIEltcG9ydHNcbnZhciBfX19DU1NfTE9BREVSX0FQSV9JTVBPUlRfX18gPSByZXF1aXJlKFwiLi4vLi4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jb21waWxlZC9jc3MtbG9hZGVyL2FwaS5qc1wiKTtcbnZhciBfX19DU1NfTE9BREVSX0VYUE9SVF9fXyA9IF9fX0NTU19MT0FERVJfQVBJX0lNUE9SVF9fXyh0cnVlKTtcbi8vIE1vZHVsZVxuX19fQ1NTX0xPQURFUl9FWFBPUlRfX18ucHVzaChbbW9kdWxlLmlkLCBcIi5DYWxlbmRhckRheV93cmFwcGVyX19Va21neCwgLkNhbGVuZGFyRGF5X2RheV9fMTJ0SEIge1xcbiAgICB3aWR0aDogMTAwJTtcXG4gICAgaGVpZ2h0OiAxMDAlO1xcbiAgICBwb3NpdGlvbjogcmVsYXRpdmU7XFxuICAgIGRpc3BsYXk6IGJsb2NrO1xcbn1cXG5cXG4uQ2FsZW5kYXJEYXlfaW5uZXJfXzFiakpZIHtcXG59XFxuXFxuLkNhbGVuZGFyRGF5X3dyYXBwZXJfX1VrbWd4IHtcXG4gICAgLkNhbGVuZGFyRGF5X3Nub3dfXzI4Rm5YIHtcXG4gICAgICAgIHBvaW50ZXItZXZlbnRzOiBub25lO1xcbiAgICAgICAgcG9zaXRpb246IGFic29sdXRlO1xcbiAgICAgICAgei1pbmRleDogMjtcXG4gICAgICAgIGxlZnQ6IDA7XFxuICAgICAgICB0b3A6IDA7XFxuICAgICAgICB3aWR0aDogMTAwJTtcXG4gICAgICAgIHRyYW5zZm9ybTogdHJhbnNsYXRlWSgtNjAlKTtcXG4gICAgfVxcblxcbiAgICAuQ2FsZW5kYXJEYXlfc25vdy0tMV9fc2NpaUgge1xcbiAgICAgICAgdHJhbnNmb3JtOiB0cmFuc2xhdGVZKC01NSUpIHRyYW5zbGF0ZVgoLTMwJSkgc2NhbGUoMC41KTtcXG4gICAgfVxcblxcbiAgICAuQ2FsZW5kYXJEYXlfc25vdy0tMl9fMjAwa0Qge1xcbiAgICAgICAgdHJhbnNmb3JtOiB0cmFuc2xhdGVZKC02MSUpIHRyYW5zbGF0ZVgoMiUpIHNjYWxlKDEuMSk7XFxuICAgIH1cXG5cXG4gICAgLkNhbGVuZGFyRGF5X3Nub3ctLTNfXzNKbVVUIHtcXG4gICAgICAgIHRyYW5zZm9ybTogdHJhbnNsYXRlWSgtNjElKSB0cmFuc2xhdGVYKDIlKSBzY2FsZSgwLjgpO1xcbiAgICB9XFxuXFxuICAgIC5DYWxlbmRhckRheV9zbm93LS00X18xdE5OVyB7XFxuICAgICAgICB0cmFuc2Zvcm06IHRyYW5zbGF0ZVkoLTQ1JSkgdHJhbnNsYXRlWCgtMzAlKSBzY2FsZSgwLjUpO1xcbiAgICB9XFxuXFxuICAgIC5DYWxlbmRhckRheV9zbm93LS01X18zRXFIaSB7XFxuICAgICAgICB0cmFuc2Zvcm06IHRyYW5zbGF0ZVkoLTE4JSkgc2NhbGUoMS4wNSkgcm90YXRlKDRkZWcpO1xcbiAgICB9XFxuXFxuICAgIC5DYWxlbmRhckRheV9zbm93LS02X18yaHhxWiB7XFxuICAgICAgICB0cmFuc2Zvcm06IHRyYW5zbGF0ZVkoLTUwJSkgc2NhbGUoMS4xKTtcXG4gICAgfVxcblxcbiAgICAuQ2FsZW5kYXJEYXlfc25vdy0tN19fMi1Ld28ge1xcbiAgICB9XFxuXFxuICAgIC5DYWxlbmRhckRheV9zbm93LS04X18zV1YzTSB7XFxuICAgICAgICB0cmFuc2Zvcm06IHRyYW5zbGF0ZVkoLTQ1JSk7XFxuICAgIH1cXG5cXG4gICAgLkNhbGVuZGFyRGF5X3Nub3ctLTlfXzNzY184IHtcXG4gICAgICAgIHRyYW5zZm9ybTogdHJhbnNsYXRlWSgtNTAlKSBzY2FsZSgxLjEpO1xcbiAgICB9XFxuXFxuICAgIC5DYWxlbmRhckRheV9zbm93LS0xMF9fRzFmY3kge1xcbiAgICAgICAgdHJhbnNmb3JtOiB0cmFuc2xhdGVZKC01MCUpIHRyYW5zbGF0ZVgoMjAlKSBzY2FsZSgwLjcpIHJvdGF0ZSg1ZGVnKTtcXG4gICAgfVxcblxcbiAgICAuQ2FsZW5kYXJEYXlfc25vdy0tMTFfXzNVQmoxIHtcXG4gICAgICAgIHRyYW5zZm9ybTogdHJhbnNsYXRlWSgtMzUlKTtcXG4gICAgfVxcblxcbiAgICAuQ2FsZW5kYXJEYXlfc25vdy0tMTJfXzNXVVJBIHtcXG4gICAgICAgIHRyYW5zZm9ybTogdHJhbnNsYXRlWSgtNDUlKSBzY2FsZSgwLjgpO1xcbiAgICB9XFxuXFxuICAgIC5DYWxlbmRhckRheV9zbm93LS0xM19fMXJtd2oge1xcbiAgICAgICAgdHJhbnNmb3JtOiB0cmFuc2xhdGVZKC0zMCUpIHJvdGF0ZSgyZGVnKTtcXG4gICAgfVxcblxcbiAgICAuQ2FsZW5kYXJEYXlfc25vdy0tMTRfXzNkcDZlIHtcXG4gICAgICAgIHRyYW5zZm9ybTogdHJhbnNsYXRlWSgtMjAlKTtcXG4gICAgfVxcblxcbiAgICAuQ2FsZW5kYXJEYXlfc25vdy0tMTVfX1hLbmZBIHtcXG4gICAgICAgIHRyYW5zZm9ybTogdHJhbnNsYXRlWSgtNTAlKSBzY2FsZSgwLjkpO1xcbiAgICB9XFxuXFxuICAgIC5DYWxlbmRhckRheV9zbm93LS0xNl9fNHNiN0gge1xcbiAgICAgICAgdHJhbnNmb3JtOiB0cmFuc2xhdGVZKC01MCUpIHRyYW5zbGF0ZVgoLTQwJSkgc2NhbGUoMC40KSByb3RhdGUoLTEwZGVnKTtcXG4gICAgfVxcblxcbiAgICAuQ2FsZW5kYXJEYXlfc25vdy0tMTdfXzNTcTgwIHtcXG4gICAgICAgIHRyYW5zZm9ybTogdHJhbnNsYXRlWSgtNTAlKSBzY2FsZSgwLjgpIHRyYW5zbGF0ZVgoMjAlKTtcXG4gICAgfVxcblxcbiAgICAuQ2FsZW5kYXJEYXlfc25vdy0tMThfXzFqZzlRIHtcXG4gICAgICAgIHRyYW5zZm9ybTogdHJhbnNsYXRlWSgtNTAlKTtcXG4gICAgfVxcblxcbiAgICAuQ2FsZW5kYXJEYXlfc25vdy0tMTlfX08yQ1ZQIHtcXG4gICAgICAgIHRyYW5zZm9ybTogdHJhbnNsYXRlWSgtNDAlKSBzY2FsZSgwLjYpIHRyYW5zbGF0ZVgoLTQ1JSkgcm90YXRlKC04ZGVnKTtcXG4gICAgfVxcblxcbiAgICAuQ2FsZW5kYXJEYXlfc25vdy0tMjBfXzNhN0pRIHtcXG4gICAgICAgIHRyYW5zZm9ybTogdHJhbnNsYXRlWSgtNDUlKSBzY2FsZSgwLjQpIHRyYW5zbGF0ZVgoODUlKSByb3RhdGUoMTVkZWcpO1xcbiAgICB9XFxuXFxuICAgIC5DYWxlbmRhckRheV9zbm93LS0yMV9fMVY4bXIge1xcbiAgICAgICAgdHJhbnNmb3JtOiB0cmFuc2xhdGVZKC00NSUpO1xcbiAgICB9XFxuXFxuICAgIC5DYWxlbmRhckRheV9zbm93LS0yMl9fMnk0bVMge1xcbiAgICAgICAgdHJhbnNmb3JtOiB0cmFuc2xhdGVZKC02MSUpIHRyYW5zbGF0ZVgoMiUpIHNjYWxlKDAuOCk7XFxuICAgIH1cXG5cXG4gICAgLkNhbGVuZGFyRGF5X3Nub3ctLTIzX18xQ2ZjNiB7XFxuICAgICAgICB0cmFuc2Zvcm06IHRyYW5zbGF0ZVkoLTYwJSkgc2NhbGUoMC43KTtcXG4gICAgfVxcblxcblxcbiAgICAuQ2FsZW5kYXJEYXlfc25vdy0tMjRfXzNWUGxUIHtcXG4gICAgICAgIHRyYW5zZm9ybTogdHJhbnNsYXRlWSgtNTAlKSBzY2FsZSgwLjgpO1xcbiAgICB9XFxufVxcblxcbi5DYWxlbmRhckRheV9kYXlfXzEydEhCIHtcXG4gICAgYmFja2dyb3VuZC1jb2xvcjogdHJhbnNwYXJlbnQ7XFxuICAgIGJvcmRlcjogMnB4IGRhc2hlZCB2YXIoLS1jLWJvcmRlcik7XFxuICAgIGNvbG9yOiB2YXIoLS1jLXApO1xcbiAgICB0ZXh0LWRlY29yYXRpb246IG5vbmU7XFxuICAgIHBhZGRpbmc6IHZhcigtLXNwYWNlLWdyaWQpO1xcbiAgICBmb250LXdlaWdodDogOTAwO1xcbiAgICBmb250LXNpemU6IDEuNnJlbTtcXG59XFxuXFxuQG1lZGlhIChtYXgtd2lkdGg6IDgwMHB4KSB7XFxuXFxuLkNhbGVuZGFyRGF5X2RheV9fMTJ0SEIge1xcbiAgICAgICAgZm9udC1zaXplOiAxcmVtO1xcbn1cXG4gICAgfVxcblxcbi5DYWxlbmRhckRheV9kYXlfXzEydEhCIHtcXG4gICAgbGluZS1oZWlnaHQ6IDE7XFxufVxcblxcbi5DYWxlbmRhckRheV9kYXlBY3RpdmVfXzF2dTcyIHtcXG4gICAgYmFja2dyb3VuZC1jb2xvcjogdmFyKC0tYy1wcmltYXJ5KTtcXG4gICAgYm9yZGVyLWNvbG9yOiB0cmFuc3BhcmVudDtcXG4gICAgY29sb3I6IHZhcigtLWMtd2hpdGUpO1xcbn1cXG5cXG5cIiwgXCJcIix7XCJ2ZXJzaW9uXCI6MyxcInNvdXJjZXNcIjpbXCJ3ZWJwYWNrOi8vY29tcG9uZW50cy9DYWxlbmRhci9DYWxlbmRhckRheS5tb2R1bGUuY3NzXCJdLFwibmFtZXNcIjpbXSxcIm1hcHBpbmdzXCI6XCJBQUFBO0lBQ0ksV0FBVztJQUNYLFlBQVk7SUFDWixrQkFBa0I7SUFDbEIsY0FBYztBQUNsQjs7QUFFQTtBQUNBOztBQUVBO0lBQ0k7UUFDSSxvQkFBb0I7UUFDcEIsa0JBQWtCO1FBQ2xCLFVBQVU7UUFDVixPQUFPO1FBQ1AsTUFBTTtRQUNOLFdBQVc7UUFDWCwyQkFBMkI7SUFDL0I7O0lBRUE7UUFDSSx1REFBdUQ7SUFDM0Q7O0lBRUE7UUFDSSxxREFBcUQ7SUFDekQ7O0lBRUE7UUFDSSxxREFBcUQ7SUFDekQ7O0lBRUE7UUFDSSx1REFBdUQ7SUFDM0Q7O0lBRUE7UUFDSSxvREFBb0Q7SUFDeEQ7O0lBRUE7UUFDSSxzQ0FBc0M7SUFDMUM7O0lBRUE7SUFDQTs7SUFFQTtRQUNJLDJCQUEyQjtJQUMvQjs7SUFFQTtRQUNJLHNDQUFzQztJQUMxQzs7SUFFQTtRQUNJLG1FQUFtRTtJQUN2RTs7SUFFQTtRQUNJLDJCQUEyQjtJQUMvQjs7SUFFQTtRQUNJLHNDQUFzQztJQUMxQzs7SUFFQTtRQUNJLHdDQUF3QztJQUM1Qzs7SUFFQTtRQUNJLDJCQUEyQjtJQUMvQjs7SUFFQTtRQUNJLHNDQUFzQztJQUMxQzs7SUFFQTtRQUNJLHNFQUFzRTtJQUMxRTs7SUFFQTtRQUNJLHNEQUFzRDtJQUMxRDs7SUFFQTtRQUNJLDJCQUEyQjtJQUMvQjs7SUFFQTtRQUNJLHFFQUFxRTtJQUN6RTs7SUFFQTtRQUNJLG9FQUFvRTtJQUN4RTs7SUFFQTtRQUNJLDJCQUEyQjtJQUMvQjs7SUFFQTtRQUNJLHFEQUFxRDtJQUN6RDs7SUFFQTtRQUNJLHNDQUFzQztJQUMxQzs7O0lBR0E7UUFDSSxzQ0FBc0M7SUFDMUM7QUFDSjs7QUFFQTtJQUNJLDZCQUE2QjtJQUM3QixrQ0FBa0M7SUFDbEMsaUJBQWlCO0lBQ2pCLHFCQUFxQjtJQUNyQiwwQkFBMEI7SUFDMUIsZ0JBQWdCO0lBQ2hCLGlCQUFpQjtBQUtyQjs7QUFKSTs7QUFSSjtRQVNRLGVBQWU7QUFHdkI7SUFGSTs7QUFWSjtJQVdJLGNBQWM7QUFDbEI7O0FBRUE7SUFDSSxrQ0FBa0M7SUFDbEMseUJBQXlCO0lBQ3pCLHFCQUFxQjtBQUN6QlwiLFwic291cmNlc0NvbnRlbnRcIjpbXCIud3JhcHBlciwgLmRheSB7XFxuICAgIHdpZHRoOiAxMDAlO1xcbiAgICBoZWlnaHQ6IDEwMCU7XFxuICAgIHBvc2l0aW9uOiByZWxhdGl2ZTtcXG4gICAgZGlzcGxheTogYmxvY2s7XFxufVxcblxcbi5pbm5lciB7XFxufVxcblxcbi53cmFwcGVyIHtcXG4gICAgLnNub3cge1xcbiAgICAgICAgcG9pbnRlci1ldmVudHM6IG5vbmU7XFxuICAgICAgICBwb3NpdGlvbjogYWJzb2x1dGU7XFxuICAgICAgICB6LWluZGV4OiAyO1xcbiAgICAgICAgbGVmdDogMDtcXG4gICAgICAgIHRvcDogMDtcXG4gICAgICAgIHdpZHRoOiAxMDAlO1xcbiAgICAgICAgdHJhbnNmb3JtOiB0cmFuc2xhdGVZKC02MCUpO1xcbiAgICB9XFxuXFxuICAgIC5zbm93LS0xIHtcXG4gICAgICAgIHRyYW5zZm9ybTogdHJhbnNsYXRlWSgtNTUlKSB0cmFuc2xhdGVYKC0zMCUpIHNjYWxlKDAuNSk7XFxuICAgIH1cXG5cXG4gICAgLnNub3ctLTIge1xcbiAgICAgICAgdHJhbnNmb3JtOiB0cmFuc2xhdGVZKC02MSUpIHRyYW5zbGF0ZVgoMiUpIHNjYWxlKDEuMSk7XFxuICAgIH1cXG5cXG4gICAgLnNub3ctLTMge1xcbiAgICAgICAgdHJhbnNmb3JtOiB0cmFuc2xhdGVZKC02MSUpIHRyYW5zbGF0ZVgoMiUpIHNjYWxlKDAuOCk7XFxuICAgIH1cXG5cXG4gICAgLnNub3ctLTQge1xcbiAgICAgICAgdHJhbnNmb3JtOiB0cmFuc2xhdGVZKC00NSUpIHRyYW5zbGF0ZVgoLTMwJSkgc2NhbGUoMC41KTtcXG4gICAgfVxcblxcbiAgICAuc25vdy0tNSB7XFxuICAgICAgICB0cmFuc2Zvcm06IHRyYW5zbGF0ZVkoLTE4JSkgc2NhbGUoMS4wNSkgcm90YXRlKDRkZWcpO1xcbiAgICB9XFxuXFxuICAgIC5zbm93LS02IHtcXG4gICAgICAgIHRyYW5zZm9ybTogdHJhbnNsYXRlWSgtNTAlKSBzY2FsZSgxLjEpO1xcbiAgICB9XFxuXFxuICAgIC5zbm93LS03IHtcXG4gICAgfVxcblxcbiAgICAuc25vdy0tOCB7XFxuICAgICAgICB0cmFuc2Zvcm06IHRyYW5zbGF0ZVkoLTQ1JSk7XFxuICAgIH1cXG5cXG4gICAgLnNub3ctLTkge1xcbiAgICAgICAgdHJhbnNmb3JtOiB0cmFuc2xhdGVZKC01MCUpIHNjYWxlKDEuMSk7XFxuICAgIH1cXG5cXG4gICAgLnNub3ctLTEwIHtcXG4gICAgICAgIHRyYW5zZm9ybTogdHJhbnNsYXRlWSgtNTAlKSB0cmFuc2xhdGVYKDIwJSkgc2NhbGUoMC43KSByb3RhdGUoNWRlZyk7XFxuICAgIH1cXG5cXG4gICAgLnNub3ctLTExIHtcXG4gICAgICAgIHRyYW5zZm9ybTogdHJhbnNsYXRlWSgtMzUlKTtcXG4gICAgfVxcblxcbiAgICAuc25vdy0tMTIge1xcbiAgICAgICAgdHJhbnNmb3JtOiB0cmFuc2xhdGVZKC00NSUpIHNjYWxlKDAuOCk7XFxuICAgIH1cXG5cXG4gICAgLnNub3ctLTEzIHtcXG4gICAgICAgIHRyYW5zZm9ybTogdHJhbnNsYXRlWSgtMzAlKSByb3RhdGUoMmRlZyk7XFxuICAgIH1cXG5cXG4gICAgLnNub3ctLTE0IHtcXG4gICAgICAgIHRyYW5zZm9ybTogdHJhbnNsYXRlWSgtMjAlKTtcXG4gICAgfVxcblxcbiAgICAuc25vdy0tMTUge1xcbiAgICAgICAgdHJhbnNmb3JtOiB0cmFuc2xhdGVZKC01MCUpIHNjYWxlKDAuOSk7XFxuICAgIH1cXG5cXG4gICAgLnNub3ctLTE2IHtcXG4gICAgICAgIHRyYW5zZm9ybTogdHJhbnNsYXRlWSgtNTAlKSB0cmFuc2xhdGVYKC00MCUpIHNjYWxlKDAuNCkgcm90YXRlKC0xMGRlZyk7XFxuICAgIH1cXG5cXG4gICAgLnNub3ctLTE3IHtcXG4gICAgICAgIHRyYW5zZm9ybTogdHJhbnNsYXRlWSgtNTAlKSBzY2FsZSgwLjgpIHRyYW5zbGF0ZVgoMjAlKTtcXG4gICAgfVxcblxcbiAgICAuc25vdy0tMTgge1xcbiAgICAgICAgdHJhbnNmb3JtOiB0cmFuc2xhdGVZKC01MCUpO1xcbiAgICB9XFxuXFxuICAgIC5zbm93LS0xOSB7XFxuICAgICAgICB0cmFuc2Zvcm06IHRyYW5zbGF0ZVkoLTQwJSkgc2NhbGUoMC42KSB0cmFuc2xhdGVYKC00NSUpIHJvdGF0ZSgtOGRlZyk7XFxuICAgIH1cXG5cXG4gICAgLnNub3ctLTIwIHtcXG4gICAgICAgIHRyYW5zZm9ybTogdHJhbnNsYXRlWSgtNDUlKSBzY2FsZSgwLjQpIHRyYW5zbGF0ZVgoODUlKSByb3RhdGUoMTVkZWcpO1xcbiAgICB9XFxuXFxuICAgIC5zbm93LS0yMSB7XFxuICAgICAgICB0cmFuc2Zvcm06IHRyYW5zbGF0ZVkoLTQ1JSk7XFxuICAgIH1cXG5cXG4gICAgLnNub3ctLTIyIHtcXG4gICAgICAgIHRyYW5zZm9ybTogdHJhbnNsYXRlWSgtNjElKSB0cmFuc2xhdGVYKDIlKSBzY2FsZSgwLjgpO1xcbiAgICB9XFxuXFxuICAgIC5zbm93LS0yMyB7XFxuICAgICAgICB0cmFuc2Zvcm06IHRyYW5zbGF0ZVkoLTYwJSkgc2NhbGUoMC43KTtcXG4gICAgfVxcblxcblxcbiAgICAuc25vdy0tMjQge1xcbiAgICAgICAgdHJhbnNmb3JtOiB0cmFuc2xhdGVZKC01MCUpIHNjYWxlKDAuOCk7XFxuICAgIH1cXG59XFxuXFxuLmRheSB7XFxuICAgIGJhY2tncm91bmQtY29sb3I6IHRyYW5zcGFyZW50O1xcbiAgICBib3JkZXI6IDJweCBkYXNoZWQgdmFyKC0tYy1ib3JkZXIpO1xcbiAgICBjb2xvcjogdmFyKC0tYy1wKTtcXG4gICAgdGV4dC1kZWNvcmF0aW9uOiBub25lO1xcbiAgICBwYWRkaW5nOiB2YXIoLS1zcGFjZS1ncmlkKTtcXG4gICAgZm9udC13ZWlnaHQ6IDkwMDtcXG4gICAgZm9udC1zaXplOiAxLjZyZW07XFxuICAgIEBtZWRpYSAobWF4LXdpZHRoOiA4MDBweCkge1xcbiAgICAgICAgZm9udC1zaXplOiAxcmVtO1xcbiAgICB9XFxuICAgIGxpbmUtaGVpZ2h0OiAxO1xcbn1cXG5cXG4uZGF5QWN0aXZlIHtcXG4gICAgYmFja2dyb3VuZC1jb2xvcjogdmFyKC0tYy1wcmltYXJ5KTtcXG4gICAgYm9yZGVyLWNvbG9yOiB0cmFuc3BhcmVudDtcXG4gICAgY29sb3I6IHZhcigtLWMtd2hpdGUpO1xcbn1cXG5cXG5cIl0sXCJzb3VyY2VSb290XCI6XCJcIn1dKTtcbi8vIEV4cG9ydHNcbl9fX0NTU19MT0FERVJfRVhQT1JUX19fLmxvY2FscyA9IHtcblx0XCJ3cmFwcGVyXCI6IFwiQ2FsZW5kYXJEYXlfd3JhcHBlcl9fVWttZ3hcIixcblx0XCJkYXlcIjogXCJDYWxlbmRhckRheV9kYXlfXzEydEhCXCIsXG5cdFwiaW5uZXJcIjogXCJDYWxlbmRhckRheV9pbm5lcl9fMWJqSllcIixcblx0XCJzbm93XCI6IFwiQ2FsZW5kYXJEYXlfc25vd19fMjhGblhcIixcblx0XCJzbm93LS0xXCI6IFwiQ2FsZW5kYXJEYXlfc25vdy0tMV9fc2NpaUhcIixcblx0XCJzbm93LS0yXCI6IFwiQ2FsZW5kYXJEYXlfc25vdy0tMl9fMjAwa0RcIixcblx0XCJzbm93LS0zXCI6IFwiQ2FsZW5kYXJEYXlfc25vdy0tM19fM0ptVVRcIixcblx0XCJzbm93LS00XCI6IFwiQ2FsZW5kYXJEYXlfc25vdy0tNF9fMXROTldcIixcblx0XCJzbm93LS01XCI6IFwiQ2FsZW5kYXJEYXlfc25vdy0tNV9fM0VxSGlcIixcblx0XCJzbm93LS02XCI6IFwiQ2FsZW5kYXJEYXlfc25vdy0tNl9fMmh4cVpcIixcblx0XCJzbm93LS03XCI6IFwiQ2FsZW5kYXJEYXlfc25vdy0tN19fMi1Ld29cIixcblx0XCJzbm93LS04XCI6IFwiQ2FsZW5kYXJEYXlfc25vdy0tOF9fM1dWM01cIixcblx0XCJzbm93LS05XCI6IFwiQ2FsZW5kYXJEYXlfc25vdy0tOV9fM3NjXzhcIixcblx0XCJzbm93LS0xMFwiOiBcIkNhbGVuZGFyRGF5X3Nub3ctLTEwX19HMWZjeVwiLFxuXHRcInNub3ctLTExXCI6IFwiQ2FsZW5kYXJEYXlfc25vdy0tMTFfXzNVQmoxXCIsXG5cdFwic25vdy0tMTJcIjogXCJDYWxlbmRhckRheV9zbm93LS0xMl9fM1dVUkFcIixcblx0XCJzbm93LS0xM1wiOiBcIkNhbGVuZGFyRGF5X3Nub3ctLTEzX18xcm13alwiLFxuXHRcInNub3ctLTE0XCI6IFwiQ2FsZW5kYXJEYXlfc25vdy0tMTRfXzNkcDZlXCIsXG5cdFwic25vdy0tMTVcIjogXCJDYWxlbmRhckRheV9zbm93LS0xNV9fWEtuZkFcIixcblx0XCJzbm93LS0xNlwiOiBcIkNhbGVuZGFyRGF5X3Nub3ctLTE2X180c2I3SFwiLFxuXHRcInNub3ctLTE3XCI6IFwiQ2FsZW5kYXJEYXlfc25vdy0tMTdfXzNTcTgwXCIsXG5cdFwic25vdy0tMThcIjogXCJDYWxlbmRhckRheV9zbm93LS0xOF9fMWpnOVFcIixcblx0XCJzbm93LS0xOVwiOiBcIkNhbGVuZGFyRGF5X3Nub3ctLTE5X19PMkNWUFwiLFxuXHRcInNub3ctLTIwXCI6IFwiQ2FsZW5kYXJEYXlfc25vdy0tMjBfXzNhN0pRXCIsXG5cdFwic25vdy0tMjFcIjogXCJDYWxlbmRhckRheV9zbm93LS0yMV9fMVY4bXJcIixcblx0XCJzbm93LS0yMlwiOiBcIkNhbGVuZGFyRGF5X3Nub3ctLTIyX18yeTRtU1wiLFxuXHRcInNub3ctLTIzXCI6IFwiQ2FsZW5kYXJEYXlfc25vdy0tMjNfXzFDZmM2XCIsXG5cdFwic25vdy0tMjRcIjogXCJDYWxlbmRhckRheV9zbm93LS0yNF9fM1ZQbFRcIixcblx0XCJkYXlBY3RpdmVcIjogXCJDYWxlbmRhckRheV9kYXlBY3RpdmVfXzF2dTcyXCJcbn07XG5tb2R1bGUuZXhwb3J0cyA9IF9fX0NTU19MT0FERVJfRVhQT1JUX19fO1xuIiwiLy8gSW1wb3J0c1xudmFyIF9fX0NTU19MT0FERVJfQVBJX0lNUE9SVF9fXyA9IHJlcXVpcmUoXCIuLi8uLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NvbXBpbGVkL2Nzcy1sb2FkZXIvYXBpLmpzXCIpO1xudmFyIF9fX0NTU19MT0FERVJfRVhQT1JUX19fID0gX19fQ1NTX0xPQURFUl9BUElfSU1QT1JUX19fKHRydWUpO1xuLy8gTW9kdWxlXG5fX19DU1NfTE9BREVSX0VYUE9SVF9fXy5wdXNoKFttb2R1bGUuaWQsIFwiLkNhbGVuZGFyRGF5TGlzdF9yb290X18zMF94OSB7XFxuICAgIGRpc3BsYXk6IGZsZXg7XFxuICAgIHRleHQtZGVjb3JhdGlvbjogbm9uZTtcXG4gICAgYWxpZ24taXRlbXM6IGNlbnRlcjtcXG59XFxuXFxuLkNhbGVuZGFyRGF5TGlzdF9yb290QWN0aXZlX18xQUVjSSB7XFxuICAgIC5DYWxlbmRhckRheUxpc3RfbnVtYmVyX19mQjB2XyB7XFxuICAgICAgICBiYWNrZ3JvdW5kLWNvbG9yOiB2YXIoLS1jLXByaW1hcnkpO1xcbiAgICAgICAgYm9yZGVyLWNvbG9yOiB0cmFuc3BhcmVudDtcXG4gICAgICAgIGNvbG9yOiB2YXIoLS1jLXdoaXRlKTtcXG4gICAgfVxcbn1cXG5cXG4uQ2FsZW5kYXJEYXlMaXN0X251bWJlcl9fZkIwdl8ge1xcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiB0cmFuc3BhcmVudDtcXG4gICAgYm9yZGVyOiAycHggZGFzaGVkIHZhcigtLWMtYm9yZGVyKTtcXG4gICAgY29sb3I6IHZhcigtLWMtcCk7XFxuICAgIHdpZHRoOiAyLjVyZW07XFxuICAgIGhlaWdodDogMi41cmVtO1xcbiAgICBkaXNwbGF5OiBmbGV4O1xcbiAgICBmb250LXNpemU6IDFyZW07XFxuICAgIGZvbnQtd2VpZ2h0OiBib2xkO1xcbiAgICBqdXN0aWZ5LWNvbnRlbnQ6IGNlbnRlcjtcXG4gICAgYWxpZ24taXRlbXM6IGNlbnRlcjtcXG4gICAgbWFyZ2luLXJpZ2h0OiAxcmVtO1xcbn1cXG5cXG4uQ2FsZW5kYXJEYXlMaXN0X3RpdGxlX19IUHpDYyB7XFxuICAgIGZvbnQtd2VpZ2h0OiBib2xkO1xcbiAgICBjb2xvcjogdmFyKC0tYy1wKTtcXG59XFxuXFxuLkNhbGVuZGFyRGF5TGlzdF93cmFwcGVyX18zdUFKMyB7XFxufVxcblxcbi5DYWxlbmRhckRheUxpc3Rfd3JhcHBlcklubmVyX18yUzdmdSB7XFxufVxcblwiLCBcIlwiLHtcInZlcnNpb25cIjozLFwic291cmNlc1wiOltcIndlYnBhY2s6Ly9jb21wb25lbnRzL0NhbGVuZGFyL0NhbGVuZGFyRGF5TGlzdC5tb2R1bGUuY3NzXCJdLFwibmFtZXNcIjpbXSxcIm1hcHBpbmdzXCI6XCJBQUFBO0lBQ0ksYUFBYTtJQUNiLHFCQUFxQjtJQUNyQixtQkFBbUI7QUFDdkI7O0FBRUE7SUFDSTtRQUNJLGtDQUFrQztRQUNsQyx5QkFBeUI7UUFDekIscUJBQXFCO0lBQ3pCO0FBQ0o7O0FBRUE7SUFDSSw2QkFBNkI7SUFDN0Isa0NBQWtDO0lBQ2xDLGlCQUFpQjtJQUNqQixhQUFhO0lBQ2IsY0FBYztJQUNkLGFBQWE7SUFDYixlQUFlO0lBQ2YsaUJBQWlCO0lBQ2pCLHVCQUF1QjtJQUN2QixtQkFBbUI7SUFDbkIsa0JBQWtCO0FBQ3RCOztBQUVBO0lBQ0ksaUJBQWlCO0lBQ2pCLGlCQUFpQjtBQUNyQjs7QUFFQTtBQUNBOztBQUVBO0FBQ0FcIixcInNvdXJjZXNDb250ZW50XCI6W1wiLnJvb3Qge1xcbiAgICBkaXNwbGF5OiBmbGV4O1xcbiAgICB0ZXh0LWRlY29yYXRpb246IG5vbmU7XFxuICAgIGFsaWduLWl0ZW1zOiBjZW50ZXI7XFxufVxcblxcbi5yb290QWN0aXZlIHtcXG4gICAgLm51bWJlciB7XFxuICAgICAgICBiYWNrZ3JvdW5kLWNvbG9yOiB2YXIoLS1jLXByaW1hcnkpO1xcbiAgICAgICAgYm9yZGVyLWNvbG9yOiB0cmFuc3BhcmVudDtcXG4gICAgICAgIGNvbG9yOiB2YXIoLS1jLXdoaXRlKTtcXG4gICAgfVxcbn1cXG5cXG4ubnVtYmVyIHtcXG4gICAgYmFja2dyb3VuZC1jb2xvcjogdHJhbnNwYXJlbnQ7XFxuICAgIGJvcmRlcjogMnB4IGRhc2hlZCB2YXIoLS1jLWJvcmRlcik7XFxuICAgIGNvbG9yOiB2YXIoLS1jLXApO1xcbiAgICB3aWR0aDogMi41cmVtO1xcbiAgICBoZWlnaHQ6IDIuNXJlbTtcXG4gICAgZGlzcGxheTogZmxleDtcXG4gICAgZm9udC1zaXplOiAxcmVtO1xcbiAgICBmb250LXdlaWdodDogYm9sZDtcXG4gICAganVzdGlmeS1jb250ZW50OiBjZW50ZXI7XFxuICAgIGFsaWduLWl0ZW1zOiBjZW50ZXI7XFxuICAgIG1hcmdpbi1yaWdodDogMXJlbTtcXG59XFxuXFxuLnRpdGxlIHtcXG4gICAgZm9udC13ZWlnaHQ6IGJvbGQ7XFxuICAgIGNvbG9yOiB2YXIoLS1jLXApO1xcbn1cXG5cXG4ud3JhcHBlciB7XFxufVxcblxcbi53cmFwcGVySW5uZXIge1xcbn1cXG5cIl0sXCJzb3VyY2VSb290XCI6XCJcIn1dKTtcbi8vIEV4cG9ydHNcbl9fX0NTU19MT0FERVJfRVhQT1JUX19fLmxvY2FscyA9IHtcblx0XCJyb290XCI6IFwiQ2FsZW5kYXJEYXlMaXN0X3Jvb3RfXzMwX3g5XCIsXG5cdFwicm9vdEFjdGl2ZVwiOiBcIkNhbGVuZGFyRGF5TGlzdF9yb290QWN0aXZlX18xQUVjSVwiLFxuXHRcIm51bWJlclwiOiBcIkNhbGVuZGFyRGF5TGlzdF9udW1iZXJfX2ZCMHZfXCIsXG5cdFwidGl0bGVcIjogXCJDYWxlbmRhckRheUxpc3RfdGl0bGVfX0hQekNjXCIsXG5cdFwid3JhcHBlclwiOiBcIkNhbGVuZGFyRGF5TGlzdF93cmFwcGVyX18zdUFKM1wiLFxuXHRcIndyYXBwZXJJbm5lclwiOiBcIkNhbGVuZGFyRGF5TGlzdF93cmFwcGVySW5uZXJfXzJTN2Z1XCJcbn07XG5tb2R1bGUuZXhwb3J0cyA9IF9fX0NTU19MT0FERVJfRVhQT1JUX19fO1xuIiwiLy8gSW1wb3J0c1xudmFyIF9fX0NTU19MT0FERVJfQVBJX0lNUE9SVF9fXyA9IHJlcXVpcmUoXCIuLi8uLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NvbXBpbGVkL2Nzcy1sb2FkZXIvYXBpLmpzXCIpO1xudmFyIF9fX0NTU19MT0FERVJfRVhQT1JUX19fID0gX19fQ1NTX0xPQURFUl9BUElfSU1QT1JUX19fKHRydWUpO1xuLy8gTW9kdWxlXG5fX19DU1NfTE9BREVSX0VYUE9SVF9fXy5wdXNoKFttb2R1bGUuaWQsIFwiLkNhbGVuZGFySGVhZGVyX3Jvb3RfXzFpMGwyIHtcXG4gICAgZGlzcGxheTogZmxleDtcXG4gICAganVzdGlmeS1jb250ZW50OiBzcGFjZS1iZXR3ZWVuO1xcbiAgICBhbGlnbi1pdGVtczogY2VudGVyO1xcbiAgICBmbGV4LXdyYXA6IHdyYXA7XFxuICAgIHRyYW5zaXRpb246IG9wYWNpdHkgMjAwbXMgZWFzZS1pbi1vdXQ7XFxuICAgIG9wYWNpdHk6IDE7XFxufVxcblxcbi5DYWxlbmRhckhlYWRlcl9sb2dvX19peF9fNSB7XFxuICAgIHdpZHRoOiAxMnJlbTtcXG4gICAgbWF4LXdpZHRoOiA1MCU7XFxufVxcblxcbi5DYWxlbmRhckhlYWRlcl92aWV3X18xR1dCZiB7XFxuICAgIHdpZHRoOiAxMDAlO1xcbiAgICBkaXNwbGF5OiBmbGV4O1xcbiAgICBqdXN0aWZ5LWNvbnRlbnQ6IGNlbnRlcjtcXG4gICAgbWFyZ2luLXRvcDogdmFyKC0tc3BhY2UteGwpO1xcbn1cXG5cXG4uQ2FsZW5kYXJIZWFkZXJfdmlld0J1dHRvbl9fMzFBY2Q6Zmlyc3QtY2hpbGQge1xcbiAgICAgICAgYm9yZGVyLWJvdHRvbS1yaWdodC1yYWRpdXM6IDA7XFxuICAgICAgICBib3JkZXItdG9wLXJpZ2h0LXJhZGl1czogMDtcXG4gICAgfVxcblxcbi5DYWxlbmRhckhlYWRlcl92aWV3QnV0dG9uX18zMUFjZDpsYXN0LWNoaWxkIHtcXG4gICAgICAgIGJvcmRlci1ib3R0b20tbGVmdC1yYWRpdXM6IDA7XFxuICAgICAgICBib3JkZXItdG9wLWxlZnQtcmFkaXVzOiAwO1xcbiAgICB9XFxuXFxuLkNhbGVuZGFySGVhZGVyX3ZpZXdCdXR0b25BY3RpdmVfXzFqaHhXIHtcXG59XFxuXFxuW2RhdGEtbWVudT0nb3BlbiddIC5DYWxlbmRhckhlYWRlcl9yb290X18xaTBsMiB7XFxuICAgIG9wYWNpdHk6IDAuMTtcXG59XFxuXFxuW2RhdGEtbGF5b3V0PSdkZXNrdG9wJ10gLkNhbGVuZGFySGVhZGVyX2xvZ29fX2l4X181LFxcbltkYXRhLWxheW91dD0nZGVza3RvcCddIC5DYWxlbmRhckhlYWRlcl9idXR0b25fXzNVeW9XIHtcXG4gICAgZGlzcGxheTogbm9uZTtcXG59XFxuXFxuXFxuXCIsIFwiXCIse1widmVyc2lvblwiOjMsXCJzb3VyY2VzXCI6W1wid2VicGFjazovL2NvbXBvbmVudHMvQ2FsZW5kYXIvQ2FsZW5kYXJIZWFkZXIubW9kdWxlLmNzc1wiXSxcIm5hbWVzXCI6W10sXCJtYXBwaW5nc1wiOlwiQUFBQTtJQUNJLGFBQWE7SUFDYiw4QkFBOEI7SUFDOUIsbUJBQW1CO0lBQ25CLGVBQWU7SUFDZixxQ0FBcUM7SUFDckMsVUFBVTtBQUNkOztBQUVBO0lBQ0ksWUFBWTtJQUNaLGNBQWM7QUFDbEI7O0FBRUE7SUFDSSxXQUFXO0lBQ1gsYUFBYTtJQUNiLHVCQUF1QjtJQUN2QiwyQkFBMkI7QUFDL0I7O0FBR0k7UUFDSSw2QkFBNkI7UUFDN0IsMEJBQTBCO0lBQzlCOztBQUdBO1FBQ0ksNEJBQTRCO1FBQzVCLHlCQUF5QjtJQUM3Qjs7QUFHSjtBQUNBOztBQUVBO0lBQ0ksWUFBWTtBQUNoQjs7QUFFQTs7SUFFSSxhQUFhO0FBQ2pCXCIsXCJzb3VyY2VzQ29udGVudFwiOltcIi5yb290IHtcXG4gICAgZGlzcGxheTogZmxleDtcXG4gICAganVzdGlmeS1jb250ZW50OiBzcGFjZS1iZXR3ZWVuO1xcbiAgICBhbGlnbi1pdGVtczogY2VudGVyO1xcbiAgICBmbGV4LXdyYXA6IHdyYXA7XFxuICAgIHRyYW5zaXRpb246IG9wYWNpdHkgMjAwbXMgZWFzZS1pbi1vdXQ7XFxuICAgIG9wYWNpdHk6IDE7XFxufVxcblxcbi5sb2dvIHtcXG4gICAgd2lkdGg6IDEycmVtO1xcbiAgICBtYXgtd2lkdGg6IDUwJTtcXG59XFxuXFxuLnZpZXcge1xcbiAgICB3aWR0aDogMTAwJTtcXG4gICAgZGlzcGxheTogZmxleDtcXG4gICAganVzdGlmeS1jb250ZW50OiBjZW50ZXI7XFxuICAgIG1hcmdpbi10b3A6IHZhcigtLXNwYWNlLXhsKTtcXG59XFxuXFxuLnZpZXdCdXR0b24ge1xcbiAgICAmOmZpcnN0LWNoaWxkIHtcXG4gICAgICAgIGJvcmRlci1ib3R0b20tcmlnaHQtcmFkaXVzOiAwO1xcbiAgICAgICAgYm9yZGVyLXRvcC1yaWdodC1yYWRpdXM6IDA7XFxuICAgIH1cXG5cXG5cXG4gICAgJjpsYXN0LWNoaWxkIHtcXG4gICAgICAgIGJvcmRlci1ib3R0b20tbGVmdC1yYWRpdXM6IDA7XFxuICAgICAgICBib3JkZXItdG9wLWxlZnQtcmFkaXVzOiAwO1xcbiAgICB9XFxufVxcblxcbi52aWV3QnV0dG9uQWN0aXZlIHtcXG59XFxuXFxuW2RhdGEtbWVudT0nb3BlbiddIC5yb290IHtcXG4gICAgb3BhY2l0eTogMC4xO1xcbn1cXG5cXG5bZGF0YS1sYXlvdXQ9J2Rlc2t0b3AnXSAubG9nbyxcXG5bZGF0YS1sYXlvdXQ9J2Rlc2t0b3AnXSAuYnV0dG9uIHtcXG4gICAgZGlzcGxheTogbm9uZTtcXG59XFxuXFxuXFxuXCJdLFwic291cmNlUm9vdFwiOlwiXCJ9XSk7XG4vLyBFeHBvcnRzXG5fX19DU1NfTE9BREVSX0VYUE9SVF9fXy5sb2NhbHMgPSB7XG5cdFwicm9vdFwiOiBcIkNhbGVuZGFySGVhZGVyX3Jvb3RfXzFpMGwyXCIsXG5cdFwibG9nb1wiOiBcIkNhbGVuZGFySGVhZGVyX2xvZ29fX2l4X181XCIsXG5cdFwidmlld1wiOiBcIkNhbGVuZGFySGVhZGVyX3ZpZXdfXzFHV0JmXCIsXG5cdFwidmlld0J1dHRvblwiOiBcIkNhbGVuZGFySGVhZGVyX3ZpZXdCdXR0b25fXzMxQWNkXCIsXG5cdFwidmlld0J1dHRvbkFjdGl2ZVwiOiBcIkNhbGVuZGFySGVhZGVyX3ZpZXdCdXR0b25BY3RpdmVfXzFqaHhXXCIsXG5cdFwiYnV0dG9uXCI6IFwiQ2FsZW5kYXJIZWFkZXJfYnV0dG9uX18zVXlvV1wiXG59O1xubW9kdWxlLmV4cG9ydHMgPSBfX19DU1NfTE9BREVSX0VYUE9SVF9fXztcbiIsIi8vIEltcG9ydHNcbnZhciBfX19DU1NfTE9BREVSX0FQSV9JTVBPUlRfX18gPSByZXF1aXJlKFwiLi4vLi4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jb21waWxlZC9jc3MtbG9hZGVyL2FwaS5qc1wiKTtcbnZhciBfX19DU1NfTE9BREVSX0VYUE9SVF9fXyA9IF9fX0NTU19MT0FERVJfQVBJX0lNUE9SVF9fXyh0cnVlKTtcbi8vIE1vZHVsZVxuX19fQ1NTX0xPQURFUl9FWFBPUlRfX18ucHVzaChbbW9kdWxlLmlkLCBcIi5Db250ZW50QXV0aG9yX3Jvb3RfXzJmSDlMIHtcXHJcXG4gICAgZGlzcGxheTogZmxleDtcXHJcXG4gICAgYWxpZ24taXRlbXM6IGNlbnRlcjtcXHJcXG59XFxyXFxuXFxyXFxuLkNvbnRlbnRBdXRob3JfaW1hZ2VfXzJJbWZUIHtcXHJcXG4gICAgYm9yZGVyLXJhZGl1czogNTAlO1xcclxcbiAgICBtYXJnaW4tcmlnaHQ6IHZhcigtLXNwYWNlKTtcXHJcXG4gICAgYm94LXNoYWRvdzogMCAwIDFweCByZ2JhKDAsIDAsIDAsIDAuMik7XFxyXFxufVxcclxcblxcclxcbi5Db250ZW50QXV0aG9yX25hbWVfXzNiRlJsLFxcclxcbi5Db250ZW50QXV0aG9yX2xpbmtzSXRlbV9fM0p3U0Uge1xcclxcbiAgICBmb250LXNpemU6IHZhcigtLWZzLXNtYWxsKTtcXHJcXG59XFxyXFxuXFxyXFxuLkNvbnRlbnRBdXRob3JfbmFtZV9fM2JGUmwgYSxcXHJcXG4uQ29udGVudEF1dGhvcl9saW5rc0l0ZW1fXzNKd1NFIGEge1xcclxcbiAgICBjb2xvcjogdmFyKC0tYy1wKVxcclxcbn1cXHJcXG5cXHJcXG4uQ29udGVudEF1dGhvcl9uYW1lX18zYkZSbCBhOmhvdmVyLCAuQ29udGVudEF1dGhvcl9saW5rc0l0ZW1fXzNKd1NFIGE6aG92ZXIge1xcclxcbiAgICAgICAgdGV4dC1kZWNvcmF0aW9uOiBub25lO1xcclxcbiAgICB9XFxyXFxuXFxyXFxuLkNvbnRlbnRBdXRob3JfYWJvdXRfX05GZDMyIHtcXHJcXG59XFxyXFxuXFxyXFxuLkNvbnRlbnRBdXRob3JfbmFtZV9fM2JGUmwgYSB7XFxyXFxuICAgIHRleHQtZGVjb3JhdGlvbjogbm9uZVxcclxcbn1cXHJcXG5cXHJcXG4uQ29udGVudEF1dGhvcl9uYW1lX18zYkZSbCBhOmhvdmVyIHtcXHJcXG4gICAgICAgIHRleHQtZGVjb3JhdGlvbjogdW5kZXJsaW5lO1xcclxcbiAgICB9XFxyXFxuXFxyXFxuLkNvbnRlbnRBdXRob3JfbGlua3NfXzFjQ01SIHtcXHJcXG4gICAgZGlzcGxheTogZmxleDtcXHJcXG4gICAgbGlzdC1zdHlsZTogbm9uZTtcXHJcXG59XFxyXFxuXFxyXFxuLkNvbnRlbnRBdXRob3JfbGlua3NJdGVtX18zSndTRSArIC5Db250ZW50QXV0aG9yX2xpbmtzSXRlbV9fM0p3U0U6OmJlZm9yZSB7XFxyXFxuICAgICAgICBjb250ZW50OiAnwrcnO1xcclxcbiAgICAgICAgZGlzcGxheTogaW5saW5lLWJsb2NrO1xcclxcbiAgICAgICAgbWFyZ2luOiAwIDAuNGVtO1xcclxcbiAgICB9XFxyXFxuXCIsIFwiXCIse1widmVyc2lvblwiOjMsXCJzb3VyY2VzXCI6W1wid2VicGFjazovL2NvbXBvbmVudHMvQ29udGVudC9Db250ZW50QXV0aG9yLm1vZHVsZS5jc3NcIl0sXCJuYW1lc1wiOltdLFwibWFwcGluZ3NcIjpcIkFBQUE7SUFDSSxhQUFhO0lBQ2IsbUJBQW1CO0FBQ3ZCOztBQUVBO0lBQ0ksa0JBQWtCO0lBQ2xCLDBCQUEwQjtJQUMxQixzQ0FBc0M7QUFDMUM7O0FBRUE7O0lBRUksMEJBQTBCO0FBQzlCOztBQUVBOztJQUVJO0FBS0o7O0FBSEk7UUFDSSxxQkFBcUI7SUFDekI7O0FBR0o7QUFDQTs7QUFFQTtJQUNJO0FBS0o7O0FBSEk7UUFDSSwwQkFBMEI7SUFDOUI7O0FBR0o7SUFDSSxhQUFhO0lBQ2IsZ0JBQWdCO0FBQ3BCOztBQUdJO1FBQ0ksWUFBWTtRQUNaLHFCQUFxQjtRQUNyQixlQUFlO0lBQ25CXCIsXCJzb3VyY2VzQ29udGVudFwiOltcIi5yb290IHtcXHJcXG4gICAgZGlzcGxheTogZmxleDtcXHJcXG4gICAgYWxpZ24taXRlbXM6IGNlbnRlcjtcXHJcXG59XFxyXFxuXFxyXFxuLmltYWdlIHtcXHJcXG4gICAgYm9yZGVyLXJhZGl1czogNTAlO1xcclxcbiAgICBtYXJnaW4tcmlnaHQ6IHZhcigtLXNwYWNlKTtcXHJcXG4gICAgYm94LXNoYWRvdzogMCAwIDFweCByZ2JhKDAsIDAsIDAsIDAuMik7XFxyXFxufVxcclxcblxcclxcbi5uYW1lLFxcclxcbi5saW5rc0l0ZW0ge1xcclxcbiAgICBmb250LXNpemU6IHZhcigtLWZzLXNtYWxsKTtcXHJcXG59XFxyXFxuXFxyXFxuLm5hbWUgYSxcXHJcXG4ubGlua3NJdGVtIGEge1xcclxcbiAgICBjb2xvcjogdmFyKC0tYy1wKTtcXHJcXG5cXHJcXG4gICAgJjpob3ZlciB7XFxyXFxuICAgICAgICB0ZXh0LWRlY29yYXRpb246IG5vbmU7XFxyXFxuICAgIH1cXHJcXG59XFxyXFxuXFxyXFxuLmFib3V0IHtcXHJcXG59XFxyXFxuXFxyXFxuLm5hbWUgYSB7XFxyXFxuICAgIHRleHQtZGVjb3JhdGlvbjogbm9uZTtcXHJcXG5cXHJcXG4gICAgJjpob3ZlciB7XFxyXFxuICAgICAgICB0ZXh0LWRlY29yYXRpb246IHVuZGVybGluZTtcXHJcXG4gICAgfVxcclxcbn1cXHJcXG5cXHJcXG4ubGlua3Mge1xcclxcbiAgICBkaXNwbGF5OiBmbGV4O1xcclxcbiAgICBsaXN0LXN0eWxlOiBub25lO1xcclxcbn1cXHJcXG5cXHJcXG4ubGlua3NJdGVtICsgLmxpbmtzSXRlbSB7XFxyXFxuICAgICY6OmJlZm9yZSB7XFxyXFxuICAgICAgICBjb250ZW50OiAnwrcnO1xcclxcbiAgICAgICAgZGlzcGxheTogaW5saW5lLWJsb2NrO1xcclxcbiAgICAgICAgbWFyZ2luOiAwIDAuNGVtO1xcclxcbiAgICB9XFxyXFxufVxcclxcblwiXSxcInNvdXJjZVJvb3RcIjpcIlwifV0pO1xuLy8gRXhwb3J0c1xuX19fQ1NTX0xPQURFUl9FWFBPUlRfX18ubG9jYWxzID0ge1xuXHRcInJvb3RcIjogXCJDb250ZW50QXV0aG9yX3Jvb3RfXzJmSDlMXCIsXG5cdFwiaW1hZ2VcIjogXCJDb250ZW50QXV0aG9yX2ltYWdlX18ySW1mVFwiLFxuXHRcIm5hbWVcIjogXCJDb250ZW50QXV0aG9yX25hbWVfXzNiRlJsXCIsXG5cdFwibGlua3NJdGVtXCI6IFwiQ29udGVudEF1dGhvcl9saW5rc0l0ZW1fXzNKd1NFXCIsXG5cdFwiYWJvdXRcIjogXCJDb250ZW50QXV0aG9yX2Fib3V0X19ORmQzMlwiLFxuXHRcImxpbmtzXCI6IFwiQ29udGVudEF1dGhvcl9saW5rc19fMWNDTVJcIlxufTtcbm1vZHVsZS5leHBvcnRzID0gX19fQ1NTX0xPQURFUl9FWFBPUlRfX187XG4iLCIvLyBJbXBvcnRzXG52YXIgX19fQ1NTX0xPQURFUl9BUElfSU1QT1JUX19fID0gcmVxdWlyZShcIi4uLy4uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvY3NzLWxvYWRlci9hcGkuanNcIik7XG52YXIgX19fQ1NTX0xPQURFUl9FWFBPUlRfX18gPSBfX19DU1NfTE9BREVSX0FQSV9JTVBPUlRfX18odHJ1ZSk7XG4vLyBNb2R1bGVcbl9fX0NTU19MT0FERVJfRVhQT1JUX19fLnB1c2goW21vZHVsZS5pZCwgXCIuQ29udGVudENhbGVuZGFyX2V4Y2VycHRfX1RhbW5BIHtcXG4gICAgZm9udC1zaXplOiB2YXIoLS1mcy1iaWcpO1xcbiAgICBmb250LXdlaWdodDogYm9sZDtcXG4gICAgbGluZS1oZWlnaHQ6IDEuNDtcXG59XFxuXFxuLkNvbnRlbnRDYWxlbmRhcl9lcnJvcl9fMVBSbWwge1xcbn1cXG5cXG4uQ29udGVudENhbGVuZGFyX2ltYWdlX18zaU5lRSB7XFxuICAgIHdpZHRoOiAxMDAlO1xcbiAgICBkaXNwbGF5OiBibG9jaztcXG59XFxuXFxuLkNvbnRlbnRDYWxlbmRhcl9kYXRlX182WkZDRSwgLkNvbnRlbnRDYWxlbmRhcl9jYW5ub25pY2FsX18xcnF0bSB7XFxuICAgIG1hcmdpbi10b3A6IHZhcigtLXNwYWNlKTtcXG59XFxuXFxuLkNvbnRlbnRDYWxlbmRhcl9kYXRlX182WkZDRSB7XFxuICAgIG1hcmdpbi1ib3R0b206IHZhcigtLXNwYWNlLXMpO1xcbn1cXG5cXG4uQ29udGVudENhbGVuZGFyX21ldGFfX3lIZmpiLFxcbi5Db250ZW50Q2FsZW5kYXJfZXhjZXJwdF9fVGFtbkEsXFxuLkNvbnRlbnRDYWxlbmRhcl9pbWFnZV9fM2lOZUUge1xcbiAgICBtYXJnaW4tYm90dG9tOiB2YXIoLS1zcGFjZS1sKTtcXG59XFxuXFxuLkNvbnRlbnRDYWxlbmRhcl9tZXRhX195SGZqYiB7XFxuICAgIGRpc3BsYXk6IGZsZXg7XFxuICAgIGFsaWduLWl0ZW1zOiBjZW50ZXI7XFxuICAgIGp1c3RpZnktY29udGVudDogc3BhY2UtYmV0d2VlbjtcXG59XFxuXFxuLkNvbnRlbnRDYWxlbmRhcl9hdXRob3JfXzFVdFJJIHtcXG4gICAgbWFyZ2luLXJpZ2h0OiB2YXIoLS1zcGFjZSk7XFxufVxcblwiLCBcIlwiLHtcInZlcnNpb25cIjozLFwic291cmNlc1wiOltcIndlYnBhY2s6Ly9jb21wb25lbnRzL0NvbnRlbnQvQ29udGVudENhbGVuZGFyLm1vZHVsZS5jc3NcIl0sXCJuYW1lc1wiOltdLFwibWFwcGluZ3NcIjpcIkFBQUE7SUFDSSx3QkFBd0I7SUFDeEIsaUJBQWlCO0lBQ2pCLGdCQUFnQjtBQUNwQjs7QUFFQTtBQUNBOztBQUVBO0lBQ0ksV0FBVztJQUNYLGNBQWM7QUFDbEI7O0FBRUE7SUFDSSx3QkFBd0I7QUFDNUI7O0FBRUE7SUFDSSw2QkFBNkI7QUFDakM7O0FBRUE7OztJQUdJLDZCQUE2QjtBQUNqQzs7QUFFQTtJQUNJLGFBQWE7SUFDYixtQkFBbUI7SUFDbkIsOEJBQThCO0FBQ2xDOztBQUVBO0lBQ0ksMEJBQTBCO0FBQzlCXCIsXCJzb3VyY2VzQ29udGVudFwiOltcIi5leGNlcnB0IHtcXG4gICAgZm9udC1zaXplOiB2YXIoLS1mcy1iaWcpO1xcbiAgICBmb250LXdlaWdodDogYm9sZDtcXG4gICAgbGluZS1oZWlnaHQ6IDEuNDtcXG59XFxuXFxuLmVycm9yIHtcXG59XFxuXFxuLmltYWdlIHtcXG4gICAgd2lkdGg6IDEwMCU7XFxuICAgIGRpc3BsYXk6IGJsb2NrO1xcbn1cXG5cXG4uZGF0ZSwgLmNhbm5vbmljYWwge1xcbiAgICBtYXJnaW4tdG9wOiB2YXIoLS1zcGFjZSk7XFxufVxcblxcbi5kYXRlIHtcXG4gICAgbWFyZ2luLWJvdHRvbTogdmFyKC0tc3BhY2Utcyk7XFxufVxcblxcbi5tZXRhLFxcbi5leGNlcnB0LFxcbi5pbWFnZSB7XFxuICAgIG1hcmdpbi1ib3R0b206IHZhcigtLXNwYWNlLWwpO1xcbn1cXG5cXG4ubWV0YSB7XFxuICAgIGRpc3BsYXk6IGZsZXg7XFxuICAgIGFsaWduLWl0ZW1zOiBjZW50ZXI7XFxuICAgIGp1c3RpZnktY29udGVudDogc3BhY2UtYmV0d2VlbjtcXG59XFxuXFxuLmF1dGhvciB7XFxuICAgIG1hcmdpbi1yaWdodDogdmFyKC0tc3BhY2UpO1xcbn1cXG5cIl0sXCJzb3VyY2VSb290XCI6XCJcIn1dKTtcbi8vIEV4cG9ydHNcbl9fX0NTU19MT0FERVJfRVhQT1JUX19fLmxvY2FscyA9IHtcblx0XCJleGNlcnB0XCI6IFwiQ29udGVudENhbGVuZGFyX2V4Y2VycHRfX1RhbW5BXCIsXG5cdFwiZXJyb3JcIjogXCJDb250ZW50Q2FsZW5kYXJfZXJyb3JfXzFQUm1sXCIsXG5cdFwiaW1hZ2VcIjogXCJDb250ZW50Q2FsZW5kYXJfaW1hZ2VfXzNpTmVFXCIsXG5cdFwiZGF0ZVwiOiBcIkNvbnRlbnRDYWxlbmRhcl9kYXRlX182WkZDRVwiLFxuXHRcImNhbm5vbmljYWxcIjogXCJDb250ZW50Q2FsZW5kYXJfY2Fubm9uaWNhbF9fMXJxdG1cIixcblx0XCJtZXRhXCI6IFwiQ29udGVudENhbGVuZGFyX21ldGFfX3lIZmpiXCIsXG5cdFwiYXV0aG9yXCI6IFwiQ29udGVudENhbGVuZGFyX2F1dGhvcl9fMVV0UklcIlxufTtcbm1vZHVsZS5leHBvcnRzID0gX19fQ1NTX0xPQURFUl9FWFBPUlRfX187XG4iLCIvLyBJbXBvcnRzXG5pbXBvcnQgX19fQ1NTX0xPQURFUl9BUElfSU1QT1JUX19fIGZyb20gXCIuLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NvbXBpbGVkL2Nzcy1sb2FkZXIvYXBpLmpzXCI7XG5pbXBvcnQgX19fQ1NTX0xPQURFUl9BVF9SVUxFX0lNUE9SVF8wX19fIGZyb20gXCItIS4uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvY3NzLWxvYWRlci9janMuanM/P3JlZi0tNS1vbmVPZi02LTEhLi4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jb21waWxlZC9wb3N0Y3NzLWxvYWRlci9janMuanM/P3JlZi0tNS1vbmVPZi02LTIhLi4vc3R5bGVzL2ZvbnRzL2ZvbnQtd29mZjIuY3NzXCI7XG5pbXBvcnQgX19fQ1NTX0xPQURFUl9BVF9SVUxFX0lNUE9SVF8xX19fIGZyb20gXCItIS4uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvY3NzLWxvYWRlci9janMuanM/P3JlZi0tNS1vbmVPZi02LTEhLi4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jb21waWxlZC9wb3N0Y3NzLWxvYWRlci9janMuanM/P3JlZi0tNS1vbmVPZi02LTIhLi4vc3R5bGVzL2tleWZyYW1lcy9zcGlubmVyLmNzc1wiO1xuaW1wb3J0IF9fX0NTU19MT0FERVJfQVRfUlVMRV9JTVBPUlRfMl9fXyBmcm9tIFwiLSEuLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NvbXBpbGVkL2Nzcy1sb2FkZXIvY2pzLmpzPz9yZWYtLTUtb25lT2YtNi0xIS4uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvcG9zdGNzcy1sb2FkZXIvY2pzLmpzPz9yZWYtLTUtb25lT2YtNi0yIS4uL3N0eWxlcy9yZXNldC5jc3NcIjtcbmltcG9ydCBfX19DU1NfTE9BREVSX0FUX1JVTEVfSU1QT1JUXzNfX18gZnJvbSBcIi0hLi4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jb21waWxlZC9jc3MtbG9hZGVyL2Nqcy5qcz8/cmVmLS01LW9uZU9mLTYtMSEuLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NvbXBpbGVkL3Bvc3Rjc3MtbG9hZGVyL2Nqcy5qcz8/cmVmLS01LW9uZU9mLTYtMiEuLi9zdHlsZXMvZ3JpZC5jc3NcIjtcbmltcG9ydCBfX19DU1NfTE9BREVSX0FUX1JVTEVfSU1QT1JUXzRfX18gZnJvbSBcIi0hLi4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jb21waWxlZC9jc3MtbG9hZGVyL2Nqcy5qcz8/cmVmLS01LW9uZU9mLTYtMSEuLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NvbXBpbGVkL3Bvc3Rjc3MtbG9hZGVyL2Nqcy5qcz8/cmVmLS01LW9uZU9mLTYtMiEuLi9zdHlsZXMvdmFycy5jc3NcIjtcbmltcG9ydCBfX19DU1NfTE9BREVSX0FUX1JVTEVfSU1QT1JUXzVfX18gZnJvbSBcIi0hLi4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jb21waWxlZC9jc3MtbG9hZGVyL2Nqcy5qcz8/cmVmLS01LW9uZU9mLTYtMSEuLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NvbXBpbGVkL3Bvc3Rjc3MtbG9hZGVyL2Nqcy5qcz8/cmVmLS01LW9uZU9mLTYtMiEuLi9zdHlsZXMvdHlwb2dyYXBoeS5jc3NcIjtcbmltcG9ydCBfX19DU1NfTE9BREVSX0FUX1JVTEVfSU1QT1JUXzZfX18gZnJvbSBcIi0hLi4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jb21waWxlZC9jc3MtbG9hZGVyL2Nqcy5qcz8/cmVmLS01LW9uZU9mLTYtMSEuLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NvbXBpbGVkL3Bvc3Rjc3MtbG9hZGVyL2Nqcy5qcz8/cmVmLS01LW9uZU9mLTYtMiEuLi9zdHlsZXMvY29sb3JzLmNzc1wiO1xuaW1wb3J0IF9fX0NTU19MT0FERVJfQVRfUlVMRV9JTVBPUlRfN19fXyBmcm9tIFwiLSEuLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NvbXBpbGVkL2Nzcy1sb2FkZXIvY2pzLmpzPz9yZWYtLTUtb25lT2YtNi0xIS4uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvcG9zdGNzcy1sb2FkZXIvY2pzLmpzPz9yZWYtLTUtb25lT2YtNi0yIS4uL3N0eWxlcy9kb2N1bWVudC5jc3NcIjtcbnZhciBfX19DU1NfTE9BREVSX0VYUE9SVF9fXyA9IF9fX0NTU19MT0FERVJfQVBJX0lNUE9SVF9fXyh0cnVlKTtcbl9fX0NTU19MT0FERVJfRVhQT1JUX19fLmkoX19fQ1NTX0xPQURFUl9BVF9SVUxFX0lNUE9SVF8wX19fKTtcbl9fX0NTU19MT0FERVJfRVhQT1JUX19fLmkoX19fQ1NTX0xPQURFUl9BVF9SVUxFX0lNUE9SVF8xX19fKTtcbl9fX0NTU19MT0FERVJfRVhQT1JUX19fLmkoX19fQ1NTX0xPQURFUl9BVF9SVUxFX0lNUE9SVF8yX19fKTtcbl9fX0NTU19MT0FERVJfRVhQT1JUX19fLmkoX19fQ1NTX0xPQURFUl9BVF9SVUxFX0lNUE9SVF8zX19fKTtcbl9fX0NTU19MT0FERVJfRVhQT1JUX19fLmkoX19fQ1NTX0xPQURFUl9BVF9SVUxFX0lNUE9SVF80X19fKTtcbl9fX0NTU19MT0FERVJfRVhQT1JUX19fLmkoX19fQ1NTX0xPQURFUl9BVF9SVUxFX0lNUE9SVF81X19fKTtcbl9fX0NTU19MT0FERVJfRVhQT1JUX19fLmkoX19fQ1NTX0xPQURFUl9BVF9SVUxFX0lNUE9SVF82X19fKTtcbl9fX0NTU19MT0FERVJfRVhQT1JUX19fLmkoX19fQ1NTX0xPQURFUl9BVF9SVUxFX0lNUE9SVF83X19fKTtcbi8vIE1vZHVsZVxuX19fQ1NTX0xPQURFUl9FWFBPUlRfX18ucHVzaChbbW9kdWxlLmlkLCBcIi5hcHAge1xcclxcbiAgICB3aWR0aDogMTIwMHB4O1xcclxcbiAgICBtYXgtd2lkdGg6IDEwMCU7XFxyXFxuICAgIG1hcmdpbjogMCBhdXRvO1xcclxcbiAgICBoZWlnaHQ6IDEwMHZoO1xcclxcbiAgICBwYWRkaW5nOiB2YXIoLS1zcGFjZSkgMDtcXHJcXG4gICAgb3ZlcmZsb3c6IGhpZGRlbjtcXHJcXG4gICAgd2lsbC1jaGFuZ2U6IG9wYWNpdHk7XFxyXFxuICAgIHRyYW5zaXRpb246IG9wYWNpdHkgMTAwbXMgZWFzZS1pbjtcXHJcXG5cXHJcXG4gICAgJl9faW5uZXIge1xcclxcbiAgICAgICAgZGlzcGxheTogZmxleDtcXHJcXG4gICAgICAgIGhlaWdodDogMTAwJTtcXHJcXG4gICAgICAgIHdpZHRoOiAxMDAlO1xcclxcbiAgICB9XFxyXFxuXFxyXFxuICAgICZfX3NpZGViYXIsXFxyXFxuICAgICZfX2NvbnRlbnQge1xcclxcbiAgICAgICAgcGFkZGluZzogMCB2YXIoLS1zcGFjZSk7XFxyXFxuICAgICAgICBkaXNwbGF5OiBmbGV4O1xcclxcbiAgICAgICAganVzdGlmeS1jb250ZW50OiBjZW50ZXI7XFxyXFxuICAgICAgICBmbGV4LWRpcmVjdGlvbjogY29sdW1uO1xcclxcbiAgICB9XFxyXFxuXFxyXFxuICAgICZfX3NpZGViYXIge1xcclxcbiAgICAgICAgZmxleDogMCAxIHZhcigtLW1lbnUtd2lkdGgpO1xcclxcbiAgICAgICAgcGFkZGluZy1yaWdodDogdmFyKC0tc3BhY2UtbCk7XFxyXFxuICAgIH1cXHJcXG5cXHJcXG4gICAgJl9fY29udGVudCB7XFxyXFxuICAgICAgICBoZWlnaHQ6IGNhbGMoMTAwJSAtIHZhcigtLXNwYWNlKSk7XFxyXFxuICAgICAgICBmbGV4LWdyb3c6IDE7XFxyXFxuICAgIH1cXHJcXG5cXHJcXG4gICAgJl9fc25vdyB7XFxyXFxuICAgICAgICBwb3NpdGlvbjogYWJzb2x1dGU7XFxyXFxuICAgICAgICB0b3A6IDA7XFxyXFxuICAgICAgICByaWdodDogMDtcXHJcXG4gICAgICAgIGJvdHRvbTogMDtcXHJcXG4gICAgICAgIGxlZnQ6IDA7XFxyXFxuICAgICAgICBwb2ludGVyLWV2ZW50czogbm9uZTtcXHJcXG4gICAgICAgIHotaW5kZXg6IDUwMDA7XFxyXFxuICAgIH1cXHJcXG59XFxyXFxuXFxyXFxuW2RhdGEtbGF5b3V0PSdtb2JpbGUnXSB7XFxyXFxuICAgIC0tbWVudS13aWR0aDogODB2dztcXHJcXG5cXHJcXG4gICAgLmFwcCB7XFxyXFxuICAgICAgICAmX19pbm5lciB7XFxyXFxuICAgICAgICAgICAgd2lkdGg6IGNhbGMoMTAwJSArIHZhcigtLW1lbnUtd2lkdGgpKTtcXHJcXG4gICAgICAgICAgICB0cmFuc2Zvcm06IHRyYW5zbGF0ZVgoY2FsYyh2YXIoLS1tZW51LXdpZHRoKSAqIC0xKSk7XFxyXFxuICAgICAgICB9XFxyXFxuXFxyXFxuICAgICAgICAmX19jb250ZW50IHtcXHJcXG4gICAgICAgICAgICB3aWR0aDogMTAwdnc7XFxyXFxuICAgICAgICB9XFxyXFxuICAgIH1cXHJcXG59XFxyXFxuXFxyXFxuW2RhdGEtbGF5b3V0LXRyYW5zaXRpb249J3RydWUnXSB7XFxyXFxuICAgIC5hcHAge1xcclxcbiAgICAgICAgJl9faW5uZXIsXFxyXFxuICAgICAgICAmX19jb250ZW50IHtcXHJcXG4gICAgICAgICAgICB3aWxsLWNoYW5nZTogdHJhbnNmb3JtO1xcclxcbiAgICAgICAgICAgIHRyYW5zaXRpb246IHRyYW5zZm9ybSAyMDBtcyBlYXNlLWluLW91dDtcXHJcXG4gICAgICAgIH1cXHJcXG4gICAgfVxcclxcbn1cXHJcXG5cXHJcXG5bZGF0YS1sYXlvdXQ9J21vYmlsZSddW2RhdGEtbWVudT0nb3BlbiddIHtcXHJcXG4gICAgLmFwcCB7XFxyXFxuICAgICAgICAmX19pbm5lciB7XFxyXFxuICAgICAgICAgICAgdHJhbnNmb3JtOiB0cmFuc2xhdGVYKDApO1xcclxcbiAgICAgICAgfVxcclxcblxcclxcbiAgICAgICAgJl9fY29udGVudCB7XFxyXFxuICAgICAgICAgICAgdHJhbnNmb3JtOiBzY2FsZSgwLjgpO1xcclxcbiAgICAgICAgICAgIHRyYW5zZm9ybS1vcmlnaW46IGxlZnQgY2VudGVyO1xcclxcbiAgICAgICAgICAgIG9wYWNpdHk6IDAuNTtcXHJcXG5cXHJcXG4gICAgICAgICAgICBhIHtcXHJcXG4gICAgICAgICAgICAgICAgcG9pbnRlci1ldmVudHM6IG5vbmUgIWltcG9ydGFudDtcXHJcXG4gICAgICAgICAgICB9XFxyXFxuICAgICAgICB9XFxyXFxuICAgIH1cXHJcXG59XFxyXFxuXCIsIFwiXCIse1widmVyc2lvblwiOjMsXCJzb3VyY2VzXCI6W1wid2VicGFjazovL3BhZ2VzL19hcHAuY3NzXCJdLFwibmFtZXNcIjpbXSxcIm1hcHBpbmdzXCI6XCJBQVNBO0lBQ0ksYUFBYTtJQUNiLGVBQWU7SUFDZixjQUFjO0lBQ2QsYUFBYTtJQUNiLHVCQUF1QjtJQUN2QixnQkFBZ0I7SUFDaEIsb0JBQW9CO0lBQ3BCLGlDQUFpQzs7SUFFakM7UUFDSSxhQUFhO1FBQ2IsWUFBWTtRQUNaLFdBQVc7SUFDZjs7SUFFQTs7UUFFSSx1QkFBdUI7UUFDdkIsYUFBYTtRQUNiLHVCQUF1QjtRQUN2QixzQkFBc0I7SUFDMUI7O0lBRUE7UUFDSSwyQkFBMkI7UUFDM0IsNkJBQTZCO0lBQ2pDOztJQUVBO1FBQ0ksaUNBQWlDO1FBQ2pDLFlBQVk7SUFDaEI7O0lBRUE7UUFDSSxrQkFBa0I7UUFDbEIsTUFBTTtRQUNOLFFBQVE7UUFDUixTQUFTO1FBQ1QsT0FBTztRQUNQLG9CQUFvQjtRQUNwQixhQUFhO0lBQ2pCO0FBQ0o7O0FBRUE7SUFDSSxrQkFBa0I7O0lBRWxCO1FBQ0k7WUFDSSxxQ0FBcUM7WUFDckMsbURBQW1EO1FBQ3ZEOztRQUVBO1lBQ0ksWUFBWTtRQUNoQjtJQUNKO0FBQ0o7O0FBRUE7SUFDSTtRQUNJOztZQUVJLHNCQUFzQjtZQUN0Qix1Q0FBdUM7UUFDM0M7SUFDSjtBQUNKOztBQUVBO0lBQ0k7UUFDSTtZQUNJLHdCQUF3QjtRQUM1Qjs7UUFFQTtZQUNJLHFCQUFxQjtZQUNyQiw2QkFBNkI7WUFDN0IsWUFBWTs7WUFFWjtnQkFDSSwrQkFBK0I7WUFDbkM7UUFDSjtJQUNKO0FBQ0pcIixcInNvdXJjZXNDb250ZW50XCI6W1wiQGltcG9ydCAnLi4vc3R5bGVzL2ZvbnRzL2ZvbnQtd29mZjIuY3NzJztcXHJcXG5AaW1wb3J0ICcuLi9zdHlsZXMva2V5ZnJhbWVzL3NwaW5uZXIuY3NzJztcXHJcXG5AaW1wb3J0ICcuLi9zdHlsZXMvcmVzZXQuY3NzJztcXHJcXG5AaW1wb3J0ICcuLi9zdHlsZXMvZ3JpZC5jc3MnO1xcclxcbkBpbXBvcnQgJy4uL3N0eWxlcy92YXJzLmNzcyc7XFxyXFxuQGltcG9ydCAnLi4vc3R5bGVzL3R5cG9ncmFwaHkuY3NzJztcXHJcXG5AaW1wb3J0ICcuLi9zdHlsZXMvY29sb3JzLmNzcyc7XFxyXFxuQGltcG9ydCAnLi4vc3R5bGVzL2RvY3VtZW50LmNzcyc7XFxyXFxuXFxyXFxuLmFwcCB7XFxyXFxuICAgIHdpZHRoOiAxMjAwcHg7XFxyXFxuICAgIG1heC13aWR0aDogMTAwJTtcXHJcXG4gICAgbWFyZ2luOiAwIGF1dG87XFxyXFxuICAgIGhlaWdodDogMTAwdmg7XFxyXFxuICAgIHBhZGRpbmc6IHZhcigtLXNwYWNlKSAwO1xcclxcbiAgICBvdmVyZmxvdzogaGlkZGVuO1xcclxcbiAgICB3aWxsLWNoYW5nZTogb3BhY2l0eTtcXHJcXG4gICAgdHJhbnNpdGlvbjogb3BhY2l0eSAxMDBtcyBlYXNlLWluO1xcclxcblxcclxcbiAgICAmX19pbm5lciB7XFxyXFxuICAgICAgICBkaXNwbGF5OiBmbGV4O1xcclxcbiAgICAgICAgaGVpZ2h0OiAxMDAlO1xcclxcbiAgICAgICAgd2lkdGg6IDEwMCU7XFxyXFxuICAgIH1cXHJcXG5cXHJcXG4gICAgJl9fc2lkZWJhcixcXHJcXG4gICAgJl9fY29udGVudCB7XFxyXFxuICAgICAgICBwYWRkaW5nOiAwIHZhcigtLXNwYWNlKTtcXHJcXG4gICAgICAgIGRpc3BsYXk6IGZsZXg7XFxyXFxuICAgICAgICBqdXN0aWZ5LWNvbnRlbnQ6IGNlbnRlcjtcXHJcXG4gICAgICAgIGZsZXgtZGlyZWN0aW9uOiBjb2x1bW47XFxyXFxuICAgIH1cXHJcXG5cXHJcXG4gICAgJl9fc2lkZWJhciB7XFxyXFxuICAgICAgICBmbGV4OiAwIDEgdmFyKC0tbWVudS13aWR0aCk7XFxyXFxuICAgICAgICBwYWRkaW5nLXJpZ2h0OiB2YXIoLS1zcGFjZS1sKTtcXHJcXG4gICAgfVxcclxcblxcclxcbiAgICAmX19jb250ZW50IHtcXHJcXG4gICAgICAgIGhlaWdodDogY2FsYygxMDAlIC0gdmFyKC0tc3BhY2UpKTtcXHJcXG4gICAgICAgIGZsZXgtZ3JvdzogMTtcXHJcXG4gICAgfVxcclxcblxcclxcbiAgICAmX19zbm93IHtcXHJcXG4gICAgICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcXHJcXG4gICAgICAgIHRvcDogMDtcXHJcXG4gICAgICAgIHJpZ2h0OiAwO1xcclxcbiAgICAgICAgYm90dG9tOiAwO1xcclxcbiAgICAgICAgbGVmdDogMDtcXHJcXG4gICAgICAgIHBvaW50ZXItZXZlbnRzOiBub25lO1xcclxcbiAgICAgICAgei1pbmRleDogNTAwMDtcXHJcXG4gICAgfVxcclxcbn1cXHJcXG5cXHJcXG5bZGF0YS1sYXlvdXQ9J21vYmlsZSddIHtcXHJcXG4gICAgLS1tZW51LXdpZHRoOiA4MHZ3O1xcclxcblxcclxcbiAgICAuYXBwIHtcXHJcXG4gICAgICAgICZfX2lubmVyIHtcXHJcXG4gICAgICAgICAgICB3aWR0aDogY2FsYygxMDAlICsgdmFyKC0tbWVudS13aWR0aCkpO1xcclxcbiAgICAgICAgICAgIHRyYW5zZm9ybTogdHJhbnNsYXRlWChjYWxjKHZhcigtLW1lbnUtd2lkdGgpICogLTEpKTtcXHJcXG4gICAgICAgIH1cXHJcXG5cXHJcXG4gICAgICAgICZfX2NvbnRlbnQge1xcclxcbiAgICAgICAgICAgIHdpZHRoOiAxMDB2dztcXHJcXG4gICAgICAgIH1cXHJcXG4gICAgfVxcclxcbn1cXHJcXG5cXHJcXG5bZGF0YS1sYXlvdXQtdHJhbnNpdGlvbj0ndHJ1ZSddIHtcXHJcXG4gICAgLmFwcCB7XFxyXFxuICAgICAgICAmX19pbm5lcixcXHJcXG4gICAgICAgICZfX2NvbnRlbnQge1xcclxcbiAgICAgICAgICAgIHdpbGwtY2hhbmdlOiB0cmFuc2Zvcm07XFxyXFxuICAgICAgICAgICAgdHJhbnNpdGlvbjogdHJhbnNmb3JtIDIwMG1zIGVhc2UtaW4tb3V0O1xcclxcbiAgICAgICAgfVxcclxcbiAgICB9XFxyXFxufVxcclxcblxcclxcbltkYXRhLWxheW91dD0nbW9iaWxlJ11bZGF0YS1tZW51PSdvcGVuJ10ge1xcclxcbiAgICAuYXBwIHtcXHJcXG4gICAgICAgICZfX2lubmVyIHtcXHJcXG4gICAgICAgICAgICB0cmFuc2Zvcm06IHRyYW5zbGF0ZVgoMCk7XFxyXFxuICAgICAgICB9XFxyXFxuXFxyXFxuICAgICAgICAmX19jb250ZW50IHtcXHJcXG4gICAgICAgICAgICB0cmFuc2Zvcm06IHNjYWxlKDAuOCk7XFxyXFxuICAgICAgICAgICAgdHJhbnNmb3JtLW9yaWdpbjogbGVmdCBjZW50ZXI7XFxyXFxuICAgICAgICAgICAgb3BhY2l0eTogMC41O1xcclxcblxcclxcbiAgICAgICAgICAgIGEge1xcclxcbiAgICAgICAgICAgICAgICBwb2ludGVyLWV2ZW50czogbm9uZSAhaW1wb3J0YW50O1xcclxcbiAgICAgICAgICAgIH1cXHJcXG4gICAgICAgIH1cXHJcXG4gICAgfVxcclxcbn1cXHJcXG5cIl0sXCJzb3VyY2VSb290XCI6XCJcIn1dKTtcbi8vIEV4cG9ydHNcbmV4cG9ydCBkZWZhdWx0IF9fX0NTU19MT0FERVJfRVhQT1JUX19fO1xuIiwiLy8gSW1wb3J0c1xuaW1wb3J0IF9fX0NTU19MT0FERVJfQVBJX0lNUE9SVF9fXyBmcm9tIFwiLi4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jb21waWxlZC9jc3MtbG9hZGVyL2FwaS5qc1wiO1xudmFyIF9fX0NTU19MT0FERVJfRVhQT1JUX19fID0gX19fQ1NTX0xPQURFUl9BUElfSU1QT1JUX19fKHRydWUpO1xuLy8gTW9kdWxlXG5fX19DU1NfTE9BREVSX0VYUE9SVF9fXy5wdXNoKFttb2R1bGUuaWQsIFwiOnJvb3Qge1xcbiAgLS1jLXdoaXRlOiAjZmFmNmY1O1xcbiAgLS1jLXA6ICMzMzM7XFxuICAtLWMtYmtnOiAjZjFkZmQ0O1xcbiAgLS1jLWJrZy1saWdodDogI2ZmZjtcXG4gIC0tYy1zaGFkb3c6ICMwMDA7XFxuICAtLWMtcHJpbWFyeTogI2NiNTQ1NDtcXG4gIC0tYy1wcmltYXJ5LWRhcms6ICM5OTRkNGQ7XFxuICAtLWMtc2Vjb25kYXJ5OiAjMzU1NDU0O1xcbiAgLS1jLWJvcmRlcjogcmdiYSgxMDYsIDEwNiwgMTA2LCAwLjQyKTtcXG4gIC0tYy1ib3JkZXItZGFyazogcmdiYSgxMDYsIDEwNiwgMTA2LCAwLjYpO1xcbiAgLS1jLWZlZWRiYWNrOiAjNTQ4MGNiO1xcbiAgLS1jLWZlZWRiYWNrLWVycm9yOiB2YXIoLS1jLXByaW1hcnkpO1xcbiAgLS1jLWZlZWRiYWNrLXN1Y2Nlc3M6IHZhcigtLWMtc2Vjb25kYXJ5KTtcXG59XFxuXCIsIFwiXCIse1widmVyc2lvblwiOjMsXCJzb3VyY2VzXCI6W1wid2VicGFjazovL3N0eWxlcy9jb2xvcnMuY3NzXCJdLFwibmFtZXNcIjpbXSxcIm1hcHBpbmdzXCI6XCJBQUFBO0VBQ0Usa0JBQWtCO0VBQ2xCLFdBQVc7RUFDWCxnQkFBZ0I7RUFDaEIsbUJBQW1CO0VBQ25CLGdCQUFnQjtFQUNoQixvQkFBb0I7RUFDcEIseUJBQXlCO0VBQ3pCLHNCQUFzQjtFQUN0QixxQ0FBcUM7RUFDckMseUNBQXlDO0VBQ3pDLHFCQUFxQjtFQUNyQixvQ0FBb0M7RUFDcEMsd0NBQXdDO0FBQzFDXCIsXCJzb3VyY2VzQ29udGVudFwiOltcIjpyb290IHtcXG4gIC0tYy13aGl0ZTogI2ZhZjZmNTtcXG4gIC0tYy1wOiAjMzMzO1xcbiAgLS1jLWJrZzogI2YxZGZkNDtcXG4gIC0tYy1ia2ctbGlnaHQ6ICNmZmY7XFxuICAtLWMtc2hhZG93OiAjMDAwO1xcbiAgLS1jLXByaW1hcnk6ICNjYjU0NTQ7XFxuICAtLWMtcHJpbWFyeS1kYXJrOiAjOTk0ZDRkO1xcbiAgLS1jLXNlY29uZGFyeTogIzM1NTQ1NDtcXG4gIC0tYy1ib3JkZXI6IHJnYmEoMTA2LCAxMDYsIDEwNiwgMC40Mik7XFxuICAtLWMtYm9yZGVyLWRhcms6IHJnYmEoMTA2LCAxMDYsIDEwNiwgMC42KTtcXG4gIC0tYy1mZWVkYmFjazogIzU0ODBjYjtcXG4gIC0tYy1mZWVkYmFjay1lcnJvcjogdmFyKC0tYy1wcmltYXJ5KTtcXG4gIC0tYy1mZWVkYmFjay1zdWNjZXNzOiB2YXIoLS1jLXNlY29uZGFyeSk7XFxufVxcblwiXSxcInNvdXJjZVJvb3RcIjpcIlwifV0pO1xuLy8gRXhwb3J0c1xuZXhwb3J0IGRlZmF1bHQgX19fQ1NTX0xPQURFUl9FWFBPUlRfX187XG4iLCIvLyBJbXBvcnRzXG5pbXBvcnQgX19fQ1NTX0xPQURFUl9BUElfSU1QT1JUX19fIGZyb20gXCIuLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NvbXBpbGVkL2Nzcy1sb2FkZXIvYXBpLmpzXCI7XG52YXIgX19fQ1NTX0xPQURFUl9FWFBPUlRfX18gPSBfX19DU1NfTE9BREVSX0FQSV9JTVBPUlRfX18odHJ1ZSk7XG4vLyBNb2R1bGVcbl9fX0NTU19MT0FERVJfRVhQT1JUX19fLnB1c2goW21vZHVsZS5pZCwgXCJpbWcge1xcbiAgbWF4LXdpZHRoOiAxMDAlO1xcbiAgaGVpZ2h0OiBhdXRvO1xcbn1cXG5cXG5ib2R5IHtcXG4gIGJhY2tncm91bmQtY29sb3I6IHZhcigtLWMtYmtnKTtcXG59XFxuXFxuI2FwcCB7XFxuICBwb3NpdGlvbjogZml4ZWQ7XFxuICBib3R0b206IDA7XFxuICByaWdodDogMDtcXG4gIGxlZnQ6IDA7XFxuICB0b3A6IDA7XFxufVxcblwiLCBcIlwiLHtcInZlcnNpb25cIjozLFwic291cmNlc1wiOltcIndlYnBhY2s6Ly9zdHlsZXMvZG9jdW1lbnQuY3NzXCJdLFwibmFtZXNcIjpbXSxcIm1hcHBpbmdzXCI6XCJBQUFBO0VBQ0UsZUFBZTtFQUNmLFlBQVk7QUFDZDs7QUFFQTtFQUNFLDhCQUE4QjtBQUNoQzs7QUFFQTtFQUNFLGVBQWU7RUFDZixTQUFTO0VBQ1QsUUFBUTtFQUNSLE9BQU87RUFDUCxNQUFNO0FBQ1JcIixcInNvdXJjZXNDb250ZW50XCI6W1wiaW1nIHtcXG4gIG1heC13aWR0aDogMTAwJTtcXG4gIGhlaWdodDogYXV0bztcXG59XFxuXFxuYm9keSB7XFxuICBiYWNrZ3JvdW5kLWNvbG9yOiB2YXIoLS1jLWJrZyk7XFxufVxcblxcbiNhcHAge1xcbiAgcG9zaXRpb246IGZpeGVkO1xcbiAgYm90dG9tOiAwO1xcbiAgcmlnaHQ6IDA7XFxuICBsZWZ0OiAwO1xcbiAgdG9wOiAwO1xcbn1cXG5cIl0sXCJzb3VyY2VSb290XCI6XCJcIn1dKTtcbi8vIEV4cG9ydHNcbmV4cG9ydCBkZWZhdWx0IF9fX0NTU19MT0FERVJfRVhQT1JUX19fO1xuIiwiLy8gSW1wb3J0c1xuaW1wb3J0IF9fX0NTU19MT0FERVJfQVBJX0lNUE9SVF9fXyBmcm9tIFwiLi4vLi4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jb21waWxlZC9jc3MtbG9hZGVyL2FwaS5qc1wiO1xudmFyIF9fX0NTU19MT0FERVJfRVhQT1JUX19fID0gX19fQ1NTX0xPQURFUl9BUElfSU1QT1JUX19fKHRydWUpO1xuLy8gTW9kdWxlXG5fX19DU1NfTE9BREVSX0VYUE9SVF9fXy5wdXNoKFttb2R1bGUuaWQsIFwiQGZvbnQtZmFjZSB7XFxyXFxuICBmb250LWZhbWlseTogJ0FmZm9nYXRvJztcXHJcXG4gIHNyYzogdXJsKGRhdGE6YXBwbGljYXRpb24vZm9udC13b2ZmMjtjaGFyc2V0PXV0Zi04O2Jhc2U2NCxkMDlHTWdBQkFBQUFBRG1nQUJFQUFBQUFnSWdBQURrOUFBRUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBR2k0YmxIUWNnM1lHWUFDQlJBZzhDWm9XRVFnS2diRWNnWnRJQzRNaUFBRTJBaVFEaGtBRUlBV0dBQWVGUkF5QkRSdm9jalhpN1RzSjZBNUkxWjJZd3p5S2trWTNPaEloYkJ3QUtmRDk3UC8vbXZTUWJWNEQvaXJJRW1RS0lvOXdCVHd6U1JuVlJXTUlROWtJbVFwZmpQR3I5cmcxWGg3c0pHc2dQNFllRDRjUTdQUzZMU1U5OFBWKzV1VkV6N2ZGTzBqODlkSnZWZmxGdnpVN2RVNitSY1ZPa2xBdmhMQXFNb3d1ZWhBSVpQZEN3Ly9yUDZPR09oTmlyYnVkQ1IzK3pMSFBuZHBNM2UwSWpYMlNTeElWYTQvZnMvY0NET1ZUVVlneTdJaU1TRVhZZkdLaGdCV1FBaURIdU1QemMvcy85KzV1emRhd0lOYkFHR3ZHWU5RWWpLZ05SbzRRR0oyS2dUYW80Sk1aaFJpTmlHSVZWbUdpdnVEeC8vTkYraXFFY2NEaVg5ZVBPdk9mRmJhZFdHQ2lpR3dIcWFTMi8vT3czQTNMbGl2Q0V4dDdIMmZBTjVzd3N4SzFMWlJkU1dWcXBhM1VtNElFU0lhVzU0RjJEZlN3SmgzWnZIY21qVkY3OExIREQwS1hzcWkxWnpnN1R4ei9TLzU4bFF3QnlRNGdUY2h0UjVKT3o3N3doMWNBT0svMzFoRHkxQ2tBT09iSUx1ZmEyZllsZFZFVjE5VkREb2lELy8rNnpIdmZKOEVYRFpISEpJOVhKcGhsTGFDY2N4YXc0cXBJbVd4WGJSMHVreXFwV3JSczcrLzIxMHFwUzduc2lkdWhDVWN5ZVVLaGZtdnhJQlM2Q21teC9uV1ZWZFhkWDE4YTFCSWRBTVZuczNiWFFCUHBOSVk1T2J5WEg0K3p5QndDeHBuQmdHM2RHaEFqSHRLclNiRDQvNzltMnZubjdsdmdXN1lFYW9RcnFyS3VVQlV1SjM4bTlNNHI4R1FLaEc2SmtxeXNNVFdDMExKY1dXQmhxbXQ4ZStXcnZ0OTU5d0VnQWRJQitqSERNZlJVcXB5TExwVXVtc1B0ZTNnUjZUMkFJaDVFQ2dJVW1CUUlTQndJK2dFUGdEUWcrUU5GL1pBQzVSUXBLRFBvLzA4NjVOamxVTW1kM2NYS3JZdkdkZW5lUmRuWXJaZXgrWTJZbUdEa2lkSjFwZFprRDdMdU1naEY3dFZDeUVMSUdmK3hKMyt1L2xDd2JhOUNRZ2dscEZVRm5mdDg1Vm9CVE5iLzBnVU5aUlRrak9zZ2syNkEzWFFUNUphSFlCQmdJakVkZU5lZVpEc2dYejNWV2cvSUVBQUorY211bkd1dUJ6aEFBUUtHY1JFTUtBU3BJTzRRd0ZoU2Nob0dFU0pBTUNobzZEeHdlWUpjNmxrUWRJZVJocFc1dkpyUzI4SEU3dWtHVVlTUGcvNU9mMXVQVmFUZS9SN3R0RHMyamxRZWtBdVZvMU9rR0VKb2hEQ0p3aUtDUTlpVnJNMmpnUkV5MVdoZzNCcVFsMmx4eDNvUUxGVUdDQWx6OGl3Q3VIQUFBV3JIZ0FFa3VCY3d1Ny9yUi8xN1R3L0orWjQxeFFtN2NHUElxbzN6QnJ3dkF3L2VMVjlicWRtdC9heWpaOTNiM3FuczZQZnpTczZqVmY2STN2RFpERzUwbzF0Y2Y1UzlFYXBaUEc5YjZXek0wWDlYc0g4cHlxREU5SHBjei9qYnZUVHlwbERhTkJUMlA5MEk5RXlSNS92Mng2YmdNVEFBcXlsQVZMUklnb1Noc3JCZ3E5YUlvOWxpZkwxV1V6cm1tR0F3dnROTWhJVGtjaWxmQ0Q5RG1EK3haR0ZFQURsWUlIRVVZUlFWTlppR0NDM1Jnb2loSnlLWVdBYmloSkFvbEhoR0VvU1J5RUpZWXhqV3JBdXNtNGo1WWRnQ2l5RjZ3NGlsVnNCWlNhSlZSRnV0RUgySFRrS2dnUVI0d2dpa0lBMW5KbHlSRHFSaUVDWW1qWlF3V2VSRkF0TUJZWHFGNlFNRkJGaWdnVW13SW9GNDVqQmRyRGgwQ2FSTENqT2tzV0t3a1M2RGRIWXlaSkl1aXpqWlpIQW9nNkdFcGdraTN3RXI3UFZwckRYV2Z3Z1BHa0xuc3FXNGxZWHB0aHRHTi9KZ3VqME9ZRGprTUVaZ0V0Z29rTzQ4M1Z3ZzJVVVNYU0xKbFVoMGdYT00wM2ZnM0lXL213Nk9GUUxrZ1ZJaG9FcEVQbTd2ZGhhVExHMHFtQzFCUGdFcm5aYWR3a3pGK0w0dEpXT2Z4bTRZN1pjSUxtdGFaYXVxbGIwUHpZY1hOMmF4Z0wwU29hUkloMldYeFUyT1BGUit5YkRoYW81dGhubHhtb2djTkNybU1aRzRCWlM2czdBdm1JY1lJbUtKRTBkRVBDRUpoQ1VTSllVNHFZcVBTSWRLMHlHeENEU1EyekZ5NU1MS1E4VlJjRWdHRkJWaFFCUWhBZ1FJVUE2amdzUURMa0Z6WTBTaEVFWWpURWlzWU9LRmtDU1VCRVlTaFpFa2ttUlJSSmlWa2xTZ0tDV1JRRkVLWlZBQUFhTnVxUUlTS0VwSkVsQkFVUXB4cGNRK1lJV2lIbEJBYVRJOUUvZ3hzb0N3S3BzcTJIUTg2T0dvNTJWN0JMOWprRDgrRFBlT2VOMHZXQVZtYlRlYmVIM3BXVWN3QXNUNFRieUhlOE9XV1gwNmpBajBJVUR2UUR6dldURENlUmRjbkFHR1B3NE54ZDErSXFKa0FsYThlQUFETEJCRjgra2x0NnVvcmlRcWx0TWxNY0FwaG05Z2dVMndrZzBodGhLVzlSWll4U3JGQythS29JQUJWckVSQUN5d1E3SHlxRmpXRFh1K3VlRXFuNUpPL3V6MU1OdFB4dktCYXFmSnpnZWhPOU8zclRGemovQkI2c3N6Y3A2ZXRMbmt2TlJyVjF0U2E2aUdvV0hVTU9aRlkyR3ZYcW9vQnZLckRhVzFRTk9HQVJHSVFlTGlWa0JnZ0FZQUFnaHdHUVYzek1rUDBtcmZ1SlFMZ1RFL1YrYlpnekpMT3M3VlVyY3FkOHRRTG1qbHhKVDRpaVBndWk5Q2tpRHJwNnVoVWIvTWxOT2JseUllUk15TFlSZ2s5OEZJN29FUnQ3dUhFMG1DUmtMSDVrM3NEbGlXMjJESmJvRWx1Z0dXYWhJc3lWN3Z3dVVRTklRWDNCa3ZvMmoxOWsyWlZ1NklWcGJzNkx3TVUzcjMwcndkbGtFRHRhbW9nQjN0SjJZRFRYQUFNRkYvdlhIQVU0OHNPeFZFNGEra28vSTdnTFovVFMrV0F6Y0E4bVNwQU1zUkFMNzlXYjlDbW9peC8zVTlQZ1JPa1lYMjJPZVFVV1BPbUlQVXlWak80blA0WG53aFg4b1A1eC9sOUxrNUxGZHN0NVc3c3FuMDVRdyttKy81NzB5eHY1cTlldVhpMlRNbkRuZk5PV2Iyem96TURNOXNuOWt5czNTRzlTbjhFVTAvZ09wTlBZS0FiL2VqRjJPcVhycGswRWQ3VGtVNi9mOWZUVXVYeU96eTYzZm9yOWdCOFRMMEZIaStRRHA4VHZ2Mk1mRGtrb3RKUEVCNkdTalcvQTBDenBST1pHeWRJOTRTZDZUYmdzWWNmVUdDOC9WQlFRR200RzgxZGZyWUxpUmliOUtqTFlLak1oMTlDazZjVFcvQUo3WHFxTlZld3JKL09WRmt5T1hObEF1VXZyQ2NjS0FkUU1GdjYrRUE2Y3VIR3lJMWV0cDh2eGE5Q1dkdzlsVVFWZFdTcmlyRWt6QlRMYWlBSHFpdG1ZS0dkYUNKbmpaNjY1eVM2NElhNHNSaG1zM1c0NUlQMXJDZDg2ZGdBWnVXVTJXWCtPZ1FhZjcxbFo0UHFwdlVhUmhpYlp1UkJsR25ZUDBta0c3SmtycG0vS3dHZE54cUlVd0NxempNQ0FqcWJpamJBNkh1VkFkTlZyWUQrcmwrek1sQ2h4S2xndHQxMUhJcmRwZjdDdEM2ZGpEMy9LWmpPNFJPTVJnUmhoUmRZbnVpdG9oZVd0OWd5aW9UWTNhdTQveVNOWU9ZVkN4cmRKcy9MM0hkT0RjK0lLcm00RGt4RTdkeHExd0VaOFhwcHVORkNiS1VDbjZ1V0Y0d2hWSUF0dWV6dXNHVGxkcks1QXMrdzRRTmZSbkFuQjVGV09oUW10WTNYMDVsUkhxdnBFbVFpWEk4Znh1eTNuZDF1ZHgva0VPbDhGWU13L00zMjdoMXl0VisvQll5c3M0N0pkdEt5STFuNWtwTXI1alBmb2RKRVhraW9MSmV5NVNMVWJ2cDlHWGVaaW83ZVJQNk1Hd1ZTSENoeS9XVm5nTW1FSXhVNEZNdDNKc3lBN09rUzVLNDBWTGtZdjl0bUF6cHZRM01va2VQOGZiMGpDSzU5b2dmbGMydllyZ0Vzb24yNlgxdTFTcCtYMTFlMVlJZFpMUzNDbmFSdVlhZUlOQVhGQXdFRFVQQndFaXdNQlljVElRQXBrTFl0UTFoZVVQYTlmTzNRVkNTQysxZ1RmMmxrdWFlKzcxdDFWeTZQMTZyWnpBYytkaHdCV2M0UjhWVlZGeER4WFZVM0VERlRWUXNVWEVMRlJlb3VSMmdrbEhZellzczF1aTByM2Y0cU5EUmR0VDBsMllQM0hYdTVvTDdBQVlRWUZhYUhYR0d0VmRxZHVSd0lHMTJ6UlB1NTJ6a3VCZXVLM0g2SVZOcUs4c2RBWGVHcWg3WGJJZEZDemJwTFZmZk55bDZQd0hzZWlBNytVaTZoTDFhVG9BS2c5NTJFSGZvUjZqZ0tjcXpWY0V6c0JnWkRaWVdueU5MY0Y5QktXMWlYU2U2bjZZdkQ4VDBOZ2hqNjFTTG8yL1BoTWVuTnRuQUpZZ2VjNGhybXdsa1lvYmNtcVc5Q0ZScG1WN0E1UVJLUERGcWowUFo0SHVMTVdrOURITzVQVHEzYzBsSFIrcXRhRjlBcEhYSW1QVGJNVFZOVVl1V1RBd1pPeEhHcVZDeG1iYUs3S3A5dEdqRktzSS9vRVlBNmlUOVpzY0tBL1lweHFpRDdVYmtodGhMUlkrY0F5bGp6VklSd0taT285R3RCMTZMb3AwczYwYlJNWEtGQlNvaVNaT3lEcWwyd3MxWExRWlZTaDk0aTF4d2tXdjdpUkNKdWNWNEVVcFU0cXduYnk4REd2ckhyVmxEbmdaMmtYTlZaVm9Ta2hiVk9uTDloaGd2WFdyUi8xY2tOOFRiMkExY1dzbEF0dXcvWjZqdFNBTXFMZk9lZExZeTg5OTg4Wkd0UjY3UmFvYSt5N2UydWZUV1NtOXY4N0tuK1cybFdoY3hMY0VHVUxQa0hvTTdGbnBxQ1VtVzNveWdBb1YzTVA0WXZidWRnNHA1b25mMUx6RlFXVDRDYnA5dVc4bU9kY3FSZERvOHVOZUY1UllMMVBzVzY1Sk9DbWtVTXNINHdPaHF0OW5DakpXVE1lOUpYcFNIM1krMk0vZ1g1eWxYSHVmVjh4MmF2YUhYRTVUb3AvVU5rOHlMYmZtTnM3a0hmTFBOcVpYdVNvd0lRTFFGR0JNQzhYblNQVXdJUUxJRm1CSXlNRDJYY0V0Z3hnVmtXNEU1VnlCL3VFUXN1SUJpSzdEa2lsYnVEdThJRmI2QWFndXdKZ1RxODZUNzJCQ0FaZ3V3SlVSdkR3bHZ1enA4Q2QxV1lNOFZ2Wi94REFjdVlOZ0tITG15YnB4bGMwK2ZmSW5UYjl4VERMUVp4V21Cb1RJUGhxbUdoUWZYMGdPc2xzakJpR3UzZ3h1M28yOHp1c2FkZEExN0QzRHdvQjdIWmhkUGJoZlBiaGN2YmhldlVnWTNEM0Qzb0Q2ZzJjT24yOE9YMjhPMzI4T1BsTUhYQS93OERQclB6WkVpVmNXM2c0MXp0TlgxWVFqZXVEQmd6eklLZi9sNEgvemg5VTk1aTRCWDcza09PV3lVQzFtNnpBN1laRThWNzV3L0pRaTF0WW10aFovdXdyYS9TdWJSb2hGVjlxUVRyN1RjUWpRcFcycndFZFQvZjB1WWFzODRVbzJ3MjJHb1kxR2xNK1BZSkN6bjBSZ29NODd3TC9KRG5URHg1UVAyWWZJcURkMEhQdHpUZTlvUHQ3MGVqMWM4cGhxdGVMczltNjMwWm5adnUzK2JUdnFiY1dEVE1EeUl3MkYxSmd2MVIyNVVyYVJKdVpKbDVaV2c0NUpoV1dYUHlYZDlONTYxbmFIcmJiaGRuNTN2VW9meGozUjJwYzlHNmZBZ1d1akYyTlZuenlLTU00eG4wZFQ3ZzZKMzVBY3VXSTlQZGtmeDdaV3BkdzV1NTNvdkxWMDZjVStiMmtmNDdmcytQS3Y5OElvdWQvaklYNHI5NWdmWGpaQlNnSUdBa1pCUlhsUlJvV1dhY2VwQ2s0K2pnREJVVGNEdml6SE80NFJ1WEdidG1tU1hFQzR3RlJZU3NvZFdZeDhMMy9mNEpQenMrVWY2NTN1RjdXUEwreVRyQ3BhY0JVNTgzV0dOMjNBc3h4bTVyQmhnN1BFWHQvV0hQeG40aWorbmUwK3g5ayt5WHdnLytPTGpZL2crNTEvdnBEVGtmNG9zaXpWdTM1V0JkS2RVWmZvU2pEMElmWkpaNTFsQ055clcwK3MwQklaMzlMNTE2LzlVZHM5dU1CMzBUa3JkVHNtRU04cW9ZMW5ONzRoUVFPQnVOUlV2UmxOR0hKdGdkc2ZMbTBneGpoT2JNZ3hBb0dtNlpjL3lEaU5BdUNWZkZTZ3ZXQWNsdExOVWpaU2t5TUV4bnJQSkt3WmFpK1REV0ptbVlYSi9XenhuaEdXUU9nSXk4cHl3S1hCZDFlTDFtcHd2QThuV01pSnYrVkloWDQ5bzF5RjRoeDJBb1g3UVY3UEpFKzRJYUZsMHgyTGdLOExNZEpOTjJuQ1l4aDIwK0FpazhZNCtwZGRkdExRb3ZOVjFFeUtoUks4UElqTUNuekpHMDN4bXpocnFEZGN1ejYwN2l3UjNnVnRidk42Ymk4NjJIc0IxR2xwL1lWK1c3ZTM2YVhMQ2JCYzFGOFlrNDdRM3RVV1JXK3N6ZkpnejZxRzY2QUFRNXBjcVBGN2lEb3l6UGs1VVIwTHpiQTQ1Sjd1V2pTYWhPejdTQlBtYnBTTkJYMGNMQ08yQXU3TGlET01QUVBnbDJiVlNpem1xVk05dkdRZHNJdWROb1I5S3hUcjR1Q0lxbG5HMHVkS2tha1AxemE4S0dqT1BpcWJ5Ym4rVkM2UE5TR3h4dTBhbHVGVW5GVVhHVXFFNktBMW03amVsU1pITGhSU3R0UXRVZmR0ZUpTOXI2ak1SL3V0UTRwSkZ6K3pJVHJKcnZ0ekJTR2haaWloNXJxYzNtSThxS2Fkc0RxRHNnRVZ5VjRhMGtaR3U4TVpOcDVsVTM3a1RhVlNTVW83eWhPWEI5VmF0RWk3UjdTcFhyaksvemFhNXJ1cDNxNXBzRlZiZFpTZmtjNXVvY1ZLcEE2cFgxUHhGcEFsRENUMWhlUjZERkJSb0xzOGh0cUpEYmtLcEUyZXFMYVhGczJNeEhNTDRwYmcrYzVIRURPNnJjdDJLcGdyS0t6K2tFeE1hampoNlVkSGsxc3J0K3dZVzE3WEpkc0pJM1QwYWV3U2djTG1oVlBjSmJBeDNEbmYwdHBvUm1tdzAzYUlTTEQrVm1yS081dFZvZ3hPNGx6UFFRK1VheHIrN1I3NXN3WGFwMnc4aGRkNklYWmQxQW1QS3NENmVrNzRjbmptRHdTK0ZISm01bW1zSHdzNXZvMDJFUzg4cEN1OUR2cmNrbFBXTDZWSC9IamJNZTFGRUZYYmV0SmF5TkJQL2xMTUtHUGtpQ05Ya0NrL0NJc2dyMGRHYmMyMFU0QWJTZ3N0VHFxMHA5K3dTdml6QlNPOUFSNnpKWE8xaXUyV0RMRlVUTE9sMEJFZmVsSW9Fa051RE1YZHR2RklvNllFc3drcU9HQ3dQMGh6MTJXYnJGWW9SdnlheStqU2hxbFg4VDRreVNkN1hNMWFyVThXNFpVNnlqQnpENHhiajE3Mm44RnpkckxHYWl0enBwcnhrRWxuTXpwdlVHTGlTK1NYeUR0Rjc4K09EN0JjZzlQV0xpUjdDZWRhRWJ1Z3RFMjRkVW1Fb2hVZitqdnpBRW5SSHlXWDY1ZFZQQ1VTYWpkMW9LKysvVy9OUXIrMC85YmxVbDkxOFVEd0tiRG5DNkxwbkI1OHU4Vng1Tmh4cnY0L1ZtVENVL2ZPMjB1NHdZMWZPU2V1MnZXRHNHTFowTU1iY1dVN0prdWdhSmZiV3J0NitDd2g1TVFPdGlyVmIzT1p2UGlUWnNUQzFYVkpBNHcra2NmVlBsSmg0VGo2eHpPRkdyMWJaZHRtQmxadDFaaWpVYmMxdzkrcjVMejYrNkwzNzhuN2NUSEw3eWU3RHJhY1FjcnhwTk1LVGthaFpZa3dlb0dpMzNMRVVwQjJzaUNsMG5XTzM1VHhTdTY0S1dZUHZyL3RuS1V4ZDhaUklRbDlwSGN4SGVVWkxwNldJeWs5Wk9tR2JKZXdxK2thaXBlY2huNUVrSCtuOUFPdlkzc2QyK0FCMDN1Wm5PdDkyRkg2VDdkZi9wL0NkSm5pQjVvZWtyNUcxbXhKdlVRNUNtcjk5RHJuaXlHQ0xmYXZmc0dPd3RDaGRHaHhYUVVMZk9ROU8zdmdPSUZ4Mm9kT2xRWjl5Vk5ocmE4YS9lUXk4NGd6OW5uWkxZYTQ2N2VzMmJxZUR1K3l6NTRKNzh2ak42Uk0vbldneDhuQm85dDN3REp2MTJndmdnSkllUndxSE9LNW5kd09rR0U5bVZ5RFZHcEZ4M1orU0VhNXRiY2ZPdEcreGJ4VmR4N0JZZXEzT3ppRzBpTkk0S3VLUXpLMkdTc0c4OE1hWlA3U1VVcFVnS3pMSXNNY21RZUM5c0YvY2MyY0tPMDFVZGdET0ZXWm4yaDhvck1TcmQzMkxUN0J5ZmR0NG1kdWZteGZEY1QycjNleWtUOG5WM2xCTUowWVhRKytvcmVvbyt1a2RGRHM1andMSWp1ek1ISWNqMC80cVN0MUxLVy9YNUlXQUEwYzhOaVdDZUZKbkRiUjcrT3BaNWw3dmR1enk3Rnc3YXgxeGt0R1FjOFBWb0xVa3pkNmRsN1d6b1NZRmdFMTdvZEpySFc2QTlLUEx0QjFNMXhoMDRJK2E4cXdReUdzTTkwc2dxQVdPL000d0ZiYllVV20vOEdjNlpTT3I1cEJmbElXWWJLOXhCNnEyRFFTbGVPYVVWNUhlSWZIZ3g4cFpKVFNxeWc1YTYyOTc0bXpuSTJSMzdTZHNleEQ1ZmVUUDBVS1RKRnB3UUdDV21JWDdsMVFkRUprdGdsaUJXR0FxRmtRSHZ3YWRGck9BRjcxY2VNRHA3RFlJUFFSS3AxWFFkS0JwLzlIbUE4MENxMVBwWEZZdXNNUXFoQWVFRlJZRlg4QlIxQSt6ZHpzcGp5K0tST2RGb3NNaTBVV2g2TnQ0anhxejF4SXpJNitma2VkODRwOVpBT0l5Rm5kbi82dzdsMG9ZeG00N3hhZmYyYjIzS1NKTGc4NGVRdHNwc1VrSEJueUQ5cFBkSWlsa1ZNcnNpYzlVSWZHNUEwajZSb3hqTmp5K1pxVzQ3U1NGQW9mN1h6NzcyZWRLUzZodWo3Sy9pRDBlSTM2TEluRHorS3NDRmFzRGc3V2Z2aXg3cWRCQWtDTCsvNG45dzVTakZrT09XcDJ1dEtRNGt3Z05Vd3Y3UDBycXg4MTFtZit1OTdFU1BCOHptUk5NTDNNMWUvRVFtb3kwc3ZNMXBrOWJPc3dmbXh6ZFZtMjg4YndqMjNoQlplbTJZYlpPYkl4bE96d1dZVkdXWWRsWVIwdlZmcUp5TWNUeGJsK1ZQZGZHN0N5YTJjNXU5aC92bHREVHBiSGFpeGp0dVdtSDNJUjZ2SFdmYTkrMi9tMTdYWHUzU3ZFVmhwOXFjRjUvWUdMb3YxNTkvN0xqS0xpY2MyVmdjSjZBY1FzcGp3cnR5WEhMSVhZeWJaUjlpb1gwWUtrcGVVMi9XL0lpY2VybW54Q0pITlpvTjIzS1F3LzZESzlkdDJEQitGV0xoT0ZCcHh2ZDF3aEo4U1cybUdDN1FtSFQrb3ZOVDR0cmJjNkU4UFRRSUcxT2pqYklYR1g3WWFrRVBHRnlmdVp5bTl5cENRZER5eXJ5ajY3TUhNeE4wYjh0VUJTNlFNR0h6S2wrUld3S2RHWUFPNmFRcWVmRitza1NWSFdaK3JmQncwdmVIa2NsQlBjZmc5Tys4d3lMclRTcnhjbFNnOHJoMEVVRU83UkJ1WWFrd2hPbWVkazUyekpXU0JQWGNMeSttdVJ5cjNFOEhubWdBWGVTRStsU1hsTnVIdHg1YXRCbmtDY3hCMnAxYVE2NXdlQ1FCMWsxZ1JJek02T1pGeGlRWUpWcHRXbXlnSVJBejZhTURXdlhzRmlyNmZUVkxOWWFPanRoeHN0cmhzTjk0dVgxaEJ2TzB4VUdhWFAxU21XMUtzY3ZkcmtyNGU1Q1UrLzUxUjRTczhRL1NhL1g1dVhxZ25YUEp6bWNTUy8yVlRiM0tsZFBveHY0ekxUS292cy9Hc1lHWUdoUEh2ejRRREdYc1Q5ZXpQd1hOT0pGbjMycUYxU1BUanFyaTdQUnYwZHZTWk1HUkR1QzVKbktrUHg5Wlh3amcxdnpVSGovYjJJTi91a2RRTTBGcTNMRDgrUmNzOTlIL3ZMWVlPazhZN2gvZFh4VVFLVFFuTkJISUlpU0JWTHZQRFRJU094YmFjdTJyOHZJV0d1M1o2eGJsMkVmTENSK3hhNktLSEx6VTdWTU5qVmRiMmxwdW42OXFiWHRmRjMxSmFnSnZiNDJabjA1aC8xYUtmN0VjODZqT20yVWxlWTY2SCtTY0ZEbkNuMnBQcWMrRnhEdTk1Wmt0eFdZK2N1OHNpU0pBU0g2aENTQjhNTjFSODlta0VQbzcyM211M1FYazdtWEVnc3l3cWVSeHNqb25teHFkblJQWTZUWjBtYmp4SzNRSGIzRWx2WEhVR1A2WmJ6L05hM1VzNjN0dGtSRnVQOURRa2g1ZE9TeWdnSkxWNDBoNVBybGp3SmxNWm9vWDd2aUJFRTZ0VGZKMWUrS251bHZWYldBZnVXelBjWGIrcmVkY2FrNit2MmIvN1pObVovcllWa252Vy96Q1ZpVVJFMWFGQ0RhaTZCeWV2L0lqNDJzcVRXYTlKOHBWYTZ4OWpGWHdCRDIrL1p2ZkorN0ZFTVlScWd1dDdHNE1Va2V5Ly9aVUEzbU03V0pEL0w2bE9pYmFzc2lWK0FRN3ZiS3E0ZEgzaDJQUCt6VDBOZXZrUS9oRHZtMHlRSmNiTWZoekx6RGJGZkFFRzc1ajFpa21GT3FWdTUxOTdBYnJjRHQ5ZkVVVHlOMWtWRkQ4a2YxMUxXYjY2K2gvbVB2dnpvdGlacVVKcE5GSkZPVEkyUnl2UzVQYlNpTUNnbDAyUFdONFp1R1pMY0lCQThQazZmUExYNzZFcjB2MFl6RlF4U3pBMWcvVllkcnpUSnNpVEltaFdockZObFNhQ05LSXJKY3pOcTZwcm16Qi9ubEpOYWNaM242WW5ybGdrZVEyZ3h5Z2hQOHZpclZLZlpBblNyVEx6ZzJKLzkyMEtxdGRybE9zV0ZuMXk3WHJzN0JsYnduc0ZNYldwNElXVDdDUXRHS2RRSmhReUJrMmdpbEpJYVVPN1VSQWpmNUdmbW1NL0t0dU1ycWltckJzWUQyZ0Y0N0laUFEyeDR3aEFzS1NQTjBwdm5vRlcwYkc0NDNIaCs1NURWQkc2bmNZL1kvTWtHLzZDbU5mdlBXOWZhd2RTcytiOHF3N2YzeW10ejVtdjZtZjJEZ0U4WW4vZXVsaHNrWlZ3SWlTa0JjTTBJdjk2VkkvalR4VnNtalA0VXR0VDNMNXZmbTUwOC9ldk1FazhxSUpQWkY4c2RQb2pncmMza0I1OTZJRWpkUFlRMWsrbWhSRWxzL2dBVXZqaGFYVTBEWEdxNjAvME96U25xVktvc09GMWRIUnZpVnhvWUV1T3Z6NzlmMlp3eGh3WHV4ZUxyRndBckZIVS8zaldEVkZucmJQc1FScGlnellveUtNa2RZWkhCUjhMNnV4TEk3VEovTEVvemtzZy9qWldabnlvMGlyVlozS2k2K0h4L2pHZHo2YnN6Q3BCbjNKNVVyK25pZEZyY2NRdklqMU9WRzQ4SU9mMFJFd2Y5bXhYcHZHZ1pENUxGOC83ZlN0NzA0SmxwSHhKRllMRTlPMU94VFhYUlB0TnFsVnZRbzRNejg5R1QzM0gwK2pRemljTTl6cFFrMXJJNVEyL1FHYlg2K1BpeWxQUC9mRHFXOTFvYzc2OFhNWDhZS3l6ZHFpZzA2VFhGK1JCajhBMEh4L1JTZi83bFk5RG1mUHlYYUlydEVDcmJrbVlTdVB6MXRIaHl0MEJVL2hKMldNL2FVNGZGZmJwSFh1YUtHY0dUbmd1SFZ4MXg0VjlFdWtNQ1hXdVBBK2lFc0tGTzhLbGxNWDAvREdiSDFVNnh2WmZEN0wyRHlmb1hnT3QySHhjVERQdnJyVVFSSjU1UkNmekt5clVuT0RHQ1JPRGx6ais0d1VoQ21acXBmWFZiUUhsbjRDUXAvenQ2THJnZGdBcTc3R0FzeGhVYTVvUGJNZlkwWnd2UU9ZSkZjUWF5OCtJRXhSOVoyMEUybkx2VU5ZUWtDdUE2U3hZc3J2Z1k3dnJoc0prUkJ1eHZKR2w4VFNCeHduZW5ENG1OeWR5SldLVWEvUW1ieUpIK0h3MmhqdG9oVmh6ZVArNXVLVXhQQ0hCR25sL2pwT0xUSk9FbEgyZVpOdDVYK0twTlZMQTk2cDRwVHZFb2ZZQW14cWJ0THZWTFRwbWJWWTFxcFBIN203R0JxWUpNd0pDRTl3V01JKy9mb2kvWEFXM1Zxdkc5OGVNNE00Qks1ZkVKQjdrVDFSTC8yRXFTNzFIL2VuejVjRUNycWo4ekluN1QvdHBuZmJId3pITjhDeW5CYnRHRjZGejZ1UGJGZC90Wjk5cC9abHhoU1VhcUxETXBSZXBpcXZsWUtpK1hDWmVFdDdKcEpCdExJeGFIYlJyZjNaL2RrL3lYNlg5cVFiaktXUm9sTWVwZTA5cWF5Tk1RZVBSUFloUitpYk9qVDFQdXRhRVI4S3lUMTdLTE1jVGY4UUpVaUlldm1FSkxuWWlkdHFNSVB1STFuRnJIckpSVytTT01LdjNwTjN3Z1pQOVFWT0dPUERpbFYzcXlWdXZRaVUxU3BNZDFraWhOL1dsSC9tZFJqZnRjWFg1TVlJZHRYeFZlbDdoQzdWeFBRSEtLL0pienlUR0RyenZ6R2U3ZHp0RlBoczhiekI4dWFTY0FpK1V0aGJKNlpudFNlakVsSmFvdWhZL09Yd0VqKzJCYXp6cUJ2MzVTT2MveEp2aWZycTNqRFgrNktzYlRTZHhJTEcwcnVWTHlUYVRYcFdRcGRlRW1zcFRHWXRaVEhGZkVvT3krMmRPWW1FYUNadjM0N3hOSGRhczR1S0tURjV6bWxUcXN6MmhWZGFpMlZsdWJGcmVPNG9RT0Z0TGRNVkZXZHFxMnRtcGlvcnFsZS9CTzFOY3d2cm81ZjNHMko2NDVQZ0tMdXVJVDRCWEh4M1JTUDc2SVBhMnFPWHUwSU5xanpzNE9DNVNuaUo0NTV0UktPMDVQWHlhYWUyRkU0NzNHeU9NQzVSWnFwMFdScHRjaWdVNnZMK21EUVNCY3d6aFdKdU9NaTRjaWZEOE9JTUdpcWRIRzROKzNlTFEvZEtLU1VoOWluR0tSbGFnVGRKTjIrcmlaS0twa1ZYM0ZzbE1UWGw2SHFhd2ZGVDA4dHJxQXpLaG0wTGpxOWcyYkEzYmN3K00wYWE2Q0JLSFZDWGNyUlUrekgxZUowRnhWM3cvUCtYZDZkMGk1SUhxYW8rZ0VUOUhkOU5oZzVFUGVKcmNwcVJyS24wS0x2aFlyZk5QcEdtU21RUS9pTExvNXZ5TEF5UzlmVStuMnRCN2Ywd0xjVDlwRUdOcFRNV3pld2RsMXBnV0lrbE1MNlBzejd2VjlXejduSEtITmVWSEJYWW1LTVpVMlNYNDNaWis2NUpiWjl2WGxucGtRV2tYd1JETy92OTVlbEpSbU1qWTRkaEhJUDJnS1BmNzJWb2hqUzVXZmFITjVSbmxWZEdwd3RVWnY4T1dPN29FRWNmdWVsYlQ4Rytma2ttQUxWN0x3VTZxSmVQTTNsd1RDa05kVnp5R2VmWGQ1THBPOWpCSVJDMjljdnhldnIwZkZlWjEzMTk4R1FxVG1TMTUvOC9mUU5pMU1rVGYzQzBVZk1PcHlLR0Z6OERMTkxQVG4xT0JJcjZmTGFudU5la1pmdDg4Y3krYi9UN2pqMXBpYld2bHF5NDZocG5hbWhSMXZaRy83d3VidnlOUGRHSmVVNk5TdzNYRkVlRnF3c3RSdTF4cnZFQk5TZHRkLzhVMklzUDdmZnR0N2FFZEJucFE3djUxTnZ2MHMybnVQekR4bnRlSEpHZjFFdk1lTS85anpZZWZEb3VSOFB3TGpGOFVza1Y2OHBMakJHcGhTVVAxeUZzUVQxWE5QcWFaL3diMWJYVEF2NWgyVHR6S3FxbDN6K09abHhRTVBLYlBZZWF4K1NockNNSWV5dmZaSUw4bTZQczB1M01TbW0zQWNaY016bDl5YnFTUDUya1BrMk4xQm5qcXdVblRQZTI4d1cwSDkxV1VTMVExbGEwcHhtbWh0dlNKVXFIZStOa3daRytoWWxrTVY2eDRQRHF2aXc1cHNDOFdNZlNuNDRmQjZMajdDbVRsMFdkSHZRV0kyQ1hVUFkvUTJwMWRhNHYvUE44ODkxQlRvd0grYnRuL2JvK1k5ek1URnVpVVpMV0dMUzRQd043WmcwMjVqTzVPdWV5dThta3E0ZEtOTTgwNWo5NldmOThnaU1QOE54NjBtZ21jaHY4ZjlFSXZwVUxQNWVMS0VQbDNUazcrZ1lsU3JhckZiRm1GVSt2eFg1RU5NRkZMS0c3QWFUS1pDYklUVjBuTmczemdaQURpM0NodlZDazVEdHRVUXoxNHhuWWpHK1M1bVlBYXBtRGtNVDF4NmlmdHE4WlRQVTZwekVxUUtVTndyTFdrR25sMHZXaGh1ZGxqRDhleVBsVk1ZUWFCMWYvdEJhVUNuMDM3RjdweHRocEFRM2ZmT0NRSHgwUHRBZGdXUlU4SDlraDBoNFhpemNKbEhwUHZLT05IMHVtYjFPbGtOdkNTUlRTWUVXUFRPL3R5eEx0dy9aQXQyWkZmNmVWMGFLTGJVa0tybldNbzhWRlNaYi9uVnlkUHpHbFJzeGhQVis4QU1CQVpLb1UxUk5JQzY1SjFrOUJGU0tIZ1UrT1NNelZUME9weEpYK0F3Zm5ScHNmNVlCanlwS1VkN0FYTmw5Vlp4aTJ1WnZoMlJEelUwY3kxb0NpcENWcHA2WG93eWFKaENYYzlUMmd2V3M0Vmt5UWNuVjc1azhEM3JmdlRDbm90M0tIam13S2c2by9xNXFDSHVFWFRLU0VtemsxVDVSODFxQVQ5VllJVTBYNTFjd1R1ZnRwZlh5TnBQTWhSaHZ6T2RmRWUxZS9BUzA2VkducUV1eENCQzhCcVlYSVB5T3VnN1FFT0krQXdOb1U5QVpTc0s4bmVMOWRBMnUvNzVCWnJablZXTWhPQXpNR0FjbTNPMFJsT1BKbXo0Nm5LYjE3MTVGSUw0NGxoaWRhdjBUZWIzK2VQYk1QcG56NnJNa1RqL0tZVmE4K01oWDBzenA2U3kzTmo5Y2lNUVBaOFVQdmVhSEpLdHhHL0xKWTg2WjNCV3BJZ2NwdHNpZFQ0QXBGVlRoTy9rVTFHaHE0cndIcktZaGhSVFJZRlkwT0dvYUY1MzBXRFJ5RXUvTmdJUUlNZUNaR0xERERLNnlGN01XWnEyWDhNMWNZdERjNzJLMmU1a0liQ05FdEhoazdqc3hUOTQyOStqZzY3bUhhdkpwcUIxeDVUR0lZeDJYMWo4QmpVNFpoenBqTlhuUjNBMWVtcHZFNFl0ajRORGNjMWovQkJReFpSekN4YTVseXR4Uk5wcFNqcGlWS3JmUHpacU5CbmhpdzVqWTBHMDJGeG1NVUcwSktWeXB5OTRCQ1gyMGJMQXptUWhzQ1VSZ3EwS0VXK2F3eGhGem1HVUJ6Z2ZLTEJ5RnJuNzR5ZkNpcmc5WHI1VUlQdmlDQmZ6ZzYrUnMvc1BNSDMzVFh6UC85UHQwMGZhL2xWb0xxMWl6UDh2aFQvSWV2czhPa0tieGR2ZExMdFg1Y0ZWZWZWRDBNT0FWcEtIZXdQZlg5dnd5N3djd3VMcWVTRkpVVFlxdzM1OFVYMkFFakwwR01CL3c5TmE1WFZzalAxc2J1TTNaQklCcDZjMnFXa2tDN1daT0lYU1hUekl1aEQwUGM1SXY0T1ZxNmtldDhFbk5SL1BLYU5yUWdKbzMyTFNrUzRwb3hMTXpuOSsyUE53SEVZMTUzRVBoWVlpaDA3TXY3L0syS1RqVTFMOEhpNXI2NDJDbFYveDJ3TjBMRk5Sc3N2Nm5LTDlJU2Jxa2lDYnpoY3IrejJ3ZzZaTHlhazh3a08rSGVMeitrRS9xOFk4OGtmc3lKbHZkbTduLzVIVGRsRnR5N2NNSGVoVHdVaDJqQkxLcFJ2c2RrRW53b1g0QVpHWjFia3NmcS8zS3ptUEkrVTdqZVZLeWFXY0RmSHN1WS9XWTdEaGlvcDRjTlZiM2NXdEtua1BJUVRsZ1U2aDZucThna3R6T0Y1U1ZkeG96V3IzOFdQcGNMZUhrdEFmc3hPdjZ1YmtjZS9IaUJkdUZrbTZwdUhwY1F0Mm0vUDZ6aW1zUkFvRHlhMmpiSVRvaUxEUllyNVg1SmxpVFZScUhCRSswVU4yc1RBMkFBaGVJckRPYWJhb0wwejd4OGJrQ0Q5eG05Zit6ZXZKaTJzd0tZYko3YjZjc3kvSGhJazlVVWVSMkZpbm51dWxUbXVobzFQbzlYMURKRFNNWGoxRkNRR3ZUbE1DL1czY3dqR0djSnZFL1h6RkticjhxUnRQSzdJZVcwc21WU2VDMGtFQnJFQmhsUFFYZ2pFSzBRQncvVGh2V2QxdlYvMC9ueWFmSklJbm11d2NHMGtQTU9hOUc1SVJIbzNrRzZRVlhFQnN3WW5MSWJsUmQ3RlNMS215MWI4R2szUXo1YXZ3YzkvVjBqTlBRWnhXTy81WVpNb2dDM05mbURDK0lzT2JqU1o2OG1CTGF3anllbzZZVzBmZ1FEM1NGUUlhalVmT2xEVEtJendBN0NqZDVrV2F5Y1VZaUhnemRUbVVDZ01UbkFMWVU4SGlkSTdkUmZVOE1iMjdvWW9iNjAzcCtVSlc1U0NhT1FEYkVoNTA2SnFmZDZwaWFiVDdQNW8rNDA5RHNqSUEyK3VkT0UwSERBbk9VdFBPWVN4cnV4MTM3cnNpYnZkbmNoQURZQ1prbW5rWExuRlZ1UGFoaWZnU1dKTGo5ZFJDaEEvVCtIOURzRFJwc1RycHBBVm9GemVNUUNzaWJZZDF6NUNEVkt1bWtvZUU4ZzZpTGZqT3pjWktoakVhWW1vL244c21MQ1lFWmVrWFk3MFFMMjdNK0JLTWIwdi9XT0kwTFlBQURwY21BcncyTzB6enFpVzFFWVhkbUEyWlRGQlc0ejl3cUhIWlJIeTdXSGFuVUI5aCtKeHNZY3d0L0huUVJkRHhHVFlwRVdjL2drZHVsemUrVENFbHN4RkhUUDNzd0lJWjZ6SzFGcldnSW1NR1VNS24wcUlQSjNyY3RwUU5xVStNVURZVDNDdWd0M0NEb2pubHhvRU1QMEJNaHoxUG9RaWQrZS80MjZEajFZendWRnhzRUh2SSsrQUt3bmh0TXFFZHplRnJrZVh0c0Q1dFYzdVI2dVZKam1zMHVKWTBOeFdERWM4elZPVGxRQi9uOWhyVTZUMkVBZlIwUDNVYjFodndHOWI0ZW4xbnlWM1RPdjdrNkRIMXo3N3UvRy9KbWp3aHZBTktyZjBOMVRqTlp5Vks0SU8xQ2lOM29yY2JTa2RoM1JFQ0lmc21nNFhRK3I1ZjFRa3U5R0pEdkw3clcyNy9SUVlFZVBxTXdYNlhCTmN0R05KWEc5NjFPMFFrT3JzSzUxYktLYlZBM05zdFN3N1UrcWZKN3FVZnFpTFJxblJFbTUrR0FSdjAxSnJzUnlISFp2SHVWRlRBR1pPZmwyUFVhL0ZWeXBFaGZMOG5TTVJHak4zWGpmejg5Yk11elZscEw0VGhudXcycEVDdWNEcFgyaWtCNW9UUnRWN202OFEvZDF2S0hZNVNkTXlpRUt4WjhaN1ZXcFRPaEdySFRZVHRaWFNiemRCNEZPQ2J4c2g2elhWbkdCcnV4aTJ5VWYyaVBnNXNEcGpCUnF0SFJPb0gzWktPMGkxbThranR0M3k1clVVWldmbTlWTU1KMExaR1I2WlBtMGpFR21rbW1GZEdnbzV5NnlJTVloem84UkVsRTloNTlMQi9ramcwbXQ4Vmd6ZWc2TWpkTjFyTUdxNFFUTmUyWDBGNjRIVWJONmhJUUtnOWdCUVo1RVlHMTNOVXFJRlVRVk5QMzdSaWRSRUVPT1ZXQ01vM3kwTkpBTnNKbUxHV1IzYlFJRFoza0FsckdoODhOajI2M2pLMlpKby9sdXE4YmVBenJGcVhENDgwREpjZzJKYW1JRmdCL2lGSjBwN1c3K3Blb2FKbEV2Y2VPcFZ4OThneWd3U3FhYXAxSXlKSk90MGlBTnAxMjB5NDhCclZkeS9MQ2tzSEt6cW9MUkE0bmQ3OXM2akUzT1BVdEhTUEN4YlZqUVVmU3d3ZDNocExmS3UwRnhNTVk0MU9pZ00zQzVURHVpY01wUnRUME5rQXFuK1FTYk91VmVtVmlJYUJheDYvanJyWHlkOXJqUUh1U05yU1k4TzNTVUdCeEZTcTN6MGRhSkxKd3ZiK2R3R3dneG5nRE05THgzY1l6YnNZQmJqZXdTVE9qK1VMOWtaTVFNNFRJZEJOczJRVlBkNHlwY0ptVXNuRkU1Snd1UzVjMUpaVlZWalFOKzdxcFZWQzNDTG5lTTlST0ExRXZSQmNGQ3JmYkkxcUUxRlZSS3NPa1BnZnNraDB6cjBvYXdXdUErQ0FBMEFMYXdQNnVFVHl1a3YzOG5yWmszaXplNm5INiswajZJVEoyTUVHSWJDS3NHVDhoR1FtWXlwMkZzekRBNTNqd2MyWGRJS2FWdnhnT21CUkl6eXNUSS9FcHdQN1NlT054cGpPbG1WYWN0TEJUNUxXb3NaOGplY1NJeEFEbTh4Q1lOaGhFOENscTB3WUFIbTJ6dFpHYWFvdGRtUk1xazJiVzFadFZRZGtTWDlmMnhydVA5NFZ0VjhRZEtwbnpYZFJpMzE1QnJmVU9NbTVFTDArckhjTlZDT3BmMHR6VHlFcFhWbDVXd2dIbEdMbEJHci9OQU8yQ0pZRUZMV2hwU1NLTWhoODZsbkNkU21vcXkyMEY0MVJIUDkyeDNza1FNS3hNYVpIQkFQb2kwS2hyZnhhMEVTZVVWTENCU0JDYlBnMWxLOUVhY1pnVGFRNFdhcDUveFdJSnhpSXRSOVZwV1FvaFZFN2c0MHR1UkoxMlo5Mm13MjZSMnpkaU1Sa2p4YW5JK21wTHdDZEJ6UldEWjVGREI5Tyt5NWhoVXczcmdIMUM1YUkrYXE4bDBQZ09VMWgvSTE5U3I1NTBZKzJpVkllZnppNG9HSklTWGNLcFBqSHdtdXNEWWlNOW1hNnZTeXkydjFVb2Y3dlNFTUhVUzBlRE1nWFdVTWU2dFZRT1IrZ1ZqK3EvdzFORXZDZ2dJS2VOR2tSN2ppc2MvYnFBc1YxSEVBSjlkdTd0eXRkZkhpNkUwUWNjVzZpNXlDLys4OFdJcFo0SFNYMHBodXNkNzFmNmZpMUJnalZYNkpFMGpqVmJiVFlTd3dNdmtSV2NMSTVtR1pmSVBQWWMyZ3lEUXhrcnc2QmQxb3lZVTNsVEhoelBRM0UwNU1pRysrZ2NLdXE4b2NwSjJSMkpWdVhDMEoxRzYySlRBVFNvazNZb3JjV1kwZ2J0WlVTV2syWjdhaWRJTFlaTEV3eTRmMEk3SmVHMG12SEpiVWFXK1FpMjdkUzh6QURkMEs5MTVQMzVpN1JGU04vOE1MU0VPNkcyQTdVbHNCQzlzUHFSY3FPdklrRzdXcTBOSjJVdDRKeUQxMHdQZWtTbi9YMWdrL3ZYaGFWMGlPbjBtazIxQ2VOTUN5WThwdE9QTDd6RzR0RnUrQmdmdGluYTFzMUxvVjZrZWtHMVA4SEl4WGhVS0xiV3JnU2lSU3NsNytUN2lhVnRRbmxKS2hQMEpveUVqUFBvUkFTSk1ZU0N6RlF3cWFYWStWeVVCUWw1K1lYWDJsK1VQT0VjYlFCNThNd2hJVHpsak9rMWlJTXpCQTU1MzlrVXhJZUFMU2lUa0dvaWtOb21Jc3cvZ2diVFRHaDhzQzFCdVphaFdHTVZuaGtNeDJ5bXVYOU9wSTh1bm9DRVBJNm9tQzU4REE0cGpXem14SHVubEhjcE1OQ2VJNmJ2QUJwbTZsV0t3ajY4SzZVZ1Rvd21NTWo2a0pDYXppK05MTE55eTJkWTBHR2l2bzl6Q0dpSzR6VFVlOEJQaHBQeGFBWkZzQms2Q0h6d2NYdVFrZ25tYlhmTE5BMVErQkxSUEE4S3B2MHlxcStJektZN2xpb2M1MCt5RG10dEVvTS9NMUp4cjBLQmhtUWVFUFNHQ3hzd0k5T1Q1eFZVTmlYTHUvQU84NjBHV2g2TnJ3OFJCY1ZaaWxZR0xjUFFURXVEUlJFb1JaVGtrd1BMVXk4ZEMrV0tSaFJoTXhkVXpNWlppOGtzb3NZYzVVWkhoeTZqNURhT25WZkVsMW0vTG1qOGZvVnNQS0JMMWdERW9iNTlURk1URlF0TFJkOXBwTTI2VTRYMnZocy92SnBqREpnLzZ2dnBzRm0xR2xlNGpFUElNRDRmdTNYaEVmNkcwN09UdXVmODhoWXlSV2pFeWV0YlJTdzhySGpTbXBsSThKQkZLNjU1N3FOUnIwRnZ0aGZ4dk9oTlUrNXRoaFhidTVwWDAzclZ0WHllYVd0Y2FJWTNJUVVOR2h0ZmlYT1doTkprZHcvNTlSV1BsZGx0cDRsN3BPMlVRNXh4UlFZVndFb1JCZktISnZZbTc3Q3o2b3VuWHJDQ0V0SXNrYXBQZ1BtRGttQURZQVlYRTJhNFpWOTBGa1ZxaVhROGJqbUw5ZFlGb0dER0M3a3g1N2ZteENpVHA0Yzd3ZnMyTm9sa05Hd2tVUnVNU0VVektXTkx3Q2l5VHdpWVI2UlhVam9RSktzT3EzenhlTENXWURYRE1GRHN4dTZZc0d2NjdwUVRkbFo5RWF5NmpIY3J3UXlWZlZ1UnJYenFxeVdRS1cvOUFBblB6NVBZTmFaQmFSTmU3NEY4YjBLOGU2RGFycVo5dWZ0eW9aM1QxaUlHNnkrT01SRkhHaUJCOG54SjVaaWo5UDluOStUbFowcUd1dUNCV2pwb3JVOW1XRVVMR2Y0LzlkRUh3aElUbFpyQThrWDZ5M2lkUmNHYm5Wc0xpbndveXQyRGUzeTAyNVI1SEhMNVRmODI5M3RSL2JYcE8rRVJLdUZoUXFSYUhNYTdsNjN6dWhmNGZicDh6d3JTTkhGR2VITk4vZDVvRjJYZnBQS0tCWmVKZkcxaE5ncHV3SVFpTGJwWHp0NDVFL2k5VENNQjdGVEVHTnlQM0FHU0FHVG9FS3VpUjdqUk0rWVhyWmNJeE1MM3NqbzVyZGVBazQrbkQvZnIrcmcrN0xhd0F6dU5Wa3lLbVIvK3dJclNNbjVCSk1XdUVxU0NoaDJLeEdwU3lUZzlhcXpLb3JrV2RwdDB6VUQ4b3RBRGNBZ0hXcXEzL2xyaVlVMnZ3ZzFVd2lSeUVaOExSMUh3U01Ld0tJQ2Z3eUpmdEFMYmZDOGhpd1JUVHE1YURvZkF4b1dKMXU4cFRUUFozdUsxRmhFZ2RZQ3pXOVRua1dlSHZ0YmNBT3UyZFhqTUo4QWlmR1pHbDZiWFJ3Z0kvZDlSa0NYSFFMSWIzcE1yeC9hVmhndTFSYWxKRjJwNkZSNmgxRC84dmFZNWpVVlN6b09Ya1FhTVhFNW4wV2hSWlZhajJtREVJOHF3Z3lvZXo5WTdFYXFWUDlKSFFtcjU4Qk9nOWNOVkxBcnNBVjJVOHcvSzhOb0tWK251bWdMNjVFNUthckdCQ0ovbDZtK1JpbUt5ZU5WR00rRkVDMHlraGtkZVFVVWg1M3JyZ01ldTZkSkZ5NnVMYVJOeDIvcFFLMHp1OU5CaExza1FyVTE5eXVBZ1ByQ2w2aExHTUdhTjhOYlNmS1EyaWIvNmlSZ1ZjMm1oSDU0eTVQNFBKbUFyQmxJc1dxeWltQ1V6SjdSQzh2eVdmb1hBY3RTVStUSm8rWDEwTCtlN0tCT3oyYWVsQml3dis2MWU2V1hYd2lac3lrWks0UjYxUElPdENJb3FtM0dnSzNHQ0FIYTE4Zk5Gd2FVOGFUQnZ0TG9oblIyVm5yeGFwS01IbDhmcFloMU92dDBVdk9icFNybktsVVZtNCt3Q1B6enZ1bFdTeEpubUNaQnNKZjAyQVkvQjJUKzFkYm8xOXprcE11WWJuTVVXREgwbU05c3NFSGgrSGR0YTBGVmRjb0xQN0xQSVZaTnNMU2NLMG9tK2ltWGIxdFVwUUNFaWphVzBZOU1FT1FpT2JkdlRwOFRqZG9iVFVxdFRVM1A2TjZCT0cxUittWlExbFo1NTNtZlBuYXJJZ2JnZ2tzRXNnK25nVkdsUnFhVGdoS3BGWVZUQ1hiZGZmUmNrYnNjNkVTM2JkT3EwSW5wRkFxTGNkY3IwdEJtZWZxcXJreExnNVgvWGtHa1FsZ1VFZTM3SXNZRDJseXdybDNwT2d5eXJ6OGFzTlZpcTB0UjFZYjY0SksxUHoxWlhkSDA4MnV5eDdmWm4rRVJTTnBwbGhGK2NDQXViWlpUM2VNTDVEUkozank1dlR0cXJic3FxbWpaakt3bHROOFBwTjlkSVpzT3hDOFFEQXRYSSsxMENCVHpFNVJteHdtTFRMU0k0S3U4L0pkaVdiTWsxZGszcllNZGhib1NoQmJKYzQzdW9UNUJJb2ZSOFMyY0NhdDFweWRUOFNuQkJTZjUzTStJbTZkUFp3dU91b0NvWi9IT05wbUpEdk44VlkvK2tTcjVJZHVoR2dEME5WQkRQaGxOVktMU29JbFU5VW8yd3RKREFlQVh0TkpETVVTUWdxYy9kSmdRVzNCYXdlc0xURUJObi9xbmIzMW04c0VJOU9FTlJ1WU9sTi9aUUVLdFUrYUFOcCsyYmVHSkVHN2p1bk5wcTU3QnlMcXRLbS9TSmN4Zm0rcTZCbzFkL1FGQkhFN2w5SXI1bXBBVUZVY2d2Um1XR1VXb0gwQzJTd1A1eWRIMEJsM3p1K2QydFJRcndqdGFuWjhEcHAvUEh4KzJ3VzNSYWxua1VVSnpDUVVMTzlKSFFyY1N2cWhmbUNJOUFCQU5DZUFlRU1PbGMyRjZNM2FLTlZTTFoxSFRoNkxwcVB4VUMyYXRhTUNGU24wZVRDbm5YdkNqMEFQU2dheTFvYXUxekNBUkFwdi9HLzBtUmQrMy9vRklCWnlQQVczY3VCZ0I4TUMzNzFnOE1HQllOK1lEeFlBQUI2SzhibmdMRGl4azRmQVVnL2EvKzEvT0hBb0NzQVRJVkFIOVJaajlLeGZRZmVVTlNqYnhMZytjT1RrUjRFY0ZtVWxpRkMzRU9JY1BNbnVGRkM5UVVJSWtGTFJkSmNwbWtJTURUdnR4VE55N0dKOHU0WDdFWUJRajVUVWh4TVFnREkzSUNhVGhybitxSFZzUUJ4U01wOTVqNmpxblhFSFhvamZTZVZxVGlJdTVTVHlGRzlJU1E1WE5Vd3crWSs0emtIa2wySVJXUHNsaXdkUVd0NHREeUV6aC8waVZDU0xROW13aVNDbVh1RkRNcjVPWC9sQm1IZWJ4TW9XWlczL0RNWjVSKzR4c3c5eWlQS1lOcFg2UlVpYnh3SVhzMTRSaTREU2NaK1BCQVpCbnYveW9mblAvQjVpVlpqaXdEdTlCaWtZM1RTU3FZSkRUNlBDVE5mV3F6R203S3puYTAxUEp6SEMzNzhFTlN2V1MvN2wvQ2RIemU4WlBCVCsvTHBPSDM2L1RINVI2aXlxb2pXd2lhL1NGTURrV2cvbEp2WTBGRVdLcVc0b09KdWNhZGNLemZldFJMNmV0M2F4L2tMUjVVQk9JLzlRSXFwL3Bpc3d4ZjJsOVJhbzR6YWJhTHlGcVNvWkdzL3NYalFjRVFEWkR2LzAveFFmakQxNFZQeUswWTVycWUwTFAvOHgxdnhRL1o0YzJyVTcxSHF5ZWtWUjkrOFRXdVRSNWVhZkU0anRjZmo4cFlVSS9mblZwQ1VtbGsrL1NKQ0VBdkNqc2ZCSGpkMmdjVkJRRVQwdW9EWEU4SkJBU1lHekpJT2Rnb0xRTkJwZzhVckpqQWdDTXBNRUxtREl6aHBybCs3TGJBQkNTTGNMS25MekFkenBhWlowRGJEUVVhNFFGdzFYNElRRHhERDhESVVRUlFOQWxUa2J5blBvREd6WnA2akFyZ3NiTVhTWjZMQVNwcXBtOURROGhYZDJrekQ5VmZNb0xmaTk5T2JpaDVuMWpGdElvM2lBODkydjFtcHZMeWhvcmkxb2IzdkpTZVJqdFByVkNwZE1ZYkpFU01KbGRnaFl4MGYxcmExL0UzL1BaODRkb0MyK3ZLZmtIbGp5RXdhOUNvUzdNcUZTcTE0anVFVDBORkxRaGZpUzU4c2NhZVVuekovVlFsbk1yVXFxWEFaNXJYODkzMWxveGFkbUNaMnM0TzdLUmdVcTVjZ3dyRldtRXVmTkZxRlN0VkkxMlpDbTNaMy9kbWFnb3FLanBHbVpKa1MyVjBiUk5ZKzNZOWk4RHJhMUdsUVQwK2NtMGU2UjBEUlFHVi9MekNPbVdGbEZjdFdQL2w5bElha2RkdjJobTZlK2NoaDROSFFFVGlob3lDaW9hT2dZbkZuY2RkOEQ0MlhyejU0Qk1RRWhHVGtQTGx4NTlNQUxsQUNrcSsvcU9ob2FVVFJDK1lRWWhRUm1IQ1JZZ1V4U1JhakZnV2NlSWxTSlFrV1lwVWFheHMwbVd3eTVRbFc0NWNlUnp5RlNoVVpKNWlleXl6bkV1Zk5aYWFOT0tZdTI0YlZhTFVBS2Y3eXR4eHoyTVBQUFRJMThvOTg4U1U0eXI4Wk5CTHo3MVE2VnZmVzYxYWxScDFhdFViMXFCSm8yWXQyclJxMStFdnY5R3BXNWY1ZWl4dzFtNkxMTFRZRXQvNXdYbXZJaXFNT1JGTlEwdkhnQ0VqeGhoM01oNm5uWEhLaEpXT0pHR0tIMTExTFJQbUVDZ01uNENRaUJqVEhFOTJOclFpdGM2R1ZteGJmWlZLb3czR1Z6UVh0NWVWTnRTVjRJdEwyMXJudEYzUlVnZSt0YXJNc1JiV2FVK3dZT0pwTDRLdGpVR2VTOHpHVnludU5sTmlUMC9DbFJkVkt1NU9FenlicXQydDRhYTFJY3lQWUdZVXZZY1N2L0VqTmRxeVNEekUvY3EvVGxsWGNWM1JyU01mY3VlY2xySzZxbjNEeEg5YXFpaXViY1VWbFN0MjgyQTJqV2tXK0gwVU11VlB5UXVOTi9pZTRYdzdGTWlnZis0YjBxaTA5bXFiQnY2ZmVqVTBlSUxRZzRsVmlNa2I4dDB3c1A3eGhtQXZsT3Y5Q3o0Tmo3bjJwN2RodDZwNmYvTzBJWjI4NFA5eTZ0OHNnZnk1Mlo4QU1WMEFBQT09KVxcclxcbiAgICBmb3JtYXQoJ3dvZmYyJyk7XFxyXFxuICBmb250LXdlaWdodDogOTAwO1xcclxcbiAgZm9udC1zdHlsZTogbm9ybWFsO1xcclxcbn1cXHJcXG5cXHJcXG5AZm9udC1mYWNlIHtcXHJcXG4gIGZvbnQtZmFtaWx5OiAnQWZmb2dhdG8nO1xcclxcbiAgc3JjOiB1cmwoZGF0YTphcHBsaWNhdGlvbi9mb250LXdvZmYyO2NoYXJzZXQ9dXRmLTg7YmFzZTY0LGQwOUdNZ0FCQUFBQUFEak1BQkVBQUFBQWZPZ0FBRGhyQUFFQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFHaTRibkhnY2czWUdZQUNCUkFnOENab1dFUWdLZ2FGOGdZeDVDNE1nQUFFMkFpUURoandFSUFXR0RBZUZPUXlCRFJ1YWJ6VnNYTTA4YkJ5QU1kTS95NklJTmc0U0dDWTdFcUhiUVJWQytRSFovMy9DY1RLR1FMSk4xY28vN1Fna0RBZUNYS1pFOWpFN0FyT1F2QWI2S0d5alY2eGJSVDRQTnI5Wk1CZWJmT0VnZStwZm04Ri9OaStSaFUrNHNKVy9hSHprM0FoMVU0WTRScEJwMTBzQnc5RWtXM1NMWlZtaXlBMm51d2VGM0w1Y3Z2NUYwTTk2MHJiMWRDS1J4a3NWeHpnY3F5b1hza3hEL0RzNnZvMjRZUndPVEpGeUlwVmhaV1RyTTdCdDVFOXk4aDdSdHYrWnViMWFqcmdqUkN4RXJBSzdNWGtSa2I5S2YyYmovLy9TOU43NzN2dEZvOVhzdUVpcmRhc3N0U0RYMlYyWGlwVFpGRmxHNmREdTBJeWs5TU9OZ2tKWVdBQUwwY2QrLzlsejdsdHkrOTB5SlNvU1NRRlQrYkNRa1NnVWdmR0k1WWxuZ09iVzRZN0o2RnJseGFLSjNaS3hOWGUzQVpJNTBrQ01DQlJzTE1UR2FQeTA0cXZVVC94dVA3VDFzNklFVC9PR3dWY1ErNkk1QTk4N0xJTW1aMFZOVWFlclhoWnZjS3hrZ0Q3b3RQY0pjQU1NRWtWVUc0d290c0g5V3RIL1NiK2YwdSsycEU5enNrMytxV3VHclU3WmxxVC9BY0FEN3RkV1h3cStKdkQvNFdLMlpwS3FBRFhlczQ4VmtlSUsxM0ZwVzNGdldURUpnTCtmVzJ4b2k2VEVkWTRRYVpBOHNZU0ovNm1pYitPYlpyYmREeUVCSmxqZUQ1Nm1ZblJGUlVXK3FCNDBXTnRHZ2hZSTFYWThVYzE0ZVA3dzk4NWZhemNwc0dzV3NNZEJ5TyszZTdadkFqN0VVb1Bta2VWR2ljQU9XTjBMaDNZMWFUUHRtUSs2WE5UbHZ5c0lwMnFsNU9kdFdsNzR2eG1OTGRzQk8raGNoVHJDb21FbzJsUnByL3I2LzQvMFovNEl4N3NyUzhhUmw2UUZHVStHZFR5UzlpSXYybnZBNUx1UUxDL2FSK3piQUVGM3dGVXVGUkIwS2JxMEpWR1pvcTBDLzkvdmZXZHpaODJscXAxMFJ5dnFDVWZYYWVQQnVGL3VUOXM1VkhYbnVhQjYwU2xOT0NUT1pKRElDSWt4S0h6YnUrLzNKTWpTYTFCelNsUG1mL1dKNzhhYlBOTTF2STR0SHhFSlFVU0NpT1NXOVBBMzY0OFdWc1NSSUVtQXhDZEdhZmYzNmJCdHREcFc5M014VmtWSFFBQWEvL0VtSXNHTjBGMGVoaDd4S1BLWXg2REhQWWNnQU02dkFKMTd2aE1ITEEvYzJ0Y0pXREFBWUNGL0plKy9zNmNUVUFBUUFFU2thVWNBQkZvYThoK1Vnd0V3RERUY1JNdXR0ZGxPKzUxMDNxM2U5THQvNDRvM0djbUFESXlJczlJWm5GeWl1RVh6aU9YVHE4Kzk3b01ZSnhKVFBwOEVJZ2NiSjg2Rjg3RHh5WVh1cXdHSmoxWFZwdnNzYlhmMzRHeVFJNjRKUzlrNXU0OUlsWTZtNFgyeEZxVlhXdStrOVVHN044YnZROGdENExMQXlWOG1JUmJSeStPMnBCTW5ralNpU1lCY0xTTUZUa2dBNThnSmlBUG4rNjdLSU15MWlha1NFKzJhUGVJanpTZmdJUEp4ZmkyUjBYNkthT0p4dkx1cS9ZTElGNkV6a2ptNE5OUmliR2dxOU15QmVJSlE3T1dJbUlpU2NNbXNRcm94czRxY2tDcEtKTm9DcXpMeGtPS0JGdEhtQllCZlZva1BJZkoxQVBCcDFQMjBEeEo3d1RaV2dLTnlBWklBNkd4UnRmcCswODZoOEVHWnlmaGxRRXk2WXAzNlFmNnVRcHI0OXpoSG85MU82UG5GeTh6RmYweU9pd1FkUVBJZDZabnVRdkh0dVRGWStLR1IzMzdGajllMnhLSy8yK1IvbExrMFg5bkFxYXRqOFViK1FLTmI5Z01JY0lobXh1VjBVTWVOTWlXV0lONkp0RDZTSzU2ZVZQTWF2M0d2Wk05K2grS0lsZ08xS2ZIZkFnVEVTeElyVWJCRVU0enNlSEc3Qit0WGYrTjljUFlkKzJxeHJiOUxWSFoyQUg0NVVKNGdUYUZLTmsyYVJKdHFObys1Vmt1MDFoWjVibkNERWlTUlZVbHlhSElwVXBFMG9YU0pNcG9rVXhhVUxVMU8weVJQUGhRUUNVcFFLS1pJcEZpaUVtbEtwU2lUcEZ5eUNpa3FwV29TbXQxRWN5MkJsb29zYTZMbFZpTnJtMlNkalRTYnBOZ3N3UmJ6SnBMZ01sdW9NcFdFT0pxY3JETFRaV2JJeGk3a2x5RkZLS08wOGlFcVVBQUpoTEFnSXNDcXFKcGtWZC9VTldxbWE1VXUxTFRyMHMydVI3cCswdldYM1FEcEJrb3lTSGJEYk85VE5jeEJhUjAwTnYxTXROV3VqT1llQitnT09ySjhsSnU2NDA3VG5lMDB6WE11c2J2aWFrK1ppbTRrNlhyRjljbmtYaW51aytvQm1UMW94eUVXS2RtZlBVbnlGUDVFUjFPRUFYcDZ5V1lTRFN6OXZ4SXRubE5DWHh6OG1BM3MyenpleFpUWHlLU2dHOURtd3dVaEFPZFdtUDUzUHlZaHJmS3VjUzVZeWhrd0pMQUhQK2RrbU1CVy9yai85NlkwdnhOT2lTVDNEbXJiblhUZVU0MGVZTWZyVjNPVFRXamRYZGhvK2NNUVRiMUdBTTNhQ0RvTUpCdHNLSDJJNWJEM1E0OWpUb3NmM09wM09TalpqVXJ4dUZJOWVXa2FFcTErQ3RjZ1FhTmt6UkswQ3JXSmRFaldhV1h1RW8yRUNhZ3doRzlGZ3cwaEdRckw5Y0NUMElGcHBoQXNWSVdBQUNYUk5iWmpoK0VnVmNac3Rnc25Ec3UrSUl1a2lMTGFGNm5TY1dQOWtNdVJqOXNvM054MmJEVWNER3pvR05XbEpsaHhKazNNelFjeXFXR25CVlczRHVCTTdwRWVCT0dHTEJ1UjNacWdGbE95MjVyTlRkbmNpT0hKYUxmZ0JFRzRJUWl5VzBOemE2cHUxNEs0NjNhcWFqSW96SWlZMEl5RWpCdDVpQlNBcDdnbFlkUC9CWUFBM3p2VnVSWG1lM3U3K1FYNk9ybmV3djI3b3pXRytMTDRGRmV0emNabWorNnBOb3FTM28ySWlUWmpOay92UDhaM2xGOU8zNU44amVkSjVLZnI5RW5TVTl6TjQxckVWeEpNRDZxV2tKYW9Zd210eWtQWVB3QldSVld3cWpVaUVzSUxodVFjUmswSFNnZ0dRUkFFV1JoV0pFUk1sZ2JVOG1naVd4N0txeFh0MmlFS01qSUtNandydlhHMGNxQ0VRUkNFaEl5TWdveU1qSUlDV1I0eU9BcDhWVjQ1NzdIWisyVElPamlOZE5aMUZnYmtuWVBoRENnN3g5OU1ObHlDbFQzdXZHSXpPZmdLditQKzJOVzAvNW4wQUsrUDBsSGhLRHNxL2s0aVAzQnZVdzJROVVDb3JoMElQRkJDRlEyMFhkME5BRW1JQUF5RVdvR3lCQy9zMnFtKzVwaVdiQXZmZHB4ZTJrR1d1ZEVadFNleTFRTlBmbzljZVNzVnBLVnZVQWpidGxPSkEzLzRMRVZHUTh5emlBK1JhSjVCTkU4anBuaDZybXBFYWczdU5jdFBtcGFjSlo5QTJnMVp0UDFQMEw3VEkwZ29INTdhYVRza1l1Sk8yS0pmYVJIZm1uQmt3VFV4bVh6WHYrOHF5ZFZKeUV2NWxRam8xTEVCcUx0SzRpa0NtWHBab3Y1UU1uamZEYmdrNEFacWVQY1pRbUZkZ2t1aGwvZUFmUUFBM3hzVWdCY0gwTzkyNENCQXFtSnUvbWxONDhVb1JsbnBuQXV1dU5ITjdoSUprNmJmSHFjMzJodm45WGxUdkpYZTY0VVJ3UUJlWTV6SmdnZGVYM2lQM2V2Mnh2N2txdDlENm1vdE45OWNpV1lhRlBpQ3MwNDc3b2gxbkYrOU5rUjBmaDlvbTdaQkFWMmVxeUNpV2ZyVlA0V0ZHWnJKUXIzaGw2Z2xSMlNCR0JCR0JyejRCNWI0QzBwdm53SUw3amgvajJ2a1R3TEowbjhsREZBdGRPNUVpQ0dFZWgzMmdHRDBEUW1ZNSt1R0NyQUVmLytRcFU5OVd0UTVXb3dvWlVHb21zMCtCMUZ4K1JGOHYzTVJhVzZRTHVaY3ZCdEtabk5hTW8zVUFLZWtyYjdOUXIrbllJMzhReHFScnNXTm5zZDEvVnM2UTJlZkJ0SE1ISW1iS2RFZFZtWU5WV0FFYXBhV1lJOWRvS2lla25vbllzUzhvUVlWRlN5TFdIbzhrR29OVjV5OHUrczZnVi9ORkc1eUVDRnllTURIVFMvYmJrVXRUVVBzWEpwWlVCTUQ1ZHRBZERjdGxUUldmWHZnZ0ZVUDRoTHE4d0UxS1FnN0s1SEt0ZFlxMTRQaXJlRUFvTE9Id2NVL0ZrcDB0bGdUcmRxTXc4MmFodWdINDhDUnZ5MThSeU83SEF4OWdGcmlHbHNWbVVXTWNsS0JKYS9DaU9IbmZIcnZLRG1FRGJla01leC9TWXkySWZvekFMTG15Q1NUS2R5YlJ1MHNpRk94MjZMU3hpaEtLK040UVhOREM0NERVWlBQMjdyN2hIcWorUk9FWVl4UEpHMkFsQjFwK0tlRktpY1ZPUnN4SW4vT3JVT2toU2hldkF1RjFVTzdlcjZ5MFIrY2JWcW00Y1hiMDVBVEo3dGJkbEJndGZmYzJ2UWdGcDVXdDhra3lIelJ6c0NjUnR3cHFOcGRMNHdMa3ExamVTdHcxdDVFcjNqZURWZUh5RjNSaTFTanhnbk5jRWN5aUNrWDRVMVlBRndkRWttbzZrbU01NThHTGpaS0l1ZGRvRlU5UmpTcEoxZVMzQ01TaTkvNmNoTXp2UG84dWhpOWx0OVhkMWVzb1ljQ2U5WFFSeUhQaUVzS0NpUVZoWktHSXFtSFlxbVBFbW1BVW1tSUp0S29ZUUhsZVZGSytZdDNRZEdTZkJzSGZzOWZWcFM2SEgrN2JrdFRIUC9YNlNrMldQZTVRUWJ4a0lQQURBUUtFQkFnVUlKQUJRSTFDRFFnTUFlSmQ4Q0JpcUpWbTBnOXh3Qy9HSWpSd3B4WmVwcTJCbGZPMWMxc3ZBRXd5UzVCUzlPT09zUGNhM1UzYzdSVlQ4YkdIVGUzMG92YlViaHJreE03cnVSV0ZkOERqOGFxSFNSSEk4TVFJenJtckdYand2VUxBT0RWSTkwcCsraFA3Qm81QVE0d29UWkNxTGVQbzRhbmFDOGNORHhyRmlSRzNXZlR6MUdVc0x1RzFrUUpTU1l4NjFuZU90R1FTQWh6NTFUVDFmZEZrV3pQM3ViV0Z5QmNwQWd4SzJtVHdsUlpyWEtPQWdmNTRuaDNMbXZRRG1OUlU0OFVCVDhIakhRNURUL3BhVHQzVFNKdHgrWkJORGtrc2tBTTZyaFlJYU10NmhISVdNZ1lSV0ZjS2xXbVpjR3BUVGlxakZjWjBTTkpZZGVsSlIybkhhY2Nja3d5cGdTT05pSTNGQzY1OWlRQ3FPMVpxakkyaUpLbDJRaWp3R21Sd2VRQU10eWUvaXNlYUloTTZhVXNvZ2M3KzZYWEpvZDFmQXlDa1VqT2YxTk9KNkp5TngzNmh4WUhLbTdqUFQwQjJHTi9TTExGb0dlQm5Ra3VxMHFyVXRKVnIvMjMxNVR6Nm9VZS9YL0c2WHBFRzd6RG9MY2N4TlhhYlF5ZG0xbkFnYlZsSGIwcXNkdjd3ODVjdDNqWkxXZmtTL3lzNW9WalMzMWU4OUp6ZmlPNmRReHpTYk5XMU5oeUxVYXZtSERwcFp5WThuSTl4Zkh3N1F5WThtcGRoaDByamxOd25mNVJUSFNXeklEQTB3VVBkTWVKZGt3Ukd4OTZyUUVsRlErMDF4ZjROa1cwVUdmaG5UQzhZVGlOTzl5REhmTXpNZWZKYmMrOE9ldXR1Z0JuSVo2cTVyZHJucmZvWVhWd2pSUXR4am1wNEZMNFJhMitJWWJHVnUvVXZTNGdaQ0FpaWFMbEJERXBLRjRGSEVoSW9tUTVRVXBLNnpSK0FnUTFaR1JSdG9JZ0p3ZmxYdzRJQlZsVXJDQW95ZEhMNU1Da0NwaFVCWk5xWUhxOUhzSlNnMnhSczV5Z0pVVzB4d1NTT3lDNUM1SjdJTGtQa2djZ2VRaVNSNkQ1WXhSRWVHTHlLVVRmNkppQ1g1OHhuRzRnd09lN1B0YWpoVUo1cVJDdHBxRUR3dHBSMkRncXRobTlncDE2aGZZSzBVR2hkbnlXRGs2T3dka3h1RGdHVnpWRE40WG9ybEI3b1BUd2RCeGVqc1BiY2Zpb0dmb3FSRCtGWGY1NDhheGNrU3BYMGRWOUorM0FaeGVDMyt2ZWFBRmhzUllBd0FzQUFGOEU4QWpRVGdPMkR3RjdBZEFUSU9FVDNNMGpUOFZFSUNKWUxJcmVkUUdWaTRtVW9CdEJQQm16a0VKN0RvRUd2QXVVWmJSWGtYM1dDVmdEK2ZWTUtHY1FWbzY1SzJUY3pPS0xNREJGbUpJNUt1aFJqbEZPVmQyZWhsNXBFdU9TeHBpSmFiRmFZbDlpbW0vbEdqR0x4WWlNcmpIRGtqeTVsUmhZVW15M3RGK1NsaVFsbXJYcjFnaTZybnBOazhhVFRHWXpKVE0zYkF0M09OVElHam9HWmszbENsTWtGbWZieC9HZTVSbEVOYWJMTktkenh6TEdic3UyNUh4ZzFoTDFGQzAxTnBudk5xQTBwWFJzMGpRdGthckZwbWRrTW96OHJTVVhGS2JHNWtndHhtTHQxSUhGeXBqa3BrOW5OMDJhMXd4ZzRqSEJhbk4vSUlqQzBZVDluN1gremxPQ2phalo2djNmWHdVWVR6MXRQSmxCcEVaUmhNMXJXYzBvS25CbFBXVmlaSlQ3Q3FFSzRnZ2o2Zy9EendGY1l3WG1jVmJJeUYyVnB4bkoydXNoZURXWThmNHByVWwxdmg1OUtxdldycUJMOGZPNk1CWnRhdW5EdGIwM2k1Nlg0U3JHajBYUDd4ZHNabzM3dlVOenRyMnpzZ2tCNDNGWk4rYk5LejY0QUx1RnNYbU50K1JrbHNnSHRybXhtQ1ROZnU2c1lQVUJScVB3UVdJTzFvWllEaXdoSUg4UVJiU2NtaHhPUE50SU4zVXMyekJHVk1iSEVnckFZbzBuOXlySmFPNER3WUlyMEdkVmdrQko3U1dHL2x0K1UyYSthWExTbitHZk1YTWZLY3pOeUtqRDQza2tjOGZ5MDlCSmdpb0VKdjhvUzJBcEl0RkFpSGpSL3pOa2JBaklUMWNTQmtCeGpKZVR0RTlEZUJ3LzVTaFJQVFl5bmlOZjBZRVcxYytYaURST1Y1OW5rT1llYTYxZnVMK1ozcURXK0hUNEZCdWNnNzgvVWE2dDBPakI5dkFqNTdSRnk2ZFdkbnk2Skw5ck5yMlE5UVhuaTduNGtuN0pvdE12TjlPMUI5elRVcWIvRVc5cjVkdllDRFJZR2I1RDBUSmZxdXNqQS8wV0tNS0xmM1dsdmNtN0lzamxIWUtCRkZpM2E4b0hQdUd2b2JBZUZ4VGhtNTlXdlRRMk5JYnhTc2pZTFoxb2txajdjVDZ1S3pVN1Q4NjNCdTIwMnVRQzZCZlc2MUFHSWNZSCtUNlRCQzJhQzk2djVaSHUxK1dvMnBiTGxzeDF6bzU4eExNR013ZUNsU0c4Y3pTMm5ocEZubElFOXhXaVM3UUg2NG9WcUJyT0ZvOThhb05YZUJFc21hVkdEajZFQnZsbXloWGRMSEdNSlFpSTN5S2U3VWVZZURZVTI2dnNkYkcrOXRrTDQzZWE5UkZDOVcwNTBwZklDcXl2TTdXTHplanZKa3ZiTWpiSElEUmQxSW5YVGVnK2hTTVpiNmFiTWpMcHJQbzFNcG01OVpUWkhtYUNORStaTlA4RloydythYlRHMHlORkQzMVU0VWpqVnFJR0kySUp4VWVwSGRnbHNiMmxOWlBvbEpPYk1EU01OaEV0T29wTGdPcUltTkQzbHpSUUlmUVBCT3dhc0lzNjhWeFphUlN0d3RUd1JhSjF5TUgzZHdZczBGd3FxOUZEZVhWUmJkWlI0NmRWb2lKZWEra3R3UlpjS1hBL3R4VEVta0tQTElBYXlOcVp2VHhtaWpGdUpYVmRnaWV4VFRXR2IveWlzVkZCMXRWclZWWXNnTmx1bFZuOWdMQlhIVk5mL3dJSVdDUElxYTN5TGN4TE5EVXZnbHQ0MFQ3amZUSnFNSDFhNGdsTVFWTFcxSitNMHpPTkZQRFF6OXA2Ym1oQmozbkhoaWlSSktKZy9JanViblFRQWY5dmVxTFAyT2dISGh0THR0YXMrUTYvbnc4SnY5Vys2RnJ1VHMvTzFLQm4xSzcwSTZ2M1FPVVAweFhHTCtzbE14KysvUlBPYVovdjZmd2hMREJPRHFhcG5aQUh6U29haWJIdnNjZlVmNUlKQmYybmYrNkZSNzlHSDFWYWpKcWlMWDZURWZCR1Vnd1EzTjFvNnVHMk1qTlRpQytlYTlseG9zdU5icHRHbUVoc2I0aVV6NUhVbGpUYWNqRTRRM2RIVnRmSm80b0F6cWcrV0Jsb0g3RzZFNU1nQ0pUVjdXNG1VWm1rSG0rMDNJdS9POHVjaHhZdUFWeHpCQjV0QWJqUlFkUUx0RnRXWWJNaVZFUWZKeXJyakt2SDJpVGtGUjhLbVdVc0hBRDNOd29zL09ycVZPNzNzSGdyTDU1aDhaUFVkWnZtNzVXbGM1cGYxajUzbThrT1MvSDM2dGd5b28xSWhjdjljSDVVWVJ0SzVkZTIxVE1uUGMrN1JGRFIyQW5rRVNUaTR1L3E4VjJZQUFkaDBxL0JNaFpuNWNVM0xMcFRrRlBESWJtbjlwai9yVzU3Z0NjL2M5R0JWbDJzZnNGekVnMCtHYXJwcC92Q3NteFJuM2ZidmVlTG1NT1h2OENWVHNUOUFtQndlUGZBR1JrNlJpRklDbXpjS0taZGFPTHhzbGErQmVlY3BtWjFtT3YvOHRCZGUwaU9rOVJwVDA0aDR4VWg5RnYwdlM5c0dNYmlENXhOOCsvSS91TllESHlLRDVIWEFrTTAxUmZBVGo5enNaWUwweGZCWE9kZGNKdzhST2FkdlBqWUg5SXk5dzd3ZllZcmlvUDEya2ZsSE9Dcm9hWUZaOEQ0N1B4SWlJeTYvWExZSWtpRnBJS1BXMlRxdjZ0NnJWc09rK09IQ2NVWklScVZnT1ZxNVd3SVVCbFhnNGFIZ1dqd0gyYkdmNzVQcDh5bEdwUUxEM0lBd3JiZis4SUNSV1NRV2pGK1M3cmd1SXVmMnpyNXpkbUxqejNud3dDKzRaSUtERFlKblpsRENDSklMK3UyNkRwR1ZQTFNObzRYUG92TGZiWHRCUDhuWUx0NDdaSm5WcGRZMHNKTThmQUc2VkptREpEZVRCVkNEMGhSS1dSaVd5WlVMN2VNRm44R2NjdmVwUG5PWlJHWEc2NEFQNXE3UkI5UXplSXV3OGU1Mk9YakRldkJLdTB3ZVdhRERwMVh5cEZwdmhmcklzQ3ZKbTErNWJvSzNXRjMvcnc2V3piazRINW5TUWlCRmMzSjlqL0pHcUk1MFMvOU9wRzZVa01qdkR2UkVsOE9MSElpeGpYcTM3MkFpb2FJeXFMZG9MWTZkeGNJY0FEQWhVRlpjYUYrRzBJd3duZkJ1RDcvNS94L1huMUdGc1kxTXNlWUpxNkpkWGhSeXhqYlpHVmFtQndtVnNNMDduNG82NjBtWnBaeEdXdXN2bjVBdzBwakl2VmVadmRZOStIalBXTTlURzg5VXIrMGtXbTF3S3d4VnBNVlpqQXpDcHBteEZ6VTB5YnVwNldWMmpWWE9OWDhkaXZuY0YxOGNWM21iQy9FYU1hcjVyeHFCOVZXMW1ZT29BR3k0UlVJbmhqVm43NmpkcEp1TVJ0MEZ1SURGKzVhVSt5dTk2VUkzcHR6OGlzcnBsYzVmRHNjdU5OcHMxZTdramFlM1RPUTN6Ukw2MHM0SklaVDNhNWx5UHNJMW9jWXA2c3dJNEppR0lvYU1SUXhHdEd5NzlMU3ZrOUx2VHVscVl4Z3hTZmY1dmZIMTZyYXk4czZyZXB5aWRLbnRKRU54VEYxcnhpOFY0YjQvMmRnNXJSSGs1ZXFyNTdQTjBPd3VVQlZGYitBb0VUOFZKL2VuYXg3MkJiS2U1UkhXQ0NGUTNPMXFrSjFVZWEwUU5Sckx6emN0NG9xN1ZXNXd3THB5ZnhIbmEzNlIxcUMrdjJadWZMUG1seFJpM1dNbi95ekdUMStSZlJpL1NqY041L3NQa0ljMmVQWjAzdzVkL055ZTVCUFBtZDhRYTFpdlJmdmVTL2RBZkIxVnNhVHpmNFhuZ1dUN2s2cnp0Y01CSk9EbXJsOVVLK3ZRdXE1czNIVkExWDVlV3EzcmJJdXVkNWFvZFZ1ZUYzOXBhbVYzSkhLeVBkSjBFOWY2L1hOc0wwNk5XOXpOdXNhZzMyazE1WDhoTFFWUW5hK3lDcUpZR0dTYmVkUlBtNFQ4NHZGTWhUSFVabkV3WXZ0ZGFSVzFmRWtrNUM0dlR0dTdOWElyZHVuWEhiL21sV0ZCK2ZCOHdsZ1hsak5oTTlSc3dOdy9aUkhNSjgzd3k0UnV4RHBWVW42cjA1dWIzRnFxSTR2dVM2QkppWHBCNTVhaGZHUkRNOXJFVHRXb0htcWRxZFU0SU5VTUJtUTZUUkJCVktXcWpFdks2d0IvZzdGMnZpbUdFNG1WNCtoNkF0U2R2K0pobFJVajBsVlBjZ05KREQrMFJNL2ZSRWJkU0lJNUE3QWVtMEFRdHdvZ2pqTzc1OWlDUGhHR3hlQmk3aDhvNEF4dFgvVnhROVpySzg1M0crWTdLKzVxbFB6SU5HZ1dqMG9nazRvOGdYeVVpVmNsb0tvUXVweXlHRUpsQTVQeGJEbExramtreXNRa3BScE9LSVYrNHJpa1R3REt0TVpVRlJua0tvU0VuVFpWT2pRaDc4ZmY0dFRFejV2OElETmR6Y0VTcWdMVG1iRUptMFppUjY3a2lWTUVQRGorQ1VwTkdPbHo2anhRVUlYekZ2eHlmdVh6dEdBbUx5am92elREaWtXVGdHYWZKdksyN0pycTRYSlAwYkFWalcvenBBbmFMWVhJSEdmbkJzUzJ6M2g2bW5mNU9aRE13RXpVRjZ5ZFlpb0Nnd0ZnenNxcWtwSHRoR0JGaUNJMHY4S1phSXRGNXJiTHZWMHRWNDYxOXJTZmJheGFTS3NMWHpKL3BON3gxWTJHeUlsS3RKb1VqcVJSNkcyRCtodHhIRnhTL2dKS2FHNlJOQkp1dGduV2RRRm9rNi8zK2d5ZHlIRk1nVnFLMllMUDdoZzVPM2xzUDdtWkdOaCszcC9GSG9FM0NlOGVjQ3gvRS9BMWdKc01KZ1lmT0wrZnVaakxkWVR4WFRlbndLZW1TOGlzVVJNUkpyNFBKRkJFdUZnWkJ4OGtwaGduK1NOTm9xK0pjKzBxTGJWUGJjVFV1M2RqUmZqVlJYVlJJZHBZYnh2SmUvZ3MrTVh2UmVIL3ZWNlVhOEhPZnowd2ludnFmY0oxT2NWZmdLMkZSam1sVVdYRWFhL1FKaTloMGd5ZVZQZXcxU0lNVkRUR04wWXFNRzBUcmVCdXQ3eFBOK3U3MmpRNWF0dUlTang5djIzQ1FpblVPK0g4eWNJQktjazBXVmROU1dOZG1iOVAvOE9ja3FBV1prTFBjajByT3A1ZXdnRUIrUGZpS3JaZmY5cWJUVzl6dU5OaEhIS0ovUW1DVVNzMjhXUTdXS3NJeVJFK0RuSE9RZjhFNHk0LzkwK1RFQWV5dDlIaGptZmdDMEZoUXpBaEFsNzdIVERCOGxRaU9jMkNZUkJVMkk5V2YzMlFTS3E2eFByaUpvQ0NWOU84TldsRmkxSytPQm5GU2NKeUFPU1lXRWE4VGR5M1ZGNXF1OVROUEdmZ25ZRE5rakdrTmdnenk0b2FETVlzUlpNVXR2dEF1YXZFSk1XSVovUHVLc3RqQ2trRUVtaURyYktpcE9scC9yNkV3U1RBblhBbEM4UGpEVy9uUDYzVi95MVNqTXU3NHFYeXErQUxqNWlDdmhTakNoUCtIY1lpNXo1ODVrZGtBZ3l1L2tJN09SSURWWlhVbjJBeFgwbms1RmkrZW1OVTFLSnNNZ3RVc0hkSDYxOFFqeFo0YS9QK3BCU29WRFdtUUYvQ1FpRUFZUFpvZEpneFViQWg0ZVJaa1ZkaFNLUCtRNThCU1l1d3lTNDd2SzZTOHlkMEVMSU1YTkJLT0JZQk9GZytVanZpbnlOMnliWGdlMVA2YjVWdnBKekpiNGliTjBiRzkrYUFWeEpmam1iUi90aWl2aHkzQndBQi84S0Q1SUVjN2E2UGUxNDFKb29UeXNac1VwU2VXWTdnVTFiaEZHSTdTeUs2L3QrT202a0xESlNpR0g1TUt0ejgrQ2l3VUhpelBpWkU5VHEySjlsejgrTWJRTXIyZTdFT0NMSkZSS0M5dlNVTXpZd00zMGdZQnVwT0xtWEFwelpZUnFmTXBjZDF5MzV2S1lDRTFMcmtJdU5xREZSNnNWeHlsU1BVY1NPNmxFNmpRWTBLQXlmV1Bsb0YyeVFZbWZCb0JhdHk0L09SK3VDV3EwbW1GOWhFYTRwWnNzSzNWdGNmMFZLT2ZZMVpsRkhVSytDaDkwZWIzR013bTRmeFFpZldHaW5ONDZ1V1luLy93NldTeUN1aHhzTEMrQUdRcS9Sa2hxa1JwK2NJSm1PNmMwUzNzaCtWNHE2MW9xMVI4ditnaVhYYy9MZmppK2hjd1AyUURWUnJiUXJSWVZPbXo1eCs4RkVUSmxZYzYvYUJVNFcyVWNXNlZRb1dTclRHaXROZVJqaitWR2g3QW5LL24xWXBpN1Z5bXQwV25sdHFVNDlEWkFaNzBXZUl6Q1BQcy9nbGNrTTNqeDlvVWMyVURQcERwaFpSQlI4a1VlZHFFdDdMaUpjT1BpMHl5TGtTMm0wcjk5MWxDNGcxSGk0ZmV5VnltVjdoOU5JeXlxRHlRdGN3RUhnSE5RYXZ6RFJ6MkxpbmVleFd6NU9vbjE0dHVScmZ3N1RFaGZkb0hqTnh5eUJRWkRZWlJYeHk2dFI3MUR2YjgvRnhDVWZaWm90WkJIeWZSZkJNcTJNMTdqR2ZVS25MZGZLUDJEQ2hQY0syQTFlUXpSVzZGRW9xaXZIb2cyRlhybEVqazhCUXcyUk9Eam9BNmM1Rm1QQzRwbk5Ldkx1TGY0NXMzUEg1Y1U0R0Z1WitvdW1QS1EzdDN1eU9mYitpZEZkMTJkTDZFOUUvdVExZDB3MVVPcU5sdXZORkFQd0lYSFpUNWxXQkxMMmdCYk9GcFV6N2FHVzE4aFRmZlZ3ZDZtTG93bmFNSDFKUWE0akxYQ0RrVW01RzhYWmZueHlvRWZBV21OandmQ3Z2a1RmcGdpcndleTlxL1pyRnVDVUpSNi85d3hjR2g4Y3YzaXBCRGxtNHZBTVRzS2FpVlBDcGYyY3lOZUhibVFCV1dqMytXM25LOG9tUDZXblJ1MklHYmd3OHdKT3dCenZicThIREJBemlyWGwxb0N2UC8zOWtmZG5oRVk3UjJlTTJLOTZHUmc2MUh1b0xKeCs4T0xMRmUzTkFjVFBUeDM4Y1NkTCtyM0dLci9samNJeEFYMTVKY0FwYkdpL24vM0FLM2M4L21FVFhwNjdHejVZNVlxb09FZVg3eFdQUXJrTm9DOStvVXlVY2tqNGVuSTRlSU43QkY2Nk1CNzA5T2NvYWkvZ0ZBMlJnTTFkQm5xbVIzdVh3T1BjVjFOQTdrdkN3OGs2Mlk4TFFmL1NIR2lmWks4czdzWU1GNjN5SUh3Q2t2QytzNDd6VXVldmJUMGFtK3k0NmhUU2RnaFRaanlZKzFWYzBwMG9UWG00TElMR3gxL1FKVnhBSWhmWjF0ZExpa2s1UW5GNHc4QWlXM1J3VmtsMFNlbnNvcWp3WWs4WXhYWEVyQVd0OGZONTRFRFdwdU9aNmNLQmxvdEprcDgrZkZVYUZDVWpKUmJWZTkvU1VkanBFYUg2Y2hPSTVWU2Q1SXJHeENsdk1YbkxMTzA1dE9rc3g4eHB5dmo0RmMwdHRCVCsyODZjbUhKVnlCaVNoZXFKK3RteTJjYlpxb1p0ZE5ncXBKM2ROdEhjUE5IYTJueW1jOWRZenM5TXdaWUpUbS9HblJ0S1N0WVRaSVdSUWhBYlMvQU5Kb2l2eDd1V1VJWklwYXhNcFphV0JSUktZUkY5MG1aVG9HYUxuUG03ajU1K01LenhxcFV1cU4vREorVXlVc0hWcEV3aHI1YVJjc1ZPU2JsOHRvblBOd3N4cWdRQ2N6VmZ5RGQvc3hWSVA1c1l6YzNpbnFEeUgwWWlUTGx6NGNtb2xGZDk0ZFJOeXYvRExrdlQ0VE5xSXA2R1dEMEpIcFlSbXp6MDlQYVI4U3doVU9QL3o4ZFRhY1lxSDZiMXhqU2pySHp0L2NzWG9vQlllWVJ2aUkrWUc4Wi9KY1ZEKzFXZFplbElwNmRFSEw0QXREMHcxVnNOWWRpWmFQYlhMUEZDQ2ZPOVBXL1kyRW1Ia3BKK3phb0JpblM0U2RiamlpZkVxd1RZUFRrdGdGRTJiSnE1ZnVPNkRYMmFIWGZlMkUvOWZMS3d3aE92QWlWNXYreDRZRFEvOVBucHNTVSs1ditCOTRZeUYvN3dlM3VoYis0cnNMM3ppNjNmeWVEN2JLRWNlR2pSMzhBUlZZdzBweEF6MjVzR3MwRGpReTVhOERqQU5mbUdndDVTdDczY29zNU8rL1dYcU1nZk5hZllvREtYNEpqcWNXelJEUTRRbHdDeFg4K3RUb20rL2RyUG1HVy94T0d1UjRCejMyS2FQNHRFMmdjdnV2UnJ3bER1S0ZqdWMwQlFQN2NYWEZwUVhtd0lCeXNLbndWSVFZWDQzdU5kMlYvdy8xYXIzU3d1Z2QydC9ZVms5alZXYklzaFp2bURscjVrWk9UK0kzN3pXZEVGUCtOYkRqaXRtc3hENmd2eXBQV2tUaUYxeTNkUjFuc3FMdkNHYWtIZGtlY0dQcFNoSGk1em56SGdjbVVoYmkwdUpCVUtBMW1zb0UxeDZGU3pLbDNKNWJ3RnRnWDdiVGxTTzFRclZsMzRnZ0pMOXNoSDM0V3A3UUEvdHNDY1BmN2srNkxQSmk5ZC9Vd0c2OEVwMldSZCt3VlZ1SHFocEhFUXo4VkhOSytIS1o3cVpyNitkbC91UlRveWZuMnYwSlpZZk5JYzZSd2hvTkhnYVBOS09xWnF0ZHFDT0k1clYxYzYxZUgxOUw4UXV6RzlXTkhGOTJXVm9pTUxHdnFEOGtFNnI5UlBVMXJRaHdjS2RES3ErZXFzU1BwOHNEbmY0RmJJRGZ5TnlCVlkvK2w4S083aDhkdkpWblg2YVJyOENBZmZMRFhoaGJiSG5hS2lzZjRiMU5ld3cvMUMyN2xhcWlqR1kzUFo3ZzkwemUya3htS3JRN2t4SXhHbjRtS2U5ZDdQZGlwL09Fb2IwdENpUHEzVlBHbDVabnJHY0RJK3lrajdLQzNqYnBRTTNnREk1bkJaWE03Ymx0bWNOOWx4Y1J5a0tDQ1AwNURaeEhRM2tYNy9Qbk1nd3IwL2ZWcjViOXJmMG5NMmlyNDJobWYrUU9Wc1NQL0JIeUg0aHBxSUhSMWgwSWNaOUpWMHhpcDY3dlB1M1poSEVLZm1SSDBSQ0FkclloYzhabkswWEVXYWpHUDVrVXVXQVhkWVhnR1pTcC9xRUVWRWNtSXNWUUZybzR5bWlrcEVhZXp2RWd0ZC9KMFVkUnRqVEZ2Z1lXcHNZbkxFTUxMcFAyY0JMUDFPYkxleisxMzlWSnBIQ1NsRzllcVVsSlVXSFpuczBSUnFPTFB0Qis1K1lCdmd2N01kQnAwMURXc1M2R3NrRVp5UU8zSGZXckhOaCtEaGY2Yk13US8vbTFJZlhBWDZCcmpEMWJhUmI2cDNkdG85MC92eFZnVC9tNXNqc05oTnZ5VkhwdCthd1hPM1paVjVYOWtPdy9OWllRSTZmTXlyaStuMnpnU3pJMDFXdVZia3ROZ1RGRVFQaXRESVBGUDF0S2xrNldZM0xHRDZMWUZHYjAzWWdIdUtZTUthdEhKdEhhU08zSjY2eUs5Y2gweFlEWWllVEZFT2NEc0gyQlVCanNjYnpvRjhnbCtqUkVqNVp1YVNtQXdLWWhNS2QyU3ZZZnJLc0tqSTFuSlRvcDdFTE9UNkdLV0M2RWVwUzR2N3l2VWpDOHN0UGRjdDBzaWQ4VVd6ckRPeVN6RDlsb3lNM3BxT0FZM01MTG4wV0xjNFRHOXVkcXhubW41THNrWnY5VVBocnZteGcyNGN2K0RSWGF0V1ZJK2VPa2pQUFF6bkh0cWpoNVBubEtyeURCNTlNRWl4OUR3NnFBUURGQ3hxbEZGQ01TeTczVlhKbGZUSW5CNzBaQS9rcW1IeSthejh2NG1KZXY3L2dRMTAvc08ySDNyMVRtZFY3MzgyN25OM1llTytmLzZoR242S2U0V2VmVTVkYkIrMGJPdXVKbXNtcCtkRzI0OVZDM1F1R3FhWHhlVTJEN2YwcHRlODF1a3JCaWFocHQ4L2FjZWJ6bG10V2tmVmlzMHBQY3AxQVV6UjRMRlNpMXROVksxYWt6cFgyZ2dlQlBhaXJSRlhXVTNXTmVIZjZ4aVFuZ1FBYmdBUG5CR0puVkg5d1V1QmVmZS9BSEwyaER2clZVR1hja3hDdzI3TVVvMFc1R3JXcUFad2JYemQ4N3ByeXFWNjA4NFllQUgrdU9SOUtuNEhUWmwvd3Fwc0hSZCtkVkVLUXhGV0FwRVBMYmhsUVhzWndoTUEwOFlqK09za1YvU1BzSlQ0R09tL3pLOUtDOE1sbWFENEhlVE91V3F0dGZQNWtnS0h4NXlmU2p4U2J5MU02ZjNubGJrTnlpVmxnN0x5aU4yc3NKQmI1NlN5LzEwNXA4TUFUczlXclFDM3pmNStBZnc0bXlzRzhQT01FZ0w0Mml5VXdTZlZOeWVoN0ZjV0hyRTU2b3B6ZEU0b296RGI1Y21GT1NoQ0d0MitKMGVtSHVEbDR4V1RqYkhPUEY3TXNzK2dYQzQ2UXZ1WHZzTVpnTHhVR1p6SzJOTnJHc0xmaVRQL1MvbFB6OTFTTFNKMHNrd3Yybjc4LzVCTWYzMlc4Yi91Nlg5SGcvL2xDTkMvUDNzMXUrZDNOMWZuWjRkbFUyWnh5QmtkdVRCNjlmcHc5THRIeVVHSUJRRDZBTW1HeUt5MWJaVWVBQ0p3MmEvOWRPZE5tam4zMWllbjJyU1haMWY1dWwwUXdvVDBkbFpxbld5MXJicmxYQloxUmFWMG9aRmFiWU4vTlhKWEpFamlLUHpyWXdiWXpmb1BEbDFsMTdXMUtQSnNra2FjMnVPbVJKY0lld2lRMitPckpkaTVWcS9rL2VQKzFXNW5NRWEwRkxZaW9kUlU3amZxbUprMXJ3Q3NMZHcxSUUyMklGdHVxOXhBZ1lkOGRjNlExODlrT1orbkthV2FuLzJZNzlkZDJxUjFrZE9FeHR6amdtUk5qb2FCN3psalpqY25YUDM5dU9zZVpRRFZ0TUQvbEJKM0RBUmdZenVSU1drY3dLNXF3d0Z5UmpBNEh2aDMyWlJQV0ZBNC9ieHhsVDVBaU5zQXlBS0NPd05WOHZUNjAxcncxUVp5VkJhTWE3MUh0ZVJrNGhydkdHb2JycWNYb1ZlTUlnVTBvOTlPam5jR0dwWndqemwzQlBFWW8vMjhlZjNKeUZjeDlwWWNBQms4N2hRQU1EQTZtYzM3ZHhHTkV6d25WOUhXdG9BaURBRDRRNC9aRllob051N29BRTdtVEtNQURMVHB0KzJYZ2xDTGdCODZlbTdUUTNSdHJaK0pWdGFhakVhWWVraXBocWVobHRPd2FOb3VRbFExN0RKeU15V0U1cE9JalZwamxQVWlJSVpXbVBrQ2R3blRrWW1nWmFFTUdmUEt1aDdrdWIxN1paOHVnbzU3TUp0c0VjSEZ2QmliOEJsMFlNYmxORkw2MzdVcTNXMS96WGFUVng4OFlvWDdSRENYM1llVXpoRHVSU2dJMmxIS1FFd1NjUGhoeHRKTldlUzhTbWE0Mkd1NUVKWWp1a3hqSUtKZm90SUQxTmxxdTJySXIvRU9CdW5zaFlOd2NzblNrRENaNFJtWGM0QUxYa3hUK1BCRU9KcTBsK0FmZU81LzZDM3lCOHJKRitVUXNPUlBRYjc2MDBzaVVYa1NXRis1ektrTkYyeDlwa0tzQUFmTitOSDM2bVp0VTFWdFQvSHVZaHlGYXRHNWF6OWJ5eXNDcjVJVTNzTkIyaDREdUxJYnN4VGRpTXhESjFHblBxZmR3aXduY2t4UEF5bnRMV3hyRm1TbG0yc2hrQ0o5M3BvWWIyQ0ZmSTBaMEROc0dZaGdIWFNlK2ZSM243MXpWWmQxdGJCaFlZQmVmRDZpaTcvR29XWk95UWhtMVNZdmxWRVpuVkg3VDF3TkdaTExBa0s0WW9uU1krbU1qTHRlM3BGTjRyQWlUMFFxSXM1aUoxN0tJY3Q0RzR1YmpjdWQrbWlNTmc1dkNTRERWRFJtRXhERFV2RDJaR00wdGYxdGMxcWZIclppOEhmaFlZYUlNQ1pUMG5uUjltY1phTG9idXZYWFRZY2tocUVHQmdzajFFWjBrb21EMmNoSGVlVU9rOXR5dE9FWUNJVm4rU3lsd0l3VmxXVzJha0JmcmFYa2xabmVWY1lSektBZ3RCblZQWTNWRFVsbGd1cHBQNXJJWnR2WmFQZnNCR05TMDFHaWdRaDcvUmlCUkVmSFlZNldOMHl6ZkxKMVFQaWtkV3NrTTVxK2NUUVk4YWlYbzdXRGlYSFhjZGl3cGRuUUJFVmpWa29oWEFNUHIwVEh4UzBFdlBMY0RvbkRURi9SN1hINVo5QWk4WXdUZFEyQXU5YXNPVXRqTkoyYmlUMGNKeEdDNnBlTTZaVGtoWnRHU0tHNlpGL1g1V0hHUFo1K2F6Um84aDdEazF1TGNHRldnemltUlBpOWVza3FnRmd4ZHlpSHRkYytJcEsxYitOSU13ZUkrVFh3TUVCWnQ5RmlXWGYxL0ZBaEFMYXFleFpVRnZyMFoxcGk2N1lORjQ0clBPZTBOeUxaaDR4SVovcktQdEtXZjJ1S0dZeHhJdWIyWEE2VWpOZVhJMjRKTWxIYXBGVDNKTWZYMktqWkZRZzlPMTExVGhpejBsRyt4OVB4bkRIdUcvVExUeTVVWWJjTVRXYkZLZ3Z0SHRDdUdIbFpDamZkVExkTnMwRzJ3NXNzSHB1MFFFb1poSUJRRHV3SzBaOGNydndVcFM5dUVjS0RmWmx3N3VFWWRJK1N6VElGa1UyRStpVUpYbGJwZmUvREJDT1RuUnFHMmhLaEYxSmFjQjZEZ2dDeUcyY1ltazdsaThvQWpyQnNucFE0NU51VURUVHZZc25JR1NnSDdibWZSRHRaWHZoMVZiQmgzcnpLdTBscVcvaW9DZ0VJK25vYUdiTkJNRElmcWtyM2JyZ3U0R2J1TkF6Z2dERzNIbXB1SnFqZHZjaUZDZEtxMS9PQUsrRnVoQklqY1Y3R0VsaFBYVFBoSyt4NWdEZno4alNDQzJNS2xsbFgzRmN5OTdrRXFLQjEyNGc2SkdVZEEzRWUra3hUUkFpRlA5YWVlbGVLZlpDaVZvajBDWVBheFVERWhpL3FpSVVHWUdCTll0ZWtSaGkxYWlBU3E4SGN3MDRBaHk4Y3JuQzV1YjUybmdrellxbWRTR2I5L1poMGo3SUJlaW53TlVLSDZPUkNwWVZhMWViMUE2TDBWVWhVWDdoVVlOVjhJQW9oeW8rKzk3N1pWZDlXMVlKbUhkWU9vYTg1ZHNwUWkvVEIvK1RQM2UzV2ZYaU11MjZmbCtRZmtUYjlMekFWdjRHOUx1T0gxbURCWTU3VWhYb1JEc0FlK3RGZU91M3AxNUFncGp0WW5SU2s3UmE5QVV3MFhkZlZnQ0xHZnFrd05vRUNnTVZHWENWSm92bk9FVjFvR2VFS3gvaE1haUROVkVyelhIOHk1cUtZb3hHTXU2SHJqaUxVT1hvSGJmN01mb1FMaGRUdnlKMDZBL0xSemh5UEE3TmZEd3czU3huRjlLc3pweFBMd2lzUnVNVkVxM1h4YUw3dVVvQnRVWEt2cE1XTWYzWnpzOWNUS1F1UHpDWlRaeEx5T3ViVUpvQWZscTk2QkJydjhQTGNFOEhkTmNERml6QUV3aW9zOHdrQ0JIVmxQK0hNZ2lqVllFMVZRZFU1UHJqN1hJSW4xUWJjSiszdWZHc0x6S3UycXZ4RkpDcmphK1pMRW52aWZBbS95S1RuQW1RWHNOS1NuYmFKZ21tSlpLK0ptelM2ZGhRc3FFVUg5ZVdpZ2UwRTBWQWp1cmgwNkM3UjVVMTg0UXBtRDIxNzFGRXpaQjRPS2FDK3pqRDdmQU03NzJaU2Q4VXNJTS9GdWtTZER5enRNaFkwZ1dMWXpLQ1JaMVBoc1A0M0dYRnJLVS9MVE85VE90RUJJdXdHMnVSTVRoYklrUXYzdEJKcFptY2lDeEx4bktEVE5HRG5EVG1VUk5HZFRXTGVEeE5QOE5QWEI4SWU0bk9RNmJsSXgvb2VvRUpaekp3dTVmVmJ3ZEwzL1ZIUlJaNXgzd2lRRkxFUWtia3pLSGdlS1BXdFVVVkJvZVg5NGRKY2pYWGlidFp3S1NLNkNFMjhDNkFLdGxyV3RxS3VYcXBTRGhzSVZnZG9mUS9sS29pSGt5S2xyZ0ZtRzh6SjJqSmNLclIxWENMT0JxbHpValVKY012MjlxaXB2RDFoOEN5Qk5IYzdIMUR4S1lJUTFIUWtrRkdyR3YvZFZoT3EySGw2a21ZQ1pzaWJLSUN3bTN3cm15b1dINzRwdFl6SjJzaXREY3RVMGV0MkJVU2g2NFlCYlV5dE5jb3VlbjNaTUY3VkxDZ0xmY2Rvb3pPUG9NWnp5UE1PMzVPZ1JuYVR6V1c1cDBsbkxhclQ5dHgzSFhZVHBNWWx4dUgzL05PU2hMOXpWVks4S3lmckFSU0hWamdpZWF4SUkyWkxlVlV3MHU0V0lJYnl5UnF2SG5KS2dmdzZ2em85ckx0NVRUTTZEVGxzVEU1WEpXamkzUEE5OVcrMW5KYXFVd01EWFkybVV2MXJTbFg1VXV0cGhjbi9pQ3l2MFJFcGFycFhrWk1ydWJ3QmZUaU9yMzNsZGVmanNENG93dkttNDNrdUw0K0tOdllraTlWcTF0V3I4OVg1aUYyN1hNeWJXVDd6M2RUMVZZOWdSaHBHVG5La0N1bWExYVlkcW5aWk9makRXL1JYY3R1bGlaa2MyWlZhdWhzYVVOWlZrSHNSMGxiS2MxMkR4Vm1mbFhuU0JNVk1xYTZEZkpVUjVKVXdWS3hscVRCb1ZiNHM1SndXcExSa05aT0N6RDFJbmVDRXJTcVVibmpROTNWMGRscFhXazV6eUVablMvTUpaZEhmajZOclg5bUJ3RE8veGczK0pSRVJtazdOZWMyaDBrd2JTZ2N5d0NwWElPY0I2STlhREpkcjFHTmhEd3JpY21jWngvMmk5Q1NxRlFkWFhXQkYxbWRwcWlMRVBiTlltbEFxVzlsUktCNnkrbE5lOUN6dG96QlF4Vk83TkJtSGFkeU1ER2FMdmlGbSs2eENiZjJMU1BIQnpLelAwakJGaURDbHI1UVd0ODJ4a29Ub0JrZTNDQS96VlNZQUVsaGhJYXltTUNkT25TU3RZQkhaYXZVaDJSU2xYaitBRytiakJSK25aMis2TnlveXRLWGZjL0QyOG1reS9HbUllOVFyWmpzbTNmVFhzMXVLVGZITFNpWVUvU01DUlE0dkpTK0pLN0VhcVg2dEQwZlJQVXA2cUlVNktxKzNMWTRHOGhUc1g2RWExdXdPMWRESHpCamxaVnRWS1Q1SVhpbmh3eGlYQlpBaFpEUXhzVVBjZzlxZzFueEZnVmF3MjkxN25TUDZ6dFo2L0YxM0lhK1gyaUU4ekFzODc2eURPTnZTTko1Rit1QXducmZjTTI1KzBqSy91OXR1Z2J0WDcxNTVKcmUzMjV1TFUyeXdFWDVkdVpXd0hjRGRYY3hWZVlwRGtESU5lNGxzRCtvUFdhUWNYdDhTbTR4OU1XUFVLTWZDSGhWc04ycW5CK3lyZVZtV2M1dVVzNzlJWklrQjkrUlpHaWdhUis0WWtiSGZUZElrQ24raG1hN3pFbXZIZEpIbE9ldmJMaXBSdjZJVnB3T0F2bEEwTFY0Zkc0dElVQ29RMEFsNGRnbVB6OFdTbWZBSkN0VS9lRkY2Ui9oZDNHTm9iRjAxeVYwMk95amorZC9Kb0Q0RFNndmxXSFl6VnhvNkkzam04aUtoRWdHRkZHUXl1WmR6akxTK2hNbnVZdGhRNGpDNCtzTGk3ZmxHQXRoaHJId2psalh0NXlTVWRpci9IMnZvZ2VvdDlSSGtTaTM3UVBpTHZVRno4b3B5dHEwelRtUGtOejdWbGhmZklRV1FrNlJ0NE9IQzBqMHhXUjIwUmVuQjFVY0hxdVBoV1E3YWJzRURtaXFmSWtIaU5zTFRzblcyWXVaY3lwT1NEZUdneUVlcFFEV3MrcFlFK2lNR1VpenpxbkxlSnhRYTBUQXdhQkRuQ0ZDSFZQSkdsUEpHUUVIMitlajBRRXpHVFFOY251KzN6YXJwbGd2VXFNdW1ySVM1ZzJIcFdZS3JPbzZoTVppTmRBS1UzY0JmQXh2RzU5K0Z5UzFoWVczdnpucm9MMjNzMGJhcVpxN01CUUpVZXpwNFdTa1daaldPMWNtSi8rNFVHOENyaCsvZWlIRmRia1NQMGpJUEw3eUhpMlJRWHhaaTdCUElxelJSd0s0K05vZCtWZHNsSWE0QVdNeDIyVVVmNDVBRGVac3Y2L0kzRDVGdEpuNDlqaFJQcjJtb1B1T0ZoeDRlWWtFanNoR1hpZGFMbThiQ2k4MHFRWjZJT1pWZ1BuTUxNeCs2L2lRSjVtc1ZpYjJBcEdtSklmZ3grZktWbzcwWUgwLzlvYkpXZVFxVG1YcDhDb0FBSUV5L1NEOUVmN2QvL25KNjltc0EvSE1zcnhzQS9yVUdmdi9wK3V4KytFckFFQUlBRUVCOTZ4OEcxSmYwQkhKT0FzTC83K0FQL0gwQkFPUVVOQVA0SDhCcnFoTW1UeHZNODhwbXE4ekpFckNXSGlzVXh3cnVYRll4SG8xdWtKRE51andtTjlrU3hnVDVTUktYMitYblVibDVpUzlQQ2VadG1Wbk9sMC9sNXlONVBsWGxGUW5wVlQ0cU5PYUt5cXdpTFl2bERRUHZtQ0E4dVlvbVhqaHZDV2RjZVBTS3hpT2NHQmllRGpIRElaelZ3bk5GZUN6Q1kxS2FONFZISVQwL0N1ZXg0cXhpbVJ5dCtZSmxidUVjSjJjZVpNcDkwaE13S2xEdEJKVG5VOVZ6Z3lINVZubytFc3Frakh3aVBaOHBUSXpVZk02ZlA0UjhvOXF2M2U5Sm9VUkJ5endYeXU5QytVd0c1elA1QytuSjFaQVJtUWxLeTYvcU1zRStNN255b3RqOHFDNGpnbWtXU0t4eHNVblBkMUo5cURvUFNzN2pmTG1EYVhuY3lCeml6RWlWOWtqTncwbzF5Zm9hdlY1RHB3M3ptZzR2S21NaTV6SVloa3loaUpQMmFwVFoxVVpwN0hTN1RqWkgwZlpMdy9PM3NDNVpuYlZVeXRLS2tNMVYrNlpEcDlheWZ1ZUwrNFVmbVVEN2p6c1JwNVdOQ0tLVEFuU0hmQ09VWmNJWlVMOVVLVjBxNVBhaE9ZZ2dERENLZFA3L1UxbUVDVU5iOXU5dlhXTXZtcC9xdUVXOG15U1B6UVBPTkY2UGNNOVl1ZGxJbXFEVVVhRnRxSkE2S1ZKN0hGcU1TYk15Tk96NEJmNHBWVFVwTlBlOTdwVUFJZ2NoZ0JkMDRSb3d4Q2RvRzRDTk1XRVFnQ3NXUUw2K0NKQUxXUlc1aUt6UkpmQm9kekZXRTEwaXN3WDVVc3lsMHF4MWFTeDJ1bXdVeDI5ZUp6bFBnQ3NWQUthN0NoZUtqOHRGTENsd0NRcFNwN0cwc3RBbDhtUi92dVJjS25kdWRHbGk4N2pMeHBhUEw2RFRjbDlqU0s5VWVCeXhWeURhdzZQT1VLMEhwQnlybVVGcmp5dnFmYkRHeGxCVFRWOG9QcldxKzh4dHBEQ0tLdlR5blAzNlJRZVVxYXVhMUtTYmJTOFJuV0srOWtlbmRqU2NZT1JkQXBoQ1hYTjZXcHFhK3hqamtLRlNKYU1XbG9neExNazdXOGR3aG1yckc5cmJZUWIybmMvZ2k5NUFhK2lnUVp2SmQ3WWV4aG9iUTAwMWZTR0dLN3JUbHY0T2Z3UEcxM043VFk4VVJsR0ZubkFFM0hyMmJxQ0ZTUWl5anBGNlcwS2REUEhjMmhLemRoeEdwbVpQc3FPaGpQM0toQkRpWDJka2lRRC9Dd3lEZ3g3ZGd5MFVxdUQvMDJabVlXV2pNOWc1ZEgzOTl4VWpWcHg0Q2J3UytTVHhTNVlpVlpwMEdUSmx5WllqVjU1OEFVRUZDaFVwVnFKVW1YSVZLbFdwVnFOV25RYU5talJyMGFwTlNMc09uYnAwNnhIV1QzOERERFRJWUVNTU5jeHdJNHcweW1oam5MUGVCZ2R0czlVNmp6anJCazk1d28zR0dtZTM4WjR4d1pPZTlvSm5QZWQ1WDVub0ZTOTZ5VTBtK2RFZXIzdlZheWI3eG5lMm1HcUthV2FZYnFiVFpwbGo5bDlwQy9BbHVkQWlYMXRzcVNXV1dXRzV1NTJ4eWtxcnJmR3Q3L1Y2STRRQzNPeVdnQ2lpaERJcXFDSkhFOXpxdGtURG5lNXl1enRzY2kweGFJRWZQT2loV05FV1BVYnNjY1FaVjZMaVhyWGZFZW9EMitzYm50Ny9VQXNhQ0JhcjN2d09iZ2dzTjBtcnViMi9yNmJ6UEdnajZ2eDd6OWxHdm9KU0taWnFDUWRnTUJwc0FHMnFpdEphVHBhUzN3UDNPeUlhYjI2R3BlcTcrNUpXUjUrdmV6UW9PWDFmUnBVUFBjUmtIUzEyblVMNUNOczJNTEplRFRVZFZVYnZubmZ4R2ZNYU9scTIrcUkrZWhkeXhyVDNBYUgzOE9SbFRaQ3duZGZlVE9TaUZubGtBdkxaYjBRSUdkV2NOODBJVkdnRmw3b3JaMytnR2lEVklsVkJZUlZvZUwzRXpaY09QaTAzUDFwVUw5VXBWNFlMNFdvZC9hcC9jRm03MXEvdHJCV0JXc1o3NVAvUWE3N3VkZTIwZmJOWHZ4NW9PQmM9KVxcclxcbiAgICBmb3JtYXQoJ3dvZmYyJyk7XFxyXFxuICBmb250LXdlaWdodDogNTAwO1xcclxcbiAgZm9udC1zdHlsZTogbm9ybWFsO1xcclxcbn1cXHJcXG5cXHJcXG5AZm9udC1mYWNlIHtcXHJcXG4gIGZvbnQtZmFtaWx5OiAnQWZmb2dhdG8nO1xcclxcbiAgc3JjOiB1cmwoZGF0YTphcHBsaWNhdGlvbi9mb250LXdvZmYyO2NoYXJzZXQ9dXRmLTg7YmFzZTY0LGQwOUdNZ0FCQUFBQUFEbThBQkVBQUFBQWZ0Z0FBRGxZQUFFQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFHaTRibkhnY2czWUdZQUNCUkFnOENab1dFUWdLZ2FWMGdaQlFDNE1pQUFFMkFpUURoa0FFSUFXRmRBZUZSQXlCRFJ0b2NTWHMyQ3ZoZGtCSURWYzFMNHBnNHlBUHc1UkdVWnMwcVQxbS8vODV1VEZFdEIwd3EvMDlwd1FIUW1Dc01xcFFrbUhWUkFWclFsMVkzbk8zMDU1OW9HZzNHQ3N5Y09EQTA4OHl2a21GYjFKRG5jbDYrSmVLNjJiOHVCdWJnK2RxN0I5bnRLckVaMnhpYlFobUpOUExsQnhmaE1ING5WcHhtc3hYUjR2b3lKZlozY3ZvdFBNemRvVEdQc20xZ09ac2RrOXp1Y2hkcENGSUw0S1UwaERjVWhvb29uV0IwbGN6ckU1ZjFlUC92ODd5d252L2Y5bERHdklDaHJFRjFuZ0M1TXJSQkJ4dEdTcjNLRlEyVzRiNGgvM0JOK2UrLzcwUW9pT1ZCTlIxNkZBRm1lRzJhZE1tK0F6UU5vTjVIcUFUS3hHSlNFVktvaVFrelRrQm8xREJoTTNxeFllTEx1ZnFNMUlEbmY3WENBUTJJSU5FQ2s2QWNNQXAvcVRkZkRHOGJxOHI3Nm8ydnIreDNldmJldXRtWnJKVjNiQ3VSNU9yZTcvWE1PL25reXAybHhVUnVENnVVYkVqekNUT2loL1RBUDhDQVUwMVZYSnBoWFpDVUM2OFpjcmhoeW1UVzhPZXpEZTNmeVM2bFNiZUVpV1NUQ05aTkxwL0U3L3hiZk9iVzJoTHFTZ1RWalByRFI4RXlJQjZTdmo4SVcxUWVpcHFGN1c2YW5SaDJBR3Jld0VxV05zT2VPbVVMQ0dKUCtKK2lFR1VPc3VLeHBIUGhFSFFBemVOaXE1NUNISE5LNlVQdkhFR1pEeTdGMlpac3F2Wk5tbGZSbjJ1bXdlN3hVa1lYSmxxM2Z2dUJaWTJBYy95bmNGYmsvTWt2blBSVi80K3lCWXpPOERzTEJZRWRrVUtYSHBBaHZZRVdvR1FYUUpTZ2RJWnlyUDQzbEgzenVGQWdjY2p6M2tmWHZUNnlOak11U1Q2TkRjdS9TQk1MbnpvdjE5K3MvdXFHVUkrTlo4Z1l4d2hRYWhOVHFRWjB0bExVcncvaEJSbFRPVlhHQ1FTUjJISkdvM3hxeWlVUkVoTWRGcE8yQWhURXB2V1hRVGJEOVB2NzIyMUFaM1RjNDY3NjZzdE1yUlNTQ0dGaUs0Zlh6dU1UYytqMmdFRzZxVFNlTVpBRUVDM3VicVpSRENPN1BFdzhvaEhzY2M4aGp6dU9Zd0FtcWhTZk5ReG5RTndYbnZSd2R2Z0pBTEFJWDhqcjduc3dHMVFBUXdnVEo1T0RCRG9hYzMvU0l3SU1BMVpab09qbmVoMDU3cll0VzQyN1UyLyt6ZitXTWxQUG1JU1NUUXVCcE9QM3l3QmFZSXloTTNZNzE3M0lTSVZTeThqVENmeGt2bUkvRVJCc2pBVHVhOEFrWllWRGM0Mm5HNFAxMmhreE92dkVralVhc2QrekNidHpkRXFjSkZtZE5yTXB1MkhkcStQMzRlSUI2QXBjblJxdXFBaGJVYVB5OUVTSWpGSmF6UVphR3J1R0txb28vcTFkY3hMRlA2c2NCTjZaT2xsNjdEekFRWldPSmhBZ3hTd21TRlZxZGhybkN3aWNUcTBrWkNpd1dDaThQSmpxS1Z6Wk83cHJCY0xPcEdNMVFtemt5VFRwSENKR0NiRkxQRkJOclBFMGl4b1pWRVdwSHFnSmJ4ekhvZ3E2T042cENBQTd5YmNGNGNSU1VjcW84VWVpTGthTm9FWTdGUy80dnUxaTZRdzBNOFppY3BIUkhOVTZOS1BSSHVNNkFLdmNRMFBkaS9NOXk4MkRuNzhMenByOStFdDk5cWdCMjEwdVAzMmNCY0dCTXoyU1Ftb21RMmhEUnQrM2NsK1Zqd29wTm1pd1ZhbmpsV0ltY3h2amo0SUtPQ1Z3YzR0MmswNzRoMEdrWEZ1YUlLc2F2THd5T2kyYkhudityYTZyeEFuV0FiVTlrTUZDeGNJc0JqUzVMVFNOUEZleS9xZ3JhZk5XeVNGTXR5TFY5UjlnTEp4TUJzK1Z3d1FGVVBpU3VqSzFIRkxTRWl6eFhaQkJ6cGV5SW5PRUhlUGUxUmlJYTNITXN0MlZVMk9YQ3hQWkk0aytWVTJWd0V5VDdwWTFTNnVDQ2tXSzVHZ1RLSnlzUXBKS3FXcmtxcGFzaG9wYXFXcWswMUNaSHVWSE9nSTVFaXhvNnJrYU1kakoxYlpTVTZsTzAycTB5VTR3NW9UU1hBMUwyU0ZqVVEwZFBtNDVHREl3WlNiUnlRcVU0NUlmdTNLOWFSVUtaSVFqQk1KQVRGTEdrZ3VMVlZEbS9rTUMyVG9xSHAwNitIUkswTy9EQVB5R0pSaFNMSmhlU3kxSjB6N1RRZWdjUjB5T2YxemtqT2R4M0NCU3hndWRRV1BLMmxUdzlXdVo3anhNd3czdVkzSEhlN2tRU2FUY2Nnd0k4MSsyZDByMVgyeWVVQU9EOXBiWXBHVDUreVRaRS9oa3dhZWNpTHczVXZhdG1uQTZYOFV2d0NWWGxUWVpyYnNWUTE2ajBra1A5WnpQNVZoQnplWWF3aUNwMVR0NXZOSzBIdjM3UTF2VTQzSHVTZ1Z1djE2NDFNcExQQzB1SHoxeFNRdDNrTTFrZlIzTlJwVkxOZkt5VEQ0K0hHaCtlUlo2T0dEOExqTi93clR0V2dEekpja1dHaUlZcEVsREJMTDY4THJnNjV5dlN6aTVxamJuYktOSzhmanl2WGs2bmxZbWhacFdpVm9rMksrQkF0RWttSUxwZWl5bW5hSnl6NENOa1NFdXlXTExDWmJBaXYyb0NWaENPYVVRckJnRlFJQ25DUTM4azU0TDloR0dPZjlJZ2NINGNKaFI5akpLUkt6dVBaOHJqazBacjFlRTFORTQxRTBhN3hqRitOZzRzYkF6SDZOenFvd1kyS05mV0F6R3ZaeFVBNVlDSHdwVVBaaW1BQnNoWWtjd0FSYnpVb09jTE0xVnJiR3hHakpiTStnU1JnbUFNT3dBeGhhNDZZY2NKZVQ1bTc3VURVekZBNGs3T2dtaVVJQXBZZW5COGRwbS9TeC92aUFTaEtQaDR3V0U3ZDZLS2lnUWh3UkpoN3NLcmVzem1NSWtNMVdmUDM3ZXpuUk5hWkFYNFA0RC9iKzNMMysyNndlQzRwMkRwQnBpOTNnRWlkbFJQeDV5MWhNTkpMdDF5Uzc2NjlDV21hakpSd0tDVWNLWUZiVk85bk1XTUlhR2VHOGlNWEtxTGxRd29nd0RNT3dCYklpSTJHM1RGQXIxRVN4UXNxMVZaMDZFU29LQ2lvS1dxR08wTkZxb1VTRVlSZ1pCUVVWQlFVRkZSVzJRakkwVkxSUXJqbjdudTU5bVFvK21rYysvT3cyQy9FamxRT0RxbzkwN0drOThYek1RdGVwczRXTFR1M3IyTFhtMm5UMFBXazMzVTdoS2NJVWNZcjBPWmx5N1ZVYlY2UGcyczYxSXloZVVFazlyU1RYN2dFUUdRa2dRdkR0QXBWcGFOdHU4YlhPOVV3VEpVaDdMeS90RlZaMG82dld3WnFuZytCTnIxRm8zcW9GNmNqTHBJTzQrMy9lUXVJV1ZLRGNLa1QwTEJiR1pMcG5NTjNUbUIwUlBZZnBKRHBUUUphb0o3RWhUMkNkSHNlU0hzVzZQSUoxSUtLbnNFNUVJc3FVcFYxLzM4NXl6VjZsZEpjM2ZSWjNkMW1oYzEvTUczT0xCSHpRdUFITml3L1JnWXFqQWppTjMzdlI4UHNHVHh6dVFpTnJOMU5JVm9lU0plblZYWUNMQUtEWGh3MndhSUJ3WHdjdkFVbUpKdi9WUEJhUmFxVmozZVFXZHhnM2FZK1VvaWo5dS9pc05DdlRDbHM1VnAxMTk5eE15UURMYWpjbzBSbys4Tzc2ZHZGWUFTdmpsM2I5dWRlV1crcXNvdzdiYnFXdWxPUEQrZTJCZGwrN3E5M2VqcldaNzA4Q1NWSW9UdTlXVzRjRGZGS1dJV1YzZjYwcUsvLzFXUzZmc1hvYk5kaUlBaENEWVdUQXkzOXdudlNTOHUvbndOSTVGNGU0UXY1TElGdjZyNGFLMTF4blRvUllUTFRvc0FkaDlBMEpPTDJ2R21yQUF2eTVvNWcrOTNuUjVtZytvcHdGb1c0Mi9SSkV4ZVcvZzcvdlRGU1pXNlI3OS8xZ0tJcHRhY0U4WWhVbEp1M0ZYZ2wrVHNBSytWOXBCVnVMRnpHdEYvYW5kSVhyOVNDYW1TTnhNeVY2d3RLc29RNk1RR3BwQVJyc0FpWDFsTlU3RVNQZEcxS29xR0JScEtmSGdsZ2JkTDJUVjErQzhtdWpzSmRBbE1qdWRMK3VlOWtYVzlKMEdtTG4wdFNDbWhpbzNnV1N1Mkd4dmhXMXNnRU9XUFZnbE1Ea0EycFZFTnlleU0rVjFsNG1TbWx2N0FGd25Ja081Ly9FOERRYWxOMFliYjhWaC9Md2h1Z0g5Y0NSdnlPNGcrVU1ROUEyVUU5Y2ZZVW9Xc1FvUng1WVlHVWlIYzlsdE9aVUNFVXBXRFE0L1AwRDR4d2FZZlFGSXUwTUdCbE03dDVleTJkQm5JcmRFWlUwUXRGeUdkY0oyaHE2TUJ5d0dWOGM2cHVWVk52b3FHQWZqcFNteXdQSS9aR0VmelM4Y3VUeDVrbU15Tjl3TndpYWkrUGwrMURFOTlDdXBYcytlc2JGWmRGcGVQbnVQdUxFdUlKbjlsSGdPdklEZHcwcHBJZW55MjB3bld5KzZBL29TQ0tORk5TdEZzVnpZWXJuaG53bXVxemZpejd4ZndkZEU3Q3ZvNHRFbzg0SkhmQjVSaGluVEVadnpnSjRkRWdpVWQrVEdCK3ZCd0hXQ3Zqbzk0RXU5UmpScnA2YWt0dzlJdW54MitpdW8rWEg1MVhGTEszNXoycStaUTFERkhpcWhoRUtlWWRZMGlDUmRFZ2xDcGxrUUM2WlVFZ0RLS1VoVkpMVnZJUmlucGZ5L2VYN29HaEpMcE5ES2JKWGU0cjk3citxNitJYzkvOVg5QmhyM0hmWGNJSlpPRVhCR1FyT1ViQkd3UVlGV3hTVUtOaWg0QUlsM2dQN01RcWJQcEhHSFlQdTljRTRjanFKQXBxR3Q0aHdOM3kvZkVsMkFDWUlZRXpUdHJKaDVvM0NPUTU3ZGpjMWpiamJGeU1PUitHZURVNC9vSkxadnZnUmVHeXJkcEpzZ1ZrSE5zazdUbDgzSy95L0FBQ3RoN3BkampFYTJKZmtET3hqY3JSUm9vV1Y0dHQwUVh0cHYrRzFuUUxGNjB0TnZxRm9ZWFFkYlc0VGtTblIvanlmT1ZIWG1SQm1qbFdUMWZmbGtRelAzOGw2MzBINHlSRVJyYVZ0Y3RQR2FwbGpDdXpuZTNnZWp3Vm96Y1JJMVN2WjREY1pZMVoxR243eWVuUHFmbXBwTXplZlJidUdSSzRWd3pvdU55c3lGVVhNWkdySnlLRXhMcFE2MDRKOXUwaHlTc1FzTnFMNmNVb0trQ1lkcDIybkhISk10cEgyc01XSVdWRHpKYWRmTWdMMWhxVnV4QlkyeGVTTWJrZFFZbEhOazJ2MXcrMGJlbUtnd1ZOckpJanEvdlo5OFJ1THd5WStCdW1RQkM3MHRwNE9oS0diaklIUVlsL0ZYUUwzNDBERC94SFpEcU9lRjNaMTVOTEdOQXVTVUZxSDNxMHA4bXdoNHVsL3hPSDZ4emI4SG90b0VWUzZtZDBNblp0YXdMNjFaUnZES3JML0QyOCtkZDNHbFY3R3lwLzFKelh2M2xuaXB6VWZucWNWb2RaVzVzcDJ2VWpaY2l1R3p5ejRhZWxLYXZSeVRlSm9qRzJEQXordnk3QmdYcXkvQ1A2cm1GQ1dPRUR5MHlmdjY3WVRjdFNLMlFkZk5LT3l3a0Q3OHFCVXRhSno1a1Jnd1BoVjBEZTV6UjVwek0vNVNzNzc2bnpkL291NmdIWVJYbFRiTDJ2ZVJ2alZkUENQRkMzR09mSkF5ZngxSGI4UmRxeTlmbFAzR29uV0hHT1NFQzlEbUpDQVpJVm93NVFrcE1zUVppUjZaL0ZUb0VsanppWGt5eEU2THFDd3B5QXN1b1JTT2NLeUMxSHBEMXVrS2hGUUswTllsNEJHaFVoZ1V4SmFaUWpiRW5ySEpteDJkWW1FWGpuQ3ZndDlBQVJ3NkJKRzVRakhMcFpOVUpUUjA2ZVZDTU9GZTRZUk1mYzRGUmpsaTF1RFpsakt1Rll5c0Y2b0dzU051N2gxVjk4QlhlR2VyZUFnQTBjWjdmUXRIcDdkdzR0N2VIVVBid3pBWk9BdW96MVFmSHk2ankvMzhlMCtmaGpBVndaK01rUCsrQm4wNkV5ViszSm9vRU9IdXJNUy9KZGdFeDRJVlhZSUFGNEVnQjRIUEFiNldlRCtFaEJ2Qkw0V1F1OUJBd0FBVnlaRXdHanIzR1VLV3EySjl4YmVHa0o5R3BDNWVvUzgxcXRPWnBsY1J6MEdqUUxSZ2V4dW1LRk1nV2hscUxvRjF0MGNOVHFCR0ZNL3Q1S0FZQUM1Q1VOdjBKdGZFcEVqeEJudnhKZ1V6N3ltVzhwa3JNL3orbks5RlZPUHpHbnNUaUxYWERNMnVLYmJzZmZPVU5lV3RXVzIrQk9qRlRNelg3dXViMTF1cjRmaFlDVGVKeVp4WnNWaVp4dzYrU0NWTEdidU9mYmR5QWtkdm9wYlhNNDd1Nk5kenVqNW1uSmVjRDV5U3NaMlFyK3czTEk2NTlRUG5OK1p5NHlNMXJCejZOcnRCbTVtakpzb0V6R2JpQnhYL3ZyalY4NHgvSVBsekt3WFlDQjRrRkNYcFNiR1g5UEErSmdROHIwUEVQcWJhZXN6b293cHg5U2tTWmx4cWhRc2FlZkNRa0w2WEs1Y3lrTHFucG1FZjZmUG1WL2RnNFBiZFVyS3FSeWtqRCszdHZOWWlsZkxjcVM1U2FiR2JXK0Z4UzViV2d3KzRIZnBkQi9MQVZZOVVuVGh6KzhMN0pQeGRNM1FQY2MxenptV3dtSWpJRE50MTlSMzJvMUpXTXFwVmxNVmF2WW9udVFhQ21hUys5OTRZLzhrYnRhbWlWSmp6dTNXa0lwU3VOVllsdDdNYUppQXdOenNKeFhIUXRYUWtsSWVvWVlQOEJjV1FpY3hCbEJRU3B1dlBrc2NQQ1ZRWU5xbGptQUdJZW91YWFyZDlzN1V0bFJVZkV2K2J0b2Izbm5JNUUxTEw0ZFdDU09Rdm5Nb09ZNVpEWENXWmo2TjdkZXNpNEJrMno0eWVMeGo0TDJKdFhFUm5taGhSOVB4NndFZmpKQWo3STk1cWVWeXFkL3lXT0ZkRE5ic2Q0TW45ZWhPOEgvLzlLL3ZvanVISmZNRjBWRENZNHBKdDYwdU4rS081RlcxK3ZaYmlyTUMvMTR2Y3pTczVlN1h6Q2JEeGRZVWFnU3RIOUNTcGViNnFmRy9tbENaMEFUTkdCYUxKK0pIRWlwbHYvd0djV28yMDVNV3lubVlnVmFPSzFjMnhtYktZVVpDcVk0bGF5WGRsQ1lxWnhZMFd4eHRKVmQ1OUwxMzJ3S21TcEF5YmdzRWJaRkpaclpIaTdORGZXZldKRWZUb2ZxWW5ySVFpblREZmdoY0tuUkQyTXZnKzcyalhtVEVITXdTaCtxYkgzUW5UQVgxVk9QUi9pQW9CaHlkMEFVcHBSNWlaZEtRVjFrU3lpRHNhZkJOM05TVERlNzZKZTZETHZVL0QwSW4yZ3cyVGlaOXFxZW1vU1dPa1U5M0JKZUVYc3MrNDkvOEcxaGJrVlZuTHNmUHpEc3NmSmlnNFRZNW1RSG5nK3FwbEp3QzZoQkd4OWplMTJSMmovaGd0amp4UU9JSWpXcml2cW10Zm56UDJiUkhWc2pGaGhubE9NbUE1TDhKREt2Slk0WVFIV0dVTWtqWEFJM3lXSHBZZXhaNURPVldyQnB6aVZ6OHU4dUIrZUJwTTAxckcrOHdVdCtMU29xNnZ6R00zMnMvc3ZFQmJxV2V5dkRaay91dzVFZnpyMlFIZWxUZmQ4Zk1FcDJ1S2xHWTFTTzNPWXV4bVhXQ2N1VEFRUG9jTUJiQ2pOUkJ1bHNOTEUvZkRqRjRoWE9hVHhVdURjdEVOY3p0SGlqdTlrekYwRUZDTDV4WTN3bG5xY2UwZTJJRnFjd2ZFUm1FVFFJaXNlMmpZVFQwaG1XZFZYME5GaEhRaHJCYlg2ZHg0V29ub0ZKelFkRlkrL2crdkhMK1drSWROYkNxZzFWcmVwVkFjeFVkTmVsaURBdlVnalQrREFkV1ZURUFIeTd2Mm82L2hNN2RKL3owS1dWWUpvS25SdWlNUTk2OTkzcWRZb3V2eXV2R2VwcU5oRzVmUEVtNWJLamxJRnZuWUdEY0UyVm0wTDZRQjJRWE4vK09kRFJJdkovczhwajZtcmd2UnRQS1BZazFNek5yd3U0S0szTFY2N0VOWFZMejcxamNyUnZiN2VkQ1AxMXBUSnlPdnVDaE9DbEw1MFYxTEg1b3ZoVXF1a2V3b1VlZ09KNkFaajJrT29hYUZhMVdOMGxGMnlsdTdFK3Bkamx4eUc3Q0F3d3greG4ySTZmVXJXcFhpVjg4MUM1UTRnU20yejRzcDlIWTlEUXJkc1NPazk5REE1ZlRJelpXZzhFdDh5Y0xiV0RiTVJyTkZoZlhQS3BjcU5yK3lnN1ZJMWtyaWF6bTV1VC9qSUZtMzhHa0czSGVZMk1reWZNWUsyL2tXVTI3ckY5am1lVVdISzdGd0RXRHB1UjFXUW0rUzRyZWR1Z1NpVmxNNGZSaDVyNU8xUEkyU3ByWi9Ma1cyMmNYeFdCTGo5TTlSUzA4NlROUU1qTFJIb0xUK1VRVW9wR0V0N1ZKUThkWERma21Oc2NiQTErSDJmUnNzYlU4MVJXbWdLMWV5Q1RMUEdTU2xEUHpuRWhDSDVnTXhxSDhYc3UxUzRjbWRzSEg0eWVYYkpVYUtkV3RYRUx1SitjQkNqT0NOSzBodWwzeTJodTZ0bjMvOVRkZmI2L1RwZmZ4WVo2c3lLS2ovcDhRbmgyZ3ZXQ2ZhQmo0TFZpQ3JneENidFcvZFB3YjdEMWFrdmJtaFZKQXFmUFlWMHZ0cFB3dHB2MmVucGJ6VGpqMFNTNmgvREFoRUpiSU9saVhkd29ON2kyNVROdnRMZTZjWW93NEIrbEc1NTJNdC96dlZPWURvZm1UckJ2WWw5NTRkZXVGSG5uNXpkZGYydE5BK3hwWG85ZnNMeG1PMGZsUWlTQTgrelAyZUs1SC85b2pGWHRubmJwSFpSLzZacEJ0VUZreTdaeTVCSGIydTBoaHpTMVlnVTREK21Kc3hYSWNBbll2MjhZTXhwMzh5Q2lNemp5Mm9aMjJHMXFGVlkwd0dqa091NmxmSFloRXFhTkJBYU9reTNQVXlodW05L3ZUQ2xncGJhVHp0ekNUcyttR0V5Zi9Ta2RaNk55UXMwNWRsRHBwSEhPUmhNOGQvVXZnWXZkdmtrRDJVSzBydTJGdklYSEJWR21YQzZPNFRnelBZME96czlIYlQ3bHhneWJpWGNkWlZQQ1RHWm5JQW0vWGptdXpPZVczRkNpR0dXaEdpOTZmN0NJSUx4d29YaHRxclIvSnFTTmZodG5GOGpVZTZma3RzY2E5dEFxZmM0ZTRRNG1ZWnVOcGExcmNYSDAxTTV3bkMyRmEwNWxQL3AzOFp4VldTVkJoam1MVUJEWDJ5RWp6VVp4YWk5Rmc4QmhsUFVaMWU5bjZ0V3BNdm1vQ2U5VHZIeFJqc3pFc3Z3M1RkYlRyeUtudW85MFltNS9sSHc5aXRCb205aWkyVWNzc3d1VHlXeWN6amp1VDdydlFoYTdDRnRBNWNaKzRVS08ybkZaclZqRHkwWWZ1ZWZrK2g2VmcxSjdUWnM5dWkxQjRLSWNVZ0NHOEhQVmMra09HZlMxSzl6Qmdpd0pXaTg3eWFIK1JWSkdkL1ZWVzlzNjdIMTlZWm9tTjd0MXgxcUg0aWhTMW9UYUVtalZsWlYxTnpkVHQvZWdlWFMzZzcySkYvSGlXZER1UFFzYnNoRXpCa2ZtY0g5ZGw2Qzl0WkVPeGFuZ0NkMW9qOXJHNERvN09GakFsdGp3VGpCeG9mUHd2czUvNzAzeVh1UDM4OTJqVVZuUktabXZtY0JSSS9HOTlUb0FvZnlNVVZyd3A5d2JWUElQMFJvMVBjcDF0Q0tqQlJJNWVjc05YTGIzSjAwcWtWZmxtdUZOdzZtVmVFSEpoaUU3VjFWcFRvL2JVYUoyVm9odWtEMUlwK3JyeXRFRjd5dUI0bUJTOThxZlhkaDZKSGRrVjNxVm0zRWxNYlJWODdRTUxmd0xYY2I3UENSZlpCdnphYzUvWk1yQ0NIT2xQeHZubGtxZzMyY3ZkRFhKNWFjTVBTWnhJNitHWlhNa3UxTlBwL1BtdXVMK2UvaTJYdCtHOE4zNEF2UzNTMjlsMDdZVXpWUGo5MlRsM2ludFFhMXRyTFNxZWxjYXdzQ240c2s5N1o5Z3VxOTVieXVlNjNWeStPbWgvcHgxTjZNOHZPbzNCRk45SjFuM0pkdlYzMyt1eURiVDd0WTgzTTF0aWtPWlYzMGF2MU5ZS3ZkY1AzbUtTYUxWNkNzM0lQaFFhSDlPQnpweFd6UDk5MGNUT2hwS1VoRmprSnRDV2dpMlJ0K2c0aEhLS2lGVlp5U3NSVi9LNGxiQXk1MzUxUTgrSVp3R3ZPb21HWVJHSFhjRG1iMnhDd3lKN3NNSnAxajNXeGgxWEhneWc1MUFVRFpQRHNWWXlKT0pLQnRmS1lWSTBtcDZIVVRTcTFrem1jTXhrcXBhR2VyaG4wMjVvWGg0a0xROFN6SWNFY2FFNUhIWU9UeGpDNHVid3NpSitGWi9yRTdJNGJUd2YyNVcrQWFuWjJIVURSZFdTcVJhQmdPdno4a1FGaVFjYVViRFFQQlk3ajhVdFlvV3BhUkkwc3NsamZmbW5sMzUyVzhIVWQxLysrZVdmM05aa0pWSUZ4aDdQZysxYjNkakF5Q2hNelMrQU9vY3dDYTFCcDZyVXc2VTVXTUwyaDEzKzJuaU1ieVY4bHlwRHVPOXpDQjIrT1ovWXhjaFVrR3pYWG9Jek5DSlN2YXlFMG1LUU04cndCa3NZam9PMmk1ajRZQUxFYlZtY3I2aDBiWEc1dG5xOG5XKzY5ZjY0S2hXVjZic1lTdDhmdXRYUmVidTd1K1AyY21kbitHcHI4elZvWi96NGNOejIrNStrVVRVU3RoZTNHaU9WSzdtVnNlUFVKZmdKWGt6eWpQekQwZzlwR2dwbkNzNjJPM3hxL09GU1A5bklFUEgwWml6K3grWHl2SmR5c3o3TVZVSkQ3amZ6NVFYNXpPd3FTRVQyRHRBdVYwYTlLZDdDTjg5WUZyTGtxVHZwZDFTRm5ES2pOY1dLeTVwVDFIZ3d4TWd4ZGxuMFRBMVZFemNRTDJsVUtFZnIxaHNHMi9qaVMrZUh4RktyeWlTcEV6cmlwTVE3TjBNSElnZldmeE1Kc2dPUUNPdmVqZEg5VEE5aTdLWUk1VjJnUTY2TStwQStLTm5NS25PZkowdlRWM1FuZ2NCWG05MUlOeTV6UGkwY0Q3UzMvOVNqazdVMkZ5dUVyN1BZc1pXbGxSZzlHdi83MHErNVQ4U1kwZmgwTm05OVMzV2JrYXpJLzVEcDI1V04vWS94VFhNUEMveFNYVDBmdTF6QlR3Njl0N2ovM1V1T0JYUkxPRUpnUk1FVmRJaEdqMm5EYitwN1hpK0wwYUt3cGJTbE5PYmZMSGJYNDNwRGpCNENIeTgzNDk4Rld1VUs1ejJLYUd1ZHN1MEh0Q1Z5dXBWbVY0b3JzN2xjeFFjb3psVTZtKzlqaXFwVUVxYXZncWN3N0l2U2RFQVhBT0lMdjhWVE5wQ1NlNCt5QzJDTkxjclNBWHUrSFFxQ2loL0hJVlZJZHFJMERxL2N4R0tWbXJUNTJsS2d2RWRuOU81bEdmZ1I0M2laNGlxbG1PWWRhRjdPU3E0by9JWklpWkhXaUx3RFFKTnpiVmwrdkY4WkxLT0R5bVhiU1FLVmZwYVR3N1E0YUFMbXhKV05WMlB1M0JvWXlIOTFUVDFQSE5CQlRFTWdSQTlJS2JTRU11ajhLTlN1RXdmcWVUTE1uNHhyakppZVlSanNuWW5NWUk3UUIrbnQ5VUx3OWlraENxcGROUnBLMUphNUl6czIzcU1yZFdvRmRUVjF1dmR5MzVYcHEybTNVVVQ2QngvR1BqeHVIb1lGUDRJMmZqUU1RNTIvOUozaSsvRG93UGZLN3lNalJOM3lnNWdXMEduallnK3c2Ym1OZjdDTDZyV0E0U2IrMFprZWlvME5EbHNzVDkxNStqN29Tc1VtSEl3cE9ycGJnT282bkZ1WjdTU2FqMDJjb3lXYTR0RFlmaER5N2E2NjN6VEk3R2VUNEMrZUNIb2xpVlltSXpTWHlxa05PaEV0OVpPdjQ0Q2FTRVVVaFB6U0djeHhybm1oaUtUaDNVTkN0b2dLYWs0QXZtS1d2d1JleS9MN2ltV2lHdWxJb0xTL0xvKzRrd21QN1NUbTFUYjZGVnRxaEh6K2NhTXBBbFBDQ1VxUEJRVzBCT3VubU0reXQzNytTOWZKcldjQm40d2RMQ25wbEVuSi83VlhTdG4xNHJ6VUROQjdzekMvZFNwVTVLa3ZVeGtTY1UraUMwOUFaSjkvdTdNQWtXdzJxbU5xZGpNNzFleTJhalBndS9Kcmk4SXZOYitrMHNWbFNwV3VlcEdJVzFrcEtEWTBPTUQxMUtXM2NialQrT3l1Qkl5MFNzcXRsd2k1OVZVeUtSUnhYeWFVL242YVJGcW1NNVpKcE5PTTdiamxSS25CcDhMR1ZuRUlLZzMzQVRsbWpJTHZNNFAzQXdqRVZ4ZVk0WmdzQ3VJM0xFMU9IVnRDYnRDTVEweW1Pc2llS0FpSk1lRTNES2YxdllRb0xsL1diVVgzZ2N6Zmp3RjJMMy96eDdWUVN1eEtEeGl2Z3lyZndKR3VmNnhTVUhEVkhYVmM3UU1Cbys3RFB3dFVGM084NitINHE3bXNFOXdmRXZjd2lDMW5lUENTTXlUU250L0VlMGowVVp2K2FZaVB4Zy8zZzNFK2txN2t6d054WWUyajhTamVpVnZUVVRDRm9HNGNpNEk2Z2owNXprRHc1bXorSXU3Mit0ZjA2cklwUVFHZFdJZmtNN1VRdzlIWXRVZzhxRU1ROXdBbXdtZkNFRzcwTDM5V09Da2xOWHBxWUNPeHROYWtMZmJLdTlzdzluOThXYzZrNVA4cE8yY2VwcFBlTitNWXpCZmxIUXpFRFpzOWN5N2J6YWE2UjRYOW90NW9mRlRmenpwOTlkb0FvSzY3aEM4eFZ1aHpvdUNxN2hSa0NsK0c3QmduTDI2Nk9ObTI5b00ra2NxRjhWN3V1TnluK0VyNVZkOTBMTU13SmQ2VVl6S2tLUXNqdkxjZmVYdlNQZUdabVB6OElqNzgxZ1RNUFZzNU93NUhINzU2VGlOY1g4Y3Q0WG9ZV1NJdlJJb20vODRSdkt2dVlXckNCUWhSM21zNTgrYlppS0ZsOGFDUWNuTkdMeEZHeFRMbzhaanMwa0dlc1NSRUVNR09RaDdnV2JMSEtYdzdvQ1FTSnRqSExpVEIrblI0UTlWS0ZMREVjalF6WDhENllLbkgyUk1Fb2hLd2wxSEdzMHA1OTg3QmhzakVrTEdFTjFpYWpSbE9wVXVpUXIxRUt1Mi82cUFqV3N2WldjWFArTFlsWlVoT2RaVjhxekt6TTFxL2VUa2o0K3RuK0EwWHlsOGU3VitCRTg3Y0V4VHdwalE2RmdJRnR4a0EzQ0VvektsSnR2Vlo0ZFplbWU4TDZPcUFBbTV3aDFwQVRMeGJadVg1d2d2SmVWbGZEb2oveW1EdlZ6bmQralZPcEMzQWxyQzRIR3NGZzFleXJveFF5OGo1QTEzMERDYjl3VHREZ2Jya1Y2QnNSSHFvLzgxMDVOSzNZcG9VcTZXSjNhUnBzc2FzclpwV2RxdkZzVG1mbDVJbGZhR0xUYzJYV2x1N0oxMXNibW0rN05zOExSY3ZKVm5hUmszbVVVczVsQ21oM0RKbXRvemtsNHBsZE14azRkczlBbTYxVU15dDh2Q0ZOQlAyQmJOdEh4Mkx3ZVA1bVBTMDIxYmI4d1lNMWIrVDZPSnlQVHdlMTQwb2orL2UwTTA5eU1rdis3U2NRTEI4U3NDL2F2bjh5cGUvaXVlOWlkdk1RQkZPWjdOdUF5eXkwTDV1UjJMS0lYc2NzSVcrY3pGeWtZYkQweTdnOGZkb2VGenhSWHk2WXlZamN6WXovV1JHK29sME1md1ZON3JuMWE3Y0FsWlpoNStlVVppV1Y1Q0dQQXFiMkJKd3F1UWVMdFhPRXRZODRySkhjcEVtRDI2YlUrQzNsK1BmVTFvcnB5aStpVFQySUNRTmNrakx2dzk0Yit2ZU1EZVpWWURwUWlMMlhTempGUmI2cy9mY3FZVkpYVWtwWjlKVHpwZGIwNE56SFdjRmVzeTgra3p1Wis5RWJOcHF0eTF1WGxoMFdEWnYzYnpGOFEyYmVzQnZMNjJhZ2xxQWFVZi9QL0NEU3JQYlhHNm5wcGJuZnoyd092cWI3OHF0YTlRaW0vSTVrN2Q4LzBVMjk5U3JpMzk3Z2p5SXpoSjI4K2VSeXdFN1p2eG1kZDNnNDhvd2hhOGRXODVUYThZZU95dHc0TjRuNWIxMFViY0JSS3k4OTEycGtJclZxYWhNemx4eVMyNWF0Z3lkdTNkNExKcU4zUFBLM1NlU3NoS0NCUTl3a092N3hoSDJROU1RNHMycy9ZMUp2ZExoeG9nRHJ5OURTWHFTdHpvTUR3eUhRbEsybi82elIwOUFIc1U5aVZaK1NaL081eUg3SHJROUFUNkxaaVAvYWdQR1h4S0hEbW52dDUyS3hKUTk1UGxTdlBlRzgyNTlwak45RGFRZUdTdFlJbUUxT0l2NU9oT2lqcU5oQWcyeWg3aXVScmdDbEI5bGIzYVNqNUpWNUtSUEwrOXlLeWdhc24xTW1aS1BHSi8yZVZzRVRmNDRaVnRnMjdHTE84ZW1lRWN0cU1nUmMrdXJwVEpMaU4va3psUWZKTTdNdHU0ZitsanZBSnMyVzJua0thNzRnSHFwTkZQSVM3ckl0czE1VjBZbTRlYS90aWlZMFM3OWlxUXVZUEFYK25ySEo2aTZOTW14NWM3RnlBaWI4VXh4SjdVZlZITkZ5Z3N3TGpydC9JUGFBQ1J5Y09lWkY2SENCS3ZjbStCOFBiNmR1VzJiaGNtUkZad0l4M0l6b1ozSkQwdS9UN3VaSjBra1hKV1JuOXhPVmZxTDlhY0tndGxwUXRQNUtIanRxVWQwWHpkSUdpLzBFYzNnZDA0OFNCUTNQbFlEU3BNNjVRYkZEOU45TXoyZzBMVDdueWp5Tk1PdXhMVWZUN2lvWjc4bHBqNmRNNTRGczMvV0xmdHorQitNZjFzQlloQ0Q3a09qcDlDWTNpTGkxditmcDlGdk1lanYwV2pmMHhJVDNHUW5EK25BSVYxcHlFbzdheEVSWHN5eHN6NUlDTCtmc3lhSnRXRnpVRk9zUCtwZ1dmK0R4T25NLy9xVG1IK0NhYnB0VjdVM3JFTFVpeElQUWZyeXZjNmN2T2ZIRHRUSWVqbjU2N1RGOEo4cUVPNkFHb0YydmZHOWYrUWtnZDF6ZkR4aDdZbUsrR2R2QkZCRlFSVGFYVkRrUnIwQ2FEQW9aeUhLaFM3VW9LZVRIanFqUHlFVkk0R01HcEdNbFpHU3dwS0owbXRIbXB4cC9ndllTUDh5Z1k2ZmZ5RXNpNldrSUtXb3JPZTVXU3dqOXkrRFJqcmROUTBpTEI4TVVjL3p2NDdiL1JQYXNtV2Q1NVJWWXl0eis1NU1sRHc5K0hYK282WHJoLzQzOVBOUTFnR1V5cU9LMnY2RnVTRUZOeldNUHVXUHdmeUhZTG9ydUIzU1YzMzMremUyekpPYisxcU9Sdk8rbTluK3R2TGU5bkJUNW1wYzY0N01rM2dFbWhmQVBkQis1OTRiQmoxNW04b3dOaElyRlZZQ3cxMyszRVRpNFQrWGNtVTRvdWFVTU80RVl6VjJ1YTlOa2lldTV1YzZiczRhWmJ6cElYcDVNbEtIaTk1VGVhTDNkQjVldWlOSGJSK3g0dXp6Mlc0UlhYN2VSNGFiMjkzcFVZNDhzOEk2c3NpTHM1VWFJZ3Exb1hMRUVqMWxNUVdhdEdzcjlKNktxak9kNUVaM1VZWkZtOG83ejdXRDNISm4ycUxJY3QyeWFLelk2SXlZaTJMZUtvbzVFc1U2NVhYYjZ6N2lwTVA4RXBXR1ZPcmdvaktlcWRRUTI2RFdMWGNiMEdmNm8xWlp4NDFFaXhTenNHaUptN0tHbUliYUx1MHNXclNVQzcwKy9GcXZSTGs3amN6dlRpWlB1Wkc5cDNLME01MXdJOHFCSHV1aEhuRm5kOUxOWmh2UmV5cWN6clQvRzkxdVhHb1lqR2tuL2hnOXR1cmhndWkxZy95aWwyTkZMNUhvMVNtbWE2TXhhQlVQVHhvK0hWenBTdStwbk90TUo5WkFPOXBMWFQzZGkxaXEzRDFTWERiTlpYOVA5V0JQZWdwSDRIaU8vazgzZks3bC8rY05SdGVmY08rT0dXOGs1L1NaTHQ3dmpjTEYrLytIdk43M01Wa2FlV3FxOGJkM1MrWnJGdHlaQkZSb1YxY285eWJ0dG5xU1czVTJuemcxbEZ5c29FV2I1RnhmdXFrQWUyYjNlVmhQdEVFck5wVXZWbS9DZUhBM1d4a1Z5MlVoUTByNlRWb0UrVTRBQW9BSERrMFZEbTM0NExvWWpwM2ZCcURuOUt5ZlNZVkUrM0tlV1QrZXlYNzFWdWZ4SEJJSFBEQ0JubWJFQzlNcDZFMDNwdDRzNEJWQzY3dmNKdGZKbHV6eUpGVThDejI5YUNVcW5sbDBwR3JJNFl5bmRoZnd4RkltQ1hUWW9xa0V0T2xTVndSb3E4V2wwdkRML0FYSi95d3E0dVh2a0RLUTIrUTYyWHBaRjZvcTd1dEZJU3RsU2U5RXlFRGZIUWRibGZiV1BBRDVNWGxaM2lkdmV0bW5aWmZmenJrbEw4dVh6L2hVeDRBOWMxQTEwRDV6YzMrQjhNTzlCbHJKMitvNlhwcHRRdEttbWJrbDVHWDVzcjlwMVNrbGxUTSs5MEMrTDkvRUJhK2V0ODZLUG9OUnh4UERWMFNuWW1Sc01uTkVKbVpZZGc3UHdteVVDWHdyQ1lhZTlNSDRXSkhKeVZpb0k2ek04OVA0SGw4alg4U1Mvb1VORG1PZUVKZzNQTHZjRzJlSWVZVE1TK213dUxtMHRycWl2T1F6MXFwckpua2FDMjZGc0hnbHFDa0FJbkNINURGaUgzb2RUUnpHd1pPQ3FZMjZDdXBMendscHpTKyttcTQ3dU9qS3pMVzJiZVBWV2g4cDBxSFdZREt1U2hRbzhpejliekJyeE9ZeUd0d082cEFSNjk3T2FrR25CSHBBTU9VSkFtUURpUzFBY05sVlhVRHJOWGtmYUlXTy9XY3RLcE9SRHdEY0M4aERyZ2RPNDJqRjh6ZzhXbW40Mjh4UFlzL2g2NjN1akVLa2gvazE2djZ1eHFCT1I4N1kyaUlkWEpDSmtRQjRXQmRxdnJBQlQrRXk0QWk1WW0zS09nOGltWWRtdlJGVUJCRGlXd0JrQzhITGtXdjFQSHkzTC9HVkFaV3pvbnpCdmIzbG9tdTFXTndIT2N5dnMrN3Z5cGxjSHBOSDllcTgrMVcramIxOG41NHY2ZmlwR3RTTWJ4TVdRV09IaUNJTndVdTJDdDZNeis0N0UxOXB6SW9xQmtCR0Q4MXlBRGhZUEtIcjJhM0cxVjc0RDhPYmFRbE5HQUhFdnpLd24yQ0UxYXlURC9oanY4b1NDUERPekx0YUNVSnRBM1RLaHpVQUE5bFh0Snk4bTlHZVRCUFdnSFc0STlKNXBOallvdlpMa2JaU3FGbjBzNUxrc0lybHVlK2tJakxJOFFUSnFSblI0a1BzMkJJaGZOcEFQU21lcTBJbHdxWnRCL1U2ejlHWURCRU0vQUtidzdYY3pwL0tMQ1VGYnFZK3lrUlRucWVMcHBOYVBCQUhURVI0VzhSWlBvNGhjTW5LazAvY09TUUV4V3g5QUNsZElrU3NIRkVVQWRFOG1oVVpRZ1RKaTROMnpxaTVuOFZJSVE0SWtZcEpHQThNT1k4RE1zdWRlN0VveThWcGNkejJaVmZLZGQ4cS9Ld25SZ1lISVVBRUovbTF4d1NyVlRLekpnbVFORWs5cVJBamF0TFdKSDBFLzRmbS9iOCt4MGlQZ0dWeXl4VlFxSFFWdG4rWHhGZHFoSkZBMHB2dlErR1VxTlhZTzBBSUhDQ2dFWk1WZ1JVLzI1VFZaTm5XN2Nyb21pZUx5Wlh6empPSmFGT2wyd3NrWGlRbGM1aGZuWjYvNmkwMldjMHpGYUVhRTFJZlladW5TSVNZWEs0bzVjU3RWWTVGTmZaRTBHcXVqV0FaSi9QWlRtTEFNSW82dDdkU3JaR1hTNVFzUHk5RnVUYnJVZUo5KzlmdnY1S3Q5dWtwYXJ2ZUNtcGhNUlJtUVVBeFM2UmcwRWhlV0w3UVZKZUoxZVBQTk13Q2dwQ2gzS0V2UTl5TFRJUXN6M2dvQW44K0xlcXl6aEkvRC9JM1lramxsSFdlc1dXSUFqR294NDRkcWkyOExQUk80N0xxYXA4UWthWm81YVJpWjluWmRjKzVVQjhrbGdpWjVtZEplcUlmbGhkenNPejM2VkpJb281Sm1CTHpFVEZZNkpCOGY1S29iTWxTSGc1OHFoWGV0ZGJNc1NaelpVSEhIRE14WjFXL2c1RHgyRTZzZ09uWkhia0ZTemdJOVl3NXRxbjZJYWxLVUVQVHR4RFI4eWdIVjNwTm1jVFNLalJJcHFjY0s3QVM5MzNoaHlaaXpHVUhGNjhOMy9kZU84V205VGRHdzhSc21LWU9ZTmpyYTU4T3p6UWJXcEFkdGFTaXhpRjRMSFNxYzh6Y012TUpPNERZTk5zZkxFeHRMWUUvYU03YTUwQWN1S3RpdFJoaDJWOUJnVis5aXU3dktnWU5pMFBueWIyOUY0VXFvUm5XcjdBczJQQ1VsNS9hcmFTYkdoVHYycnRFY0xNU0pGQ2JHVWFiUkN2MHBLYXh6K0hoOEZVUndhci9Pa3QxQmR4ZVNCVnZBa2pyYzZ5d2xIM2JrMm9FMUNsZzAzVXVDakcrbjJZNGlqMUhBRCtvUTN0c1VKQjJVRm9KOEt2Q1JQRlRvUE1uUjdWYkV0UUxjTkFZODhtZURac3p3Y0tQOCtCT2FIa2M5djIyaWlGS1lZRTd0aGE5dktpUjBKV2NnVWxxdXdaRHhzWkhMVlhteDVhMmUybHVHbXJvMytKQnFlc0czR1JBMVBQVFpTSGc4OENuck1tYXBIcUxiWDJMMkN4Zk1pOU5ORUJ5Z0ZZS0FRQmxRQlhZM3dYQ3czdFYxdjJpajkzM3NlQ0RYNzE2UFg4MTJxNWpIYTRXb1VGdlFnWU5JVjlpcG1BYW5BVlkyOGVrWlhlcXFnQTlqWnlGcEpNUFlhMm0zSlVkS0lzMmxNMWMvd3V5N1NiUUEvdGtLT3BLVHFEN0tBSjRReHpUV0Y1VlRQU0pYbmZBQWt2aFVXLzdUK09KaU9SVVpNZDBjRWhjWnhKdllObldWbGYwSGZXZHI0ZjRHMmlOS0pLVi9sQmdObWhYaVJSUW9kRXpDRXRWbmZBamYxRitHQUxoT0t3UUlKQ3RUdTJXWnh4cElvZE1na3J1aUdpYld4TDJPWkJQWGVxNFJJYTBqbVEwMGVmSDAzTWFNazNWTTNxVkdMbUtEb2t0SlhmZG9WUi9xb2dTSmdYK2dzUm12R3NWd1VEK1I3S0k5SnZXeVQzclFRU2RqdzFXenNNRHlheEFBVk1MOEREUVB5YlRZK2pDTFpnM3FSTXpVOEx2ZnZiNEZhVmcxcWtHYWZLRWxaNzJBdHVrVFFQdDgvR3ZiYnVNRG1OMmphU21TRWF1QlIwekVVYy93b0tRRHJLbk15eHU3eHRoOW9reUpUVDAzRHRZZGlWeHBwMjVlcHBpWVpPZTQxai9LZGdJTVIwclhRUVh5dW1RTGcxbUFoRms2VElnNjZFZnZaTHl6alh6QUx5UzFKWEtEM0wzelFqKzg1aHlpQStvT0d0b1hzWDJrOFk4OVFMbkdwY2licjZaWS85bGNHWWZxVklyekJ3M0NRVExPSld5TEY3c1NGN1VtRGNpRElJNnNPaFo1ZUNuMWZob1JhRTA2d0YvOTNwQ0xOMVhwVy9vWXdMNkMxQTJGVHBSNjFVVVRhS3hDTGRpck85RStzNnNRK2lnaTBEZ0dLMVkwQVlDSUUyQUx2b0NUbWdhVFhRM3cycnZRRVR3bWVvaXNuVVRpbzlCUGJXOW43cE9FK29nT00vK09aWll0R3VwOXpHWW5aM1dXRXNXQUIwVnhMTWpSQ1ptSDZMaG1sZ05XTlNCR0Uvd3A5VTFWMUVHYVNxdm5ScU9IRUZ5L24yMWlpcEYxYjY0ay9wcTlkWHNTU3FtRXFzTElOSEZjbCtjd0xjVkNSK2g2RWcxZ2pHSUZVczhFV3FSRHRNOFY5RTZ4cmpXdFcyVHNLNUI1Q1NoRURyLy9pTCtraFByQ1VwcXdLTE1tVVJCbGpsVHlyOFFCcmhCQ0NpbTJtWWgrQnlBUkpzbWZpdjRrV0Z2L1psdVVhaUpscUxmdkV2eFB3ajB3QWJDV0VnYlFLOTBJK0tMNm1JaTZqUG0wQUJzTHQzbUZPRFFnazh5b28vTlBXejJIc3NyU0gvZTI2YW11SUNZaEpaeTBmeERKUFpPSXV0R0FIYm9ySVA5c1FMSm1TSnRVcUhyU2xheFlEdkZYUWFVQm5UOEFHazZBeFhtM1RJMVFVS2JYdjhBSFpjdmlqbUdoa1dXN3N3V2xJWG1mSk91N1pIZGttK3MycExPUEZ1VmF0YU9CcUp4SWpOR0lxNUZkRjNVM3FkUUxTaW1ialkyWVFkd1NJU1EvUDM1cVlqYVZrUmEyT05TdTdxR0JCMkhBbFF2SmNSWEVpcGJ1MnF5U3pBZU5taTlpUU5mN0VlNDg0aFMrbmkvckVqR1cwRXIrVGExZUFEUUFwb2FnbVZ1eW9MVnBVNGxKcjBwTFJnVVo5ejgvRExsSEpnK3A0L3pjZHN2Skovd2NSckR3OEZUYVQzakRLMCtIL3ZiYXpXZXZXcFpMUlJhWDZ1M1dTTmRmNjNMTE96NHFGMGRycXY0RjZvMnFCOXoxSnhYT2syTk41dG1oVGMzOXlYcTE0dHVQZ05pVXhVNm1NcGc3cG5PRzFsVlIrZG9rU0szYS9EUm0veXUxSDZWWjZ5WGFvRXlYWitpVW1rampmMC9CK015aVpRUGJmaWpubUYvMmpNNUpIbkJrc2NTdzJ6MXVjL1pzeklBa0FidUtockNMWFlsdFpZdHBmUmxyY1JLd2lnQUViZ1M4T0JNMk1MeFhpYy9QNTlrUzB2ZUFNVTBybnVTRDBpTllKQWtvOVRDZ29YSnFYNE84TW84QVJDVWo3N0E4NHBDSGZibHNtd3NpVWJJdEFzT3BqMlRLa0dTRDFpZGZza0xjbm1jV2V1UnJXVDZwNnp4RC9hU0pacjQ1TGtzUm1udExSZUdQV3dKUDBIcUp6TGRpM1dMdGJRNnBFWU1wejB6bkVDcUFJbzI0WUU2YTRIYnBaYXhUNllIb0ljUk01R09mQ2dSYnRhRGFRYm01OFZpaGJoMk5aTHBaMC9JMTlLUGtGN0RDSnF0Q2NYdHBERnNJTkVJYXM1WUNNRHFqWjZ5RjZyMHZqRVJjYWUrU2ljTHNLL1BiVi9tU1RTVFhuVlVMWlB6SWxTNlJrdFhsaGpPbXYrRExtWVRyY1diUjYyMk4vSldBNldIaU9GQzRoTlZZNGlpRXQyVkE2TDc3U1ZrMElybmJqQllzS0NXWFUxTHRjZEVMRnlBTFFXUU1TaDFhb29kWTFkUU9zeTQ4K3JVWUVyM0RFYkhUMWQxT3ZVOWNIcDNldHNmKzhOdWl6WFdValpCVzQvODNWbXJsaVRqT2FXU2Q3UlFLbzNiZ1NZZlF4VURrdHZORFZncDdxV2JSVEpqSkxMVjMxc0FaNXcwU1N5Q3JvUFNhYytsWTdSMGhLem1sVFJFNFNDbURweDQzcU00bGtXZUpsRVkrRFkvWVJ5WE5zbS8yYWRmTlhQNVdTUkZLMEN3VGtzYkIyMDdRTjBCMDNYcUNGblBRbVRHWnZJY014bnBodjMvMHdXMXBwak1yYzVKSE9uaVk0ZWNoYlhzQXZyU0Nud2NmVG9NZHkvWnJXaGprYzdrUEhRSnBBc2s0bU1VUzgwRHcxNDJFRThicHl1MDRlSmU5ckNNZWFLRzRzNDBYcTBqZEZvcm5xaDlSTjBwd1VBdkxkdUo1aXo3UHRXaWhmVC9HdzZ3L2o4RW9uSVR6ejVTczZPVlM5WGExYm1YUlkxZWN4ZHVWaTBoTkI5eDZTNjhhcDNPL09EemFQRndHeXQ1NHoxV0RaWkpyT1BBeDJYUnRabldWcmZScHVDbTZwakxZTm5wQ1EyMnFURlpLek9xZlRRaDBMWFRNUW9VUVZkN1JmdFhyMG5FZjR3YnFsc1Y4b0NFQjcwamQwRkRPcklhNW9LSmtyc2lWYTB0V3IyUEZnQVp2VVBWYnhqWWphbFpia0ZybDdWZGg2cTZueUovTFBPdUF4NjM0NzdiZFAxcUNRblpkRTBoV0lML3dyWW1LQXFxYW9SRUgwc2REc05Ob1hmZkZQeVBEWkdCbFI2ZjJhTnQ3S1F1ZVBUTE9qTE5YMWFEVDlLa1cxRWxZbVNtcitYbVFiQ2gxT2VQdHA2bjN4bFBuQVZncmlLMDZlWjQ4UFBIOGRZOUdhTVJ2WGNsNXpWWFFVYTFyczhzSjBYcVBpS2tHVHhmaDdaelZhOThtbmtIU1hEUUJUMWtuTG5RU0VWY1RIcU55YncremM2eXJOcUZyQkZuakNwbjF5WldJUXprK1BpcDZIaVU4dmp1K1BaK2xRZTU3MWVCR0l3MnpQMWxIR2xSWG1CSkRabG9mRkNpY0lrVzVGTGNVWXFwTkdPNXRJckpxNFZzbTdudzI0NEhmQy9tck40TzN3bDhaWExuT0NoeE9YZDYwM1dpdmZpaTFiREcwWFJybTAyaEZuUFo5NHFudnpMdElGaE5KVmFvMVZmWU56VWV4VVozNkhRYVJxRk04bFFyTTAxV0Rnd0F6cDdwQUMxYmF2UFRjS1NhMThQMHVmQXd6MTBFOEVlVDRMUWRWaWZ4UHFXVi9SV2Q1UzJVVWtEWWZoOVZIbytBSUF2c3Q4dUZiTVpsN1BrNFRPbURtdTVGMWlQK21lOGtyUUJKVW9RMENrU0xPcUU5amJJYlNwNkM0aWpzYWtEdXI4TmthSEdSdlVNMW9KVDFHUXpQQnlITGhCS1lGaDNvVVRNZ2dKOXZjaFRWU3hVRW9NaC8zaEg1TlBWS2Zxdk1YcllEOE1wRG0yOEN3RnNiZXg3NGZ5ZWw4OGhpQktnWUFCQUlKOEJaR3lCOEVvSGlCTWptZndjdjVnL0xBYUE5Z2RZQStFWlpUcVZQb3Z6ZU1tL2FCU1l1Nmg3K3BNdEpPbWYycVoxQzlYWXljNWwyejR1a2lENDY4bFBGbjMzeTg2QTUrVUZXSHBhZkY0VnlscXg4S0QrdmlQaGVvUitaZVYvMWVOWG5mZlc1bHJaY3AzeUNabzBkaVNsUU1Ha1MrVkFpMXlSR3BHQXlKSklpbVM3bWVDV3lKREZYSkVZcE1UTHh2Q2N4WW5QemwwU2VOUzhYY1V4WTFRalFab1puU25ueUhqa2ZpYWRLZXpqOW1VUnMwalRQZlozNWxaVlBWR2UzVUQ1bDVTM1ptY1BLbDJiblM5VitFdmRQVC9lczZ2aFV6WE9xODZYcXZDT2tjMFArakpVR0ZibVNsUlpaK1VKSnBzbXpscFozdWZLaGt0d3NsZzJ5VW01WmduSW5LTWYvYXZLa25Ed2xrTGZJeTJPV1pCOVBOb3E3U1RDVDhqRkorMncvV1FLbngrUkRGUUd3VTdvTENrb3JqVU9laTlISTBMZGUvZFJScEFNbzlQOUJjdFlnZ1VzNkVWc2FoYkFpMGlFcS9kUXh3U3ZTWHl5NzNxZG15NUVnWlR6cTh3RVhWazRnWUw4aC9rN016SnFMSkRLcGFOa2l2dmhFd3RBR0tXMEhxdEwvZjRVdlNsTktkRDZyU1huYXAvK0dWRkRSYTdLOEtqZmpNak11MndlOGM2Zk1PVlAyNUFxT1J5TC9DRTA5eTAvaWk4RWFDYUZaeHBxUGhhWlA0VFFvVkwza3E1bVFpaWNCSVFSNDBRS2FSaUlXVnVJc3dMR0pFUkhBSDJmS1lUblNZSUE0bEg5N21hTEZLd2hJZWtVT2ExQ1N4N0xsT3ErTjdtaXZ6dWwwcjV2cTBxTTJpSzRsb0JVMkFDTnVCQzhKeHVsbHp1UjVCZkdVYTJKYzNxQkprSS9QbHFYWEpwQXJ2YnFNVEh2ZDNIbitrd3hxM2k5L1lwaDV4L1JmZFNDZkMyOTNkcTc1YmF1OHFWYy9yTnovTmVOVG1vSWJ4amF1UG5qczkxdXlMMGJkcHlnV2o1Zld2RTkzcUdhV05NOTVqWDFRS2tWMDFFRStKODRZSVZjM0dzQW55eGNnV296WjdnZ0gybXlqVFE1bXVZT2xXRnlSTXBZMWptQnBnM2FzWmVrczUxcGpuZlZHaklpeE5GMWtXOFgxZzI1bzZ5ZGMvNWZ4b2RaYko2YkpCaHVNMldpMWc0MnhOQnN6WXAwKzYyMTBpQkdySGFoSVRGeGNxUnFET2d6clVsT3dlRjZHbWZwUTNWL3JJSnVOMmNhcU5MT3U2SWNkVEJRejBzRUpSNjJ2STdCcXNmMjNtb29vRm5yeFF5UDlueDc1UTZTeTBkanBISnhjM0F3bUQrK250VjF3NlRKa3lqS2JKU1FzSWlwYmpseDU1c2czVjRGNVlnckY5TjlBc1JLbHlwU3JVS2xLdFJxMTZ0UnIwS2hKczFadEV1WnJ0MEJTaDA0TGRlbldvMWVmZmdNR0RSbTJ5R0pMTExYTWNpdXN0TXBxTnpuWktTNTFsak9kNUJFM3VzZFRuakJ1amJYT3Q4NHoxbnZTMDE3d3JPYzg3eXNidk9KRkw1bXcwWTh1OExwWHZXYVRiM3puREZ0c3R0V29FZHRjYjh3QnRpOUVISUxiNktFTzg3WERIZWtJUnpuRzBmYTZ3WEdPZGJ3VGZPdDdNOTdJR2hJd2FTb0FTU1NUUWlyWlNDTTdwdTNJV3V5MngwNjduT2F1SkpFVFAzalFRMGttZDR5WThjUWJYL3labFVBR3B3R2QvczR3ME5aL2ZWaWtvNW5ONVlrUXY4aDRkT0RuQVhjaDZoc2k0UXVhelhrY1JSemNuT2E0WS9EUFpKR2tKS2F1QXB0WEJud3ZMaHZSelB5a2d4U253NFNJR3J4Z1UreVRFWHh6MFJiM3dVYlhuVkhlUDJFc3VQSjNFSkVQSHFRYlZYM1VZYWhvYS84N1lzMnJSMWQrZE9IRFBuUGFRWUhSemFpR3ZhR3BzZFZ0QjZ0MWw4YzJuQjhKT2w3SGt5Zi9mWXFnNTU0MVNXOXltK2ZHS1NoSHZKaEd5QWZkTCtsd1VsZksvZkp3OVlnM0JRVmlZN0RKeUsxRFdsK0kwdWtuTFpwc1BIMFJnMS9LU1poUmg5R0tzNzEyWU5Gc2tyek90TU1KSnozL2RiSWFlejRXWHRCTjM1Y2sveXBJNjFFQUFBQT0pXFxyXFxuICAgIGZvcm1hdCgnd29mZjInKTtcXHJcXG4gIGZvbnQtd2VpZ2h0OiBib2xkO1xcclxcbiAgZm9udC1zdHlsZTogbm9ybWFsO1xcclxcbn1cXHJcXG5cXHJcXG5AZm9udC1mYWNlIHtcXHJcXG4gIGZvbnQtZmFtaWx5OiAnQWZmb2dhdG8nO1xcclxcbiAgc3JjOiB1cmwoZGF0YTphcHBsaWNhdGlvbi9mb250LXdvZmYyO2NoYXJzZXQ9dXRmLTg7YmFzZTY0LGQwOUdNZ0FCQUFBQUFEZ1lBQkVBQUFBQWVxd0FBRGUxQUFFQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFHaTRibkhnY2czWUdZQUNCUkFnOENab1dFUWdLZ1o0b2dZZ2tDNE1nQUFFMkFpUURoandFSUFXRkl3ZUZPUXlCRFJ2Y2JEWHNtQ1hpZGdBbDRWVlJQaklRYkJ3RUVQNHJqQ0tQQTluVTZ1ei8vNXpja0NGWW9XeVdyOGZLNVBJeTlpSVhrbHFVNk5TTngxZ3paS00xR0srSzhqZmh2dkE3ZVBpckRiRlpwRUNpaEpHeFQvclRackdpT3JJam4vNytTTlFaU3RHcktEUEQxcUVTckNDUHpZSWl4WE9aZFY2SnJQaFBPazhsRmRwRnl3MXZOeGExVVZGYmljRlQrSUl2ZGFQb2dhSThRbU9mNUZvOHVmbXo3d3JIY2NBZElHTE5pVmdhSWpic3hOSlFnNjBra1VSc0tmaHI2K3J2NXVmWDJzNytmNjNQcXJyM1B1amhwVmtBakNidVAwR1kwNkhaamdRaVIralE3WW1LUzJ5TWpTVVpSZnp6c0QrZWZ1MXozeWhCckpPRVJJVU1aekRrY2Fod1NCTWI5UDhab0cwR3pERmRDYWd6WmgxSUhjY1ZGUjRjWUhIUUFtYitkRzZ1aksxMSsxaDg2NkxDUmJxcTh2ZFY4UHczMTN2ZjBBSW1XWjRsL2dWQWxWOVcwN0x3UGI3R3NHVlo0V3BrSlFxSE5sTnpvKzA2S1cyMFNLWUVycE85bXpXMU5zWE1Ydi9YcmYvdVFBWU5UQklnbUFlYllaNzV5WXBJNjMxbC8zdFhibFd1bGJwL3FTZ2hwR2FWQzN2c0FIMXdTSTgrd2wxUWVsVFVLY3FNdW1ybGNJTGpBcUFNYmlWSW9VZncvOHVwL2JHTGYrd1N4UUVBQjBrbEdHbHNLNDIzNkgwdnh5V1NydmExU0NFb2dSMG15U3B3ZHZtNEVNTGFkdStHeThCTFhJcVVVTEhLMW5iZkhMTkJwbVpmcHBPSXJzdFJPYTBja3BBc1E0RjVXeTZIb29BUTh2bGYrMVo1NSs2cytHVStVazNTaEl5MDFaQ3dFcjY4LzNlSHkwTjhHTXgzZlZpMHJsbmN6Q0VVU0c0aGJpUmF5SGdOOU1yL2I3clBYY2QzbnpTUU4wVGNiWkpqNkRmRzFsV3F0blgxOU42YjBjd2JhUkF6UkEwcmkySGhnSVQvRnhyNEh1RERVV0l0MkpSWW5PT216TmRQaEIvQktlZWlDeUhWTGlxM1pTcGR0SlhkdVJOWVlKRlhXaXhYWFRXaW00RVlFUU1pLzdOdnIrMFd6dEk1KzVVWWtUQU1LWU52RVBIWjhudWwzdStuOWN6aWxsS1RLSGFRUVpBWkVNdDlmTjNsSUlCQ2ZXdEd3TGtWdWR2RHlDTWV4VHptTWVSeHoyRUlJUE9wd0I1czd4bUM3ZVhZM2p0aHd3UEFJZi9KbCtKNzdvUUVZQURDaU5NREJ1QW90ZEwvaUI4UGNCZ3haZGJCam5TOFU1M3RVbGRiOWFiZi9Wc3J2Y0lLRVFlZVFHYW5jVWppbHN3alJhcDBYbXQydWM5dWhLZGowbmJFSzBEZzRwRkU1YVpLNWVIVmlleGVnQWdQYkJKMXRyQ3Z6eWZ6SUs1OHlPMmhYOXhGWW43NnZCMTViK3c3b25YaDJocnVRbmhmcm5VM2Ruc0FvZW01Q1lXQkI3SE5tbHVycDFwS3pmck1hVUlScGpNTTE0eHVBa2EvZHdEam92S09HY1oxZUtUdFNxY2V5bjc2Sm52anlHRGNvOTVoL05pclJUdVpWR3E2MnpBWXQ2QXZNWEZ4VXhpbUtiR0dMcm93cVpFa2ZWWENXQWdVeVRTeGsyZ2l5MGlRQkpvbGswa1I1eFR4TWtISkF6RmhwVGJBcDdpSkpJeEhBRHlKYUYva1JZUnNZU1RmUU5iZlR1YkRvSzlONDhuM1o4eE9Db2RtWnVOVGlQQUtWT3N6aVBpMmd5aDhENmRsYktnTHNFK09LS3pjcmI5VVA5Z092NDBXcFpNU3Fvd2VEMzVKZ0dnNHoraVQ4ek1hTW96K1oybjRIY3VKWUw4NzF4MVA1RVlieHU4d21HS0Y0cHpOMFdOVnEzVGpnYW8wRStDempmelNvbGwzdEdKYllzYW50Z0gxRjRjVm9MTEZic0UvaWw4ZjRwTXJWNzdHVFpodWVic0dWZmQ4TGQ2SEJJNTMzbUMvVnhuL2ZWN0d6TWtKOFBFakFlVVVsUnFvMnJWTHNXaEpxajBkTHN1UlRoQndpMXVFTUZsT0VaTVRnN0pjZVpoOGtnSUtDb05Na1dLa2hBcC8wQ0tnREFtU0tTZW5rcndxTXRVVWhLaW9vYVNXb2pxYTFGUFNRTE4ya3FVZzJkTUJ5SUZrRGdxU2d4Mk9PVExJSE9WWWl1TW9PWjZjRXlRSFlUalY4a0prWWlZU0dRcVQyR21sMGNwQmxaUEVSNGRja2tJYlNwSlVxRUFTQkFZYkJIRGdJMEVUMGE0bHFHblRRZE5GVFNUb3RFR1VVejgxZzlRTTBXbVltaEdLUnVrMEtXZWNJb2M5WUVNSGlZSytLRGpSYVIrQ1p6aUg1bHdYaEJleW9PWmlsOU5jK1hMTlZhN2pkSU1iT1ltSnlLMmdabzJ5WGJTNGo1TGROSHVBVmcvSzlSTUwwVGd2UGtuMEZObzBiS3E0NnVZUGpuUVdLY0RwZjVWMFByckFJaEpWNVRGZyszM0dINnljVG1XZHpCL2FqU2IweWFQcDBKM3RPTHJYNDlORy9RNzBLdVBVMFhTQnkwV0FUdThYQzR4VUdYZWdxc0J4KzZIN01GdzJ3MGJSL1ovYkhaUEk4L0hBeVJ4aUZocHdGQWJiLzJ3WVJZczJRSWR1bkY0alRNWk0wSktZTG1jbVUxM2tjcG1KRy9sY0g1bmpWdVo2bkhtZVhEVWZrNktGc2xaeTJtalNRVTRYU1RlWlhwcjBTY283dy93QkhNemd3VjB2R0ROT05BR1p1Z1BaY0dtSTVSUTRjWjBDQnc3TUNBcnpqbHlNQS9IT1BDc3I3bzlENkkyMHlYYkpYQnZsS1JoWXBKaCtaVmtlaFN5WmQyUm5IRGlnUW9NajZSWVdKa0dNRXNuc0F5WkdocEk0S1BMb0JaS014Ky9Id09BQms0bUo1S0VFWnN0SzhuQ3paRmFXek1TUWpTTStnU3pCd09BQkF3T1RoMExKM0JSNTNCUXB1MWxKcElveEZLd1FZSUVpa2pEQkE5TWNWaDVPMDBVTnNQN3RBTVhVVmhnZjZ2bCthWXVLaGZiV2pxcjdmdHZtT0dYdXFoRmxRR1VUemFmdjlMdEwwdmgyMFl6RVJ3N05lWGZibHJtODRoL05iQ2FYNU1jdy9qb3hUd3owMEdScnoySTBmUklNZGw3WUM0bWxwaVhrY2hKbWZ3QjdGeGU2VUtXNlFpREIycHljL0JtVmZpZ2hPQVJCRUNSTFZpUUVCa29KcXB5YXlNcEp1V2F4c0VBVVpHUVVaRFJleWFhanlnOGxISUlnSkdSa0ZHUmtaQlFVU0RuSjBLQ2djYm5QMlZRL090NzdkQ2grZno3eHZvazJIWUVIMWcvcHFIMWdZTmpWK3ZEeGxJNitaNFlMeDU0WmlPelkwamZOUFJudHBKTVNWc0tWOENYQ3gwU21seGZtWWloK09iRjFPNEtYQ0tFUnJlaGVNd29nSWdRQVBBZ3M1a2k5NE1Jb1h2UzFpMWd2Vzl3NDZlSkhYRUltVjllblZhcG1lQ28wLytCSy9VdnFnRG13aTBUdzVlUWlnU28xK1RYZHBlU3pHQy9HbzNybUI2VHRhWXhGcitlS24xcWdjUERJNVBNa1pzUVRtQjZQWTdvOWl1bnpDQ2FDOEo3Qzl4TUJMME9tVG9OTkt6TTB1YXpNVFpvZmV6ZkxHR05LZzl0aXp6U1hBT3pPVVFITmw1dWwyd1NUQUVDZ2ptM3lqaHQrZUxRUFlmbzFUTTFkVnZtUjY0V3JnTE1Bb0Y4bkFOREpnSGk3NE1JaHNTZHYrYmMxbjQ0bjJleFFWN25HRFc2MTdHNEduVzFRVDZyaUtxK2FTbFNQMVY5N0hmOVRnQzdtQ2l0NDRQUUdkR2NWVmRsdnp2b1dsU3FXSzFXeWNLSDBodmJETzVaWllvRXUwOFM4ejRpaS9QRGFsaWlaQUxBbmFBME0zVEZvYUtaeTRkNmszUXZqaXA5T3lUbWlHTVN3RGd6WSt3ZWJzMGZ4L3FPeTRvVDVyM0dPUFB4Q1p1bS9GQWFvSmpKMjNoUGpSSXYwT3hBWVEwMEM5WHhla3dGVDhFR2JmUHJZNWNlRWc4bUFZcWFlbk5ucHB6UlN2TXRqRjR6ZS9OckRyKzRQaHdaQ3I0WmkyWldtekNlNVFHbzRJQUpXNk1FMHpKRlBUQXVTdFhnU3VsN0lZMXlGcWo0S29wazVrcHNKRWRXWldVME9HSUM4cFNrbzhGZ3BhS0Nvd1hsdnBMd21EL0hpTVMxQ0dYQkpPeHQyamRPSDRLSWI1TmRGYnVNTHJ6bVI5Yi9sUlMrQjdvRjhPdEY0N05LcHFaZzNNSHl2WERpNTVMWUpYMXNBVGF3Nk1KQ1FxSm9vSVNCVVh5SXI1MEtyekNnS201b21vSnZwRms3KzhhRTBHbmdzbk50eEsvWlBOaWVoTTQwREIrR1JoeDJaYzRjaExOZXdkWEloV3NoYnhDQm5GNWhDWlNJTnp0WFVUeGdHYUFnNWs5U3YvcHhZaWpiUjl3RlFrQ0dGU2pOM1p4bTFNL1ZPdkQzeTNHTkZZYTJNTXcrNmF0cGdWQ0NtY0xkb2NFcHFNRnAvd0FCWTNUWHRBRlYxZVBDUEQxWE9McjRjd0lnOHJkcUtTT1pTc1hldWhhLzdkdWYrSG8xOFY3WFRtU2U2ZDNiUjVMenhPZS9aZ1FLN2VxSGFoMUdrSXREdUprMlNXU2pLSlZnOXBIMEJPZk9pS001TjNrSStFVTEyYkx5OFViN0NMZ3V4WU1ldTA0MEtSN1FpbU1tanAySzB0MlFCenBVK2lVUmpSekZlZlJRNHNWQ0U2ZWRLdXdZTWFORkFXVWw1UUNRVnY3V3RSWm5oT3VUcGYwZFBlVUoxY3R0cXVsRGdyR29tb2RBYmNtT0drakdIUEpoSEtWaEFxVmhFYWRpRTByR0VNckE1WGdDQnZDekZmTzljQlEzcGMzUVFYVnA0cE5MdC96bDBVV1d1Ly9jNm5Za0Y1dDQzV0FlWm9JTkFGZ2g0UVNBYkJId2drQU1DdVNDUUJ3TDVJTjNGUUd1aXFDUWpVc3ZSYTE3MDlFakhuU2kyVTQ4ZkxIR1diT1NCcFFCR2hRZlFrYlF1WkZoOHBuQTlSd0g1ZlAyMHo5Sk5FZUxlUUorWWRIb1pLTVVkNnc0Q0wwWFZ5cDljREZrRE5za2JMbmhvVWJoL0FYandyYXlYWU93bHUwWXFnQmFqenJZVExZcm9XNmtTemZXMlpsVStBcElOM3ZWV283Q3dmeGVOakJIWlk2SnZKNTg0MHBoTTBMRWpWYStHcmlxeXQvcUlEUTZCY0ZORkUyOHR5ek0zemF4bTJhOUFtMFBsdzZscFJsT1BRMTRERjVuRU5HSjR3N2Y2azEwc3I5MlFUTXRUQ3lpYWtvaWN6Um1Wb2IxSW5xNG9JcEx4a0xFT3hqZ1Zja3hUcTdKUmM2dUlLSmFYdnowSjFFSjhrbUZhZDBLSlF6SWJXUXNYRzhIQ2dwY3EzMUFOdkdEQkVvVWFZK1JUYjNUclFKVkZqcE5aN2FqV0dMVVFhTWkwQ0NscGwzYjl1ckxPb3BTbERrRWJwQU5uMUI5bWtzamdlakdrRFZyeDdoUzZtQUVLNm04U2JUZGxKN0J6elJVMGFYbVFoTnExMFhESGdKZXZSZlQvZWVWVmRKdHNoS0FCa0hUenE5UmpkMnFLMXByaWoxMVZPV3pUYVUvZDhkbUh5eFhOL1NLdkIwUGVXSG96V09OWmQ5UzJMbUVPNVJ0RW5nMzlqMUdMQmJkZCtoSTMzb1NnaFlxczEvaE50QlZGNmxnZzNEZC9GeU9icFQyZytQUzhyYXc3YngwdDNzUkRiWEdFS2dpMDloMXhMVjVTdVJjaGlhRWpuRFM2elE1dXJLN2txaW8yUjZhenJ3c0Z0R2xpSmUvcUJxdEhGTmtVM0FOQmcySE9Ma0F5ZTJDK1RZd3NnM3JSSVFKTmdvbERWZzJCalVQT25xQ0RpME5lRFlHUEd4emdKMEFXRVBwQ1VTMUI3QXNsZXdFaDlZV3lXb0xjbHlqYUF4V1hkSWVxR29JYWg1bzl3WUFXaDdvYWdoNkhiQkNKMHFpSjBxeEZxemJ0ZnFEZ2R1M3QvTkhTbWloby93V2l1QlhPZGlDcHoyV0UyZWlWNlBza29yOE5ZSFExd2hpL0RzYjZkZnE0aE4zQ2VQa1dUWkRvcUVXaWE2MU5wUjdhL0hwbzkrdGhvbDhQaytRRVRaYm9hSXBFMTZhaTBnRFQvQWFZN2pmQURMOEJPdVFFZFVwME5GT2lyekVMMmg0UnhwaW9xbWE3Wm5qbGxuNXBydkVoK08wdU5SV0VscG9BZ0JjQW9LOEJqNER5SWFpL0EveW53TjRHTWk0RjJiM09OZ2V1T2tmQTBOVjA3RXR3QUZ0Q0pwNVlHQXpPSmo4a2R1UUlHQWNtN3BkanNtNGNuUncrZ05KVjNGUFJvRTVGMmo1amhrNm1rekhYbFJQQ2lTeVNRSVU0TG9zNlJxajVaK05ZUTVhR0ViSVJ6bENuNjJNd0RPSW1jbDJXSVdZRWM3V2tjYnVjdFdNMzQrOWhyY1R2NUVVbGxsblpOcllFUmdScmpzV1lZL3VNbWF2aDZ3NjJMQU1aR3NwZHo2bTRrNWg4SWh6am1iTTd5Y2loczM4NlQybU5hSXd4RWs4UklWa3JuRlk5RlZHdmNXTGJldVRGdWpPdmU0TFJWclhlOUtPTURlWVlRMXJjUFlIdUU3akVKMWo2bHl3N05BY0dGQkFvUVVJSmU5T1lVUTdZbEpUdkJQdmFGNUFvMlN6M0RuTkszTlNCZXB1bzdkVFhDa29MZWhpMUlYVCtWQnRPcXltamg0ajR5S0IvVGZlRG9qRkFNaEtNeXJzNmJ5ZlBaZ2FJYWdpRXdyQWVtWE50SVJlQy9wUGtRUis4R2lScW9CQWFCbC9pbXdXaUxsTGZQQ2h6Mk4wcmJ4SDB2Z0RGVC8vWXZVMldtSWhaYytnTkJvbHFjTWtLNkJ6a2R1MklwR2x3VTZkdWdhRitvUlVjRmxGME1iL0NNSWdhbElwMFhUQ3ZMS1pJSW5LVzltNTB1aWhSeGxOUG9QeUlJSHJsSXJjem1kcGtibmZUdW4xN01FaFUxRENFUjljQkZFM0ROZWhmMXlCNk5RQkZwKzVsYUdia0JGZ0k3NzVQMUFYMHp0bHliK2NOY3J1WS9mV21hdFFYSEFqTHV5cFc0SnNkSk9yQURIcnZiRXJqRm1JRkpzQXRaNUdwZy9JYW9NbVhPWlpRS0ZzQldmTms5c3NYakNaRTNYcmQ0RVk2dmRDWG9LVThwcThNd1V6YmhkVGRVSWN5a3I5T1pOQ2E5clQ5WDJqbkNDZVArNEp6b015dllsRm9XaXA2YjBhWVV6M0pWdjdhZEVWaldncGVIa3cyMGgrY3NUNE5pUUROQ0wvY0FqMTl4V1M1Z0luNWU3aFU1SFJ3TmVUNllHKzdmVkFOZW0xK2V2a3luM1JzdXdBYXNPWlBwRHZQSTEwL0ZYT25abTlzb3orUjJFMVgvUzVxOEF0YVBVMDFmZnUwQjBJMVNZQnhJbnljTENOZE0yeURKNUNobXg5RnllVndOOWU4OTg0ZU42TXNXNGEzR3M3M2pJOExJZ3hvWjJaK1Z3dHl1bFo2UVkrRzdsR3V2UmdpNTZlZHNITk1iZ2NhWWdYTGNpdDhxU2h6NmptdG1IUExOSWhwTVFHY2htVkllUHNGRXpYVE1kcGd5cEI3aVVkYjBodTFpOGhJUE95SVI2Yk1pU2ZBZ3BITHZsdUdaZ2U2VEZkTlR2bXRPUDF4TWFmTXhoanVUYk5iMWYvcnRjaHB5eDdsVHZNSlZsNVFOVnVMM3BMeHZmU3prS0hTYS8ybDVZc29uY0Z6bWt2WDdDbkJURlFuWnBFVVRDY3dVVGpoNExRaWVoMzhPR2FzQThVL1hqQ09CV1UwOU9BeVhJN0UybDFIem5Nb2pYUVRNM1ZDa1Y2SDlZSlQvbTYwWEk0TGxacDVyUkpEMlNXSXZNYmg1SUJFT2s0cTE3aVY4RGpKTCtTVEhZVnFyd0YwMDZNb0NzdHJDVjJCSG9tVmNsRzAyaXhMblNYWVpFc1R3bXNjMm1ReTRZYlNLSXllaVlkaHcrVUNkQnRqNW1WdWVzQXdiNGYzaXFuNWwvUnBoeFIwYVBJWlJaR09xU2EwdHpyRURIMC9iYVp6MDNHd0s3Q3Jja05IV0ZLRER5OHdJSmNKelVqb2VCd2NhMnRDajlUNnVLWDhJV2UxMDRwYVZUWkR2YmFsclN1bHhMZFoxQnhER0NQY05xRlpncDQ3Y3dtbVBvVzVUV0grNWZzV2lDdzRsRTQ3QmZ5ZjA1NUtPUHZOdi9DZE9OR2NKeTRLNTZsdk9yWGJvSFhDMUo1bVFaeTBDV2FwT01wcStYSEY5cXVwVTgreVd2TkFYZkRsckV0SDM4eGVkV3lPT0xjekk1aElHYUFIQjNia1VTTGhBek83SDAwRWFLd2pOT2ZTNDNtZmRJQXl2ZXZoZUQ4b2ZScHlRR3lCY01VS1FjbWptZEpwOTVoUWFvSFVJV2JCUkhwbGpYVFo0MENYNEpTL2NwaGhyU3V2NDRTSXFvWkw1TGxRVHUyazlJdURNQTBwaXN4SkNoWWkyL2pJZ0JCMUlKYzg3azJpVjVmclBJZDNXZ0NVRnpIUTJJL1hvalhXdHpYMERMcUZGYWpIaForbHZxM043WVNvZy9GRWtYMXRjUmpXYkRRL1QvcnQ4S0N2VUFKNTkrd3g4VEMyc1hHSVBROHB3SXYydUtaSG1ObVM4QVpIdDFZblUrZVNFVkp3UmNzUmE2Tkg5SExsZ2lTd2gzcW84ZG9uV2g0VVIwME5lLzI5eHBYc1FFSzd1aHlZUXI3aXE0bmJLZUJGdUtvbFFEUDFOY1kyUHFTK3gvRnlCQkVCbjBtZitQZ3MvV1RvM0QrQ2tXV2FqY0dzR1lrcEFZTzlTbVdwTFJxK0tYZDR6M2RPeW10dUJTVW1FOU1Ra0orL1ROUnpXODY1Y3dSVGh4eWxyQzBxMnk1MHRPUzM5QVc0dHZDYUFMaG1XVzkzeUdYU1FPWWJJc2l3d1FvbnpiRkUvc0ptK2w1UXB0RDdiRXR5NjNvTHRSUDFXVndPSC9FYWM1OFE4eVZXeUtVaWtSZDRoT0s0TXc0bWNSd1pkaVR4OTB4UFc0R2VwYXlUbmFTYmpVV1VIYXQ5ZHRoQnRENk5sVDJvMDVGdzVvd0JkYmI2Ny9MMjcxLzNsRDYrbHhnb2JHc2JHaTZIdEhlck0xZXI1OERSbkNBYktzSUx6QUlrTDZncWJvZjcxRFR1NDJ3WmFRdkVuUnR4Mmw5ZVdERktYNks2YzFLdGlIUDBDQ016bDdTOUx4QlJVVEpiMW5taUJnK3pwQ09CM2FYakpRY1M5ODdyOExGejJack9HYktuWjFhd1RENk5makR2bmxTY1ZEYndNSWxsaVI5VGVkdkVyR25Nei9aa3RTc1BZenorUEpVRkIzNDM2RlE1MlFQYVM2endSWGRDdEpvUHlIejVReW8wZ3BCTnowcTd0TGp3Um1wZ0JuR0wxcWVMS2ZVOGxkVkxMSW1MOWZlZHErcHNvK2Q4U0VFUG5tdmEwbjZaNTlCN1lWczlCWHdQZ1BVK2dDbkNUd2tqcnJjVHRRMjlMVDVKWmF2Tjh0VHVza0tpTWV3QnZJWVp6OUJ6OUhSR0IzNllmRjE1TFYwQ08xOFdtK252S3RhOWpYUXU4UUxKa2hJU2VtbGlHVXdSdzlZcDYyY1U4TXlQVXNPVjZUcVZyV0RwM3FmajVhbU9jK252MHorWnZTYStHVmdOa0h5U3UycEs3V29lYVFPc1FCcGdLZ1hNZkROUVlTT0I0ZVlaM05VVkZTMXFiaXlBVkxpQXB0Vk5xemFNV2owS2NGVWdGZE9yQUpzVjVxN21WdHZnVkNEZVZxNW1IaFgwWCtabnNTeHN0b3pOc3JJc1o5c2t4NXNYTmlmTlJGdTk5Nks5WVdIRDhZREdCWTFKSFZiSGtTUXhjc0hpWHZkaDFOdWlTRnBlRDJtenZKWUJXWGpXUzRmSDlFNmU5OTNqYlZNRFlvV0Q2c25BYlIyTzdMSjdBYmYxY29kdi85UjlWVmVUdGpVOUYvSS9iRDhudklDSW14Q1FtZFV0Rm5lQkRTRml2QjI4K0RoWmZEd3ZqZ2pPaVdmdmgxL3VnMFdvQ1MxUUhyL2owT2FodUZkaEw2aDJocGZ2QjlFN3g4ZW9XZVRHblJjekpyekk3RWQ1dElPOGJtdmo0SW5jL3E5RWNlMWg2aE5WdGRwVGF1L25jcnR5WDFtSmZLZk0wYzIwNHc1RVM4b081S0s5VytVdC9WV3NyVktkVUhxWWo3ZTFhQ3dOT2N4TzRZRE9oaHhmcTZaVlJ6YmFCOHdVTW1jMjJMMzh2UzhXcjhQWExVWVdyOFhYTGdiRTQ4RTdvN24zbUVYUkp4ZWRqSFBRZ2V5TC8vZzFlcWlkSStvc28wQ3ZtaENNQ3lveXRXZzAzL1pRVGloY053a0hHMGZHalF3MFdDekJCaEQzYVVkQzZ6QWMvOC9Qb1NsVEVkUXV1ZkRQOFQycDRQY2lxR1R0M1QrZExYcVJoUzgwaTRXQTJiRDlQc29KdUNHSkUwWmh0eHZCb0V6QmU5ZURLdEtJcG0wYm5wWW1XY1lkUE9NcWIrUHVjS2taV2JGQjJUa2JtWVBQWWRRc3dmSWFqOUkrTWg0Z3d1UThDbjVialNBSWhlei9rUjc0Z2RSamFkdUg4OUlTdDZjbCtobG5XQU9qa2VlRGpoYTZFdlRTQmc4T2VqRzUxT2ZEMUpwY0JaUW5vTk9vWUZkVnFRSVMweGZ5bTJHRFFVc3FER3FzT1M2OUxzZGxsTmlncHd1VGRIYTNVVm1FbkVBVVBmLy9qcWFNRnluZG1GUk0rUkNEMWc5REZJeXAzTHkrbkd5dGx5TE5Ya3JMMC9WTnZyQlNMTjRKSTkrSnhTdGgyd3NycFVpKy9SeEZuOTlPVm1iWlNjT1c0dmFlU0xKRTA2MjIyVzFOUjR5ZG1SZGhzN1VKL3ljVXovNSs4aGZNWkg4a0hIN0tuLzhOLzVmd1R6eHpTaGZBaVNOSCs5Nm5BYkwvNVNmdm5JTWlpS0NUb1BMeWJKakUzSno4TWlrSzRIYkY5UiszSGwveWlrYTJabjlia0I4ZHVDOTd4aDZBWnFxRWxXYTlzRHJMZ0VYM203RzFsZnk1VTBCU3N1WFRhUlN0TU5pOU1GZ2UvREUvZjBsWlZlSENya0RJV0pMTXVsMXJicVpWYkNxdjJkN1VVTDF0UTFYRmlDMmxsZXZvTmYzSEhtcWszYnRjQWFqSVNzcGpMbExORzlueUthY0Yzd0lSL1RhanVHeE5uYS9XSjhtSEcvdW5aM3JzSm5mWGw0b2NCU2JOeUVtRFRtOVZZWG9ZZWc2cm41ejVpcWtnRFRLNFJiYmdqdUZsV0xXUmFBMXhRcFpNWG0xNkdkR3pvajRiZlo3dVF2RktPeWVIQ0wzbklUd2J5OSt4dG93ZzRIellXMEkzMUt1dGt5dVhMeGhWOE5XWFdGNTlRN05EVnBjcms1bm9GNkF2YVk5T0k2ZVBEa0dNcUJGQnZxSTkzNGZzZTQrYk9jUXZ3MnFOeHZiOGdmbEVhT2NJVzRPUFRieTc0aUZVdUFmRmFwd0RuVmoxdjA4SGFUWWs4V25ETjBnZlNiTzFEYVZhclhJdmd1SnYvMzZMdzV5WXY2T0ZpM0NVRThYRzJ2S29rc3lFZi8rTVhTQ3FtVWNqdjRPUjhJeVdIemZqU0pUcUg1bTIrMUJ2bzRaYkFDTjBtTU5JS1lhaytObER4U21IeXkvaVV0bUY5cmpEU1crbE1BTGZ1WXRMdWVETkcya3Z3Nm9ONlcwaFRvZ0l4Zlc2bWhrQ3IrNmhDOFdyN0J5S0VaZ3dMUGVnT0hia2ZITkNldGxub1JvTjVuR0FTeHIzeXBCbCtYUkdObmVKUTVLVlpUVkM1bGcwK3BPKzFtaHFDdzRKRXFGK3ZhN09hS2I1WEpwUjlOb0YzZkpLRHdiRFhzekdzb2ZrWUU4RTlpeWRNd1JZSzljRW50U2MxcGJ1SndZMTd2ZjU2UXg1dUNxZnJmM3puRXhMUmhacExHSEVWR043d25MRUlNRjlsMjNTeTlXM3BDbkR3YVhSVzdza1FnbVJreVkxRjlqSDN5dXd5Q0d1ZHUydzVQQ0I4Nko3TjhBaXZpVkhySUtMLzU4THgxelVNL3hKV0VpQmw1b1lvVStVWi9mbW0waFhIcFdIMGZKTldHbElvUVgyd3Z0Z3ZKMmJ0L1R4MGtlcFg4TWRNRHp6RUErbWVUZ2pyM1VjRm5VY0dYbWRXcmZoTjd6Zk5DZVM5ck9hbHI5YjJkZjBRTXpKUk92Yjl4L3dEMnNKN213VzR5c1dONmxGQ29ka3ZQTThhVUFCbklGR3JSMkpYOTV4QlIvSmpXQy9QbHY2bFIyWHQycVMrdjRPckc1cmJ4dFBYL2pkd201bTNlRFRqak9wTS9QWGlaRSt5bWs3YjhtZ1pYeTM3VXNlZzBGTFB6S1EvR0VvYmVMS2Q2blo4TGR5SUxOb2h5LzlRSVplVUdtd1NDcXk1YkRwWWZ3dzFNOStmTmdtQUlCdk13c0RkcUpTR1VGYzAxdHUzajJLN1FzTHFQQnlBOHVBbHdkVUNvMmZTT2pZUk1naElRRUtLSXlGOGUwbVVDQWxaQWZIZ2Y1ME5Uekw3VUY0a1gxUGhlMTRtUS9kUE9URHJSYjhYeFBiRitiWElKVW1BcTNNMVNwbGZobFdvSXVOeUtDRms4MGVNb0ptTVBOOGM3NUJPNHN1NFp1Zjh3Vi9DQ3dDd3hGb1ZvcXhEQ3Byd1Z1MGtKYVFrd1RPVzdkYmtEanR6T1FTNW44OEgrbzZNOFVvUjcyNXNGcVhKeXZORk5xRXNOSGgwQ1JzM3l3MHlnTnFXYWxlSnlzTHFPVjBHZzJmSCtUb0VsQW1pVkJva3ZBcEZPRlRoRVFvTWtrRWRyU3E2S0FyWU9YaXc5UTZFOHI4NlpkNVJJVzdPQzkyVUJBSVIwUjgrTE44cnc0Y2o2NC85MVk3OVlldUZEbjN5eEVrN1N5SGRreTZmbklpbHBKUzRQZ3pPUTFYcDhjSzhlRXFCelM0ZDBVZ2oyYkZlNTdTelNOV2xVU0N2ek9XMnNVaWVXSGw1VHk3bUs3QmR6Tm9lNWM1cEdMcVlGaElKWHYzU1UrbXVFcVpOME13cjdLZEJBVVV6c0lGRGpNb0ZwdUJIWWk2Q0JFVTNRZStFTVp0WWRESmg1YUFjSTY1d1B0ZDFwRzN6VWFzL3N1ZWRrNzRmdkxEcyttVnh4WUpPWVd6bTJTWGYrbmtNdW1udldiUjNMOUVnMHNZeEVDRk5jdEordy9mK3hNamF6QzVPSXpnbVd6M0V5azdha2ppbFUvYmxFbHhaVjdTb0hNYTk5NHZtQzBHMW1DUkthajdZVzJKSUVWRkFnajhKNHFsNkVlUXROL1ZxTHFUODdrZjlkUGVTOWRQOXEvczJZM1J5WU4yUGtnNGM2M0RPV3p0SElTZkxaMUdVeFhPMjdWZ2w2YWRsekZ6ZXVkMElMZW52VWRSWFY5VHIwaHBQOVVmVWpjYXhNK2R1bmFLZG52QmJkVzBudWs5cW9WM0Z0MGhPL2QzN3ZNa3IraTU0cWtvOVVLT3RKaHZIaE5KUEcxT1JucUIyZUx5L2wrRFdwTTc4MFhvSlpLQ1BBKzlRRktFUFEyOXdwTUFxakpXaDRzUDhVL3dvdnRKNTBhaWNWRkh3Y2JmaFZkbC9GTXh3d2oyU09qcE1HUE5abzRRWnhPTlhnZ05qMENKbUpoVC9MSlgvYTFzMTlFb0VSb3Z4ZG04RS94RG9vaHFvNUFBVGdwN2VRYkI3NlB5azRZMUxscTRMekthT3JPYjd6RkZUMXI0V1JLTGM5S3U5djJkYkU5TUczZzNHZEdMREszNGZDMzBTM3ZkUzRhSlNBOXphS0VpRGF0UE9EVmhZWWVyd1NCZjJ2Uy81T1NIYitDSCtNbjU4UW10b2RxZUtJRjUxM1psTVpRNDN3M3FBUVNBb1N5N1dLb0prcy9tL0dDV1MyUTJVaGIveDVCNXM4RzJjZkVEeGJuZk0vYkdzbmNIUXduRFlzREIxTitXQ2w2enV4bG9Ib2VQbXc1TWQwOXZXcnE0ek9YVlRLamFVbDI5cGFhMkk4bXNyWmtTVCtHdHlVTzY4L0s2OHd1ODA1VlhVSUNxZ256VTdWSE15cFZqZVVvbFNKcFBMclFtcisvYllCQ2FoUUtyV0l3ZE00dUU2ak45WFpZa1FkRXlVUUNYQmVReVdTNFNjandYdDZyTWFnRjYwTm1aSUpnSmdXQldOWlRaQUVKZzVnOGJDSDd2M3ZwL2FyZnBsOVFMTENRQnlWaXlaY2hneDFUVDRJR29jYzJVZVprUjhkT3F3OS9NQVBzdEZtUGxjbEltelJyNk5nYVEzVk9nZTUyU2NDTGtJbVE1b0NoTGlrRmtHZXNtek9ENXcwT2NGZTd6NHlzZ3B1NDFUNUVuSXg0azNVc3NUOC93UUZNQlZQcERQdm95VXpBWUFBdEZ2SHVOelJRWTkzZDhURUtmQzJhMW41UTNPNmNUdXJ0Ky9rUXYwdVAvbXowdjhxdTVVWTFNemJQbm5nMWpQamdwSXN2RDhNWmsrZERiOWZkTVpETGg5OU5iZzMzOFh4VDNWdUdwS2FMWjVtUithTjVBZWNIM1BIQkdsa0NFZUc1ZDBjQUZNLzdHaXk5VDN6d2FSem5OKy9xUy9jRkh4dlNhOTJ2ZXV0VDVLMmx1eWttYVBlbXl4R3h3L3B3QkVZRGhtS2xIaUluTkZrQ280NytlRGM4bFpDclIzTHJlOVZHRFRseUo0OFp3QTFKWXBLWnRRR3Nqd2pQaVJHeStoUEZmcGZUOERHb0thbVZmRTlGUCt2WkZHWitPcEFvM1NuRFl4Qy9MbXJqWERoNzd0aWtTajB4NXVXZlFZME9FODM5aEJvNlRGeUhDWXl5TlVmczFUOTdNMUlyelZjRk11QVdrVCsrKzB4OFZLKzQrMVEzb2gvdDBTTG1Sa0ZVRU5BcDlDWlVlemc0cTUwU2JEZlYvWFozclBmWEtXWmMwd2JDNHVHR3B3RzJXaXNTa05Ia1VTb0hYTEJXTFFXQXI1UkZTWC9CVnBabTk3STJPV2tudHdoVi9IbGYyYlZVd0c5bkhpNjNKRzdvN0xtUmtrLzVXUkxiazlkM2ppbjRkLyt5Tk1waEM5R3Z4YlRYUDNpdzJpcjJBcmhCNGlnajN2MXpER2lZbmpuUHRQTUZOWmZPcytQTDVhY3pFQ1czbjBIYmhVUzhhaDAxSHI2VDFmclZKcjQvMHlPYnFtZTYzR2hIcTRmU08yODVGSDdvMmtEZFNrT1dnU3JNTktyK2xHZytySEk2Q2JLTVdML0R3c001U2x6ZGdBc3FEY1EwMENleGlRQU42OWV5WXZkLzVCMmRVQ1puMDhqZWNkNVF4V3lIZU0vN2N3dEVvY3k4MnZKdk9yYXBpSmc3eE9KeU9kNDExamJYTWQrcUo0aUcxQ2EreUlvWjhMQ3NwZ2grdCt3dEllTVljZEdTVTRwVC9ESGdtVlRYY3oyWnJ3Y0ZjSEVGbHhQcWtsTFVwU1YzWXNmbEoxK1NSTEVWa3BKVVZhWWxVNXcvbU5mRGk4TE0wb3FnaGpsNTNRWEFoTHVrSHdaTnBTYytZdk8vam4wWHpuakE1dXIyUjhYRXA4YkdSY1hGOWNjay8xZjNYdVdtYzRjdzBIMk1iN2Z2K2tEV1lHMk9kRmU4TTR5WVJXankxdjdCOExGOXF5aDlzMG5QVnNVTTVISit2VjE5elo3VTFUMDhGeXI4VVh1dWpUMC9INjJJanl1RE4zdVhzT01kTi9tYnZqWlBlVFJ0cU52VFk0LzY0K0tGU3RlQmNIQy9JdWZxZVdUSGI5MVZSdlJaa3Q0RTZrUCtnM2dnYVJ4czFFZHE1bXdLMXZOZmIyYzY2QVI3K3YwZSsvK0hWcVY2NEViVFRjS2NMdGdQdnR1aktuYWVMMnY2OWxZR3ZhN2xVKzR2R0s1M1dlTFg1cGJlWHdMN1hxVGZDODFWZ0NWM1BlOG9lNXZpdTFsdTdmTDlNZDdpWDc4NG9XTGhGV0U5K0ZmYm5NdzVBTVpkZFYwRGpsZEpUcTM2enJpdjV5ZExaNHJibnVvRTgvNDRtWEZuSGVZYWw3VUd2RmJWNVFhd1ZCU3M2eXdWZGRHSEFYdENiZzE5ZHlCTWJ6SHNodDFxd2NDZkJ1dnFkcHZtdG1LdTM1Z0ptWFl0azhoS3Z4WjBzTFZ3Y3RsdmNiaUN2eFM4MVBzY2YzNi93NzZvUkhmRnlUbXNyRzY5MGZHcTFXRjc0aGNhTEQrOGJOM1l0TzN0bmFMeVNPYlhxNDN3MDVyNi92YklIM25MUnJ2SmdBK3pzRDFGSTVtSFJBb3M4ckVzTHZKZDVZM1RtY2xteThVcm5wbFpMNUYzOWV1UE1GL2ZpSnEzanMzY2pyTm12TlNaOGZxY29iWHUrUElNeGZFejMveitvUXQvL3FkZkNtc3V6czN6dHYwVzdYTHhrMGE2L0NKbnR1WjN3dFdZeU5xUFZXVDV5WS9hY1BOdjEyN25pZ2I3UmtiMVdqKzZDYThsdEMxWjI3bzlrMlRmNGYzUFJLMlVmZjdTUDVRNStyZVltMzZVcUJ2akhTMjJabzd5QlgycGlYMGtVL0FMd0N6OVU4LzZWd0xNWmh5RURNSUI3R1lBTzhPVWl3eTQyL1dkWEdPMzZnK1puK0VGVEVjbW84N3dXaFprUjUzQWJhN3pKRmRxSE5jQWJoYk5KbkxlS2NCNWZjWWhzWlFYeXF5VS9GUTJ0MGdmM1ZzZG91ZStZWnZ1Y3k0WGYzY0IrNlh4UGZMSk1lVkl0MjFGcnZmeTNvUmdCL05aYkcvczNYWUQzRDcxQ09JTk9PUExCUDY3WFgzdjhqcEdId3hNYldxLy92bnQzb1lKOHhDazRreEhPYThWQStsWnFscG9lczI1VVpaRE43RXJwVEQweHg0YVJ6M1VzK29CVUlHNUJmbWxzQmdUZjVPVk93RHIyNU16VDJmYXhLNFYwcG1LNmFRbHV5R2hON0NKSUo4RjhnT3NiZHJJK1R0SE9MZFZiN2dBNTM3bUJyZkkrMmZRYzI3RVNSYzl5VVVaNGhTNU9nUHpBSmdmd3R4eHJXalRWejdxR2pPdEhCZ2gwYXIzenBETFdzZ0RmMTZZbmVHWWsreDlEcVI5SGdSNzUzUXZ6ZDU4ZTdxNnZ6dWVoSzVPSVUySzYwSnpXejU0RjBaOGxCeUdXZ0hvS2tuVUdzN203OE5JSEVJR3IxMTdISUxIblB2SHhnWnBzODF3L2U1WkdmNWJqTGdsaHF2cmFscWgxdkZhdGNzdTVMTXVKU3BrWlFwcG80YVY0d2Q1NHhpajVySXRTYVZXUUJiQTl5MnVDeC9maWFMTTJHNm42d3RSM3FPeE9Ud2JSTm1XUlJwUTR3NXFtSW13aCtCckEwMTRjS25tanl1OUE4SkQzSmFLaHBiQ2VoRkpUZWFoQ0hUS3o1aDVRWFlPY2NMRWVzNHdRNUllLzQ5bTZ6NFpNTkJWSlNjTDlSNUVaM0Q4Z2NwZlRiZDc3RERHRnEwMmZUZEdmWlFuR3dqeGV4RXhMcFBHYUl3S2RBTlN3OExMTjdBYlU4cnluMkVIT1dRVHBEZ012ZUI3U3NHRjYzcUl5QUlTNEZTQkxDRjRiRVNWdjBwY2pnYWNITUMwcEcwcDJ3MEZUUzA0bWpoVEJlVE00bGQyT24xYkpJbGg0WU5Dd2d2U1UrNHdGbkY5blJNdGI5YVVSVDdjMVZuSUE2UlFnalFLVTBPeDNBWFlUUVBBYURzbDg4MDJnaEE3UVNyZVl2UUdENW92R0RJaEhySWhEaUtpdnRLSVRNaEJxcVlGQ29PSU1pNWpWcUpxeUIzY2tveEdtbGl1alE5cGs1dGlHWmQ2TUx0M0ZRRy9LeWZPNlNsWFoxbXhRbmRsUzBCVGhacjFsZW1iZFNtdXpHL2tpaUsyQ0YrZzB1Z2c2em1KMm95ZUNTM2s0T0l2cGVadksyMnFqMkRiRkE2OTNia2RBRFBXNG16aXVtUXN3WTFvOTFzM3pwQlBsVzR0Z0xuc0kwanhhM1hNdk5NaUJ3VGFmMmhyNitQNkhjN2NKbUtxN3VOZkYxc2gxQnpUQzNtUzY1ZkZxbDdFVVNTTE94ZGxoU2Zxa201ZmVVRk55ajBrWFppTU93dGxqcGxyZWl0b1BPekpsNHlJRTEvSm1mUTc2aVRaK1BwOGMwamxpOUpma0JWdnFaUkJQNzZzM1BMNDRjT1BsYlVaMmNrRitCUFJpRWxCRW82WjNhbGpKM0Z1TVNtQzBMYWUraFNIRHhRTEEyOVpMWXFYbzhzdVI1cldjZVNrQmE5Tm5mZlJuZVlRY1hObDdBaW5TQTVRaXZtdUxXZFM2V3pWWnc0dzkxc3NEOXpWc2dEV1VvcU14eXQ0SjNpL2UrWHdXbmVnblpiWTIrZ3lNSmwxcTR3WlRKVm1hL0dvK3FJM2dEcVZ1dm5lM081MnhFWWNRcmxoaHRlUnBidzUzQzF1T1R5aXB5NlJKbXlnZ01ZM25FME5xOTVLbGVPQkN0Z2lkS1llT3h3SkdERmY5WVBmOUU0amhYcjBaTlZHbDluTGxkRU50Yjh3Mkh1cHRyY1llM3luMktPUENrbXhZbjFScWx6QXdlMmE1aHNoN0FZdWhVNnltWEhzVlVKbXN5WE04a0l0NjVRNlQyMHBrTTdxV3pMbWY5QytZUjc1aVZUZDNZSC9PeXZtcTFsUmM1eGVBWXJ6c0Fnck9yRzl2a01vRTFYYjlZZ3d1NktwaHNtN2ZxbWRVYVNhbmcxZXJlVFZrTzA3c016VlR6L1pRWnpzaExETVR1eVpEbE5zUGZLMlcwWEsxWVlMWUdsZkdvRXVHQWc2cHczWVN0UGdJTTlhazhjQkJvNEdzSjdocmFaSEMxTkxWSEdnbHpyeVlTeG5ON0tEamV5Y1lIL3U1blUrdDJuQ29LTTYxS21TUXRCNkJDSzVDdlJqTEVoYVBwL1RVQTl1OUpERXlCNzVFVk8wVkFCamZmZXhseitJZ1JGU0RYRm1JT0UyQ2JFSVUrOW1CbkhMM2tSQW5yZS9rVzlPUUlGVkttbk1jMHN6SHJPRHRRREtEc1UyZnhkR2ZwYmQxOWJKbVF2N1Y1QUM5YlhneEkzVGxEZElSVU1aUWhabUYybWFTVFlCV0JhZGh0OFV6akt0YUxBWTFLM3Q0RFdGc2krcTZ3SVI5Z1lsbXNEU1NtQUZNWVhOWjd1bVZjRlhJSEVyS3FWYVBtVzRkZzNIWnRjQVZDSyswQUZMVkVBSkNEVGdVWWk4ZFdQd2twWmtyNFp6a0VVYVptMVdrT1VJTjBKNFpnZzM5RE45aUFPUmVmeC96TW8wV2REczJMV3gwa09aNUVIMU5vNGl4Y3MyelhYVzR4WmhUc3pDcnM3V0Z4a09aYmh0aW9zZ1QybGtCaWp1eTNkUWFSejZxbWxiSXJtVGNEcDA4NU1CRGsrYXlvODRkRDVSVGtiTjV2M0phOEx1MFhnTDBwbkZzbVVPWHppd1FQbkswMVpCaVBValRQQWdTdWM1MFNuVkVUT2wrT0pZR0lLSkMxZCtBd1pVaXdqaWcyWG5sNDEweUJwdDVHa1RxODRTSmZJbEF1eVJOR2pQTU16MER5a1dwUmxqNEZoVFRVbFRnZzl3b1haZnBoUFcvY1VKN3lEOGpMM09JVDBwbldYVEE3dU80KzFQMGk3MHd4L2wwNEhSSTc1Q2VPRWxoQW5WSDNQT21Bb2hWUm9lL3c1elNxa1ZqbHFma0NHWVdWTnVyVGhNNFVpVTArOXJkRzNsYTVBcmo0Q3BSUWJVYU1ycGNvSWd0aGh4MVlNeUc5VEpvSTA4dCtodHhGYnZWdkQ5a3BxYytHZ29oNktITXVkSW9tSkI3bDAzTFI3RTczcHpQM09yaG5QenJ1UVVLUi9vbHM0a1gwNFZZN3pobURYdlpPUEM1L05sMmtINGpCdzFaSHZIbWlGbmZPcTVDVUtadDAwRDl1SWRhWkZPbnNpanhEUWtOQ2J1ZElWM1U3a1dQY2V1eVBSTFRva1Fwc0hVNjhGTzByV2IvbGJxdThJWTZ6MnJTbVcwSk9mb2Y3cFo3MjdCZUxEMm5aVDIvUkhhQVdocFVVWmVTQUlVSTVINUpKbkhGbFp2QkxkOU9pSmxlSjY2QnFUS1pGRk5mbTltQ2l2RkZrMW5rZlIxUmJBbXkxZUlpT0FzZk5IRG5YRlV1ZUhha1prZHkxcE9hT2FrbG15ZlNSUCt4Vi9sT2JpVnJucUQ3NWhqMEJVYW9DYUxjMU16cituYW5kL2dVaDY2WmlyRmVoT1lpaURHdHZLTDNaRVBzNytuSnhRT1lySTAyNURWK3hOY2J0OU5uZyt4NlhDdVdlOXNETTF4dkVubjg5RzF4eHpmVTdwVWpCMG1EdFVDTXNCY05acStDa1ZVTll3ZEZ0dWQwOVhsNHlUdzROR3dXTThzc2c2c0JKWWYzVU9MdGk3WUVkZjA4aUVaMEZuWlc3d0hEcnNwQno3U2thZVVNS0UraU5SNHRNbkdReVlLTnVHVWNVMmFvSnNFb0VJWVdEakZ1bmdEYjRhVzNYUTFvM0hjMG9oQitId3ZtcXpSOGpUNHRDOFhpZ3JkU3k0Q2d0V1VxcjNGWXB1UXJ1YUtBS095SjhBNzNxVUd0VTh1eXAyOEh5bnRCdzY2eEZnVUhYUGtiMU80OHlMMHl6N3FCcElzOWExWGM0QkJzbnd4YnRMbkg2TDBnOHdrRzM5dnl1NXZyWlVZcDJBS1VRejJPU0I0OXFXRzJsUHNDUnRydEJXeEMrZGZkZVAyNElnUVluNjd1cmk3Vy9TaElTWXFJUXczamcybmVDREt0T2ZsYVVLcG1EK1lOWCtpTVpDVWVic1JUcXBlK1REVURVZE9xbFBoS3ZxTHQ1V1dSNTFnS2V6Rk5CdGtjRHVKRjk1NklYK2JWNVg2WnAzR29LeEdsbkZzUnJSY3NiS3Z4V1o5aEpoR1laNXNhSXBkeGdNNjlGWDdHMm5ySlVuZVlGQTU4d1FRRmt6MWdpQ3AwOGI2ellqaEtCRXdFdHhEajlRbGFPZmF2dHVqYy9zL08zNlI5OFJJeXZJY2xsalZFdms4M3lPc3dxTHdpcXlJRnJ1S3JBam1uSlNuTnR5eExTc0dKMXVOWUJUWFpMSVM5NGZBYWZqbFBxanluSFNCbk90YzNpcm0zRUc1MDhNZ2lzY2tNYXR3bWpUUTg2TnY4YS9JWVJ4ZVQwM1VIWnQ0Mks0ZkRDNzRwZlRJTytGbk1EaThaNm12dW9iTVFLcm82VUZPWU9FT083K3pRTVV2ajBCazIxVFFnekpZY1dYTjRaek10Z2tCb2N6QmY4QzB5bmVBWUlzeTJ5Y3VBN1hZWVBHelQ0R1ZBQWoweks3cjFHUEsvb0hQL25tbE5rVzBCelEzL0RUd2NqaG04Y3l6R0MwMGN5TDNHWkM5emZKNmhyUFp0Qkg4L3gwT2VScnl4TS9zbmc2U0YzeXNRL29EaHJ5V1dMWXU0R0RudGFyVXBwMnUzNUVBV05QYzMxSENnZ0dVSktBNlowZVJWTlZVcDNqbGYwNk1OT0xFQTZiUWo4WG5rTU8wcHArQ1VmZkY1L2RuTkNwMTNhUlBId0dUSkczNm9naXhscDhQWWFnN1NuWnhiNEdYbGRKZ1d3bzlkc25wOFhGZmc3TlhIOTkrUjY4TjZmMzBKZTlrN0MwVHI5ZTNPQVkrZUxiSXVpM3JITHpEOEJoN0pHZTZCR0FLV1A2VWJHZHRKVlJaWnVucmVZL0ZxVmdYWmxFKzV6RGg0bkFieFhsVEVhZ0F3cVM2ZFBSQ05MNkM3TTFBSWNoUHh6UEI0d05FdGpsQWp1UkNQR3R4MU8rN1I1WGF1RDVJVElGOXhWLzZmRlF5QklScVFaM0drVUFQaHA5ZGswM0NndzJ5cFhIUFJpbnJIWnhDK0FHSFRJcDhRZ3M5ZGk0L1hDNTd6V294SnZUQ2xzL2RURTZVOEIyWVFhdjcvRHJYR0lGZEc2akFaemFyQVFENVJ6bmJmdThsTUZzVm9FdlpxTnk2NEJPNGh1RzIwQWd6ajVwdDY3TlAyam0zV0o5M0xzeUtOc0RPb2xkSFpLZkkzdDEzWEpYaDhNclFoNm8zNUpOK2tQQzdaRUdwSkRRTXBWdmxVT2E4bW1DWk81MWNyWGczQXVUT1g1OE54V05XcWxobHk1VjQzZEgyTHR4cXJHQTJQR05oRGlPUDVjdEdYZHFEQ2NzNjEvQjhXL0NWbnRTTlpxRmdZUmFLSXl3QWRqRWJQZktORW9TaW5vcDdNQmduUDhxWEJLT3QrSFBUNHYwQ2VnSkZMY2EyZXBZY1VSWVRXNEgxRWZwK0U2SysxckV0TGRqYXJKSUxxQnVpRXdMOGpFQU5oellsay96b1dlN21iODN0bjNKcXNvQ2M5VGVGRlJzeENyTnRFdkVRYnYxK0dtWmhNWkdFVWoxQ2VWaUdMWldVMlZzby9HVnlLc3E2bEFmVTZ4NVJ4NjBzTllxbldGL2c3Q005OUp2OERRcm8wY2o5ZlhSZTNMdCtiS1owTjczRVQrUWdBQWxEaWZ1N3QzN3J0OWI5TG8yTUpBRjc1NG0wQThOYVpnUXNOOWJMSERKY0xrREFBUU1EZHNDeHd2MVhRYUJhUSs5UUwvVzVqdm4vdjF3TitCenlrdVJ6YzlFTHNDYTB6aVlMeEM5bklHbysyZUdSMW9mb3hJZUk2aFIyRVlidlZWQ2d3RmxTbnltNVpkVStvN0c0NXZhQ3VqMVcwRXpsOW9icnYxSHRYeEwwS3UxRGRBSkV1Vk45V3NHTUVSZjBrYnl5WUdsM1RlRTMxcktrdU5qVk5tc1pqS2d1MnR3anZNRXgxS0tabXQ2bnB2T3NJOXdwdk9pQ0Mycjc2QXV0VjRYYkNOaUVqUFV1Ykd5WDN0K1N1cFhZcGIwWDJxcEJja1k3dTBqQVhpdmU1c2o0dzNxUEsra1JabjZyS2pwSitWam9DeG4wbTRydWR6REhqY1JnZVEzWG44Qmp2V3hmNC9LT20yR2dYcUN4WDJRRFJWcXliL2FEM3VOeitGKzEwb1lxMEpHQ2hJa1U5SnM5am1ycFhkbzhxNmx6cThiaFlYUzAzaWs1SENQYVNka29LM2psejl0NXBvaFRsaWowc3hya2FNWERQc0k0WGVkSFZieUpKWk5DVUl4amNuOXZlcjZiQ0tpU0dISDZWUFNweTBPQ3pIVlRyUTl3YUN4WVVJQzlZL0VtQ2dpbFJ3YWlLUGFKTExNdG54anNBVXlVd2VJd2dmQXlpSmc1ZFlOZ1lXQUdBS0ZEQnRudHVwRmNOejdxUHFaNWI0a3laVHVXclVtcGwwdDBvYmJJMU5RYzJqY29INk8xWEplTlE0ak9SdzZXa2Y1Vk1tWko1U09uNFJFWVRzZjNBbVZFSVJnOEN2S0NQckJXUDhTcDNFdURnSnNBamdNUDdDQUFBVlRBTkVFbFZnREZwREhEU3RBVjRxdW1Bd0dxcFZOUUZ6QlNIYkYxaGN3SU9uWmdCYkhjZUFrU05DekMybkFGT1ZWa0JudDVvUUpEYWZxVWlBbWFlem5nZVJYbzNyTkRIdkdIM1FTK2dxMjJPOVNTMjdIcW0razdQbHlhc3JBZjR1UFd6czRtNTJONkpUUmJPS1BPZm5GemN6MFBYcU5OR1NvN3lGdVVWR2JMcU9iWFFKVGxGdGpmM050MFJSNHVFSlFmWTA0STU4L2FtdTRFdUtLQk1KZDBXQjlDMUdSZmFTdGNqWVlzWmNkdWo1b2UrZmx5cXUrdDdGYlI0Z3ZqdjgzM0Z6ZkJiYjlhc2hEa3hlMHNZRURkbkg5dkY3S21NWDBCQWhUckRJa2IxcWJPZnB1UmtjaVo5cFBFYjJzdUNoSjMwQm9vTFJ0OXZwUHFSTDBUWERuR01lclRHTkVIR0M2dHNVNWJlOWowa01aTlpLS3hzN0ZRYUJ5ZlgwcEswTlBXMnlaQnBIVjBXcjJ3K09YTGx5VmVnVUpGaUpmeEtJL0tmUUZDNUNwV3FWQXVwVWF0T3ZRYU5tb1N0MTZ4Vm0zWWRPblhwRnRHalY1OE5vdm9OR0RSazJJaFJZOFpObURSbG8wMDJteFp6bGFNZDQxd25PZEZSSG5HbFd6emxDYmZhWXF2VHpYaEczSk9lOW9KblBlZDVYNW4xaWhlOTVEWnpmblNHMTczcU5mTys4WjBUTEZxd3pRN2I3WFM1aEQwc0hXdjdzTS9JZmUzbmEvczcwQUVPY29pRDNlTUtoem5VNFk3d3JlK3RlU01HY1ZpMkVrOENpV1FpaWN3a2t3V3Jiay9CWGU1Mmh6c2Q1NmFzWk1NUEh2UlFrYVNtNWNpWnE2VGNKZWM1NlpsSjdNMXY3Mi9jdE0vT2hVRHcvTnJjSHRxcDhWMXpUWmxqVy9mWmU4ejBhcmxxTi9kZXVKZFRpbHc4U2RmNEhmcEo1b2lkdjgrdmxWTE12T0Nmei9pb29ZR0lOTHQ1M2o5Zjh1QlVzZWpmTzdKSGFZcnJBR2lGTjIrRkRGM3BGenM3ZEJMN091RFZzdmROVmp5MlkvTnF3Kzc0d2xQMml1OVlxQnF4dFBUbFdIL1p2amNpditMSnA4WldpRTU5a1RSbnlUS3ZyOEIwLzJvS29mQjU0SFpGSXVtbzFpMk9sTzVmNDhJZ1pvWE1FdVkydEg3bm8rT2YxT1h3anpHRlpuQnUycHAwT0RvNXhyYWVqNzJ0dlJqbXU5MG1rVkw0S3czRCtTbmY2U0x6QjJGR1JPdURBQUE9KVxcclxcbiAgICBmb3JtYXQoJ3dvZmYyJyk7XFxyXFxuICBmb250LXdlaWdodDogbm9ybWFsO1xcclxcbiAgZm9udC1zdHlsZTogbm9ybWFsO1xcclxcbn1cXHJcXG5cXHJcXG5AZm9udC1mYWNlIHtcXHJcXG4gIGZvbnQtZmFtaWx5OiAnQWZmb2dhdG8nO1xcclxcbiAgc3JjOiB1cmwoZGF0YTphcHBsaWNhdGlvbi9mb250LXdvZmYyO2NoYXJzZXQ9dXRmLTg7YmFzZTY0LGQwOUdNZ0FCQUFBQUFEWGdBQkVBQUFBQWR1Z0FBRFYrQUFFQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFHaTRibUdBY2czWUdZQUNCUkFnOENab1dFUWdLZ1pvZ2dZUmxDNE1nQUFFMkFpUURoandFSUFXR0FBZUZPUXlCRFJ0aWFTVnNtMGIwYmdlZ1NGYjNGMFZSdGxkN1VjUVlCekNlYk03Ky8xc0NGeklTVGhkb3RlOW1rZ3EwcXRSalVWQnNkejFhOW1wWjdCM0l5RDQveFNPRXh6RUdzSzJxYys5dHhjU2YrL1J5R1hBOFdJWWErcmhwSFpWaUdkaGtDdU1SUXpjWnYyUllPdDA0QitaL1BQNDZ2cjJiNnIyeUxxNmhWZjFaditsb1QraGtpSjY3ajlEWUo3bjJQTTNadkwrYWpVTUNubG9PdGx5b2JOcGlTelVOclllcXBtNENkYVFpeW9tbGQ4Nkp0VTc4TDFYemhmOTNGd0FUbE9tVVM0Mm5kNmtBOFJ4aXhZRVRqZXRjZEZGWEZsZWE1Ly9aSDN6NzNQZkZrT1Q0SXp4V3MvcE1xUFRxNHVvVDhqU3dpMmVBdHZsL0tEb3hBUU5PVVEra2hJTTdhS2tRRURBQXdYak9Bb3dadlh5YkxxSmM1dDl6MGUyMkY3bG85LzdlMWo2bzg2c25XV1k1bGd5Y3hERW1jWnhQTUtRQnpPNGVZMUZlMDl4MDFTNjNDL0c4Mjk1Qkx5dlRvQTZUZmp0QUd5c3h1c0VCY0xIK1pHYy9rK3ZldEtGMmcvdjBXWW03ejdJSnRZa1A1dUpEdnVXdjdaNDRha0V5MlpPOHB1S2R0S2g4blI2YWtxNEQvaDl0MzVDaUZFdHp3ME5zQnJHVndmSU5mTmNUTlBObGk1cWlUbGVkREg3a1ZzN0N2YzFBUk4rY3FMU201Y0lDKzMvRWVTbGp0clJjRzFVNWlVc1pndFRyOWI4VnFnT3hTRmd0cmt3dFgzNTZCL3NFU1JuTzgyUU5aRTErUEJsalVrVktGUTFtZG9IZEhTenNHV0J4QmlUUEVlY0FMSThDcmVENEQ5N2RPNTRNMzFPSzN2b0loM00wYjhpM3htWEtySTFWaWo2SWxJWXVja0VhaU9kNTluTjEvOXpOMHh3aWVTVlJJaW1ZUDZ6Q2IxVFRhcEl5cVhEd1pUOHJYeEpBbkJaV0VhZFlzRzY5OW4zN2U5VXE2QnBPbDdONFBrb0lwOWc2S3Zzb3djUXZYMTNyM3QvRTBkS0pPSGhDN0tJWEEvcitKKzFCQUpQaW1tWUVuS1BJR1plUks2NWlycm1HWEhjUFF3Q0ZXdzNzN0hrT0QyQzU3K2FPSnNDQ0J5Q0YvQmQwNysxdFRZQU1ZQURDaU9QQUFCeFRZbklXU2NJRExQeWFhV2V3a2NhYmFiblRIdnJWZjhxVUlSWThnU0tDVTVRWXNlSlVWS0JRa1dLRXAyTGkrMFJGT29HRGk1TkRGSWM0TGhWMVF1clFFUXVBRVdnVUxoeUJTdUZTU0dFZ05FUnBLV3RMMkZ1aW9LVUtXNnFvSWNVTnVkQVNJb0dmUWxmZzB0MmxpRU14bHhZNlFRQlUwRUZ0MHpHT1VGNXhRZ0s0WlM3eC9Vb24vRHc4WUIwTXhURkF1RVNSRWw3WnZ4c3lZUzUzZDlvNWhPL2Z2WUpJSFB6WTR5Vmd1TnBpVEZ3Z0pPRk5DYU1RaUVnaEVpc2hka0dXTVVFMENCTXJPUHNZendVaXV4QW5ySklFM0R6b0hxSzhGTVN0dlNJaUlHVWdqODN3QWd3RGNHd1d0VmRFU2o4aUVYaW81OFM0cFNDOHl0SzAwQnB4SThkTjFKdUpLVmdXNDRHK25ORVVrUkIrdGRqY1VncmFRaTNvclNEZC82U0FIbUNPL2JSUi9PdjNXVEM4bC9xemoxekZDNmRHNkYxZ1dDZVJsbml3OXlWMHFoVmpTYThVVE4zdi92cjRrVkJxTklaTUdWTDN5ZCt2V2tCOFRUWFJ4cGhFRWdIY2NaSVVGRmRlTlY0R05hVXh5NUROeHMvUGFhRGhvb3cwWGFLWlp2S1laNzVVUnh4UkZST1BZMmVTSkdPVVlxUXlFMEVLSFpGUGVkS3JxWTVvSUl5WGNHb1NYaTNDcEJGQkJwRmxFbEVXa2VoRWxrME0vSVFNZjFjeTBnUmtJbUVtMmNsazB6RnF3Q2lJYkw3Z0NBb09IWVNZeEVDRUtOaEVJbGlKaFoxWVJCTGlKbFpKaEtRb2xHT2tCZ3dpVzQ4d3d3TG1NQjhUTk1DN21qV1V3Nnd4TVd2NnJqWXRCZGprRXJQV3hLd05zV2xMek5vUlVYdGkwMW5ZZUk5WmpZRGlIU1pNYllLRmxoMTQxeFhXTUZ0cmc3NlIyc3cyMng3SlRqdmZlWmQ5YkE0NHlIbUlrYU5FekFxSW9wQVlGUkZaTVRHNFFDd3VDbnNld1NMWTJtNFMzY0pKTVdQWmpBZjZkdW9aUkVHUzQ5MyszZXNLQXBjdkJnSWxjaVBoa2xTQlh0RXY0UWZGQ3krU1gzVlIzRGhvWDJFV3RXcGVoZG1WNkNRNDdha3IxV2pZMGYvQ2krbFhYWG5RREZCRktjVDduM0w2eTlRU1VvRXY2S0JSdklubTRYWmg1bXFsdFRiYWFxZURqanBaYVpYVjF0aGtzeTIyMm1hN25mWTcyc2x0VEJSZklKeUdSSkpET0kwSmFVS1k1a0xDRmV4QWNLR01aY3hqVGdoMTZhS2pUcGZjcTlmZ2JCSXNRREVYNCt3UGhIT1VjSzRUNXFZdUpKSk5FQkhSaXNVWXowd0R1UnlsVndKeCtNUXVTMWFabkhDSXJFb3ZjcW9oUjQ1WlpqWVdWcll3cnd2NU9BZnp0NE1sTW42M25kUnZJYkp3OW5NeGpCT0xJWXJqOUowVWUwVEhtYmdpcDZ5bDJKMWw3a29zMzdhWmJ3RTVvakdNRThPd09CbUxITmRIVG9kQ1YzWTRrUnlHUlRjVGdjSVlrZ3ljREJYVzlud2FwWUYrWlFTb21lbE5lZnBHdUlCR2o5T25jYk90Wk9iUHdkVlFuN0RPWE9DaWprc29OZXZzMHFWak8xZHJXcTM4Nk1wNG0zRldFc09BOU5MSUxtSWdXakp5WUdGN1VoaHRSNFRJekJHSXVGTWVrNW8vd3ZJRWhzY3dETU53eEFpQlJvd1VZcVJJd1RVcGE2WVpJcE5JWkJLRkhFTllSYzRXZUF6RGlDUVNtVVFpa2NsWXBHQ2hrQ203MHJiRlhQTjkzWTNnK1ZzbG5yckpES0hhR2IwSFF1WVpWenowWFR3OGdkRGltdDJwRHRlNDdQdTl0a0ZXeTBJSGROQmdEYTdCTjRUL1JOSjlkOWRVQXA3N21xc2JBTzFVdXRwOG1rd0dBRVFrQUI1aGp6bXlDTzFHNVVDL3V0eG1GRzZjdk8xUUJYRkFKTmU5RnRyRWFiN0dRZnJmN0ZYRmowd2dFNlZObnRjVVg3M3dCaExZeFBHb3BRZkN1NHVwaUJHWjNNR1kzTVlZeitCZTNFUVl4b2lZWWJpNG1YejBHNUUwYzUwMGNaVzBjRVUwdFlkYjc5b01FZkFTaHpiU3VtN2g4azA0ck9DUTZDL053eE9McWVyZE1lWkdZQUt3bzRNSDFEL2RMQjJoSlFJQWVNVkhTaTZ4dGhmN2NvRzZ5dThraGtMVmVCZkkvZTNBS2dEbzA2a0dLRStCN3JiQmdVT0M4STcvdWFySzQ4bTZtMnFYUFE0NDZyZ3p3blFSOTNZbkJFS3BFQTFpUW1wb214ZnhQUXdvcjZjZFZuRGhHN20yUjBKa2lQS25zMzdYVUMvMlFvdDZ0bWVhMTRPZDBNNWZGK3kwM1dZYnpPTDhlam9pOVZpRFlwaVBvN0tMY2dEQzJZdTczcEgwZmY4MVIvcSszdHVwQlFjT0FyK0xreVM5L1lmRjdWdU0rMCtSNnhPMnIvbEk1WGN2VU92L1c2RVh5b1hObmZmZ1QrQzFqUWVRd0J3YUNLaXpvd1lLTGNYUFc3RDBhZGhHaDVQRkJHTVJQWnFsbmMvUm0zZmxqeGY4OHNaSDFhdTdTL2RMNzErVHFtVnp2MlJMcWtLWHBIUGozQXI5bktJamxjLzVBemw2SGhtMTNuQW0waTI2RGVha0NRZnhHRFV3MWxhWEM3eEJneWFDV2I4VU9yY2l1Z1lNRGM3N0JNa2FHTXliMTdMcVJaQ1drZlc1MnRtTmV3VzlOYVBOL016cHAwcjk5M1gwZXQ3dVlXazc1aTNYNzZSb3lTZWg3cU1FblNkUDNWUjY2c0RrclFHVUpXUm9KaVZNd0MzdW9jV1IwVXNmUlo5NXk0U2FtZXB5OFkrRnd1c1FTMlhwN2tnZXk4MVpHTXhoNENUYzlMd2pPNzhiZkE1Q2pMamxOZ2F6ckVscGN5MjVDcVBrY3dYMUNZb2hhalZiOUkzLy9wcTR5NGJvRGdDSzdpTE8vcG5LZ3p0b0xxSjM1dE5OTDFrZUttMHMrTytHNW9ZRnZDWlluRytXZFhkSkRRbFBnVitEWjIvd0ljVDlrYVYvTEpTbHpZOW90RnJ4Tk5GWlpKVUUzdTdGeXFweHVyeStvYllmbWh6TjM0NXZkNDlDem5zY3ZuR0FDcC83bWg4eklYbkE5M0ROZ0Zxby9CcThiTWkrQ2MyMjFyQjd6ZzZ6VUQ1ZnJESTI4N2JITS9NNUU2THVtcCttSmpobmVIQm5DaHpUVXluYUc3Y0NvWTBoQk04SEV1T3pHMENJWXhWMHNSZnhOV2lDcXdGSElWbFFodVMvNWRaeHJJZnJVUDc1SDNRbS91OG5sMUpEaElyd1ZrT01TajZoUktJb2xUU1VTUXpsa280S3lVQ2xaS0pLc3RCU3N1ZnVZSkJYeGNqZTdrVlRDL24wRGxxVzczdHFFc2ZQMUZQTjRQZzlYSzl3akxYTEJtdFlRUTBDR3hCb1FLQUZnUTRFZWhBWVFHQUVnUzFJNndIcWJCVE5HUm1aYVVSZmpQU29rWUZ4Y05Pc0k1aWRlV1pmZlFacFZ0eUFMZGF2V1RRc2ZkQndrcU56OWZINnlUNW5zNnJIdlVtOG00UVRGNkNVMXRkNkNUM2lWYi9hc2hZdUtGZ1FwMXk4YTB3a3Z3QUFiNTdaV3IyTXNXQ0h5alhVYWNac0ZMeDJENk9HRzdUbnVvYmJjVUZJMXIwMit3NlZodjByYXEwRldwOVkvTHA4WG1sSTlvcHpGMVd6TlF5M2tleWR2c25wOXdBSkFpRm1iM3hNWld6ZVdwV2pTbDI1bjUvR1EwVHRvNlJnR2laWjRwK0lrYTF1NDA5NmNiSjJNWmxPRmltZzZCS0xLdTNFb0UyclFSbEQwY2hJcHVTTWRWRG1wYUd4WDFZYWJYWDNOREtLRlp3K3FkNGtXTEpwditZTWkxT29NZDlnclZtdHovQlNZMWVtZ2IzWHJVY25hTUdTTk1JWWNGcFdjREpuR3kxZC9ZOFE2TXJNMEZNVHRXNXR1dVpKQkd0SW00SlJaSWJ6UCszbWdxamdadU8zc1ZWbjNvMjhUNFlJWGYwaHczb0RYbWQyUlhORmJWbzFrcUZ1WGY2TUN6LzFaT1QwWDFCY2oyNlR6MkZxQWFUMXlJSnh5KzJrcUM2MTlSaWpXd3ROWDN6Mmp0dGF2VnBXOHVSOS9STGNPN1d1cjhDRGwvcWljNjN2c055UFM0T3g1Y2pvZFFTSlcrS2tXRy9DMU1tWmF3UlQzcUJhTGF1K3AwaWUvRTNNWEpaSndQQnB6NTJ0T2U4Y00zemlENzJkaS90YkVPanZldlEwdzl0TmxjSXJNTHozeGQ0ZEhoREcycW1jODNyMmdYeFkvQkVWNUNYRWpUUi9BbmN0T20wS3ljVFVhbHJhSEtUd0Y3RGZFS2RIMnBjWXNCVDRMQ1FsUXFrNkFFb2lsQ2FDaHBDUkNHWHJBT1FrU3M5N1RnaFF6MEFCRXlyV0F5aGhRdVd0QkFRVlRLaGFENkNHeWFodkJ3MmtCcnVnWmgyQWxrU29UUVIrNkVpRXVuVUFlaElKbnllb2p3TjJSZjE2QUFOTVl0aXdCa2FZMExnZXdBVFRpcWtuVHpLMUoyWS9oSDZLbFk0UTRzWmM0ZndDQ1cweGFUS01sako0SllQV3N5U0xJR3djV2JCMVpJbGR3MS9DWG4ySkRqTG9LS09mcmpVNm5CMDZYQnc2UkE0ZHJtcURiakxvTHFNL1VKTU5UMGMydkJ6WjhIWmt3MGR0MEZjRy9XUTYvQThuWEo0VnFwcWg2dWowZVpkelh6RXNCNi9NQTZHRzd4TEJnOS8rb05jQVY4RDBGdGhQQXVCZkFQWVl4UDBNQlFBQXJHSENFVEFrT2xvVm14bWNMU1ZXQjY4STVvYXBpSlRaQjBiQWNtNEU0U3J5Z3lVZ1JvZndHRkpPd1pGS0IrWlVvdTFhMkhVd011YUR3b2pDWklrTWVwaFRaRW1rSmxQWjRBWnpETTZZeTNqRmV0TmtYTk15bDNsZWtLRStPd2lNb2wxMG1XaEQzSmZyaTFIejE0dW1DY2V1WFpjN0EyYytOenduQ0R3ZUJkS2RyZGowdU9OWXpESllLU0plSjR2Q1RpYVJjTDVQZ2lEaWlSQnpGSzI0eUdwblpHUE8yZkNpRUtJU3duTTU1N1hRSG5qaHVoRy9QUzdzaDFGd05sK05WY0VZMkI1alJ0NDhneFVKWHZOcmpQOHZYajI3bkFNQkFqRmt4SGlwYysvUnhJbU5FZ2FmdlFDUXFXYSs4SVFGc1lCY3pJUVloVWtxaUZRQVFrN0ZDQ0d1NnN1b2xqalRVZlBYRi9wMXNZTVU2d0JrWi9sZHBTWEpkZWtYTDNkeEpQUXdnanVjd1p6anV5RjcwOGR1WDZNM0FvNzRmbWluRm54M2k2TTdrcnBCNmhvT2JlRm9FK0oxcERiSUQ3alF2ckgzbkRnbURUSFA0MGh3T3lhZ2QwalFVYXpQajFrV0tZNGpnY1V4WnpBYUtwYXpHNzJxb011YVpvMDdrZEl1ZG13VXZGUTRaYlpEWEpUTVFrQ2VFR24yZHJxNFl5cjJPaHBRVXorVjV6R0xCTUZuY3h3Q3hiSndxZXJxcnVpVUFUU1ZXOFVFNW5FMkN3d21yODFOdTZYNVdrM24xM05RckhlT2R6TjU2NHZCbVU5U2dqQy8yek9sMjJBbWNEWVNoaVRYb1lZMStqVjJFOGRXMm04QzhrTm53eW9VMVBUT1BTUnBSNzlyNU0wMGowSU9xcjBKQTRQOWVoWWFPUHV2WWRJa2tkcCt4cS9OR1Jic05YZWU3OS82Q1VmNkhwUXpCMTZtVS9oeTBxUnM0SGI5Vk9GWW5pc2lWWHByUzdhMnQ1N1FRMkJ3N1lFSDF1dnlDRXBERzE3RzJKbDNxVjJXZ0o1R29oYkdTQU5JdW9tMmJKQ1U0TDdsM09qYzBKR1N4K1BvTU1zSm44OWFtcTVlR3VPNmYrTmtsc0V4R05tTWp1OEdzb1d0QzVUbkFFb0JaenZnZmRraGdsNkhQalpQbXBMT3BqK2twbGtJN21XVmhWZ3dVMjFZRkdnRUNDWVllU1o4MDlIbWsybWFDd3ZZdmJqcTE5MmVRR1lBNWxtYXFWTTdmcnVtV0lqdEtvYWtzRVFXOHU2TWtMaUhzNzUyVGl4S29PNmlyNW1RSncrRzJoS3lsdFk4aTV6Mkk5OC9ZelBXNkJhZjV6d0k5cTZUZHNSNDd1ZnVwVmo3bFdtMTBWbjlqS3RScEovQnNGbVVzVWtxTGJ1bmIwNERYZDlid1o0ekM3VlBRMjJjdkQ1eC9LN1FqZ25NUTJieU8xdGFMaHl0V0NmdmNXb1RKcTFtdWFnTithNVA4eVI1MGpRVnBXL1pzc0gxQkNBcmdoNFpGbGhHNkNlL29iTURnbkdKOFlBQk5hTTlNVzhDbzN3TUhkNUgyTFpaYkh4ckRCQ3ZLdTBweHF6WXpJRTUwbWN0SVN3Y0pSQUdwQ1U5OUtwNk5nZzl6cDk0TnUrZ1pTN0FPOVdZVSthTTY2aUVJUWV2WkZRR3ZuZEdNOVBONlN3U2Z3VGxXSDZoNnZWL1dnY1FvSVk2TW9wN21aUzhDS0Z6Z2JFNTFzcU0xODZ4cXlvb01DeWxMQjlUbkNkeHBzT0Q5N0l3dHpUVUxUMXBubWZ2aVlUU3BsYjVwR1ZKTXBMYTFjT0JOQWdCL3ArNHFIQnVqWDZuNzIvSjFDMGJjajM3aE4rNUtZR1FaQU51OUJNZEM0S01HcHZXL0xDdU1OR29STFRSdCt6MXRSWjhkWk1PUFRIZVNXcVRMN0tzMnNOVk9ITnBnK2dHM2RrMlYxOHNubTVHdE9USnh0NmNhbEE5ZXRGMzVqVUt0WTJnZ0p1eDYyRVdNVXZWVFBKa3FLRnptT1o4ckZ1YVVhcjRReGQ5eTVQelhHZDArRm5DUm9lamNOeFMwUkJxeWhCU2RERE1scUltZzNJQXMvWk9tRVdiTkQ0M2xZdzFya2NNUVZ4R29OYk5pTmxCb0NwU1VhWUlRR0RsWTBhcUNoYWRhNWhGZXhhOGQ1TW1YWVZZckF5VDFBb0MxWGlPQ3VzSUZJaERhNk1veFREbnhGT3F2czZKUmJxNGlLRmw2eTlFWGRJa3lmdG1uY3M2YTdEdXJtSDJycWVXcXUvWWNIelc3dm41cVBpaXdlS2FzTklEWUhSMFZwUENNSzNhK1RaU0RadUNBRzV4eEtCa0tadGdLR1loeHBZcy9vbFFOeUExZ2VvOUdpVk0vVjlNcUJwOFZibGNFY2dPRGJGWmQrMzJZTFhZeWl5OFd6YXRTeU02SS9kVmtESS9oZ0VJS05iRlo1elMwSGNrUnFWRW5scDYya29lcVpkZkxXLzdZTXhFWllpMWZWckNXMU9xT0c3SDlRMHg1Tmh1d216ZC9lYXBVU3hmVnlVdWtEcVh4WnRTUzNERkx0dkMwZW9MYUl2bWo4ckM3dWJ3SHNMcGFZdnVvVkU5ZU5HRDBUNWlkSWY3RTcyL0M3N05XUEN0ZmZhUlZKSG5LeUlYbFpyZUNUbDNvMGpWcllFSVVoV3Fzb0VRODA5cDFVWkVydnFtV3NWUlBDNnJUZUVJaVJZaERXY2hEK05pRjU0ZzhMZTVCS2R3YXRqL1N5MFl3L1JmVjhQVUFYZXFVcUZZZzdQeGtpME92YXNmMlFIZU5lMkpNNlJ4eEkvelVuRzF2M3lnSGltWjlvSkRuK05YanI3emRQZUQzQVNqS1BYZlVPbnI3ZS9zTGJ0MXRwYm5IRHg5MlpQUEIwNmF5SjNUR2d0aWZZZm5ma3ZEZWNablkzTGtDRG5aMk04WjhrYlpBdXBjbFd0NkR1WVhudVhQUVJsSjA0ay9yRnVZMGozWjF5NU9pdDQ4bWNtczVLYWFwMmtWeWdxcnFBeXNMVXJmRWlHSUkvUERDUEFqQlBTSk50RVcyZ2l1dzNZZU40d3l0ckJTdHJNMGl3M2ZCRVArYjh2ZUJYTlZvQnFxREMzRHA1SnM3eHA5QytJbG0vaEFXTVNiK0w4SlNFMHpNdHBvZFZrYW1MUDZOZ2NCcmlZbVhVSEdqazFDeXdTRElvb2o1bndwd0tiekZ2ZTdsOW9CQTAzUE1GQTNVbzBNSTIxRFQ5M0dER00yMVV5bFUvV1ZWTVBramMrZmJhU21HQ2JRTnZyOUkrUTBFaFh4NTFOYk43WnUyTmEyc1kyYTcwZjg0NFBVYkRPZnRwRldrODJIcUtDaklpM2tVbExvd3U5RzQ1dlI5Q282Nm5VMDQrUVU1RkczcFJ1YUQwTHorMitpd3kzRGg3UkpqRWliQ1ZyUkx4T2pMQXY3eHpleWZncy9ZZWRTYnBiZGJRKzFnSlkvakJ4MWFzQmhNcmVIbjF6anpaVGsyMDZiUWRNSnR6VVlxTEFxTVFOTE91eVovTmp6bW5GeHNWNHZGT3BrOXovbm5rSElUUWdZNWhNeEdFTHhSaUxHeHNLVTVJYVV3dVJkazBKMC9QRTY2WDE1a2U0NXhTMmdwT29NaGVvU0FlS1Y1RmJVdWJIVisxUEF0LzlzR1pObWMwMVk5U2hMTnlOTTZvQ1pWaTQvMDU3TGxXcHhvK2VFL0o2RW54QXVPVllkbEorU0ZEakZUc2toLzduZ0trZjRrU1o0enY5Q0I5Um9CZE1UREZaTGpva0x3dS91SEtsNTNHNExuUVppcDNYWUh2T0pIS203MTJuSFRnZERwM2ZZSHpNMnZWaTFGZHk2aW5UejJHMkNVYXpiQlJsM3d3ZEhIYkFjSU9kakdGME1mcDRYYyt4YUlmNEtwa1FwSFZhVVhPUm90eU9aYkM3cnZ6d3gwdWhLZGxFaVZ5UVFpQ3BvNW82THd2TUZRcERzRGlXbmp5Q1J0YVRiVWJoZjZJaEp3eFBkK1NYNC94eXRrajdReEdSRGh2S3puOURybmxoeEhwcVpDeU84dkR3K0NsdFlsNTNEbGpuTXNrd2ppMmxpWjdKTlJpYUx5QnAzNUdvcVNVM2FmVnJhdGhUcEJYdERHK2FuMUl6NDgwWFBNNFJOTHNwRGVQa0luNWUvOVB2YVdJK2NOWWNkcGl6RW5EaWJBNTJscjhSSFJwSGZ4WDVYc1RNMWkxSHZSbEczVU1oQnQ4RFI1L2ttOEFqWm9BMjJJU1pWVVVHeXJNUmF1L0c5anV1emNqTnRYRGpUYXVId1lDdUhZNFg3Ym5QYXBQbklPWVJ5bkJST1RtL2xLYjFDbU9Wd29ScUZtODl4OG9RNCtYTzBNNWl5UEp0T2wyZVRNV2RvRDVtTktvblVvT2J4eTRvWDErVDVWRFJJWitYSTVUWEZRNFRHcEJ1dG1XSnBzclFSNWNLRzdwRHJnM0s0Y1NOS2NRUWwrREhhOHZ6cms2K3hJdUY1cEhjdHR2L3IvTW9ranB2S1NxUWova0Q2S0tiQ1psWExMS2JDOWpHZVhKM1Y2elh4WVpQTHRIRTRLWUdGbjlieWYrZXpCUGxQQU56RHZMQ01KcG84MkpqT0VGaGw3S0JKeFF6bXFFVUVmMitWcXNjRllLU3d4alIzMWl5Z05WQlJ1bnhOU2JDNHQ2eHNYYkMrZk0yeW9oSWRVRVVidXJtemdXR28yRlFlM05IYTRQOXBRM1ZGdy9aeS8zcE1NTHp4MXRXeG9jYXpETTYvdEJMWllIdTk1bExyQkF4bkF0akgwL2Nob0hENTBPSERobk9yRVMvV1lYWmI5Y0xrWFV2a2RybWx6R005dEEzSlVtYUx4VGFWUkdjTmVib3FVWjFyVVVnMEp0WE9MK3BuV0w5YU82cVlXTnpRYmdKeVRabHFsMnBsZ1VRdUtKYktXOTFFRnlpdVc2aThRRExEdm5hd1NzMnZSdGJsYWhxazJhTnJ0cTVvS0JzekJneU9HRGFoU05WUkpaSGJYTi9Ra2FTd08rUTdmNUxKS0lxU2tWR2s4SlBrazU5QUZDRm5Qc2ZXcU5VL2xrV1VnV0pTV25POUs2N3JmcGxWTFMrVnl0cTlFVjVaVzNINUNqMGlRYlVaZDRMOGdPcVFONWRueVNWOUNBcCtvbndDa2U0MFNocHJEb2oyRUFlaEV6eVdINnpvbS9HYmVWMXJnRjdya3BESXdJeE5SL0pudEFETVRWdTg1K3h3Q3MxSEl2K0xkSlBUUzNoODhPUDlHY1QrV1o5QjNxTkJZcXRTL3hsT0pEOENCL0tQT3pBWStuTnNRSzBkV1VJc2FXaTNJNFZpcmdLN1JDcHZjUlBkOGxhRVJDSklyYzZXWWczMjUyVzlhMGlXTUQrWHpScDVLaGsxaG1hSCs1aEdPdHNpOEhnYzV2VEVQaldhK0V4UnE5YVBLbzRwYmlpYkNqbFNXZmJvRmVQM2xFa1ZMZTRZdDZJVklaRUlxQlc1MEEvanNWWkxOWVdZbXF0cDFlY0c0aWFkUWYzZnhOSlFVTk84ck5DVlcrREpNVU9KcllxaGd2MVlHNmM1TFpCbnoxYWJMRVl4bzJEbUh3bDlpN21NYlJZYXJDdXkxUVNxbkVwUjVxOXZRWHJlNkp1TUUxdGdWWUhIRGJ0SUM4a2dlUUhabFBJWTY1T2dGWnJRd2EwaEZiSk1qNE9QT2txQ25nb1E2SzVCS255U3JNejF5R0dFZkJqcDJRRWNhNlVVTWhVQjV6OWY4QnljaW5TUC9qci9aM0QrNDlGZm5EOGRHblI0VU5xRnRHTnhOL3ErN0tZYkp4TXZwbkx1REx3RDMyM1N1M3NoVEMvVW5WcWJtR1NuaUQ2TGttenBnZzl3ejFvUHVQcithdEJEaTE5RFJ2THk1clZZOTFPU3ZYZlV5SkdkeEptVFpzd0liNDNjSnRzRy9XaCt4QVBaVjJjMUd5SG1RK2l4ZDE2OXFPMHBCTjVHSmRmbWhoT0FuOXM4R0o0c3kwS1BDRzFLcGw5bHpnellwR2gwZm9aT0lBVUx1L3NOU25mT09udGRlUmE5MUNTNDljNWl4TmtWTXM4SnJGY3FxdElRTmFJcXIxU29jQm5mNS9SWmxTSTRCNFc5Y3FJTTl1VWdYSkZOY1VMeDJHMVE4RWQ3Q3NseFVVNURHcjB4QjlFZlZGK2RHMExpNzFiTkVheFhqZ1FNZW1IUUp4Y2pibFJVcEl6SGxRSVI3VXJxY21BYnZLMW1WNkZVc3Z5amtKTm40WEZoaHdBdWdOVjdESytvZWZYayt1bmdkQlZabGNmOUdVN2QzQ1dqakx1NGFIakVWbkdsT3BOc0syV2JNc1JJdm9jbmwvcFlVd1o4dVJsQ0pJZk56dWFrZi9wejhlY01vVmNtcWxTclJaVmVtVENtNG5TVWVCN3NzNk5jcmgyRmZWSXA3TTE1QW55WmVxV05wVWRkUGpNTlROV2FiZklJQXNNa0dHc0RYVDMvL09YaWNuazQzQnQ3KzdpWklESzIrNTh3cUdkdUw1MUNtL2swQy9oOEJ2QmxhdGdyQmFTa1ZTMzdXK1AyM3BHRktWeVFxVllZaFRFaFc5WFpRRDY0cndvd2hXajBHd21ET0RybXdPKzVyRXh4U1gzSGJVVEg1b0Q3VzRHY2YvTTRNTzhVdHFnbGFCZVVpR3REUEFmaUVjWG5uUWpQS3lmS2VUNEh3dWM3Q3NtSHZJUHk0TlpHOFJ2L09HZDhUNlJSSVRKc2R0ZjVkNTdJYkVPVVFZVE5HTHQzUk0vM1pTcjkvK2w0M2o3a1l1dFhYZC85aWZwdWJ5aTJCYStUOG5senJXeG1UUDRndHg3aUdGU0FNL1pnQzhZV2tib1NleEtmM2JXclE1UjFoMDRKZTcvMVNMR2RodWJwbE94ZjhtUVRkVG9SeW9LSEVla0wxdjB5b3BsQndlcW9DUDhWR2FSSW5tWUJNUm5odkozZU03T1lYQXlRVXgveDh0ZnUydzlpc244dllQSjFlVDR6cFFmVUdtMVNycHQzQmhqa1RkNjNhbCs2cWR5OWFQbkM1ZFRDZlQzN29JNEYwS0NVMGoxMGVlYzhpR2o3Rys1ODNiK2lQM1hPdVhublVsZjFyM20wZXRHbGhSZFhrOWJ1KzlreHVEU1A0NkFtRHZ4aFNtUG9QQTVUd3g5dUZ2Ny9qUjdrYm83SzBmdmZ1RGRrQXVYOXVOZGtBbk51UVAxYnN2SXBtek5BdXdzaEZOeGJibmxjUWhLaG4wdnBEN3RJWmZ5YUVKcElhQW05RWFWbzNEdzJHY1FyZ2pkQ1d3aUpvUW0vTXFnWHcvb3AzSDVDVWtMYzdOQzNoZ1FFdWtzYjRMQ2ZLcE4vVTJzVnJLK2pqNUtUZWxiT2ZCUUg3M2ZRajZjbjVPMllHVXNnM0d1UTVDM1BuWXRqUk5oTDhXeUpDSG54TnRJdG00N09wU2xDQ21Sb2hZcW9hbWkzT0VSSmcrbFRxN2tWb1RkMzdTelNHQVdKTW0xRTBYNEN5L2g0blNJQVUrT2RKSDFuUVFiTXRkallzTHpRY0N0d3lDWkhHRzhkek9SQk1jOFdrS2Jjek9EemY5Z0RXQklJL2JaNkJZa0Vwam4raUJ5U05CUlRQQ3hwMkhody9QU2s2Y1dZYVVsamV1bHJzK3lzRWRVN2dzRWR0YlUxVGRUbXpyTEtVOWFVbDYrcHFHREtsSE5sbG1SWm9WaFlMSlV3NVpIRlRDTmxLZkN0ajJmbndia0lBdWNWSS9KMFg0RDFwNUlaZzlleGZTS1JUNHhVcjA4b0ZucUZvb2x1bXMrbUN6YzZZTmpCWitRQWZvTUQ1alA0dWZJdjRjUnJrSDcwMzVSZjRwRWsySFQ4VEd6eXU0TG9TSjJwZGx6dlFIcTRQR0pnRGRlbkNtZGpKVkpHRG90Tkg4SlVXTExWTXJPeGNQN21qY3lOc2QwUk9oY2ZJZS9YVDRGZzFxV2NtU0FWMFpEUmxvYWpReXpGOFFPRG4vZWhZZm1SbkpRTXRvcEJ2NjdKSEJLV2txS2pKR2xSZWl6VFo1QjB1all2aEhNRnloVTdXdnoxMDR6bDM2djhnNVhFdDVjNTVtRGZ2REZ4bWVEMUZZTE9BQmw5bFdORGZKbFB6SVJkNWswNjYvcGNKcmUvM3NDTUlWcTlmWnVIeHhmbmNvR3NZTEQ0TCt1TWcvcWxEVVI3MnA5a2lMOGNicG0xZUt0TUtxanVBNXJtMkpRYXV4Sk4rMUd4YmZhZ1NFSGpuM09mc2tTdzNwVEtvSjB2djMwblMyQlg2UGovSFhxOGhZaWJkek5ESVNVeEw0dkVPN1I5WkRSaTlzTjBmM1MxWmRucWJsQTkyREEwM0VUbm00UFo0UGpjY3B1cXJ6aXdKeWRmei9zV3VKZFJJcHpwdllUUGxERVdmdC9ZeDJlbU5jTHdmcWlmemNuaWxHYjFieFFhVGk5ajRtVU1iVXJ6T2djTGpzQVMzUXJFcjlHTGdrVnlDZUpDcElVMUtLdGNzNnpMb3YvRHBEbS80ZVQ1ajlyZlV3OFkxMVpQM01BcmNRaDVmS2QvNXhLRmdsZnFFUEw1Tk8xWklZNTRXaDFrQjc2dXRKaGN2R1JGWlpseVhsMmRmZDNlbTIyRmxnK2o5bnFkYVorcnZRbU53QjljMUlnWEdhaytWRkJRUWIyU0J3eEpjd2ZEL1pmNDc2UDQxNUFlc09lR1BzdTRlM0p1V2ZReFJ1RmZUR0wxM3A0RElCR0hDeU51b0I3a2xCUlRnMVU3NE12U05GcFRURk5Rc3E3dS9hQlBDWi9CSE5mYTgvNllLejE0UzF4MlRhRlJrcjgyWWF6MXhsbndGcjlYZjdxMk1UaFF2Tm5SOGh2dGFqbENMbWY5aVJRMGZla3BNeXYwQ0dQekdQYkMxaFBobTVseG5leGw5ZUhFR0kvSDVZR0NldDZGM3hKMnpVeUtxay81Q3gvN3lsWDdqdlBidEU5VTd2OEhHVmVOayt6UFBrQTZBTEhKMzJMTTMwd096QldTQ21OTVlMSXhHY3dvM3BnT1BwSEU0YVVWdmZpNFFyeDhNT2I3ckJsTjFtcXhrakVkTzBrN3lhbkxNeDRVcEQ4TXAvVW1QNXpqSHJmOHpPYUUrRTBKeE0zRStDM0V0TDhDMjBFSHZ4dGJmK3Z0eVFsYlM1RXdRV2VMcUk2ZnBVOWFWNXg2dEppbkw0czBhRUJGQ3A2WWdNc0NWVGlMcnVvSGdTQTVuRzV1UGtkUkZLRTdDcDdBSlJEeEtjZkJ3MXNWQlU1V1psNGVwcGhjSEk1VFJFamhaSDQzbTIrY015NzJyTVdrNFRNQUJYdEFNRUI1QlZzeVlJZURtZ2toZ04yaGpHWWlKaUVjc01KcFl3S1hVYkdqWHlZL25nWWNCQ2tCcHl6cFM4akhZbXY2UjJxemg5LzVQSU9URXZlSzQ3RVpMejR6TDFNK016OGRYM0FpWGQ3SXRnKzRIN2NiSys2N2JJSzU4WFNxbWlvdWlUZFRWczM1VWdFekNBcFM0MkF6eVQyenNJY2N0OHNEbjVrWDI1UjhwWXJyRy9uUitLMmljUzBObk54NE11M002c1R4TEZNalZlNVRwdVFsVHdWekNTZ3U4bktGb2puSlkvektURWNpMllKeXVubFFVY0NjQzRwclk3Y2crVk1mVTdmR2JWR0RpRzNwREQ4a0J5OXc4QUlIRDRoZElNTlBaZzRBTXdjWFcrVWNQRm5Pd1IzTUhDVFpoUzhwd1VTT1crWlJQalBQaHluNVN0VE8wQjZEUWUycHY4d0FWVHphektXQm8rVmNQRnZPTlh0SXhVWHVyWkNTUy9BdFIvdEZxZGoveFdmbVpkbVUvQXhTK1c4TTlIL3l0SzhDbmExRlNIak1jZ2hlNHFwTDdrZGZzOEVPVjVBRHRLQVNLN0Frb1RIK1VSb0x6YThyL0wzVmJqZW9qUkdOc2M0SDNLanhZRVRyVkZiaGM4MVdDOUNpY1BRcWV0ekU0MXB6N0lXYitvZmN6bXh0ZGp4MlRqODFkWkE5VzVMczJRUU9NUHJyYkprcEFtQWdmVnZGRGdZOEF5NUtMMlRubHVRbkM4Q0tyUnhnOGhGNEVKOEFJQVp3NFVSNDI0azZ2NllIODdaL0FZQmVkMnQ2dEcyWlJkbEY2MnF6MGtuQXFoeE1YMjBBUzZaR1EvVmFNM1ZrS1RFaXNVZ0Yrbml4bDgrWk12azc4MnNUWVFqdTNETkxQRGprRjgzUGZmdEcyTFhZOWEybExlTzVBS1h6VFJ6Z3gvbkZKdjdWSElQT1A4M3YvSDAvNGNpSDU3QXkrYnVHcjNYL1d2bHR2c3JQMGk5eUFEMmVPM2hwTGN1RldRTHlSTGxPRHNKVTYzMjJ5M3lRNTY2cmIzOEFMSnZKV2hYd0FaUlhsMHdkTWY1NGJENW9iL2U1clRqa21sZktjK1VCMzF4Zm5WcVdkYk5VbmdTZHdTdFBFbzJ3SjNQRG9Mb0RIWjU4c2VuMXd3eEgrbExmempCTmVYMEgxYUFCUFQxZEFINVF1cHJwdGdMN2FFRzk2VFhCYitPbDFUczFvOVcycDNKMU5rakk2NHh3V1ZRVHBCRTZjSTg1R1ZWZm95dGtVdEh0RXZ1eFd4ZFpJb1VkUW44N3FRWWdlQWJGWjBpZUdYdnJBOHZZeHVaaktmUjZQYWszZkZQYjdEeFh0UHFIMzRXMEtQRGs2cnJORXlOdGRRQisvL2NNZDBTSnNzaXpQMnN5SUY5ZjF1YmJrenBkakYyOURyeGFjaVFvbW5JU241SFVJeHgrQnNGWHlJd1pFVmNuVXltWUtTREZGd2ZWTGsyVnRsbFdaU0ZsYkRGME0vb05oRWpGNHNxZUx1a0ZCYTByYmZGMEsxWjJkUUd3ZUFLNTVXRzdyU29oV0h4MnRiMDhIcXF4R3BwYWxLSklJakdseFpsL21xZWhyaXpKQ1VJVzVZSUlIMkZ2bmdENFRHVnpCbmxORHBsbU45a21rekp1UWtadlRNb0Q0UUhBL3dKU0w2ZnZWc25iQ09WQ1ZZMFUvbXJvdTFhTHhUWElDU0I0QlhKSERsbEU2OVYwK25wU2YxUXhES2RZb0VYUU9DRmlaSWRTTGNFY3p6M05nUFpEVzkwNFVqQmUvRW5aeCtzdXdxaHZUTitaMjFXTkFVTDhBSUFjbDFndnBLRFJYU1VBeUV5QlVnR0FpLzRqclY1T21zSVYyRk4xbW0wSEtzd2dNbHAwajRPTkdRUkEwQVpObVVOQ2pNWmN2YUoyT21va29BeXNuS0VqUjhuV3FUb3YxakpOV05Nayt3enA2c1FFOEk2MTVjajdVVnBkOEtxODZEYlZwdzBKUGdMUUJHc0RaVzNtVEVrUFVSa09hdFJpcDZuZTdSVTdrTTZVQnpIVHRvRkFxSjRmaWJxdHk0SVBTWEV5Sk1TVXBpT2t4Q0psYUYwdEdoa053MkRXdlpzZUU5SVZCSWY4RXFRc05FU01IaTNMZ0d6TWhucUZGRWwrWU50ZHdlSzh5aGVHT05tMEFUVWpkTGc2R1RLSmFvUDJ1QjZ1dHQwNDlXeGdyNHNoUUFRWHRHaldxWlNSTDNpdDYvSWUzNEQvMDU5ZlgzMldQbWttWHp0bHlYZEozdjd1T2VFRE9BaGVTZDBLSXNpTWdQNUtBcFNnMkJLeklWNk1mNmhyb0o3cS9kQmhqWFUvaVgxaGgxbEttKzdlSm1aMDdmTUxtdkIwK2pwV2YxUVgwRkd5L0lhSU9xUFczUW10dVlSdGYzSjBuZmpMdDArd1c2M2NCV1B2TTVnSTFWaG05Ky81TERWUFBwUU42TWFyVkI3KzlDY1Z2TmFVWDc3K3hYN29UWElhdXRaRnNDVmJteUczOHFGMVNraGpqV2FwMWh2RnRkQk42NlBGdlBZU01wUW4yRGhGTzFNRWoxUk9TRmxJc1ZrWFRkbGtzY2hsdmorMzFOVTJWU1VmVGdhOUJNRUplS016dWs0RnNNWnFQUEdteXd4aVhCQ0ZsQ292YTJaS0cxVGo0MXk2bC95eTMraUVXdzhBMEp1NWxTMk9pTmhjbU4yTDdkTzRpeUdTY0FmekQyTjNvQXNOTmQ3SFlTUG1jSEZmZGVreWVKUUlXT0VUMitHY0tZV3Y5YWF0Unljanh3azNkR0JPaEdVMEVUM1lGT0NEQWJzZkVoN1FIUllrMHRRZVRGc2hxSW54dFRCZWExdGdjOWEyQ2twZjI0VUc4YTBwUG9DazB4SkVnVFlvcXQ4dy8veDRPR1lXYmxlTVhQWUM4TGsra05VMmxnVnhZaUY3RUdUQUF3MWRCajBIUjZkT1BvQnJZMmJVZy8xaEhjUFpFNy9HWFV3Z0RiMmJ4UTA0K3JFUHI3SU9MWWJvS2U2MVNPMTkxRzNUc1RiTzBpTWxFKzFjUlBLVW8zSk5jcmRTRnU4dlpCTTIwM2U1VEo0NHkxRWx6d2JmNG9DcG40ZEVSZ2txUHo1aER3MjJaWHhnVkx1cFRRS2dNOGppMm9LV1JBakRuWUlqdFQ0S05FVExHU2RiREpReFFmWDZhV2cyVFB3UW9hakd4dE5WbGJObjRRUXN4NDIvQnJ5L1RmMlQ4Z3JBZy9OTWNtVmtqRTROQmowQkFxd1p5a0wycDUwcGw2eTFNQXpYeWVQSkRIVVBPNmZKRWQ1QXE2YTBZamJnWC92U1NwQ3RIN3h1cnZ3Q3FDSXBtTTFBdEJaQ1FLZ0Rwb0wxWFNCdTc2cnkrNXVVVC9NSVkxeG5LUTIvbHhoR2FOSTl6SHZlbjR5bWVrQXJOWE5mN3JwbTZBSVAzWFN4MzByeUNBQU9ZN1VVbW5jbkFQa0pFWEptc2M3UERUOHp0V3VYMnRmUlNrYURhSXJFdHc4MDcyUGZXY1FpWS9QNDB1QnRSZ1IyQ3pOSGVvelBoNzRRK2ZsRS9VbEZTUUlrYmRJc1M4U0loMDdXbEMyUFNVelpNY3pnY0NpUEw0ZVJVaFJBMFlUVTlSSTVzbll2ZjJoelRsTHl2TEJWTE5OWWxvb280NW03RE5FZVJ3YVFrWlBsTWNodEpTTk1aOGdkcS9ZM3F4eDZaaGl5TEdONE44dFBuZjBDeEloYXFXcjVHWDdNU2poNUppbkZBU3pUT3JBWVQ2S2FPWTVTNEFoc2tkSW93VG82RFF5SVJjdll2QkZuOVUvSytWbzViUHZackc5T2FoOTRBamxKUWYwQVVtLytmUnhSR0xQaU50UmVqMi9JLzhNdkVYMkdQNHBFNDJtT1J1bUhxM21vVlBHbjFTK1dGV1Yrc3NvMVVIaXhXZVpzZG1YdVQ2ejZiNDhkdG1QVXBpMDB0cjBVbE9hWlZpV3ptNC9XSDJSdTFjdXF1bi9qUW5CYXpHWDNBUEpudmlGOHE5ekVvT0krQzdVTTBXR2loUHVZNnR1amhXUFdFbTNYSjkxeDZLUE9tL2xkbXNnaEY1ZnBwam1JcWNpWkE1L2YzNzUrT0xUN2Z1aWxCN2VjbXpGV28vNnh3UFJFVHZkRXh5QlRQUDFXdWNBaUdFSzBNSWhOYW1qZEI0N0w4eGFYSHpiamJ1MzFNVDUyZGppMnFHZXU0cnBlN2NDeDVkazE3MUl6U2VNSE5INkFZKy9JN1dweDRtR1FUbkVOZEg5WUpiNGRyWHFITFNYeG9IczR1TzBSQ3Y2Z2RhUnYxNXZiNmtpRVBNVVpZK09wcjBJeStBM1loSk56NTVQNE1CZEdwdmdSc1R4RmU3ejRmMEs0cXZKWEFBYjBjM3RvQ3g0ZFQ1YTZTd2oxM2pwMmxTQnBlRW9CZVBIL3BHVS9pSkIyYnBWTHRUMGZaTndRVWRSZnBCRitFU1VxTzY4RTlWV25Sc013end0ZHowRnB5bjlaZXNOL0FDY09wQUxCci9nTzhHMkliTmE3UmNrSVBZMjNIc3MrMHhRWm1nems0K0hGLzdLK0NDdzdaeE4xWDNTVWFlRE5KZlZ4dmFMT0x5NHAyNG9kQjZLTHllQktOZXVFQm5hTnl6MkI1YnNUdXE2eVMzMzZPTXEwSDJxcmE1eXkvRlczQ1VHM3pJTEt3dFpTOG5BV09UbjNLQVFPSnhsNUZrZHljN1VDS2VwNURwUHROL2QzMDU0ZCtkOEVvQUdkV0dTSlhGQjZWcGU2MkV6Nkp4c0ZrSFhtemEvcVdnaWdmbEkvM2w0ZkQ5dEJyTVVxUytCajg0bGJMeFhLQ1MvNTIwQktsMCtNY3BlaS9DL3l4OVM2YUF2WG9XUlhUdTREN0dLbmJwNkQ4MTI0anpkWGgybS8yNDVOdlVVVHo1aFhCZnQwRWxnSHBock9kYzJ2QXFFdWFRRmZmNDdFU2Z1dkZxdE1yQ2FNVFlTZ3NQd2JrNWdGeVVRN0MwWTdOdEJ5WkdpdFYzbTZ0cVFmaHVMcjhWeDlRaFlUZnNTeTFCdHBQdTR4cUlWT1RqeVdVSXVUcmRaeVJDa0hsWWp1eHFBSmlpQTQ0ZnZHMW5BejA5bjZkSmcwUlMzdkV0U0xrRG84Z1FnekZxVFlkbGNuUzYzTzVBMytFL01tUFFDNHgxMi82L3J1TXJicm0vdGdtRm5hSnlScEZ1SUhQTjR2T2ZPN3RrYVkySDY4cnVseEhNYWhLdk1zOVZaRFA3aEV6OXY1dHV4MjArRGg2bEcreEU5STVYMStqS2hqeFFlT0NCK1ZOcWpoT1doUTVsS0FLUFdjVzVSZGFMUXNhRmxESVR3dTc1U20rODMxeGRtcXlwTEdPWkNCSm56NjJ2NzZqMHBjZEJ1dEgyN2xvdFhzcXFZeVYrTTJiYXYzcGhZWnAvMUpsWlhIZUlTell1MzZla0xtZU1hQXdobnhxb1ZoS0QxSzJaODhYWGNnV2I1OUFzQ3V5a0xnOWVKNWk2SEhuQkQvS1hjRllBTjU3U1dDTlBXMmZYcU1iUE04YUgvU1h6cFUvZlRwOFFnOGZmUDB0WHB4ZkhKOHZMbkNqTG1OaHpic1d6OTRQalI3WkV4S0RWajZaeEI4MzZJdVF1SktHVzJ6cVZmTFUrVzVEaDhPdWJ3YTk3aDN5dFhGdEJ2ZXVNQVZsZVhxSGpEaWxFQU9lQk5FWnZ6VUxXZFRSbjZGRy93T3NPZi84TUNqRmxoaGRaa3hlVmk1NWR2N3pob0krOG43M3pQTzRmK1NQNE9rVjBBSVJWUWJYbHV5ZU5tb2p2WE1ocGVMbEEvM1FpQlFoaVV6UUJKc0gxT0MycEsvOTdnNW83V290d29ncVE1aHFaVzdVdVkxTyt5M25hemFxQXB4UFNjZmw2U1ZUYXRHYWtMcm1XaDVjbGVWVWorSFRmYmxvQ2Y0NFFGNGVQbWduajI5dVRyc01XRG94cTV2ZWNxM0drSmhoMXVMWE5uak4xL01NWHlvbmwrckg1eUJyYW1nZVdIZnRhWHZoajFENVdXZGc2bm5SSHdiekt5bGJicDFkdVVyb2grY3RsTVBsYjlabjJiMEJna2kvdExWaXpNTWUvMUJ0ajZsYlZ4TjVZbjRZbG5SS0pZR2FqSkY0ejI4KzJCVFR3N2lLV2NPNTRiaEh0dTZyM0I1ZHB3UE11eGJHVWViVjkrZWlPc3V6V0NyMXdMYitPTXoxdFZUYVBtVWVkNjBaeWR2NXZIVGcvSk9lTElmQUZnQWVYbDVpZ2Z1VGF0YUhxZjZyYVV2TFFBOGVma2xBSHkyMmZkUzJGTnRxVm9nZ0l3QkFBSnVlelhndmhEMHc4NGcyb3QvRFEveW42NEEwQjdBWDRBVC9Ba0QyT1dVWE5aMEZOUkI2ZXBUZkJEd2daclo5SHdVc0pPV05wMmNWUzlzK2tSQ1R5alViS2ZuZ295c3ArYVd1dm1abmdBMXorajVtZWE1dHZiU01vNmVUd0xsNVBPQk8wYk5uMUluQ3NHaDhnOURNR2R2YUY1b0RIMUlhc05oZkdxMnZQcUxZTHIwWXdUMk5nZC9yZ0dWMXVaUC9TNWZmbFdzVTBmM0hPU1k5V0x6V0d6bWNXUVNWNWhtUnVVSVV5QUw2RFBkMFB3aExiOEk1bnpTLzJUNDYrSUpoNVpQMGlZV1FkOXA0K2VHY2tMUVI5MFh2T0RFSUpnQkYzaXNjK2pFTHFhSEltMGkwQ2w5MUJsTnpUR3BxajRsbjA0VzhMK2hkQUpUczRrcVg5M3NWaWtuYVJuRHNmZzcxdi9FeGlWZ2pLdzhFdUNrNkZYTGpPdmZQREdPOGtVREx2eTJGbjNCTlNSdUdGQVFHTFk3R1VrODVVa085citNejJ0Qlhvb0oyOEtnNTd6SWh4ZjVyai9VYWdYS2NuRU1TSVdDd01MSW5Rd3ZOd1hsOUp3WGFiNFRUQXVxMWVxKzVQTXZmdlc2WVFHRTJ3Rm80SUVjdUJHYms3UEhFT1lpeU02V21jUmxyRXFKUVd3aUVHczlWOTVybW54ZzUwTFptY2N0RXdxdGkxT1dCRnBlY2UzUTNubWZ0RW5RZGpETTFyMk4xV05kUTlGenJ1VlMrUENZaXJ3V0FlWmxIUjRCb2hJYmIxQkxtYm1JUlMwWEkvRzVPTEdhNnZ5eUhIUUp6RWFXaXpxWGdjazBNTW1MWERheURjZHVKOWlCUXlzTUFBYmJLMXdrSVVRWFkwa1ZGMGVMU3VkSmJuSUo0aksxWEJRdWc1aThaQUc0dk80UzhQbStKeW5TejI4VkV0NnNyOVBQM2hEV2NvUlZYMnBSMHpmS3U1UjZQbDkwRlgwUWJLNnA3R2lHSENmcVI2TE5FUEJSVkt4ODVWYS8wb1I1QlJUMVRkTDRvbm1yWWU4Ull6YlVPTFBSWDRMdlhvaUFVYk1XdzdXcFU2TldCOGhtSW9RU2tJQlVHUTVpTnA3WWFoQ0habFg4QWhvMDRJUG9KK1dRdTJoWDlFQ0NnTjdGNlg1OGVzR1EzcXhHcFE1aU9CN3JkSmVBR3AxbnZSSnRBbnhvZU9ERmxBclorZVJTdWs3RksxMHZ2QVQwOXY2ZW1qV0JrRXZ6U0F3ZGFYd1U4bk5uR3dWcXlkMlBjRFpUZk4zd0xCci9nM2VPOHJ5RjFJK2R6RUJoWkdKbVlXVmpGeUdTZzFPVTZEY251ZlVsY2ltbnZBb3Fxc1R0RTBtU3FTcEw4U21QVkZWVVZVMTFHcThhYXFvbFRib01tYkxvc3RWV1IxMzExT2ZUa1A4bDZnOStVODAwMStLRjZzMzJCLzkyZGRaRlY5MTAxME5QdTh3MngxcUxMRFRMRlRzZGNjc05SL1hTMjNKQmQvUngwMjBQM0hYUGZiL282NG1ISGptbW43K3M4TnhUei9UM205OHRNTkFBZ3d3eDJGRGJEVFBDY0NPTk1zWm9ZNDN6cS9FbW1tQ1NLU1k3YTRkcHBwcHVobEovS1BBaUljVGh1THp3SkpCSUVzbGtJSVdNeUhjaUpweDJ4a21uekhNb1pyTGdUeGRkU2h6WlFnZ3g4VWxJWXBJeUdBbER4anI4elIzWWh1YW9CM1UyMWFGQ2tRejNwVXdIQnI0aDZCSmNaWFZueDRUck5aR0w0anJxMXVWVlRIRXB5eVE5aTNvRkxKRUorOUY0TEZ3ZC8wV3d1M2hjOW9oZ2VTMy9SYlBkM1piMWpnNnp0VElnNFhlWThwVi9GUkwyM2tQOGFPcEVuanFVeFhKL0lLbTVsWTNsNzE3MHRIMEcyd09OZFl1YVVRMDlDZnpLaGc3QXZoKzQyUXBLVVIvUjBodVAwOHNlVm5tb0Q5THA5Mk1KU0Jrdi9jQWtrN3hYSHlWMmxrOS96dFZGREE0WlpGVFc0WHZQVFpPdjdQQlQzZmtkSEFwS1NTa0g1ZWxveGREcTNhYm9idjFHSFdtWFJTWlR5cWVFNTd6TGxyeEhKekkvRUlLckFOOVpBQT09KVxcclxcbiAgICBmb3JtYXQoJ3dvZmYyJyk7XFxyXFxuICBmb250LXdlaWdodDogMzAwO1xcclxcbiAgZm9udC1zdHlsZTogbm9ybWFsO1xcclxcbn1cXHJcXG5cIiwgXCJcIix7XCJ2ZXJzaW9uXCI6MyxcInNvdXJjZXNcIjpbXCJ3ZWJwYWNrOi8vc3R5bGVzL2ZvbnRzL2ZvbnQtd29mZjIuY3NzXCJdLFwibmFtZXNcIjpbXSxcIm1hcHBpbmdzXCI6XCJBQUFBO0VBQ0UsdUJBQXVCO0VBQ3ZCO21CQUNpQjtFQUNqQixnQkFBZ0I7RUFDaEIsa0JBQWtCO0FBQ3BCOztBQUVBO0VBQ0UsdUJBQXVCO0VBQ3ZCO21CQUNpQjtFQUNqQixnQkFBZ0I7RUFDaEIsa0JBQWtCO0FBQ3BCOztBQUVBO0VBQ0UsdUJBQXVCO0VBQ3ZCO21CQUNpQjtFQUNqQixpQkFBaUI7RUFDakIsa0JBQWtCO0FBQ3BCOztBQUVBO0VBQ0UsdUJBQXVCO0VBQ3ZCO21CQUNpQjtFQUNqQixtQkFBbUI7RUFDbkIsa0JBQWtCO0FBQ3BCOztBQUVBO0VBQ0UsdUJBQXVCO0VBQ3ZCO21CQUNpQjtFQUNqQixnQkFBZ0I7RUFDaEIsa0JBQWtCO0FBQ3BCXCIsXCJzb3VyY2VzQ29udGVudFwiOltcIkBmb250LWZhY2Uge1xcclxcbiAgZm9udC1mYW1pbHk6ICdBZmZvZ2F0byc7XFxyXFxuICBzcmM6IHVybChkYXRhOmFwcGxpY2F0aW9uL2ZvbnQtd29mZjI7Y2hhcnNldD11dGYtODtiYXNlNjQsZDA5R01nQUJBQUFBQURtZ0FCRUFBQUFBZ0lnQUFEazlBQUVBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUdpNGJsSFFjZzNZR1lBQ0JSQWc4Q1pvV0VRZ0tnYkVjZ1p0SUM0TWlBQUUyQWlRRGhrQUVJQVdHQUFlRlJBeUJEUnZvY2pYaTdUc0o2QTVJMVoyWXd6eUtra1kzT2hJaGJCd0FLZkQ5N1AvL212U1FiVjREL2lySUVtUUtJbzl3QlR3elNSblZSV01JUTlrSW1RcGZqUEdyOXJnMVhoN3NKR3NnUDRZZUQ0Y1E3UFM2TFNVOThQVis1dVZFejdmRk8wajg5ZEp2VmZsRnZ6VTdkVTYrUmNWT2tsQXZoTEFxTW93dWVoQUlaUGRDdy8vclA2T0dPaE5pcmJ1ZENSMyt6TEhQbmRwTTNlMElqWDJTU3hJVmE0L2ZzL2NDRE9WVFVZZ3k3SWlNU0VYWWZHS2hnQldRQWlESHVNUHpjL3MvOSs1dXpkYXdJTmJBR0d2R1lOUVlqS2dOUm80UUdKMktnVGFvNEpNWmhSaU5pR0lWVm1HaXZ1RHgvL05GK2lxRWNjRGlYOWVQT3ZPZkZiYWRXR0NpaUd3SHFhUzIvL093M0EzTGxpdkNFeHQ3SDJmQU41c3dzeEsxTFpSZFNXVnFwYTNVbTRJRVNJYVc1NEYyRGZTd0poM1p2SGNtalZGNzhMSEREMEtYc3FpMVp6ZzdUeHovUy81OGxRd0J5UTRnVGNodFI1Sk96Nzd3aDFjQU9LLzMxaER5MUNrQU9PYklMdWZhMmZZbGRWRVYxOVZERG9pRC8vKzZ6SHZmSjhFWERaSEhKSTlYSnBobExhQ2NjeGF3NHFwSW1XeFhiUjB1a3lxcFdyUnM3Ky8yMTBxcFM3bnNpZHVoQ1VjeWVVS2hmbXZ4SUJTNkNtbXgvbldWVmRYZFgxOGExQklkQU1WbnMzYlhRQlBwTklZNU9ieVhINCt6eUJ3Q3hwbkJnRzNkR2hBakh0S3JTYkQ0Lzc5bTJ2bm43bHZnVzdZRWFvUXJxckt1VUJVdUozOG05TTRyOEdRS2hHNkprcXlzTVRXQzBMSmNXV0JocW10OGUrV3J2dDk1OXdFZ0FkSUIrakhETWZSVXFweUxMcFV1bXNQdGUzZ1I2VDJBSWg1RUNnSVVtQlFJU0J3SStnRVBnRFFnK1FORi9aQUM1UlFwS0RQby8wODY1TmpsVU1tZDNjWEtyWXZHZGVuZVJkbllyWmV4K1kyWW1HRGtpZEoxcGRaa0Q3THVNZ2hGN3RWQ3lFTElHZit4SjMrdS9sQ3diYTlDUWdnbHBGVUZuZnQ4NVZvQlROYi8wZ1VOWlJUa2pPc2drMjZBM1hRVDVKYUhZQkJnSWpFZGVOZWVaRHNnWHozVldnL0lFQUFKK2NtdW5HdXVCemhBQVFLR2NSRU1LQVNwSU80UXdGaFNjaG9HRVNKQU1DaG82RHh3ZVlKYzZsa1FkSWVSaHBXNXZKclMyOEhFN3VrR1VZU1BnLzVPZjF1UFZhVGUvUjd0dERzMmpsUWVrQXVWbzFPa0dFSm9oRENKd2lLQ1E5aVZyTTJqZ1JFeTFXaGczQnFRbDJseHgzb1FMRlVHQ0Fsejhpd0N1SEFBQVdySGdBRWt1QmN3dTcvclIvMTdUdy9KK1o0MXhRbTdjR1BJcW8zekJyd3ZBdy9lTFY5YnFkbXQvYXlqWjkzYjNxbnM2UGZ6U3M2alZmNkkzdkRaREc1MG8xdGNmNVM5RWFwWlBHOWI2V3pNMFg5WHNIOHB5cURFOUhwY3ovamJ2VFR5cGxEYU5CVDJQOTBJOUV5UjUvdjJ4NmJnTVRBQXF5bEFWTFJJZ29TaHNyQmdxOWFJbzlsaWZMMVdVenJtbUdBd3Z0Tk1oSVRrY2lsZkNEOURtRCt4WkdGRUFEbFlJSEVVWVJRVk5aaUdDQzNSZ29paEp5S1lXQWJpaEpBb2xIaEdFb1NSeUVKWVl4aldyQXVzbTRqNVlkZ0NpeUY2dzRpbFZzQlpTYUpWUkZ1dEVIMkhUa0tnZ1FSNHdnaWtJQTFuSmx5UkRxUmlFQ1ltalpRd1dlUkZBdE1CWVhxRjZRTUZCRmlnZ1Vtd0lvRjQ1akJkckRoMENhUkxDak9rc1dLd2tTNkRkSFl5WkpJdWl6alpaSEFvZzZHRXBna2kzd0VyN1BWcHJEWFdmd2dQR2tMbnNxVzRsWVhwdGh0R04vSmd1ajBPWURqa01FWmdFdGdva080ODNWd2cyVVVTWFNMSmxVaDBnWE9NMDNmZzNJVy9tdzZPRlFMa2dWSWhvRXBFUG03dmRoYVRMRzBxbUMxQlBnRXJuWmFkd2t6RitMNHRKV09meG00WTdaY0lMbXRhWmF1cWxiMFB6WWNYTjJheGdMMFNvYVJJaDJXWHhVMk9QRlIreWJEaGFvNXRobmx4bW9nY05Dcm1NWkc0QlpTNnM3QXZtSWNZSW1LSkUwZEVQQ0VKaENVU0pZVTRxWXFQU0lkSzB5R3hDRFNRMnpGeTVNTEtROFZSY0VnR0ZCVmhRQlFoQWdRSVVBNmpnc1FETGtGelkwU2hFRVlqVEVpc1lPS0ZrQ1NVQkVZU2haRWtrbVJSUkppVmtsU2dLQ1dSUUZFS1pWQUFBYU51cVFJU0tFcEpFbEJBVVFweHBjUStZSVdpSGxCQWFUSTlFL2d4c29Dd0twc3EySFE4Nk9HbzUyVjdCTDlqa0Q4K0RQZU9lTjB2V0FWbWJUZWJlSDNwV1Vjd0FzVDRUYnlIZThPV1dYMDZqQWowSVVEdlFEenZXVERDZVJkY25BR0dQdzROeGQxK0lxSmtBbGE4ZUFBRExCQkY4K2tsdDZ1b3JpUXFsdE1sTWNBcGhtOWdnVTJ3a2cwaHRoS1c5UlpZeFNyRkMrYUtvSUFCVnJFUkFDeXdRN0h5cUZqV0RYdSt1ZUVxbjVKTy91ejFNTnRQeHZLQmFxZkp6Z2VoTzlPM3JURnpqL0JCNnNzemNwNmV0TG5rdk5SclYxdFNhNmlHb1dIVU1PWkZZMkd2WHFvb0J2S3JEYVcxUU5PR0FSR0lRZUxpVmtCZ2dBWUFBZ2h3R1FWM3pNa1AwbXJmdUpRTGdURS9WK2JaZ3pKTE9zN1ZVcmNxZDh0UUxtamx4SlQ0aWlQZ3VpOUNraURycDZ1aFViL01sTk9ibHlJZVJNeUxZUmdrOThGSTdvRVJ0N3VIRTBtQ1JrTEg1azNzRGxpVzIyREpib0VsdWdHV2FoSXN5Vjd2d3VVUU5JUVgzQmt2bzJqMTlrMlpWdTZJVnBiczZMd01VM3IzMHJ3ZGxrRUR0YW1vZ0IzdEoyWURUWEFBTUZGL3ZYSEFVNDhzT3hWRTRhK2tvL0k3Z0xaL1RTK1dBemNBOG1TcEFNc1JBTDc5V2I5Q21vaXgvM1U5UGdST2tZWDIyT2VRVVdQT21JUFV5VmpPNG5QNFhud2hYOG9QNXgvbDlMazVMRmRzdDVXN3NxbjA1UXcrbSsvNTcweXh2NXE5ZXVYaTJUTW5EbmZOT1diMnpvek1ETTlzbjlreXMzU0c5U244RVUwL2dPcE5QWUtBYi9lakYyT3FYcnBrMEVkN1RrVTYvZjlmVFV1WHlPenk2M2ZvcjlnQjhUTDBGSGkrUURwOFR2djJNZkRra290SlBFQjZHU2pXL0EwQ3pwUk9aR3lkSTk0U2Q2VGJnc1ljZlVHQzgvVkJRUUdtNEc4MWRmcllMaVJpYjlLakxZS2pNaDE5Q2s2Y1RXL0FKN1hxcU5WZXdySi9PVkZreU9YTmxBdVV2ckNjY0tBZFFNRnY2K0VBNmN1SEd5STFldHA4dnhhOUNXZHc5bFVRVmRXU3JpckVrekJUTGFpQUhxaXRtWUtHZGFDSm5qWjY2NXlTNjRJYTRzUmhtczNXNDVJUDFyQ2Q4NmRnQVp1V1UyV1grT2dRYWY3MWxaNFBxcHZVYVJoaWJadVJCbEduWVAwbWtHN0prcnBtL0t3R2ROeHFJVXdDcXpqTUNBanFiaWpiQTZIdVZBZE5WcllEK3JsK3pNbENoeEtsZ3R0MTFISXJkcGY3Q3RDNmRqRDMvS1pqTzRST01SZ1JoaFJkWW51aXRvaGVXdDlneWlvVFkzYXU0L3lTTllPWVZDeHJkSnMvTDNIZE9EYytJS3JtNERreEU3ZHhxMXdFWjhYcHB1TkZDYktVQ242dVdGNHdoVklBdHVlenVzR1RsZHJLNUFzK3c0UU5mUm5BbkI1RldPaFFtdFkzWDA1bFJIcXZwRW1RaVhJOGZ4dXkzbmQxdWR4L2tFT2w4RllNdy9NMzI3aDF5dFYrL0JZeXNzNDdKZHRLeUkxbjVrcE1yNWpQZm9kSkVYa2lvTEpleTVTTFVidnA5R1hlWmlvN2VSUDZNR3dWU0hDaHkvV1ZuZ01tRUl4VTRGTXQzSnN5QTdPa1M1SzQwVkxrWXY5dG1BenB2UTNNb2tlUDhmYjBqQ0s1OW9nZmxjMnZZcmdFc29uMjZYMXUxU3ArWDExZTFZSWRaTFMzQ25hUnVZYWVJTkFYRkF3RURVUEJ3RWl3TUJZY1RJUUFwa0xZdFExaGVVUGE5Zk8zUVZDU0MrMWdUZjJsa3VhZSs3MXQxVnk2UDE2clp6QWMrZGh3QldjNFI4VlZWRnhEeFhWVTNFREZUVlFzVVhFTEZSZW91UjJna2xIWXpZc3MxdWkwcjNmNHFORFJkdFQwbDJZUDNIWHU1b0w3QUFZUVlGYWFIWEdHdFZkcWR1UndJRzEyelJQdTUyemt1QmV1SzNINklWTnFLOHNkQVhlR3FoN1hiSWRGQ3picExWZmZOeWw2UHdIc2VpQTcrVWk2aEwxYVRvQUtnOTUyRUhmb1I2amdLY3F6VmNFenNCZ1pEWllXbnlOTGNGOUJLVzFpWFNlNm42WXZEOFQwTmdoajYxU0xvMi9QaE1lbk50bkFKWWdlYzRocm13bGtZb2JjbXFXOUNGUnBtVjdBNVFSS1BERnFqMFBaNEh1TE1XazlESE81UFRxM2MwbEhSK3F0YUY5QXBIWEltUFRiTVRWTlVZdVdUQXdaT3hIR3FWQ3htYmFLN0twOXRHakZLc0kvb0VZQTZpVDlac2NLQS9ZcHhxaUQ3VWJraHRoTFJZK2NBeWxqelZJUndLWk9vOUd0QjE2TG9wMHM2MGJSTVhLRkJTb2lTWk95RHFsMndzMVhMUVpWU2g5NGkxeHdrV3Y3aVJDSnVjVjRFVXBVNHF3bmJ5OERHdnJIclZsRG5nWjJrWE5WWlZvU2toYlZPbkw5aGhndlhXclIvMWNrTjhUYjJBMWNXc2xBdHV3L1o2anRTQU1xTGZPZWRMWXk4OTk4OFpHdFI2N1Jhb2EreTdlMnVmVFdTbTl2ODdLbitXMmxXaGN4TGNFR1VMUGtIb003Rm5wcUNVbVczb3lnQW9WM01QNFl2YnVkZzRwNW9uZjFMekZRV1Q0Q2JwOXVXOG1PZGNxUmREbzh1TmVGNVJZTDFQc1c2NUpPQ21rVU1zSDR3T2hxdDluQ2pKV1RNZTlKWHBTSDNZKzJNL2dYNXlsWEh1ZlY4eDJhdmFIWEU1VG9wL1VOazh5TGJmbU5zN2tIZkxQTnFaWHVTb3dJUUxRRkdCTUM4WG5TUFV3SVFMSUZtQkl5TUQyWGNFdGd4Z1ZrVzRFNVZ5Qi91RVFzdUlCaUs3RGtpbGJ1RHU4SUZiNkFhZ3V3SmdUcTg2VDcyQkNBWmd1d0pVUnZEd2x2dXpwOENkMVdZTThWdloveERBY3VZTmdLSExteWJweGxjMCtmZkluVGI5eFRETFFaeFdtQm9USVBocW1HaFFmWDBnT3Nsc2pCaUd1M2d4dTNvMjh6dXNhZGRBMTdEM0R3b0I3SFpoZFBiaGZQYmhjdmJoZXZVZ1kzRDNEM29ENmcyY09uMjhPWDI4TzMyOE9QbE1IWEEvdzhEUHJQelpFaVZjVzNnNDF6dE5YMVlRamV1REJnenpJS2YvbDRIL3poOVU5NWk0Qlg3M2tPT1d5VUMxbTZ6QTdZWkU4Vjc1dy9KUWkxdFltdGhaL3V3cmEvU3ViUm9oRlY5cVFUcjdUY1FqUXBXMnJ3RWRUL2YwdVlhczg0VW8ydzIyR29ZMUdsTStQWUpDem4wUmdvTTg3d0wvSkRuVER4NVFQMllmSXFEZDBIUHR6VGU5b1B0NzBlajFjOHBocXRlTHM5bTYzMFpuWnZ1MytiVHZxYmNXRFRNRHlJdzJGMUpndjFSMjVVcmFSSnVaSmw1WldnNDVKaFdXWFB5WGQ5TjU2MW5hSHJiYmhkbjUzdlVvZnhqM1IycGM5RzZmQWdXdWpGMk5Wbnp5S01NNHhuMGRUN2c2SjM1QWN1V0k5UGRrZng3WldwZHc1dTUzb3ZMVjA2Y1UrYjJrZjQ3ZnMrUEt2OThJb3VkL2pJWDRyOTVnZlhqWkJTZ0lHQWtaQlJYbFJSb1dXYWNlcENrNCtqZ0RCVVRjRHZpekhPNDRSdVhHYnRtbVNYRUM0d0ZSWVNzb2RXWXg4TDMvZjRKUHpzK1VmNjUzdUY3V1BMK3lUckNwYWNCVTU4M1dHTjIzQXN4eG01ckJoZzdQRVh0L1dIUHhuNGlqK25lMCt4OWsreVh3Zy8rT0xqWS9nKzUxL3ZwRFRrZjRvc2l6VnUzNVdCZEtkVVpmb1NqRDBJZlpKWjUxbENOeXJXMCtzMEJJWjM5TDUxNi85VWRzOXVNQjMwVGtyZFRzbUVNOHFvWTFuTjc0aFFRT0J1TlJVdlJsTkdISnRnZHNmTG0wZ3hqaE9iTWd4QW9HbTZaYy95RGlOQXVDVmZGU2d2V0FjbHRMTlVqWlNreU1FeG5yUEpLd1phaStURFdKbW1ZWEovV3p4bmhHV1FPZ0l5OHB5d0tYQmQxZUwxbXB3dkE4bldNaUp2K1ZJaFg0OW8xeUY0aHgyQW9YN1FWN1BKRSs0SWFGbDB4MkxnSzhMTWRKTk4ybkNZeGgyMCtBaWs4WTQrcGRkZHRMUW92TlYxRXlLaFJLOFBJak1DbnpKRzAzeG16aHJxRGRjdXo2MDdpd1IzZ1Z0YnZONmJpODYySHNCMUdscC9ZVitXN2UzNmFYTENiQmMxRjhZazQ3UTN0VVdSVytzemZKZ3o2cUc2NkFBUTVwY3FQRjdpRG95elBrNVVSMEx6YkE0NUo3dVdqU2FoT3o3U0JQbWJwU05CWDBjTENPMkF1N0xpRE9NUFFQZ2wyYlZTaXptcVZNOXZHUWRzSXVkTm9SOUt4VHI0dUNJcWxuRzB1ZEtrYWtQMXphOEtHak9QaXFieWJuK1ZDNlBOU0d4eHUwYWx1RlVuRlVYR1VxRTZLQTFtN2plbFNaSExoUlN0dFF0VWZkdGVKUzlyNmpNUi91dFE0cEpGeit6SVRySnJ2dHpCU0doWmlpaDVycWMzbUk4cUthZHNEcURzZ0VWeVY0YTBrWkd1OE1aTnA1bFUzN2tUYVZTU1VvN3loT1hCOVZhdEVpN1I3U3BYcmpLL3phYTVydXAzcTVwc0ZWYmRaU2ZrYzV1b2NWS3BBNnBYMVB4RnBBbERDVDFoZVI2REZCUm9MczhodHFKRGJrS3BFMmVxTGFYRnMyTXhITUw0cGJnK2M1SEVETzZyY3QyS3BncktLeitrRXhNYWpqaDZVZEhrMXNydCt3WVcxN1hKZHNKSTNUMGFld1NnY0xtaFZQY0piQXgzRG5mMHRwb1JtbXcwM2FJU0xEK1ZtcktPNXRWb2d4TzRselBRUStVYXhyKzdSNzVzd1hhcDJ3OGhkZDZJWFpkMUFtUEtzRDZlazc0Y25qbUR3UytGSEptNW1tc0h3czV2bzAyRVM4OHBDdTlEdnJja2xQV0w2VkgvSGpiTWUxRkVGWGJldEpheU5CUC9sTE1LR1BraUNOWGtDay9DSXNncjBkR2JjMjBVNEFiU2dzdFRxcTBwOSt3U3ZpekJTTzlBUjZ6SlhPMWl1MldETEZVVExPbDBCRWZlbElvRWtOdURNWGR0dkZJbzZZRXN3a3FPR0N3UDBoejEyV2JyRllvUnZ5YXkralNocWxYOFQ0a3lTZDdYTTFhclU4VzRaVTZ5akJ6RDR4YmoxNzJuOEZ6ZHJMR2FpdHpwcHJ4a0Vsbk16cHZVR0xpUytTWHlEdEY3OCtPRDdCY2c5UFdMaVI3Q2VkYUVidWd0RTI0ZFVtRW9oVWYranZ6QUVuUkh5V1g2NWRWUENVU2FqZDFvSysrL1cvTlFyKzAvOWJsVWw5MThVRHdLYkRuQzZMcG5CNTh1OFZ4NU5oeHJ2NC9WbVRDVS9mTzIwdTR3WTFmT1NldTJ2V0RzR0xaME1NYmNXVTdKa3VnYUpmYldydDYrQ3doNU1RT3RpclZiM09adlBpVFpzVEMxWFZKQTR3K2tjZlZQbEpoNFRqNnh6T0ZHcjFiWmR0bUJsWnQxWmlqVWJjMXc5K3I1THo2KzZMMzc4bjdjVEhMN3llN0RyYWNRY3J4cE5NS1RrYWhaWWt3ZW9HaTMzTEVVcEIyc2lDbDBuV08zNVR4U3U2NEtXWVB2ci90bktVeGQ4WlJJUWw5cEhjeEhlVVpMcDZXSXlrOVpPbUdiSmV3cStrYWlwZWNobjVFa0grbjlBT3ZZM3NkMitBQjAzdVpuT3Q5MkZINlQ3ZGYvcC9DZEpuaUI1b2VrcjVHMW14SnZVUTVDbXI5OURybml5R0NMZmF2ZnNHT3d0Q2hkR2h4WFFVTGZPUTlPM3ZnT0lGeDJvZE9sUVo5eVZOaHJhOGEvZVF5ODRnejlublpMWWE0NjdlczJicWVEdSt5ejU0Sjc4dmpONlJNL25XZ3g4bkJvOXQzd0RKdjEyZ3ZnZ0pJZVJ3cUhPSzVuZHdPa0dFOW1WeURWR3BGeDNaK1NFYTV0YmNmT3RHK3hieFZkeDdCWWVxM096aUcwaU5JNEt1S1F6SzJHU3NHODhNYVpQN1NVVXBVZ0t6TElzTWNtUWVDOXNGL2NjMmNLTzAxVWRnRE9GV1puMmg4b3JNU3JkMzJMVDdCeWZkdDRtZHVmbXhmRGNUMnIzZXlrVDhuVjNsQk1KMFlYUSsrb3Jlb28rdWtkRkRzNWp3TElqdXpNSEljajAvNHFTdDFMS1cvWDVJV0FBMGM4TmlXQ2VGSm5EYlI3K09wWjVsN3ZkdXp5N0Z3N2F4MXhrdEdRYzhQVm9MVWt6ZDZkbDdXem9TWUZnRTE3b2RKckhXNkE5S1BMdEIxTTF4aDA0SSthOHF3UXlHc005MHNncUFXTy9NNHdGYmJZVVdtLzhHYzZaU09yNXBCZmxJV1liSzl4QjZxMkRRU2xlT2FVVjVIZUlmSGd4OHBaSlRTcXlnNWE2Mjk3NG16bkkyUjM3U2RzZXhENWZlVFAwVUtUSkZwd1FHQ1dtSVg3bDFRZEVKa3RnbGlCV0dBcUZrUUh2d2FkRnJPQUY3MWNlTURwN0RZSVBRUktwMVhRZEtCcC85SG1BODBDcTFQcFhGWXVzTVFxaEFlRUZSWUZYOEJSMUEremR6c3BqeStLUk9kRm9zTWkwVVdoNk50NGp4cXoxeEl6STYrZmtlZDg0cDlaQU9JeUZuZG4vNnc3bDBvWXhtNDd4YWZmMmIyM0tTSkxnODRlUXRzcHNVa0hCbnlEOXBQZElpbGtWTXJzaWM5VUlmRzVBMGo2Um94ak5qeStacVc0N1NTRkFvZjdYejc3MmVkS1M2aHVqN0svaUQwZUkzNkxJbkR6K0tzQ0Zhc0RnN1dmdml4N3FkQkFrQ0wrLzRuOXc1U2pGa09PV3AydXRLUTRrd2dOVXd2N1AwcnF4ODExbWYrdTk3RVNQQjh6bVJOTUwzTTFlL0VRbW95MHN2TTFwazliT3N3Zm14emRWbTI4OGJ3ajIzaEJaZW0yWWJaT2JJeGxPendXWVZHV1lkbFlSMHZWZnFKeU1jVHhibCtWUGRmRzdDeWEyYzV1OWgvdmx0RFRwYkhhaXhqdHVXbUgzSVI2dkhXZmE5KzIvbTE3WFh1M1N2RVZocDlxY0Y1L1lHTG92MTU5LzdMaktMaWNjMlZnY0o2QWNRc3Bqd3J0eVhITElYWXliWlI5aW9YMFlLa3BlVTIvVy9JaWNlcm1ueENKSE5ab04yM0tRdy82REs5ZHQyREIrRldMaE9GQnB4dmQxd2hKOFNXMm1HQzdRbUhUK292TlQ0dHJiYzZFOFBUUUlHMU9qamJJWEdYN1lha0VQR0Z5ZnVaeW05eXBDUWREeXlyeWo2N01ITXhOMGI4dFVCUzZRTUdIektsK1JXd0tkR1lBTzZhUXFlZkYrc2tTVkhXWityZkJ3MHZlSGtjbEJQY2ZnOU8rOHd5THJUU3J4Y2xTZzhyaDBFVUVPN1JCdVlha3doT21lZGs1MnpKV1NCUFhjTHkrbXVSeXIzRThIbm1nQVhlU0UrbFNYbE51SHR4NWF0Qm5rQ2N4QjJwMWFRNjV3ZUNRQjFrMWdSSXpNNk9aRnhpUVlKVnB0V215Z0lSQXo2YU1EV3ZYc0ZpcjZmVFZMTllhT2p0aHhzdHJoc045NHVYMWhCdk8weFVHYVhQMVNtVzFLc2N2ZHJrcjRlNUNVKy81MVI0U3M4US9TYS9YNXVYcWduWFBKem1jU1MvMlZUYjNLbGRQb3h2NHpMVEtvdnMvR3NZR1lHaFBIdno0UURHWHNUOWV6UHdYTk9KRm4zMnFGMVNQVGpxcmk3UFJ2MGR2U1pNR1JEdUM1Sm5La1B4OVpYd2pnMXZ6VUhqL2IySU4vdWtkUU0wRnEzTEQ4K1Jjczk5SC92TFlZT2s4WTdoL2RYeFVRS1RRbk5CSElJaVNCVkx2UERUSVNPeGJhY3Uycjh2SVdHdTNaNnhibDJFZkxDUit4YTZLS0hMelU3Vk1OalZkYjJscHVuNjlxYlh0ZkYzMUphZ0p2YjQyWm4wNWgvMWFLZjdFYzg2ak9tMlVsZVk2NkgrU2NGRG5DbjJwUHFjK0Z4RHU5NVprdHhXWStjdThzaVNKQVNINmhDU0I4TU4xUjg5bWtFUG83MjNtdTNRWGs3bVhFZ3N5d3FlUnhzam9ubXhxZG5SUFk2VFowbWJqeEszUUhiM0VsdlhIVUdQNlpiei9OYTNVczYzdHRrUkZ1UDlEUWtoNWRPU3lnZ0pMVjQwaDVQcmxqd0psTVpvb1g3dmlCRUU2dFRmSjFlK0tudWx2VmJXQWZ1V3pQY1hiK3JlZGNhazYrdjJiLzdaTm1aL3JZVmtudlcvekNWaVVSRTFhRkNEYWk2Qnlldi9JajQyc3FUV2E5SjhwVmE2eDlqRlh3QkQyKy9admZKKzdGRU1ZUnFndXQ3RzRNVWtleS8vWlVBM21NN1dKRC9MNmxPaWJhc3NpVitBUTd2YktxNGRIM2gyUFArelQwTmV2a1EvaER2bTB5UUpjYk1maHpMekRiRmZBRUc3NWoxaWttRk9xVnU1MTk3QWJyY0R0OWZFVVR5TjFrVkZEOGtmMTFMV2I2NitoL21QdnZ6b3RpWnFVSnBORkpGT1RJMlJ5dlM1UGJTaU1DZ2wwMlBXTjRadUdaTGNJQkE4UGs2ZlBMWDc2RXIwdjBZekZReFN6QTFnL1ZZZHJ6VEpzaVRJbWhXaHJGTmxTYUNOS0lySmN6TnE2cHJtekIvbmxKTmFjWjNuNllucmxna2VRMmd4eWdoUDh2aXJWS2ZaQW5TclRMemcySi85MjBLcXRkcmxPc1dGbjF5N1hyczdCbGJ3bnNGTWJXcDRJV1Q3Q1F0R0tkUUpoUXlCazJnaWxKSWFVTzdVUkFqZjVHZm1tTS9LdHVNcnFpbXJCc1lEMmdGNDdJWlBRMng0d2hBc0tTUE4wcHZub0ZXMGJHNDQzSGgrNTVEVkJHNm5jWS9ZL01rRy82Q21OZnZQVzlmYXdkU3MrYjhxdzdmM3ltdHo1bXY2bWYyRGdFOFluL2V1bGhza1pWd0lpU2tCY00wSXY5NlZJL2pUeFZzbWpQNFV0dFQzTDV2Zm01MDgvZXZNRWs4cUlKUFpGOHNkUG9qZ3JjM2tCNTk2SUVqZFBZUTFrK21oUkVscy9nQVV2amhhWFUwRFhHcTYwLzBPelNucVZLb3NPRjFkSFJ2aVZ4b1lFdU92ejc5ZjJad3hod1h1eGVMckZ3QXJGSFUvM2pXRFZGbnJiUHNRUnBpZ3pZb3lLTWtkWVpIQlI4TDZ1eExJN1RKL0xFb3prc2cvalpXWm55bzBpclZaM0tpNitIeC9qR2R6NmJzekNwQm4zSjVVcituaWRGcmNjUXZJajFPVkc0OElPZjBSRXdmOW14WHB2R2daRDVMRjgvN2ZTdDcwNEpscEh4SkZZTEU5TzFPeFRYWFJQdE5xbFZ2UW80TXo4OUdUMzNIMCtqUXppY005enBRazFySTVRMi9RR2JYNitQaXlsUFAvZkRxVzkxb2M3NjhYTVg4WUt5emRxaWcwNlRYRitSQmo4QTBIeC9SU2YvN2xZOURtZlB5WGFJcnRFQ3Jia21ZU3VQejF0SGh5dDBCVS9oSjJXTS9hVTRmRmZicEhYdWFLR2NHVG5ndUhWeDF4NFY5RXVrTUNYV3VQQStpRXNLRk84S2xsTVgwL0RHYkgxVTZ4dlpmRDdMMkR5Zm9YZ090Mkh4Y1REUHZyclVRUko1NVJDZnpLeXJVbk9ER0NST0RsemorNHdVaENtWnFwZlhWYlFIbG40Q1FwL3p0NkxyZ2RnQXE3N0dBc3hoVWE1b1BiTWZZMFp3dlFPWUpGY1FheTgrSUV4UjlaMjBFMm5MdlVOWVFrQ3VBNlN4WXNydmdZN3ZyaHNKa1JCdXh2SkdsOFRTQnh3bmVuRDRtTnlkeUpXS1VhL1FtYnlKSCtIdzJoanRvaFZoemVQKzV1S1V4UENIQkdubC9qcE9MVEpPRWxIMmVaTnQ1WCtLcE5WTEE5NnA0cFR2RW9mWUFteHFidEx2VkxUcG1iVlkxcXBQSDdtN0dCcVlKTXdKQ0U5d1dNSSsvZm9pL1hBVzNWcXZHOThlTTRNNEJLNWZFSkI3a1QxUkwvMkVxUzcxSC9lbno1Y0VDcnFqOHpJbjdUL3RwbmZiSHd6SE44Q3luQmJ0R0Y2Rno2dVBiRmQvdFo5OXAvWmx4aFNVYXFMRE1wUmVwaXF2bFlLaStYQ1plRXQ3SnBKQnRMSXhhSGJScmYzWi9kay95WDZYOXFRYmpLV1JvbE1lcGUwOXFheU5NUWVQUlBZaFIraWJPalQxUHV0YUVSOEt5VDE3S0xNY1RmOFFKVWlJZXZtRUpMbllpZHRxTUlQdUkxbkZySHJKUlcrU09NS3YzcE4zd2daUDlRVk9HT1BEaWxWM3F5VnV2UWlVMVNwTWQxa2loTi9XbEgvbWRSamZ0Y1hYNU1ZSWR0WHhWZWw3aEM3VnhQUUhLSy9KYnp5VEdEcnp2ekdlN2R6dEZQaHM4YnpCOHVhU2NBaStVdGhiSjZabnRTZWpFbEphb3VoWS9PWHdFaisyQmF6enFCdjM1U09jL3hKdmlmcnEzakRYKzZLc2JUU2R4SUxHMHJ1Vkx5VGFUWHBXUXBkZUVtc3BUR1l0WlRIRmZFb095KzJkT1ltRWFDWnYzNDd4TkhkYXM0dUtLVEY1em1sVHFzejJoVmRhaTJWbHViRnJlTzRvUU9GdExkTVZGV2RxcTJ0bXBpb3JxbGUvQk8xTmN3dnJvNWYzRzJKNjQ1UGdLTHV1SVQ0QlhIeDNSU1A3NklQYTJxT1h1MElOcWp6czRPQzVTbmlKNDU1dFJLTzA1UFh5YWFlMkZFNDczR3lPTUM1UlpxcDBXUnB0Y2lnVTZ2TCttRFFTQmN3emhXSnVPTWk0Y2lmRDhPSU1HaXFkSEc0TiszZUxRL2RLS1NVaDlpbkdLUmxhZ1RkSk4yK3JpWktLcGtWWDNGc2xNVFhsNkhxYXdmRlQwOHRycUF6S2htMExqcTlnMmJBM2JjdytNMGFhNkNCS0hWQ1hjclJVK3pIMWVKMEZ4VjN3L1ArWGQ2ZDBpNUlIcWFvK2dFVDlIZDlOaGc1RVBlSnJjcHFScktuMEtMdmhZcmZOUHBHbVNtUVEvaUxMbzV2eUxBeVM5ZlUrbjJ0QjdmMHdMY1Q5cEVHTnBUTVd6ZXdkbDFwZ1dJa2xNTDZQc3o3dlY5V3o3bkhLSE5lVkhCWFltS01aVTJTWDQzWlorNjVKYlo5dlhsbnBrUVdrWHdSRE8vdjk1ZWxKUm1Nalk0ZGhISVAyZ0tQZjcyVm9oalM1V2ZhSE41Um5sVmRHcHd0VVp2OE9XTzdvRUVjZnVlbGJUOEcrZmtrbUFMVjdMd1U2cUplUE0zbHdUQ2tOZFZ6eUdlZlhkNUxwTzlqQklSQzI5Y3Z4ZXZyMGZGZVoxMzE5OEdRcVRtUzE1LzgvZlFOaTFNa1RmM0MwVWZNT3B5S0dGejhETE5MUFRuMU9CSXI2ZkxhbnVOZWtaZnQ4OGN5K2IvVDdqajFwaWJXdmxxeTQ2aHBuYW1oUjF2WkcvN3d1YnZ5TlBkR0plVTZOU3czWEZFZUZxd3N0UnUxeHJ2RUJOU2R0ZC84VTJJc1A3ZmZ0dDdhRWRCbnBRN3Y1MU52djBzMm51UHpEeG50ZUhKR2YxRXZNZU0vOWp6WWVmRG91UjhQd0xqRjhVc2tWNjhwTGpCR3BoU1VQMXlGc1FUMVhOUHFhWi93YjFiWFRBdjVoMlR0ektxcWwzeitPWmx4UU1QS2JQWWVheCtTaHJDTUlleXZmWklMOG02UHMwdTNNU21tM0FjWmNNemw5eWJxU1A1MmtQazJOMUJuanF3VW5UUGUyOHdXMEg5MVdVUzFRMWxhMHB4bW1odHZTSlVxSGUrTmt3WkcraFlsa01WNng0UERxdml3NXBzQzhXTWZTbjQ0ZkI2TGo3Q21UbDBXZEh2UVdJMkNYVVBZL1EycDFkYTR2L1BOODg5MUJUb3dIK2J0bi9ibytZOXpNVEZ1aVVaTFdHTFM0UHdON1pnMDI1ak81T3VleXU4bWtxNGRLTk04MDVqOTZXZjk4Z2lNUDhOeDYwbWdtY2h2OGY5RUl2cFVMUDVlTEtFUGwzVGs3K2dZbFNyYXJGYkZtRlUrdnhYNUVOTUZGTEtHN0FhVEtaQ2JJVFYwbk5nM3pnWkFEaTNDaHZWQ2s1RHR0VVF6MTR4bllqRytTNW1ZQWFwbURrTVQxeDZpZnRxOFpUUFU2cHpFcVFLVU53ckxXa0dubDB2V2hodWRsakQ4ZXlQbFZNWVFhQjFmL3RCYVVDbjAzN0Y3cHh0aHBBUTNmZk9DUUh4MFB0QWRnV1JVOEg5a2gwaDRYaXpjSmxIcFB2S09OSDB1bWIxT2xrTnZDU1JUU1lFV1BUTy90eXhMdHcvWkF0MlpGZjZlVjBhS0xiVWtLcm5XTW84VkZTWmIvblZ5ZFB6R2xSc3hoUFYrOEFNQkFaS29VMVJOSUM2NUoxazlCRlNLSGdVK09TTXpWVDBPcHhKWCtBd2ZuUnBzZjVZQmp5cEtVZDdBWE5sOVZaeGkydVp2aDJSRHpVMGN5MW9DaXBDVnBwNlhvd3lhSmhDWGM5VDJndldzNFZreVFjblY3NWs4RDNyZnZUQ25vdDNLSGptd0tnNm8vcTVxQ0h1RVhUS1NFbXprMVQ1UjgxcUFUOVZZSVUwWDUxY3dUdWZ0cGZYeU5wUE1oUmh2ek9kZkVlMWUvQVMwNlZHbnFFdXhDQkM4QnFZWElQeU91ZzdRRU9JK0F3Tm9VOUFaU3NLOG5lTDlkQTJ1Lzc1QlpyWm5WV01oT0F6TUdBY20zTzBSbE9QSm16NDZuS2IxNzE1RklMNDRsaGlkYXYwVGViMytlUGJNUHBuejZyTWtUai9LWVZhOCtNaFgwc3pwNlN5M05qOWNpTVFQWjhVUHZlYUhKS3R4Ry9MSlk4NlozQldwSWdjcHRzaWRUNEFwRlZUaE8va1UxR2hxNHJ3SHJLWWhoUlRSWUZZME9Hb2FGNTMwV0RSeUV1L05nSVFJTWVDWkdMRERESzZ5RjdNV1pxMlg4TTFjWXREYzcySzJlNWtJYkNORXRIaGs3anN4VDk0Mjkramc2N21IYXZKcHFCMXg1VEdJWXgyWDFqOEJqVTRaaHpwak5YblIzQTFlbXB2RTRZdGo0TkRjYzFqL0JCUXhaUnpDeGE1bHl0eFJOcHBTanBpVktyZlB6WnFOQm5oaXc1alkwRzAyRnhtTVVHMEpLVnlweTk0QkNYMjBiTEF6bVFoc0NVUmdxMEtFVythd3hoRnptR1VCemdmS0xCeUZybjc0eWZDaXJnOVhyNVVJUHZpQ0Jmemc2K1JzL3NQTUgzM1RYelAvOVB0MDBmYS9sVm9McTFpelA4dmhUL0lldnM4T2tLYnhkdmRMTHRYNWNGVmVmVkQwTU9BVnBLSGV3UGZYOXZ3eTd3Y3d1THFlU0ZKVVRZcXczNThVWDJBRWpMMEdNQi93OU5hNVhWc2pQMXNidU0zWkJJQnA2YzJxV2trQzdXWk9JWFNYVHpJdWhEMFBjNUl2NE9WcTZrZXQ4RW5OUi9QS2FOclFnSm8zMkxTa1M0cG94TE16bjkrMlBOd0hFWTE1M0VQaFlZaWgwN012Ny9LMktUalUxTDhIaTVyNjQyQ2xWL3gyd04wTEZOUnNzdjZuS0w5SVNicWtpQ2J6aGNyK3oyd2c2Wkx5YWs4d2tPK0hlTHora0UvcThZODhrZnN5Smx2ZG03bi81SFRkbEZ0eTdjTUhlaFR3VWgyakJMS3BSdnNka0Vud29YNEFaR1oxYmtzZnEvM0t6bVBJK1U3amVWS3lhV2NEZkhzdVkvV1k3RGhpb3A0Y05WYjNjV3RLbmtQSVFUbGdVNmg2bnE4Z2t0ek9GNVNWZHhveldyMzhXUHBjTGVIa3RBZnN4T3Y2dWJrY2UvSGlCZHVGa202cHVIcGNRdDJtL1A2emltc1JBb0R5YTJqYklUb2lMRFJZcjVYNUpsaVRWUnFIQkUrMFVOMnNUQTJBQWhlSXJET2FiYW9MMHo3eDhia0NEOXhtOWYremV2Smkyc3dLWWJKN2I2Y3N5L0hoSWs5VVVlUjJGaW5udXVsVG11aG8xUG85WDFESkRTTVhqMUZDUUd2VGxNQy9XM2N3akdHY0p2RS9YekZLYnI4cVJ0UEs3SWVXMHNtVlNlQzBrRUJyRUJobFBRWGdqRUswUUJ3L1RodldkMXZWLzAvbnlhZkpJSW5tdXdjRzBrUE1PYTlHNUlSSG8za0c2UVZYRUJzd1luTElibFJkN0ZTTEtteTFiOEdrM1F6NWF2d2M5L1Ywak5QUVp4V08vNVlaTW9nQzNOZm1EQytJc09ialNaNjhtQkxhd2p5ZW82WVcwZmdRRDNTRlFJYWpVZk9sRFRLSXp3QTdDamQ1a1dheWNVWWlIZ3pkVG1VQ2dNVG5BTFlVOEhpZEk3ZFJmVThNYjI3b1lvYjYwM3ArVUpXNVNDYU9RRGJFaDUwNkpxZmQ2cGlhYlQ3UDVvKzQwOURzaklBMit1ZE9FMEhEQW5PVXRQT1lTeHJ1eDEzN3JzaWJ2ZG5jaEFEWUNaa21ua1hMbkZWdVBhaGlmZ1NXSkxqOWRSQ2hBL1QrSDlEc0RScHNUcnBwQVZvRnplTVFDc2liWWQxejVDRFZLdW1rb2VFOGc2aUxmak96Y1pLaGpFYVltby9uOHNtTENZRVpla1hZNzBRTDI3TStCS01iMHYvV09JMExZQUFEcGNtQXJ3Mk8wenpxaVcxRVlYZG1BMlpURkJXNHo5d3FISFpSSHk3V0hhblVCOWgrSnhzWWN3dC9IblFSZER4R1RZcEVXYy9na2R1bHplK1RDRWxzeEZIVFAzc3dJSVo2eksxRnJXZ0ltTUdVTUtuMHFJUEozcmN0cFFOcVUrTVVEWVQzQ3VndDNDRG9qbmx4b0VNUDBCTWh6MVBvUWlkK2UvNDI2RGoxWXp3VkZ4c0VIdkkrK0FLd25odE1xRWR6ZUZya2VYdHNENXRWM3VSNnVWSmptczB1SlkwTnhXREVjOHpWT1RsUUIvbjloclU2VDJFQWZSMFAzVWIxaHZ3RzliNGVuMW55VjNUT3Y3azZESDF6Nzd1L0cvSm1qd2h2QU5LcmYwTjFUak5aeVZLNElPMUNpTjNvcmNiU2tkaDNSRUNJZnNtZzRYUStyNWYxUWt1OUdKRHZMN3JXMjcvUlFZRWVQcU13WDZYQk5jdEdOSlhHOTYxTzBRa09yc0s1MWJLS2JWQTNOc3RTdzdVK3FmSjdxVWZxaUxScW5SRW01K0dBUnYwMUpyc1J5SEhadkh1VkZUQUdaT2ZsMlBVYS9GVnlwRWhmTDhuU01SR2pOM1hqZno4OWJNdXpWbHBMNFRobnV3MnBFQ3VjRHBYMmlrQjVvVFJ0VjdtNjhRL2QxdktIWTVTZE15aUVLeFo4WjdWV3BUT2hHckhUWVR0WlhTYnpkQjRGT0NieHNoNnpYVm5HQnJ1eGkyeVVmMmlQZzVzRHBqQlJxdEhST29IM1pLTzBpMW04a2p0dDN5NXJVVVpXZm05Vk1NSjBMWkdSNlpQbTBqRUdta21tRmRHZ281eTZ5SU1ZaHpvOFJFbEU5aDU5TEIva2pnMG10OFZnemVnNk1qZE4xck1HcTRRVE5lMlgwRjY0SFViTjZoSVFLZzlnQlFaNUVZRzEzTlVxSUZVUVZOUDM3UmlkUkVFT09WV0NNbzN5ME5KQU5zSm1MR1dSM2JRSURaM2tBbHJHaDg4TmoyNjNqSzJaSm8vbHVxOGJlQXpyRnFYRDQ4MERKY2cySmFtSUZnQi9pRkowcDdXNytwZW9hSmxFdmNlT3BWeDk4Z3lnd1NxYWFwMUl5SkpPdDBpQU5wMTIweTQ4QnJWZHkvTENrc0hLenFvTFJBNG5kNzlzNmpFM09QVXRIU1BDeGJWalFVZlN3d2QzaHBMZkt1MEZ4TU1ZNDFPaWdNM0M1VER1aWNNcFJ0VDBOa0FxbitRU2JPdVZlbVZpSWFCYXg2L2pyclh5ZDlyalFIdVNOclNZOE8zU1VHQnhGU3EzejBkYUpMSnd2Yitkd0d3Z3huZ0RNOUx4M2NZemJzWUJiamV3U1RPaitVTDlrWk1RTTRUSWRCTnMyUVZQZDR5cGNKbVVzbkZFNUp3dVM1YzFKWlZWVmpRTis3cXBWVkMzQ0xuZU05Uk9BMUV2UkJjRkNyZmJJMXFFMUZWUktzT2tQZ2Zza2gwenIwb2F3V3VBK0NBQTBBTGF3UDZ1RVR5dWt2MzhuclprM2l6ZTZuSDYrMGo2SVRKMk1FR0liQ0tzR1Q4aEdRbVl5cDJGc3pEQTUzandjMlhkSUthVnZ4Z09tQlJJenlzVEkvRXB3UDdTZU9OeHBqT2xtVmFjdExCVDVMV29zWjhqZWNTSXhBRG04eENZTmhoRThDbHEwd1lBSG0yenRaR2Fhb3RkbVJNcWsyYlcxWnRWUWRrU1g5ZjJ4cnVQOTRWdFY4UWRLcG56WGRSaTMxNUJyZlVPTW01RUwwK3JIY05WQ09wZjB0elR5RXBYVmw1V3dnSGxHTGxCR3IvTkFPMkNKWUVGTFdocFNTS01oaDg2bG5DZFNtb3F5MjBGNDFSSFA5Mngzc2tRTUt4TWFaSEJBUG9pMEtocmZ4YTBFU2VVVkxDQlNCQ2JQZzFsSzlFYWNaZ1RhUTRXYXA1L3hXSUp4aUl0UjlWcFdRb2hWRTdnNDB0dVJKMTJaOTJtdzI2UjJ6ZGlNUmtqeGFuSSttcEx3Q2RCelJXRFo1RkRCOU8reTVoaFV3M3JnSDFDNWFJK2FxOGwwUGdPVTFoL0kxOVNyNTUwWSsyaVZJZWZ6aTRvR0pJU1hjS3BQakh3bXVzRFlpTTltYTZ2U3l5MnYxVW9mN3ZTRU1IVVMwZURNZ1hXVU1lNnRWUU9SK2dWaitxL3cxTkV2Q2dnSUtlTkdrUjdqaXNjL2JxQXNWMUhFQUo5ZHU3dHl0ZGZIaTZFMFFjY1c2aTV5Qy8rODhXSXBaNEhTWDBwaHVzZDcxZjZmaTFCZ2pWWDZKRTBqalZiYlRZU3d3TXZrUldjTEk1bUdaZklQUFljMmd5RFF4a3J3NkJkMW95WVUzbFRIaHpQUTNFMDVNaUcrK2djS3VxOG9jcEoyUjJKVnVYQzBKMUc2MkpUQVRTb2szWW9yY1dZMGdidFpVU1drMlo3YWlkSUxZWkxFd3k0ZjBJN0plRzBtdkhKYlVhVytRaTI3ZFM4ekFEZDBLOTE1UDM1aTdSRlNOLzhNTFNFTzZHMkE3VWxzQkM5c1BxUmNxT3ZJa0c3V3EwTkoyVXQ0SnlEMTB3UGVrU24vWDFnay92WGhhVjBpT24wbWsyMUNlTk1DeVk4cHRPUEw3ekc0dEZ1K0JnZnRpbmExczFMb1Y2a2VrRzFQOEhJeFhoVUtMYldyZ1NpUlNzbDcrVDdpYVZ0UW5sSktoUDBKb3lFalBQb1JBU0pNWVNDekZRd3FhWFkrVnlVQlFsNStZWFgybCtVUE9FY2JRQjU4TXdoSVR6bGpPazFpSU16QkE1NTM5a1V4SWVBTFNpVGtHb2lrTm9tSXN3L2dnYlRUR2g4c0MxQnVaYWhXR01WbmhrTXgyeW11WDlPcEk4dW5vQ0VQSTZvbUM1OERBNHBqV3pteEh1bmxIY3BNTkNlSTZidkFCcG02bFdLd2o2OEs2VWdUb3dtTU1qNmtKQ2F6aStOTExOeXkyZFkwR0dpdm85ekNHaUs0elRVZThCUGhwUHhhQVpGc0JrNkNIendjWHVRa2dubWJYZkxOQTFRK0JMUlBBOEtwdjB5cXErSXpLWTdsaW9jNTAreURtdHRFb00vTTFKeHIwS0JobVFlRVBTR0N4c3dJOU9UNXhWVU5pWEx1L0FPODYwR1doNk5ydzhSQmNWWmlsWUdMY1BRVEV1RFJSRW9SWlRra3dQTFV5OGRDK1dLUmhSaE14ZFV6TVpaaThrc29zWWM1VVpIaHk2ajVEYU9uVmZFbDFtL0xtajhmb1ZzUEtCTDFnREVvYjU5VEZNVEZRdExSZDlwcE0yNlU0WDJ2aHMvdkpwakRKZy82dnZwc0ZtMUdsZTRqRVBJTUQ0ZnUzWGhFZjZHMDdPVHV1Zjg4aFl5UldqRXlldGJSU3c4ckhqU21wbEk4SkJGSzY1NTdxTlJyMEZ2dGhmeHZPaE5VKzV0aGhYYnU1cFgwM3JWdFh5ZWFXdGNhSVkzSVFVTkdodGZpWE9XaE5Ka2R3LzU5UldQbGRsdHA0bDdwTzJVUTV4eFJRWVZ3RW9SQmZLSEp2WW03N0N6Nm91blhyQ0NFdElza2FwUGdQbURrbUFEWUFZWEUyYTRaVjkwRmtWcWlYUThiam1MOWRZRm9HREdDN2t4NTdmbXhDaVRwNGM3d2ZzMk5vbGtOR3drVVJ1TVNFVXpLV05Md0NpeVR3aVlSNlJYVWpvUUpLc09xM3p4ZUxDV1lEWERNRkRzeHU2WXNHdjY3cFFUZGxaOUVheTZqSGNyd1F5VmZWdVJyWHpxcXlXUUtXLzlBQW5QejVQWU5hWkJhUk5lNzRGOGIwSzhlNkRhcnFaOXVmdHlvWjNUMWlJRzZ5K09NUkZIR2lCQjhueEo1WmlqOVA5bjkrVGxaMHFHdXVDQldqcG9yVTltV0VVTEdmNC85ZEVId2hJVGxackE4a1g2eTNpZFJjR2JuVnNMaW53b3l0MkRlM3kwMjVSNUhITDVUZjgyOTN0Ui9iWHBPK0VSS3VGaFFxUmFITWE3bDYzenVoZjRmYnA4endyU05IRkdlSE5OL2Q1b0YyWGZwUEtLQlplSmZHMWhOZ3B1d0lRaUxicFh6dDQ1RS9pOVRDTUI3RlRFR055UDNBR1NBR1RvRUt1aVI3alJNK1lYclpjSXhNTDNzam81cmRlQWs0K25EL2ZyK3JnKzdMYXdBenVOVmt5S21SLyt3SXJTTW41QkpNV3VFcVNDaGgyS3hHcFN5VGc5YXF6S29ya1dkcHQwelVEOG90QURjQWdIV3FxMy9scmlZVTJ2d2cxVXdpUnlFWjhMUjFId1NNS3dLSUNmd3lKZnRBTGJmQzhoaXdSVFRxNWFEb2ZBeG9XSjF1OHBUVFBaM3VLMUZoRWdkWUN6VzlUbmtXZUh2dGJjQU91MmRYak1KOEFpZkdaR2w2YlhSd2dJL2Q5UmtDWEhRTEliM3BNcngvYVZoZ3UxUmFsSkYycDZGUjZoMUQvOHZhWTVqVVZTem9PWGtRYU1YRTVuMFdoUlpWYWoybURFSThxd2d5b2V6OVk3RWFxVlA5SkhRbXI1OEJPZzljTlZMQXJzQVYyVTh3L0s4Tm9LVitudW1nTDY1RTVLYXJHQkNKL2w2bStSaW1LeWVOVkdNK0ZFQzB5a2hrZGVRVVVoNTNycmdNZXU2ZEpGeTZ1TGFSTngyL3BRSzB6dTlOQmhMc2tRclUxOXl1QWdQckNsNmhMR01HYU44TmJTZktRMmliLzZpUmdWYzJtaEg1NHk1UDRQSm1BckJsSXNXcXlpbUNVeko3UkM4dnlXZm9YQWN0U1UrVEpvK1gxMEwrZTdLQk96MmFlbEJpd3YrNjFlNldYWHdpWnN5a1pLNFI2MVBJT3RDSW9xbTNHZ0szR0NBSGExOGZORndhVThhVEJ2dExvaG5SMlZucnhhcEtNSGw4ZnBZaDFPdnQwVXZPYnBTcm5LbFVWbTQrd0NQenp2dWxXU3hKbm1DWkJzSmYwMkFZL0IyVCsxZGJvMTl6a3BNdVlibk1VV0RIMG1NOXNzRUhoK0hkdGEwRlZkY29MUDdMUElWWk5zTFNjSzBvbStpbVhiMXRVcFFDRWlqYVcwWTlNRU9RaU9iZHZUcDhUamRvYlRVcXRUVTNQNk42Qk9HMVIrbVpRMWxaNTUzbWZQbmFySWdiZ2drc0VzZytuZ1ZHbFJxYVRnaEtwRllWVENYYmRmZlJja2JzYzZFUzNiZE9xMElucEZBcUxjZGNyMHRCbWVmcXFya3hMZzVYL1hrR2tRbGdVRWUzN0lzWUQybHl3cmwzcE9neXlyejhhc05WaXEwdFIxWWI2NEpLMVB6MVpYZEgwODJ1eXg3ZlpuK0VSU05wcGxoRitjQ0F1YlpaVDNlTUw1RFJKM2p5NXZUdHFyYnNxcW1qWmpLd2x0TjhQcE45ZElac094QzhRREF0WEkrMTBDQlR6RTVSbXh3bUxUTFNJNEt1OC9KZGlXYk1rMWRrM3JZTWRoYm9TaEJiSmM0M3VvVDVCSW9mUjhTMmNDYXQxcHlkVDhTbkJCU2Y1M00rSW02ZFBad3VPdW9Db1ovSE9OcG1KRHZOOFZZLytrU3I1SWR1aEdnRDBOVkJEUGhsTlZLTFNvSWxVOVVvMnd0SkRBZUFYdE5KRE1VU1FncWMvZEpnUVczQmF3ZXNMVEVCTm4vcW5iMzFtOHNFSTlPRU5SdVlPbE4vWlFFS3RVK2FBTnArMmJlR0pFRzdqdW5OcHE1N0J5THF0S20vU0pjeGZtK3E2Qm8xZC9RRkJIRTdsOUlyNW1wQVVGVWNndlJtV0dVV29IMEMyU3dQNXlkSDBCbDN6dStkMnRSUXJ3anRhblo4RHBwL1BIeCsyd1czUmFsbmtVVUp6Q1FVTE85SkhRcmNTdnFoZm1DSTlBQkFOQ2VBZUVNT2xjMkY2TTNhS05WU0xaMUhUaDZMcHFQeFVDMmF0YU1DRlNuMGVUQ25uWHZDajBBUFNnYXkxb2F1MXpDQVJBcHYvRy8wbVJkKzMvb0ZJQlp5UEFXM2N1QmdCOE1DMzcxZzhNR0JZTitZRHhZQUFCNks4Ym5nTERpeGs0ZkFVZy9hLysxL09IQW9Dc0FUSVZBSDlSWmo5S3hmUWZlVU5TamJ4TGcrY09Ua1I0RWNGbVVsaUZDM0VPSWNQTW51RkZDOVFVSUlrRkxSZEpjcG1rSU1EVHZ0eFROeTdHSjh1NFg3RVlCUWo1VFVoeE1RZ0RJM0lDYVRocm4rcUhWc1FCeFNNcDk1ajZqcW5YRUhYb2pmU2VWcVRpSXU1U1R5Rkc5SVNRNVhOVXd3K1krNHprSGtsMklSV1BzbGl3ZFFXdDR0RHlFemgvMGlWQ1NMUTltd2lTQ21YdUZETXI1T1gvbEJtSGVieE1vV1pXMy9ETVo1Uis0eHN3OXlpUEtZTnBYNlJVaWJ4d0lYczE0Umk0RFNjWitQQkFaQm52L3lvZm5QL0I1aVZaaml3RHU5QmlrWTNUU1NxWUpEVDZQQ1ROZldxekdtN0t6bmEwMVBKekhDMzc4RU5TdldTLzdsL0NkSHplOFpQQlQrL0xwT0gzNi9USDVSNml5cW9qV3dpYS9TRk1Ea1dnL2xKdlkwRkVXS3FXNG9PSnVjYWRjS3pmZXRSTDZldDNheC9rTFI1VUJPSS85UUlxcC9waXN3eGYybDlSYW80emFiYUx5RnFTb1pHcy9zWGpRY0VRRFpEdi8wL3hRZmpEMTRWUHlLMFk1cnFlMExQLzh4MXZ4US9aNGMyclU3MUhxeWVrVlI5KzhUV3VUUjVlYWZFNGp0Y2ZqOHBZVUkvZm5WcENVbWxrKy9TSkNFQXZDanNmQkhqZDJnY1ZCUUVUMHVvRFhFOEpCQVNZR3pKSU9kZ29MUU5CcGc4VXJKakFnQ01wTUVMbURJemhwcmwrN0xiQUJDU0xjTEtuTHpBZHpwYVpaMERiRFFVYTRRRncxWDRJUUR4REQ4RElVUVJRTkFsVGtieW5Qb0RHelpwNmpBcmdzYk1YU1o2TEFTcHFwbTlEUThoWGQya3pEOVZmTW9MZmk5OU9iaWg1bjFqRnRJbzNpQTg5MnYxbXB2THlob3JpMW9iM3ZKU2VSanRQclZDcGRNWWJKRVNNSmxkZ2hZeDBmMXJhMS9FMy9QWjg0ZG9DMit2S2ZrSGxqeUV3YTlDb1M3TXFGU3ExNGp1RVQwTkZMUWhmaVM1OHNjYWVVbnpKL1ZRbG5NclVxcVhBWjVyWDg5MzFsb3hhZG1DWjJzNE83S1JnVXE1Y2d3ckZXbUV1Zk5GcUZTdFZJMTJaQ20zWjMvZG1hZ29xS2pwR21aSmtTMlYwYlJOWSszWTlpOERyYTFHbFFUMCtjbTBlNlIwRFJRR1YvTHpDT21XRmxGY3RXUC9sOWxJYWtkZHYyaG02ZStjaGg0TkhRRVRpaG95Q2lvYU9nWW5GbmNkZDhENDJYcno1NEJNUUVoR1RrUExseDU5TUFMbEFDa3ErL3FPaG9hVVRSQytZUVloUVJtSENSWWdVeFNSYWpGZ1djZUlsU0pRa1dZcFVhYXhzMG1Xd3k1UWxXNDVjZVJ6eUZTaFVaSjVpZXl5em5FdWZOWmFhTk9LWXUyNGJWYUxVQUtmN3l0eHh6Mk1QUFBUSTE4bzk4OFNVNHlyOFpOQkx6NzFRNlZ2Zlc2MWFsUnAxYXRVYjFxQkpvMll0MnJScTErRXZ2OUdwVzVmNWVpeHcxbTZMTExUWUV0LzV3WG12SWlxTU9SRk5RMHZIZ0NFanhoaDNNaDZublhIS2hKV09KR0dLSDExMUxSUG1FQ2dNbjRDUWlCalRIRTkyTnJRaXRjNkdWbXhiZlpWS293M0dWelFYdDVlVk50U1Y0SXRMMjFybnRGM1JVZ2UrdGFyTXNSYldhVSt3WU9KcEw0S3RqVUdlUzh6R1Z5bnVObE5pVDAvQ2xSZFZLdTVPRXp5YnF0MnQ0YWExSWN5UFlHWVV2WWNTdi9Fak5kcXlTRHpFL2NxL1RsbFhjVjNSclNNZmN1ZWNscks2cW4zRHhIOWFxaWl1YmNVVmxTdDI4MkEyaldrVytIMFVNdVZQeVF1Tk4vaWU0WHc3Rk1pZ2YrNGIwcWkwOW1xYkJ2NmZlalUwZUlMUWc0bFZpTWtiOHQwd3NQN3hobUF2bE92OUN6NE5qN24ycDdkaHQ2cDZmL08wSVoyODRQOXk2dDhzZ2Z5NTJaOEFNVjBBQUE9PSlcXHJcXG4gICAgZm9ybWF0KCd3b2ZmMicpO1xcclxcbiAgZm9udC13ZWlnaHQ6IDkwMDtcXHJcXG4gIGZvbnQtc3R5bGU6IG5vcm1hbDtcXHJcXG59XFxyXFxuXFxyXFxuQGZvbnQtZmFjZSB7XFxyXFxuICBmb250LWZhbWlseTogJ0FmZm9nYXRvJztcXHJcXG4gIHNyYzogdXJsKGRhdGE6YXBwbGljYXRpb24vZm9udC13b2ZmMjtjaGFyc2V0PXV0Zi04O2Jhc2U2NCxkMDlHTWdBQkFBQUFBRGpNQUJFQUFBQUFmT2dBQURockFBRUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBR2k0Ym5IZ2NnM1lHWUFDQlJBZzhDWm9XRVFnS2dhRjhnWXg1QzRNZ0FBRTJBaVFEaGp3RUlBV0dEQWVGT1F5QkRSdWFielZzWE0wOGJCeUFNZE0veTZJSU5nNFNHQ1k3RXFIYlFSVkMrUUhaLzMvQ2NUS0dRTEpOMWNvLzdRZ2tEQWVDWEtaRTlqRTdBck9RdkFiNktHeWpWNnhiUlQ0UE5yOVpNQmViZk9FZ2UrcGZtOEYvTmkrUmhVKzRzSlcvYUh6azNBaDFVNFk0UnBCcDEwc0J3OUVrVzNTTFpWbWl5QTJudXdlRjNMNWN2djVGME05NjByYjFkQ0tSeGtzVnh6Z2NxeW9Yc2t4RC9EczZ2bzI0WVJ3T1RKRnlJcFZoWldUck03QnQ1RTl5OGg3UnR2K1p1YjFhanJnalJDeEVyQUs3TVhrUmtiOUtmMmJqLy8vUzlONzczdnRGbzlYc3VFaXJkYXNzdFNEWDJWMlhpcFRaRkZsRzZkRHUwSXlrOU1PTmdrSllXQUFMMGNkKy85bHo3bHR5KzkweUpTb1NTUUZUK2JDUWtTZ1VnZkdJNVlsbmdPYlc0WTdKNkZybHhhS0ozWkt4TlhlM0FaSTUwa0NNQ0JSc0xNVEdhUHkwNHF2VVQveHVQN1QxczZJRVQvT0d3VmNRKzZJNUE5ODdMSU1tWjBWTlVhZXJYaFp2Y0t4a2dEN290UGNKY0FNTUVrVlVHNHdvdHNIOVd0SC9TYitmMHUrMnBFOXpzazMrcVd1R3JVN1pscVQvQWNBRDd0ZFdYd3ErSnZELzRXSzJacEtxQURYZXM0OFZrZUlLMTNGcFczRnZXVEVKZ0wrZlcyeG9pNlRFZFk0UWFaQThzWVNKLzZtaWIrT2JacmJkRHlFQkpsamVENTZtWW5SRlJVVytxQjQwV050R2doWUkxWFk4VWMxNGVQN3c5ODVmYXpjcHNHc1dzTWRCeU8rM2U3WnZBajdFVW9QbWtlVkdpY0FPV04wTGgzWTFhVFB0bVErNlhOVGx2eXNJcDJxbDVPZHRXbDc0dnhtTkxkc0JPK2hjaFRyQ29tRW8ybFJwci9yNi80LzBaLzRJeDdzclM4YVJsNlFGR1UrR2RUeVM5aUl2Mm52QTVMdVFMQy9hUit6YkFFRjN3RlV1RlJCMEticTBKVkdab3EwQy85L3ZmV2R6WjgybHFwMTBSeXZxQ1VmWGFlUEJ1Ri91VDlzNVZIWG51YUI2MFNsTk9DVE9aSkRJQ0lreEtIemJ1Ky8zSk1qU2ExQnpTbFBtZi9XSjc4YWJQTk0xdkk0dEh4RUpRVVNDaU9TVzlQQTM2NDhXVnNTUklFbUF4Q2RHYWZmMzZiQnR0RHBXOTNNeFZrVkhRQUFhLy9FbUlzR04wRjBlaGg3eEtQS1l4NkRIUFljZ0FNNnZBSjE3dmhNSExBL2MydGNKV0RBQVlDRi9KZSsvczZjVFVBQVFBRVNrYVVjQUJGb2E4aCtVZ3dFd0REVGNSTXV0dGRsTys1MTAzcTNlOUx0LzQ0bzNHY21BREl5SXM5SVpuRnlpdUVYemlPWFRxOCs5N29NWUp4SlRQcDhFSWdjYko4NkY4N0R4eVlYdXF3R0pqMVhWcHZzc2JYZjM0R3lRSTY0SlM5azV1NDlJbFk2bTRYMnhGcVZYV3UrazlVRzdOOGJ2UThnRDRMTEF5VjhtSVJiUnkrTzJwQk1ua2pTaVNZQmNMU01GVGtnQTU4Z0ppQVBuKzY3S0lNeTFpYWtTRSsyYVBlSWp6U2ZnSVBKeGZpMlIwWDZLYU9KeHZMdXEvWUxJRjZFemtqbTROTlJpYkdncTlNeUJlSUpRN09XSW1JaVNjTW1zUXJveHM0cWNrQ3BLSk5vQ3F6THhrT0tCRnRIbUJZQmZWb2tQSWZKMUFQQnAxUDIwRHhKN3dUWldnS055QVpJQTZHeFJ0ZnArMDg2aDhFR1p5ZmhsUUV5NllwMzZRZjZ1UXByNDl6aEhvOTFPNlBuRnk4ekZmMHlPaXdRZFFQSWQ2Wm51UXZIdHVURlkrS0dSMzM3Rmo5ZTJ4S0svMitSL2xMazBYOW5BcWF0ajhVYitRS05iOWdNSWNJaG14dVYwVU1lTk1pV1dJTjZKdEQ2U0s1NmVWUE1hdjNHdlpNOStoK0tJbGdPMUtmSGZBZ1RFU3hJclViQkVVNHpzZUhHN0IrdFhmK045Y1BZZCsycXhyYjlMVkhaMkFINDVVSjRnVGFGS05rMmFSSnRxTm8rNVZrdTAxaFo1Ym5DREVpU1JWVWx5YUhJcFVwRTBvWFNKTXBva1V4YVVMVTFPMHlSUFBoUVFDVXBRS0taSXBGaWlFbWxLcFNpVHBGeXlDaWtxcFdvU210MUVjeTJCbG9vc2E2TGxWaU5ybTJTZGpUU2JwTmdzd1JiekpwTGdNbHVvTXBXRU9KcWNyRExUWldiSXhpN2tseUZGS0tPMDhpRXFVQUFKaExBZ0lzQ3FxSnBrVmQvVU5XcW1hNVV1MUxUcjBzMnVSN3ArMHZXWDNRRHBCa295U0hiRGJPOVROY3hCYVIwME52MU10Tld1ak9ZZUIrZ09Pcko4bEp1NjQwN1RuZTAwelhNdXNidmlhaytaaW00azZYckY5Y25rWGludWsrb0JtVDFveHlFV0tkbWZQVW55RlA1RVIxT0VBWHA2eVdZU0RTejl2eEl0bmxOQ1h4ejhtQTNzMnp6ZXhaVFh5S1NnRzlEbXd3VWhBT2RXbVA1M1B5WWhyZkt1Y1M1WXloa3dKTEFIUCtka21NQlcvcmovOTZZMHZ4Tk9pU1QzRG1yYm5YVGVVNDBlWU1mclYzT1RUV2pkWGRobytjTVFUYjFHQU0zYUNEb01KQnRzS0gySTViRDNRNDlqVG9zZjNPcDNPU2paalVyeHVGSTllV2thRXExK0N0Y2dRYU5relJLMENyV0pkRWpXYVdYdUVvMkVDYWd3aEc5Rmd3MGhHUXJMOWNDVDBJRnBwaEFzVklXQUFDWFJOYlpqaCtFZ1ZjWnN0Z3NuRHN1K0lJdWtpTExhRjZuU2NXUDlrTXVSajlzbzNOeDJiRFVjREd6b0dOV2xKbGh4SmszTXpRY3lxV0duQlZXM0R1Qk03cEVlQk9HR0xCdVIzWnFnRmxPeTI1ck5UZG5jaU9ISmFMZmdCRUc0SVFpeVcwTnphNnB1MTRLNDYzYXFhaklveklpWTBJeUVqQnQ1aUJTQXA3Z2xZZFAvQllBQTN6dlZ1UlhtZTN1NytRWDZPcm5ld3YyN296V0crTEw0RkZldHpjWm1qKzZwTm9xUzNvMklpVFpqTmsvdlA4WjNsRjlPMzVOOGplZEo1S2ZyOUVuU1U5ek40MXJFVnhKTUQ2cVdrSmFvWXdtdHlrUFlQd0JXUlZXd3FqVWlFc0lMaHVRY1JrMEhTZ2dHUVJBRVdSaFdKRVJNbGdiVThtZ2lXeDdLcXhYdDJpRUtNaklLTWp3cnZYRzBjcUNFUVJDRWhJeU1nb3lNaklJQ1dSNHlPQXA4VlY0NTc3SForMlRJT2ppTmROWjFGZ2JrbllQaERDZzd4OTlNTmx5Q2xUM3V2R0l6T2ZnS3YrUCsyTlcwLzVuMEFLK1AwbEhoS0RzcS9rNGlQM0J2VXcyUTlVQ29yaDBJUEZCQ0ZRMjBYZDBOQUVtSUFBeUVXb0d5QkMvczJxbSs1cGlXYkF2ZmRweGUya0dXdWRFWnRTZXkxUU5QZm85Y2VTc1ZwS1Z2VUFqYnRsT0pBMy80TEVWR1E4eXppQStSYUo1Qk5FOGpwbmg2cm1wRWFnM3VOY3RQbXBhY0paOUEyZzFadFAxUDBMN1RJMGdvSDU3YWFUc2tZdUpPMktKZmFSSGZtbkJrd1RVeG1Yelh2KzhxeWRWSnlFdjVsUWpvMUxFQnFMdEs0aWtDbVhwWm92NVFNbmpmRGJnazRBWnFlUGNaUW1GZGdrdWhsL2VBZlFBQTN4c1VnQmNIME85MjRDQkFxbUp1L21sTjQ4VW9SbG5wbkF1dXVOSE43aElKazZiZkhxYzMyaHZuOVhsVHZKWGU2NFVSd1FCZVk1ekpnZ2RlWDNpUDNldjJ4djdrcXQ5RDZtb3ROOTljaVdZYUZQaUNzMDQ3N29oMW5GKzlOa1IwZmg5b203WkJBVjJlcXlDaVdmclZQNFdGR1pySlFyM2hsNmdsUjJTQkdCQkdCcno0QjViNEMwcHZud0lMN2poL2oydmtUd0xKMG44bERGQXRkTzVFaUNHRWVoMzJnR0QwRFFtWTUrdUdDckFFZi8rUXBVOTlXdFE1V293b1pVR29tczArQjFGeCtSRjh2M01SYVc2UUx1WmN2QnRLWm5OYU1vM1VBS2VrcmI3TlFyK25ZSTM4UXhxUnJzV05uc2QxL1ZzNlEyZWZCdEhNSEltYktkRWRWbVlOVldBRWFwYVdZSTlkb0tpZWtub25Zc1M4b1FZVkZTeUxXSG84a0dvTlY1eTh1K3M2Z1YvTkZHNXlFQ0Z5ZU1ESFRTL2Jia1V0VFVQc1hKcFpVQk1ENWR0QWREY3RsVFJXZlh2Z2dGVVA0aExxOHdFMUtRZzdLNUhLdGRZcTE0UGlyZUVBb0xPSHdjVS9Ga3AwdGxnVHJkcU13ODJhaHVnSDQ4Q1J2eTE4UnlPN0hBeDlnRnJpR2xzVm1VV01jbEtCSmEvQ2lPSG5mSHJ2S0RtRURiZWtNZXgvU1l5Mklmb3pBTExteUNTVEtkeWJSdTBzaUZPeDI2TFN4aWhLSytONFFYTkRDNDREVVpQUDI3cjdoSHFqK1JPRVlZeFBKRzJBbEIxcCtLZUZLaWNWT1JzeEluL09yVU9raFNoZXZBdUYxVU83ZXI2eTBSK2NiVnFtNGNYYjA1QVRKN3RiZGxCZ3RmZmMydlFnRnA1V3Q4a2t5SHpSenNDY1J0d3BxTnBkTDR3TGtxMWplU3R3MXQ1RXIzamVEVmVIeUYzUmkxU2p4Z25OY0VjeWlDa1g0VTFZQUZ3ZEVrbW82a21NNTU4R0xqWktJdWRkb0ZVOVJqU3BKMWVTM0NNU2k5LzZjaE16dlBvOHVoaTlsdDlYZDFlc29ZY0NlOVhRUnlIUGlFc0tDaVFWaFpLR0lxbUhZcW1QRW1tQVVtbUlKdEtvWVFIbGVWRksrWXQzUWRHU2ZCc0hmczlmVnBTNkhIKzdia3RUSFAvWDZTazJXUGU1UVFieGtJUEFEQVFLRUJBZ1VJSkFCUUkxQ0RRZ01BZUpkOENCaXFKVm0wZzl4d0MvR0lqUndweFplcHEyQmxmTzFjMXN2QUV3eVM1QlM5T09Pc1BjYTNVM2M3UlZUOGJHSFRlMzBvdmJVYmhya3hNN3J1UldGZDhEajhhcUhTUkhJOE1RSXpybXJHWGp3dlVMQU9EVkk5MHArK2hQN0JvNUFRNHdvVFpDcUxlUG80YW5hQzhjTkR4ckZpUkczV2ZUejFHVXNMdUcxa1FKU1NZeDYxbmVPdEdRU0FoejUxVFQxZmRGa1d6UDN1YldGeUJjcEFneEsybVR3bFJaclhLT0FnZjU0bmgzTG12UURtTlJVNDhVQlQ4SGpIUTVEVC9wYVR0M1RTSnR4K1pCTkRra3NrQU02cmhZSWFNdDZoSElXTWdZUldGY0tsV21aY0dwVFRpcWpGY1owU05KWWRlbEpSMm5IYWNjY2t3eXBnU09OaUkzRkM2NTlpUUNxTzFacWpJMmlKS2wyUWlqd0dtUndlUUFNdHllL2lzZWFJaE02YVVzb2djNys2WFhKb2QxZkF5Q2tVak9mMU5PSjZKeU54MzZoeFlIS203alBUMEIyR04vU0xMRm9HZUJuUWt1cTBxclV0SlZyLzIzMTVUejZvVWUvWC9HNlhwRUc3ekRvTGNjeE5YYWJReWRtMW5BZ2JWbEhiMHFzZHY3dzg1Y3QzalpMV2ZrUy95czVvVmpTMzFlODlKemZpTzZkUXh6U2JOVzFOaHlMVWF2bUhEcHBaeVk4bkk5eGZIdzdReVk4bXBkaGgwcmpsTnduZjVSVEhTV3pJREEwd1VQZE1lSmRrd1JHeDk2clFFbEZRKzAxeGY0TmtXMFVHZmhuVEM4WVRpTk85eURIZk16TWVmSmJjKzhPZXV0dWdCbklaNnE1cmRybnJmb1lYVndqUlF0eGptcDRGTDRSYTIrSVliR1Z1L1V2UzRnWkNBaWlhTGxCREVwS0Y0RkhFaElvbVE1UVVwSzZ6UitBZ1ExWkdSUnRvSWdKd2ZsWHc0SUJWbFVyQ0FveWRITDVNQ2tDcGhVQlpOcVlIcTlIc0pTZzJ4UnM1eWdKVVcweHdTU095QzVDNUo3SUxrUGtnY2dlUWlTUjZENVl4UkVlR0x5S1VUZjZKaUNYNTh4bkc0Z3dPZTdQdGFqaFVKNXFSQ3RwcUVEd3RwUjJEZ3F0aG05Z3AxNmhmWUswVUdoZG55V0RrNk93ZGt4dURnR1Z6VkRONFhvcmxCN29QVHdkQnhlanNQYmNmaW9HZm9xUkQrRlhmNTQ4YXhja1NwWDBkVjlKKzNBWnhlQzMrdmVhQUZoc1JZQXdBc0FBRjhFOEFqUVRnTzJEd0Y3QWRBVElPRVQzTTBqVDhWRUlDSllMSXJlZFFHVmk0bVVvQnRCUEJtemtFSjdEb0VHdkF1VVpiUlhrWDNXQ1ZnRCtmVk1LR2NRVm82NUsyVGN6T0tMTURCRm1KSTVLdWhSamxGT1ZkMmVobDVwRXVPU3hwaUphYkZhWWw5aW1tL2xHakdMeFlpTXJqSERrank1bFJoWVVteTN0RitTbGlRbG1yWHIxZ2k2cm5wTms4YVRUR1l6SlRNM2JBdDNPTlRJR2pvR1prM2xDbE1rRm1mYngvR2U1UmxFTmFiTE5LZHp4ekxHYnN1MjVIeGcxaEwxRkMwMU5wbnZOcUEwcFhSczBqUXRrYXJGcG1ka01vejhyU1VYRktiRzVrZ3R4bUx0MUlIRnlwamtwazluTjAyYTF3eGc0akhCYW5OL0lJakMwWVQ5bjdYK3psT0NqYWpaNnYzZlh3VVlUejF0UEpsQnBFWlJoTTFyV2Mwb0tuQmxQV1ZpWkpUN0NxRUs0Z2dqNmcvRHp3RmNZd1htY1ZiSXlGMlZweG5KMnVzaGVEV1k4ZjRwclVsMXZoNTlLcXZXcnFCTDhmTzZNQlp0YXVuRHRiMDNpNTZYNFNyR2owWFA3eGRzWm8zN3ZVTnp0cjJ6c2drQjQzRlpOK2JOS3o2NEFMdUZzWG1OdCtSa2xzZ0h0cm14bUNUTmZ1NnNZUFVCUnFQd1FXSU8xb1pZRGl3aElIOFFSYlNjbWh4T1BOdElOM1VzMnpCR1ZNYkhFZ3JBWW8wbjl5ckphTzREd1lJcjBHZFZna0JKN1NXRy9sdCtVMmErYVhMU24rR2ZNWE1mS2N6TnlLakQ0M2trYzhmeTA5QkpnaW9FSnY4b1MyQXBJdEZBaUhqUi96TmtiQWpJVDFjU0JrQnhqSmVUdEU5RGVCdy81U2hSUFRZeW5pTmYwWUVXMWMrWGlEUk9WNTlua09ZZWE2MWZ1TCtaM3FEVytIVDRGQnVjZzc4L1VhNnQwT2pCOXZBajU3UkZ5NmRXZG55NkpMOXJOcjJROVFYbmk3bjRrbjdKb3RNdk45TzFCOXpUVXFiL0VXOXI1ZHZZQ0RSWUdiNUQwVEpmcXVzakEvMFdLTUtMZjNXbHZjbTdJc2psSFlLQkZGaTNhOG9IUHVHdm9iQWVGeFRobTU5V3ZUUTJOSWJ4U3NqWUxaMW9rcWo3Y1Q2dUt6VTdUODYzQnUyMDJ1UUM2QmZXNjFBR0ljWUgrVDZUQkMyYUM5NnY1Wkh1MStXbzJwYkxsc3gxem81OHhMTUdNd2VDbFNHOGN6UzJuaHBGbmxJRTl4V2lTN1FINjRvVnFCck9Gbzk4YW9OWGVCRXNtYVZHRGo2RUJ2bG15aFhkTEhHTUpRaUkzeUtlN1VlWWVEWVUyNnZzZGJHKzl0a0w0M2VhOVJGQzlXMDUwcGZJQ3F5dk03V0x6ZWp2Smt2Yk1qYkhJRFJkMUluWFRlZytoU01aYjZhYk1qTHByUG8xTXBtNTlaVFpIbWFDTkUrWk5QOEZaMncrYWJURzB5TkZEMzFVNFVqalZxSUdJMklKeFVlcEhkZ2xzYjJsTlpQb2xKT2JNRFNNTmhFdE9vcExnT3FJbU5EM2x6UlFJZlFQQk93YXNJczY4VnhaYVJTdHd0VHdSYUoxeU1IM2R3WXMwRndxcTlGRGVYVlJiZFpSNDZkVm9pSmVhK2t0d1JaY0tYQS90eFRFbWtLUExJQWF5TnFadlR4bWlqRnVKWFZkZ2lleFRUV0diL3lpc1ZGQjF0VnJWVllzZ05sdWxWbjlnTEJYSFZOZi93SUlXQ1BJcWEzeUxjeExORFV2Z2x0NDBUN2pmVEpxTUgxYTRnbE1RVkxXMUorTTB6T05GUERRejlwNmJtaEJqM25IaGlpUkpLSmcvSWp1Ym5RUUFmOXZlcUxQMk9nSEhodEx0dGFzK1E2L253OEp2OVcrNkZydVRzL08xS0JuMUs3MEk2djNRT1VQMHhYR0wrc2xNeCsrL1JQT2FaL3Y2ZndoTERCT0RxYXBuWkFIelNvYWliSHZzY2ZVZjVJSkJmMm5mKzZGUjc5R0gxVmFqSnFpTFg2VEVmQkdVZ3dRM04xbzZ1RzJNak5UaUMrZWE5bHhvc3VOYnB0R21FaHNiNGlVejVIVWxqVGFjakU0UTNkSFZ0ZkpvNG9BenFnK1dCbG9IN0c2RTVNZ0NKVFY3VzRtVVpta0htKzAzSXUvTzh1Y2h4WXVBVnh6QkI1dEFialJRZFFMdEZ0V1liTWlWRVFmSnlycmpLdkgyaVRrRlI4S21XVXNIQUQzTndvcy9PcnFWTzczc0hnckw1NWg4WlBVZFp2bTc1V2xjNXBmMWo1M204a09TL0gzNnRneW9vMUloY3Y5Y0g1VVlSdEs1ZGUyMVRNblBjKzdSRkRSMkFua0VTVGk0dS9xOFYyWUFBZGgwcS9CTWhabjVjVTNMTHBUa0ZQRElibW45cGovclc1N2dDYy9jOUdCVmwyc2ZzRnpFZzArR2FycHAvdkNzbXhSbjNmYnZlZUxtTU9YdjhDVlRzVDlBbUJ3ZVBmQUdSazZSaUZJQ216Y0tLWmRhT0x4c2xhK0JlZWNwbVoxbU92Lzh0QmRlMGlPazlScFQwNGg0eFVoOUZ2MHZTOXNHTWJpRDV4TjgrL0kvdU5ZREh5S0Q1SFhBa00wMVJmQVRqOXpzWllMMHhmQlhPZGRjSnc4Uk9hZHZQallIOUl5OXc3d2ZZWXJpb1AxMmtmbEhPQ3JvYVlGWjhENDdQeElpSXk2L1hMWUlraUZwSUtQVzJUcXY2dDZyVnNPaytPSENjVVpJUnFWZ09WcTVXd0lVQmxYZzRhSGdXandIMmJHZjc1UHA4eWxHcFFMRDNJQXdyYmYrOElDUldTUVdqRitTN3JndUl1ZjJ6cjV6ZG1Manozbnd3Qys0WklLRERZSm5abERDQ0pJTCt1MjZEcEdWUExTTm80WFBvdkxmYlh0QlA4bllMdDQ3WkpuVnBkWTBzSk04ZkFHNlZKbURKRGVUQlZDRDBoUktXUmlXeVpVTDdlTUZuOEdjY3ZlcFBuT1pSR1hHNjRBUDVxN1JCOVF6ZUl1dzhlNTJPWGpEZXZCS3Uwd2VXYUREcDFYeXBGcHZoZnJJc0N2Sm0xKzVib0szV0YzL3J3Nld6Yms0SDVuU1FpQkZjM0o5ai9KR3FJNTBTLzlPcEc2VWtNanZEdlJFbDhPTEhJaXhqWHEzNzJBaW9hSXlxTGRvTFk2ZHhjSWNBREFoVUZaY2FGK0cwSXd3bmZCdUQ3LzUveC9YbjFHRnNZMU1zZVlKcTZKZFhoUnl4amJaR1ZhbUJ3bVZzTTA3bjRvNjYwbVpwWnhHV3Vzdm41QXcwcGpJdlZlWnZkWTkrSGpQV005VEc4OVVyKzBrV20xd0t3eFZwTVZaakF6Q3BwbXhGelUweWJ1cDZXVjJqVlhPTlg4ZGl2bmNGMThjVjNtYkMvRWFNYXI1cnhxQjlWVzFtWU9vQUd5NFJVSW5oalZuNzZqZHBKdU1SdDBGdUlERis1YVUreXU5NlVJM3B0ejhpc3JwbGM1ZkRzY3VOTnBzMWU3a2phZTNUT1EzelJMNjBzNEpJWlQzYTVseVBzSTFvY1lwNnN3STRKaUdJb2FNUlF4R3RHeTc5TFN2azlMdlR1bHFZeGd4U2ZmNXZmSDE2cmF5OHM2cmVweWlkS250SkVOeFRGMXJ4aThWNGI0LzJkZzVyUkhrNWVxcjU3UE4wT3d1VUJWRmIrQW9FVDhWSi9lbmF4NzJCYktlNVJIV0NDRlEzTzFxa0oxVWVhMFFOUnJMenpjdDRvcTdWVzV3d0xweWZ4SG5hMzZSMXFDK3YyWnVmTFBtbHhSaTNXTW4veXpHVDErUmZSaS9TamNONS9zUGtJYzJlUFowM3c1ZC9OeWU1QlBQbWQ4UWExaXZSZnZlUy9kQWZCMVZzYVR6ZjRYbmdXVDdrNnJ6dGNNQkpPRG1ybDlVSyt2UXVxNXMzSFZBMVg1ZVdxM3JiSXV1ZDVhb2RWdWVGMzlwYW1WM0pIS3lQZEowRTlmNi9YTnNMMDZOVzl6TnVzYWczMmsxNVg4aExRVlFuYSt5Q3FKWUdHU2JlZFJQbTRUODR2Rk1oVEhVWm5Fd1l2dGRhUlcxZkVrazVDNHZUdHU3TlhJcmR1blhIYi9tbFdGQitmQjh3bGdYbGpOaE05UnN3TncvWlJITUo4M3d5NFJ1eERwVlVuNnIwNXViM0ZxcUk0dnVTNkJKaVhwQjU1YWhmR1JETTlyRVR0V29IbXFkcWRVNElOVU1CbVE2VFJCQlZLV3FqRXZLNndCL2c3RjJ2aW1HRTRtVjQraDZBdFNkditKaGxSVWowbFZQY2dOSkREKzBSTS9mUkViZFNJSTVBN0FlbTBBUXR3b2dqak83NTlpQ1BoR0d4ZUJpN2g4bzRBeHRYL1Z4UTlacks4NTNHK1k3Sys1cWxQeklOR2dXajBvZ2s0bzhnWHlVaVZjbG9Lb1F1cHl5R0VKbEE1UHhiRGxMa2pra3lzUWtwUnBPS0lWKzRyaWtUd0RLdE1aVUZSbmtLb1NFblRaVk9qUWg3OGZmNHRURXo1djhJRE5kemNFU3FnTFRtYkVKbTBaaVI2N2tpVk1FUERqK0NVcE5HT2x6Nmp4UVVJWHpGdnh5ZnVYenRHQW1MeWpvdnpURGlrV1RnR2FmSnZLMjdKcnE0WEpQMGJBVmpXL3pwQW5hTFlYSUhHZm5Cc1MyejNoNm1uZjVPWkRNd0V6VUY2eWRZaW9DZ3dGZ3pzcXFrcEh0aEdCRmlDSTB2OEtaYUl0RjVyYkx2VjB0VjQ2MTlyU2ZiYXhhU0tzTFh6Si9wTjd4MVkyR3lJbEt0Sm9VanFSUjZHMkQraHR4SEZ4Uy9nSkthRzZSTkJKdXRnbldkUUZvazYvMytneWR5SEZNZ1ZxSzJZTFA3aGc1TzNsc1A3bVpHTmgrM3AvRkhvRTNDZThlY0N4L0UvQTFnSnNNSmdZZk9MK2Z1WmpMZFlUeFhUZW53S2VtUzhpc1VSTVJKcjRQSkZCRXVGZ1pCeDhrcGhnbitTTk5vcStKYyswcUxiVlBiY1RVdTNkalJmalZSWFZSSWRwWWJ4dkplL2dzK01YdlJlSC92VjZVYThIT2Z6MHdpbnZxZmNKMU9jVmZnSzJGUmptbFVXWEVhYS9RSmk5aDBneWVWUGV3MVNJTVZEVEdOMFlxTUcwVHJlQnV0N3hQTit1NzJqUTVhdHVJU2p4OXYyM0NRaW5VTytIOHljSUJLY2swV1ZkTlNXTmRtYjlQLzhPY2txQVdaa0xQY2owck9wNWV3Z0VCK1BmaUtyWmZmOXFiVFc5enVOTmhISEtKL1FtQ1VTczI4V1E3V0tzSXlSRStEbkhPUWY4RTR5NC85MCtURUFleXQ5SGhqbWZnQzBGaFF6QWhBbDc3SFREQjhsUWlPYzJDWVJCVTJJOVdmMzJRU0txNnhQcmlKb0NDVjlPOE5XbEZpMUsrT0JuRlNjSnlBT1NZV0VhOFRkeTNWRjVxdTlUTlBHZmduWUROa2pHa05nZ3p5NG9hRE1Zc1JaTVV0dnRBdWF2RUpNV0laL1B1S3N0akNra0VFbWlEcmJLaXBPbHAvcjZFd1NUQW5YQWxDOFBqRFcvblA2M1YveTFTak11NzRxWHlxK0FMajVpQ3ZoU2pDaFArSGNZaTV6NTg1a2RrQWd5dS9rSTdPUklEVlpYVW4yQXhYMG5rNUZpK2VtTlUxS0pzTWd0VXNIZEg2MThRanhaNGEvUCtwQlNvVkRXbVFGL0NRaUVBWVBab2RKZ3hVYkFoNGVSWmtWZGhTS1ArUTU4QlNZdXd5UzQ3dks2Uzh5ZDBFTElNWE5CS09CWUJPRmcrVWp2aW55TjJ5YlhnZTFQNmI1VnZwSnpKYjRpYk4wYkc5K2FBVnhKZmptYlIvdGlpdmh5M0J3QUIvOEtENUlFYzdhNlBlMTQxSm9vVHlzWnNVcFNlV1k3Z1UxYmhGR0k3U3lLNi90K09tNmtMREpTaUdINU1LdHo4K0Npd1VIaXpQaVpFOVRxMko5bHo4K01iUU1yMmU3RU9DTEpGUktDOXZTVU16WXdNMzBnWUJ1cE9MbVhBcHpaWVJxZk1wY2QxeTM1dktZQ0UxTHJrSXVOcURGUjZzVnh5bFNQVWNTTzZsRTZqUVkwS0F5ZldQbG9GMnlRWW1mQm9CYXR5NC9PUit1Q1dxMG1tRjloRWE0cFpzc0szVnRjZjBWS09mWTFabEZIVUsrQ2g5MGViM0dNd200ZnhRaWZXR2luTjQ2dVdZbi8vdzZXU3lDdWh4c0xDK0FHUXEvUmtocWtScCtjSUptTzZjMFMzc2grVjRxNjFvcTFSOHYrZ2lYWGMvTGZqaStoY3dQMlFEVlJyYlFyUllWT216NXgrOEZFVEpsWWM2L2FCVTRXMlVjVzZWUW9XU3JUR2l0TmVSamorVkdoN0FuSy9uMVlwaTdWeW10MFdubHRxVTQ5RFpBWjcwV2VJekNQUHMvZ2xja00zang5b1VjMlVEUHBEcGhaUkJSOGtVZWRxRXQ3TGlKY09QaTB5eUxrUzJtMHI5OTFsQzRnMUhpNGZleVZ5bVY3aDlOSXl5cUR5UXRjd0VIZ0hOUWF2ekRSejJMaW5lZXhXejVPb24xNHR1UnJmdzdURWhmZG9Iak54eXlCUVpEWVpSWHh5NnRSNzFEdmI4L0Z4Q1VmWlpvdFpCSHlmUmZCTXEyTTE3akdmVUtuTGRmS1AyRENoUGNLMkExZVF6Ulc2RkVvcWl2SG9nMkZYcmxFams4QlF3MlJPRGpvQTZjNUZtUEM0cG5OS3ZMdUxmNDVzM1BINWNVNEdGdVorb3VtUEtRM3QzdXlPZmIraWRGZDEyZEw2RTlFL3VRMWQwdzFVT3FObHV2TkZBUHdJWEhaVDVsV0JMTDJnQmJPRnBVejdhR1cxOGhUZmZWd2Q2bUxvd25hTUgxSlFhNGpMWENEa1VtNUc4WFpmbnh5b0VmQVdtTmp3ZkN2dmtUZnBnaXJ3ZXk5cS9ackZ1Q1VKUjYvOXd4Y0doOGN2M2lwQkRsbTR2QU1Uc0thaVZQQ3BmMmN5TmVIYm1RQldXajMrVzNuSzhvbVA2V25SdTJJR2Jndzh3Sk93Qnp2YnE4SERCQXppclhsMW9DdlAvMzlrZmRuaEVZN1IyZU0ySzk2R1JnNjFIdW9MSngrOE9MTEZlM05BY1RQVHgzOGNTZEwrcjNHS3IvbGpjSXhBWDE1SmNBcGJHaS9uLzNBSzNjOC9tRVRYcDY3R3o1WTVZcW9PRWVYN3hXUFFya05vQzkrb1V5VWNrajRlbkk0ZUlON0JGNjZNQjcwOU9jb2FpL2dGQTJSZ00xZEJucW1SM3VYd09QY1YxTkE3a3ZDdzhrNjJZOExRZi9TSEdpZlpLOHM3c1lNRjYzeUlId0NrdkMrczQ3elV1ZXZiVDBhbSt5NDZoVFNkZ2hUWmp5WSsxVmMwcDBvVFhtNExJTEd4MS9RSlZ4QUloZloxdGRMaWtrNVFuRjR3OEFpVzNSd1ZrbDBTZW5zb3Fqd1lrOFl4WFhFckFXdDhmTjU0RURXcHVPWjZjS0Jsb3RKa3A4K2ZGVWFGQ1VqSlJiVmU5L1NVZGpwRWFINmNoT0k1VlNkNUlyR3hDbHZNWG5MTE8wNXRPa3N4OHhweXZqNEZjMHR0QlQrMjg2Y21ISlZ5QmlTaGVxSit0bXkyY2JacW9adGROZ3FwSjNkTnRIY1BOSGEybnltYzlkWXpzOU13WllKVG0vR25SdEtTdFlUWklXUlFoQWJTL0FOSm9pdng3dVdVSVpJcGF4TXBaYVdCUlJLWVJGOTBtWlRvR2FMblBtN2o1NStNS3p4cXBVdXFOL0RKK1V5VXNIVnBFd2hyNWFSY3NWT1NibDh0b25QTndzeHFnUUNjelZmeURkL3N4VklQNXNZemMzaW5xRHlIMFlpVExsejRjbW9sRmQ5NGRSTnl2L0RMa3ZUNFROcUlwNkdXRDBKSHBZUm16ejA5UGFSOFN3aFVPUC96OGRUYWNZcUg2YjF4alNqckh6dC9jc1hvb0JZZVlSdmlJK1lHOFovSmNWRCsxV2RaZWxJcDZkRUhMNEF0RDB3MVZzTllkaVphUGJYTFBGQ0NmTzlQVy9ZMkVtSGtwSit6YW9CaW5TNFNkYmppaWZFcXdUWVBUa3RnRkUyYkpxNWZ1TzZEWDJhSFhmZTJFLzlmTEt3d2hPdkFpVjV2K3g0WURRLzlQbnBzU1UrNXYrQjk0WXlGLzd3ZTN1aGIrNHJzTDN6aTYzZnllRDdiS0VjZUdqUjM4QVJWWXcwcHhBejI1c0dzMERqUXk1YThEakFOZm1HZ3Q1U3Q3M2NvczVPKy9XWHFNZ2ZOYWZZb0RLWDRKanFjV3pSRFE0UWx3Q3hYOCt0VG9tKy9kclBtR1cveE9HdVI0QnozMkthUDR0RTJnY3Z1dlJyd2xEdUtGanVjMEJRUDdjWFhGcFFYbXdJQnlzS253VklRWVg0M3VOZDJWL3cvMWFyM1N3dWdkMnQvWVZrOWpWV2JJc2hadm1EbHI1a1pPVCtJMzd6V2RFRlArTmJEaml0bXN4RDZndnlwUFdrVGlGMXkzZFIxbnNxTHZDR2FrSGRrZWNHUHBTaEhpNXpuekhnY21VaGJpMHVKQlVLQTFtc29FMXg2RlN6S2wzSjVid0Z0Z1g3YlRsU08xUXJWbDM0Z2dKTDlzaEgzNFdwN1FBL3RzQ2NQZjdrKzZMUEppOWQvVXdHNjhFcDJXUmQrd1ZWdUhxaHBIRVF6OFZITksrSEtaN3FacjYrZGwvdVJUb3lmbjJ2MEpaWWZOSWM2Undob05IZ2FQTktPcVpxdGRxQ09JNXJWMWM2MWVIMTlMOFF1ekc5V05IRjkyV1ZvaU1MR3ZxRDhrRTZyOVJQVTFyUWh3Y0tkREtxK2Vxc1NQcDhzRG5mNEZiSURmeU55QlZZLytsOEtPN2g4ZHZKVm5YNmFScjhDQWZmTERYaGhiYkhuYUtpc2Y0YjFOZXd3LzFDMjdsYXFpakdZM1BaN2c5MHplMmt4bUtyUTdreEl4R240bUtlOWQ3UGRpcC9PRW9iMHRDaVBxM1ZQR2w1Wm5yR2NESSt5a2o3S0MzamJwUU0zZ0RJNW5CWlhNN2JsdG1jTjlseGNSeWtLQ0NQMDVEWnhIUTNrWDcvUG5NZ3dyMC9mVnI1YjlyZjBuTTJpcjQyaG1mK1FPVnNTUC9CSHlINGhwcUlIUjFoMEljWjlKVjB4aXA2N3ZQdTNaaEhFS2ZtUkgwUkNBZHJZaGM4Wm5LMFhFV2FqR1A1a1V1V0FYZFlYZ0daU3AvcUVFVkVjbUlzVlFGcm80eW1pa3BFYWV6dkVndGQvSjBVZFJ0alRGdmdZV3BzWW5MRU1MTHBQMmNCTFAxT2JMZXorMTM5VkpwSENTbEc5ZXFVbEpVV0habnMwUlJxT0xQdEIrNStZQnZndjdNZEJwMDFEV3NTNkdza0VaeVFPM0hmV3JITmgrRGhmNmJNd1EvL20xSWZYQVg2QnJqRDFiYVJiNnAzZHRvOTAvdnhWZ1QvbTVzanNOaE52eVZIcHQrYXdYTzNaWlY1WDlrT3cvTlpZUUk2Zk15cmkrbjJ6Z1N6STAxV3VWYmt0TmdURkVRUGl0RElQRlAxdEtsazZXWTNMR0Q2TFlGR2IwM1lnSHVLWU1LYXRISnRIYVNPM0o2NnlLOWNoMHhZRFlpZVRGRU9jRHNIMkJVQmpzY2J6b0Y4Z2wralJFajVadWFTbUF3S1loTUtkMlN2WWZyS3NLakkxbkpUb3A3RUxPVDZHS1dDNkVlcFM0djd5dlVqQzhzdFBkY3Qwc2lkOFVXenJET3lTekQ5bG95TTNwcU9BWTNNTExuMFdMYzRURzl1ZHF4bm1uNUxza1p2OVVQaHJ2bXhnMjRjditEUlhhdFdWSStlT2tqUFBRem5IdHFqaDVQbmxLcnlEQjU5TUVpeDlEdzZxQVFERkN4cWxGRkNNU3k3M1ZYSmxmVEluQjcwWkEva3FtSHkrYXo4djRtSmV2Ny9nUTEwL3NPMkgzcjFUbWRWNzM4MjduTjNZZU8rZi82aEduNktlNFdlZlU1ZGJCKzBiT3V1Sm1zbXArZEcyNDlWQzNRdUdxYVh4ZVUyRDdmMHB0ZTgxdWtyQmlhaHB0OC9hY2ViemxtdFdrZlZpczBwUGNwMUFVelI0TEZTaTF0TlZLMWFrenBYMmdnZUJQYWlyUkZYV1UzV05lSGY2eGlRbmdRQWJnQVBuQkdKblZIOXdVdUJlZmUvQUhMMmhEdnJWVUdYY2t4Q3cyN01VbzBXNUdyV3FBWndiWHpkODdwcnlxVjYwODRZZUFIK3VPUjlLbjRIVFpsL3dxcHNIUmQrZFZFS1F4RldBcEVQTGJobFFYc1p3aE1BMDhZaitPc2tWL1NQc0pUNEdPbS96SzlLQzhNbG1hRDRIZVRPdVdxdHRmUDVrZ0tIeDV5ZlNqeFNieTFNNmYzbmxia055aVZsZzdMeWlOMnNzSkJiNTZTeS8xMDVwOE1BVHM5V3JRQzN6ZjUrQWZ3NG15c0c4UE9NRWdMNDJpeVV3U2ZWTnllaDdGY1dIckU1Nm9wemRFNG9vekRiNWNtRk9TaENHdDIrSjBlbUh1RGw0eFdUamJIT1BGN01zcytnWEM0NlF2dVh2c01aZ0x4VUdaeksyTk5yR3NMZmlUUC9TL2xQejkxU0xTSjBza3d2Mm43OC81Qk1mMzJXOGIvdTZYOUhnLy9sQ05DL1AzczF1K2QzTjFmblo0ZGxVMlp4eUJrZHVUQjY5ZnB3OUx0SHlVR0lCUUQ2QU1tR3lLeTFiWlVlQUNKdzJhLzlkT2RObWpuMzFpZW4yclNYWjFmNXVsMFF3b1QwZGxacW5XeTFyYnJsWEJaMVJhVjBvWkZhYllOL05YSlhKRWppS1B6cll3Yll6Zm9QRGwxbDE3VzFLUEpza2thYzJ1T21SSmNJZXdpUTIrT3JKZGk1VnEvay9lUCsxVzVuTUVhMEZMWWlvZFJVN2pmcW1KazFyd0NzTGR3MUlFMjJJRnR1cTl4QWdZZDhkYzZRMTg5a09aK25LYVdhbi8yWTc5ZGQycVIxa2RPRXh0empnbVJOam9hQjd6bGpaamNuWFAzOXVPc2VaUURWdE1EL2xCSjNEQVJnWXp1UlNXa2N3SzVxd3dGeVJqQTRIdmgzMlpSUFdGQTQvYnh4bFQ1QWlOc0F5QUtDT3dOVjh2VDYwMXJ3MVFaeVZCYU1hNzFIdGVSazRocnZHR29icnFjWG9WZU1JZ1Uwbzk5T2puY0dHcFp3anpsM0JQRVlvLzI4ZWYzSnlGY3g5cFljQUJrODdoUUFNREE2bWMzN2R4R05FenduVjlIV3RvQWlEQUQ0UTQvWkZZaG9OdTdvQUU3bVRLTUFETFRwdCsyWGdsQ0xnQjg2ZW03VFEzUnRyWitKVnRhYWpFYVlla2lwaHFlaGx0T3dhTm91UWxRMTdESnlNeVdFNXBPSWpWcGpsUFVpSUlaV21Qa0Nkd25Ua1ltZ1phRU1HZlBLdWg3a3ViMTdaWjh1Z281N01KdHNFY0hGdkJpYjhCbDBZTWJsTkZMNjM3VXEzVzEvelhhVFZ4ODhZb1g3UkRDWDNZZVV6aER1UlNnSTJsSEtRRXdTY1BoaHh0Sk5XZVM4U21hNDJHdTVFSllqdWt4aklLSmZvdElEMU5scXUycklyL0VPQnVuc2hZTndjc25Ta0RDWjRSbVhjNEFMWGt4VCtQQkVPSnEwbCtBZmVPNS82QzN5QjhySkYrVVFzT1JQUWI3NjAwc2lVWGtTV0YrNXpLa05GMng5cGtLc0FBZk4rTkgzNm1adFUxVnRUL0h1WWh5RmF0RzVhejlieXlzQ3I1SVUzc05CMmg0RHVMSWJzeFRkaU14REoxR25QcWZkd2l3bmNreFBBeW50TFd4ckZtU2xtMnNoa0NKOTNwb1liMkNGZkkwWjBETnNHWWhnSFhTZStmUjNuNzF6VlpkMXRiQmhZWUJlZkQ2aWk3L0dvV1pPeVFobTFTWXZsVkVablZIN1Qxd05HWkxMQWtLNFlvblNZK21Nakx0ZTNwRk40ckFpVDBRcUlzNWlKMTdLSWN0NEc0dWJqY3VkK21pTU5nNXZDU0REVkRSbUV4RERVdkQyWkdNMHRmMXRjMXFmSHJaaThIZmhZWWFJTUNaVDBublI5bWNaYUxvYnV2WFhUWWNraHFFR0Jnc2oxRVowa29tRDJjaEhlZVVPazl0eXRPRVlDSVZuK1N5bHdJd1ZsV1cyYWtCZnJhWGtsWm5lVmNZUnpLQWd0Qm5WUFkzVkRVbGxndXBwUDVySVp0dlphUGZzQkdOUzAxR2lnUWg3L1JpQlJFZkhZWTZXTjB5emZMSjFRUGlrZFdza001cStjVFFZOGFpWG83V0RpWEhYY2Rpd3BkblFCRVZqVmtvaFhBTVByMFRIeFMwRXZQTGNEb25EVEYvUjdYSDVaOUFpOFl3VGRRMkF1OWFzT1V0ak5KMmJpVDBjSnhHQzZwZU02WlRraFp0R1NLRzZaRi9YNVdIR1BaNSthelJvOGg3RGsxdUxjR0ZXZ3ppbVJQaTllc2txZ0ZneGR5aUh0ZGMrSXBLMWIrTklNd2VJK1RYd01FQlp0OUZpV1hmMS9GQWhBTGFxZXhaVUZ2cjBaMXBpNjdZTkY0NHJQT2UwTnlMWmg0eElaL3JLUHRLV2YydUtHWXh4SXViMlhBNlVqTmVYSTI0Sk1sSGFwRlQzSk1mWDJLalpGUWc5TzExMVRoaXowbEcreDlQeG5ESHVHL1RMVHk1VVliY01UV2JGS2d2dEh0Q3VHSGxaQ2pmZFRMZE5zMEcydzVzc0hwdTBRRW9aaElCUUR1d0swWjhjcnZ3VXBTOXVFY0tEZlpsdzd1RVlkSStTelRJRmtVMkUraVVKWGxicGZlL0RCQ09UblJxRzJoS2hGMUphY0I2RGdnQ3lHMmNZbWs3bGk4b0FqckJzbnBRNDVOdVVEVFR2WXNuSUdTZ0g3Ym1mUkR0Wlh2aDFWYkJoM3J6S3UwbHFXL2lvQ2dFSStub2FHYk5CTURJZnFrcjNicmd1NEdidU5BemdnREczSG1wdUpxamR2Y2lGQ2RLcTEvT0FLK0Z1aEJJamNWN0dFbGhQWFRQaEsreDVnRGZ6OGpTQ0MyTUtsbGxYM0ZjeTk3a0VxS0IxMjRnNkpHVWRBM0VlK2t4VFJBaUZQOWFlZWxlS2ZaQ2lWb2owQ1lQYXhVREVoaS9xaUlVR1lHQk5ZdGVrUmhpMWFpQVNxOEhjdzA0QWh5OGNybkM1dWI1Mm5na3pZcW1kU0diOS9aaDBqN0lCZWlud05VS0g2T1JDcFlWYTFlYjFBNkwwVlVoVVg3aFVZTlY4SUFvaHlvKys5NzdaVmQ5VzFZSm1IZFlPb2E4NWRzcFFpL1RCLytUUDNlM1dmWGlNdTI2ZmwrUWZrVGI5THpBVnY0RzlMdU9IMW1EQlk1N1VoWG9SRHNBZSt0RmVPdTNwMTVBZ3BqdFluUlNrN1JhOUFVdzBYZGZWZ0NMR2Zxa3dOb0VDZ01WR1hDVkpvdm5PRVYxb0dlRUt4L2hNYWlETlZFcnpYSDh5NXFLWW94R011NkhyamlMVU9Yb0hiZjdNZm9RTGhkVHZ5SjA2QS9MUnpoeVBBN05mRHd3M1N4bkY5S3N6cHhQTHdpc1J1TVZFcTNYeGFMN3VVb0J0VVhLdnBNV01mM1p6czljVEtRdVB6Q1pUWnhMeU91YlVKb0FmbHE5NkJCcnY4UExjRThIZE5jREZpekFFd2lvczh3a0NCSFZsUCtITWdpalZZRTFWUWRVNVByajdYSUluMVFiY0orM3VmR3NMekt1MnF2eEZKQ3JqYStaTEVudmlmQW0veUtUbkFtUVhzTktTbmJhSmdtbUpaSytKbXpTNmRoUXNxRVVIOWVXaWdlMEUwVkFqdXJoMDZDN1I1VTE4NFFwbUQyMTcxRkV6WkI0T0thQyt6akQ3ZkFNNzcyWlNkOFVzSU0vRnVrU2REeXp0TWhZMGdXTFl6S0NSWjFQaHNQNDNHWEZyS1UvTFRPOVRPdEVCSXV3RzJ1Uk1UaGJJa1F2M3RCSnBabWNpQ3hMeG5LRFROR0RuRFRtVVJOR2RUV0xlRHhOUDhOUFhCOEllNG5PUTZibEl4L29lb0VKWnpKd3U1ZlZid2RMMy9WSFJSWjV4M3dpUUZMRVFrYmt6S0hnZUtQV3RVVVZCb2VYOTRkSmNqWFhpYnRad0tTSzZDRTI4QzZBS3Rscld0cUt1WHFwU0Roc0lWZ2RvZlEvbEtvaUhreUtscmdGbUc4ekoyakpjS3JSMVhDTE9CcWx6VWpVSmNNdjI5cWlwdkQxaDhDeUJOSGM3SDFEeEtZSVExSFFra0ZHckd2L2RWaE9xMkhsNmttWUNac2liS0lDd20zd3JteW9XSDc0cHRZekoyc2l0RGN0VTBldDJCVVNoNjRZQmJVeXROY291ZW4zWk1GN1ZMQ2dMZmNkb296T1BvTVp6eVBNTzM1T2dSbmFUeldXNXAwbG5MYXJUOXR4M0hYWVRwTVlseHVIMy9OT1NoTDl6VlZLOEt5ZnJBUlNIVmpnaWVheElJMlpMZVZVdzB1NFdJSWJ5eVJxdkhuSktnZnc2dnpvOXJMdDVUVE02RFRsc1RFNVhKV2ppM1BBOTlXKzFuSmFxVXdNRFhZMm1VdjFyU2xYNVV1dHBoY24vaUN5djBSRXBhcnBYa1pNcnVid0JmVGlPcjMzbGRlZmpzRDRvd3ZLbTQza3VMNCtLTnZZa2k5VnExdFdyODlYNWlGMjdYTXliV1Q3ejNkVDFWWTlnUmhwR1RuS2tDdW1hMWFZZHFuWlpPZmpEVy9SWGN0dWxpWmtjMlpWYXVoc2FVTlpWa0hzUjBsYktjMTJEeFZtZmxYblNCTVZNcWE2RGZKVVI1SlV3Vkt4bHFUQm9WYjRzNUp3V3BMUmtOWk9DekQxSW5lQ0VyU3FVYm5qUTkzVjBkbHBYV2s1enlFWm5TL01KWmRIZmo2TnJYOW1Cd0RPL3hnMytKUkVSbWs3TmVjMmgwa3diU2djeXdDcFhJT2NCNkk5YURKZHIxR05oRHdyaWNtY1p4LzJpOUNTcUZRZFhYV0JGMW1kcHFpTEVQYk5ZbWxBcVc5bFJLQjZ5K2xOZTlDenRvekJReFZPN05CbUhhZHlNREdhTHZpRm0rNnhDYmYyTFNQSEJ6S3pQMGpCRmlEQ2xyNVFXdDgyeGtvVG9Ca2UzQ0EvelZTWUFFbGhoSWF5bU1DZE9uU1N0WUJIWmF2VWgyUlNsWGorQUcrYmpCUituWjIrNk55b3l0S1hmYy9EMjhta3kvR21JZTlRclpqc20zZlRYczF1S1RmSExTaVlVL1NNQ1JRNHZKUytKSzdFYXFYNnREMGZSUFVwNnFJVTZLcSszTFk0RzhoVHNYNkVhMXV3TzFkREh6QmpsWlZ0VktUNUlYaW5od3hpWEJaQWhaRFF4c1VQY2c5cWcxbnhGZ1ZhdzI5MTduU1A2enRaNi9GMTNJYStYMmlFOHpBczg3NnlET052U05KNUYrdUF3bnJmY00yNSswaksvdTl0dWdidFg3MTU1SnJlMzI1dUxVMnl3RVg1ZHVaV3dIY0RkWGN4VmVZcERrRElOZTRsc0Qrb1BXYVFjWHQ4U200eDlNV1BVS01mQ0hoVnNOMnFuQit5cmVWbVdjNXVVczc5SVpJa0I5K1JaR2lnYVIrNFlrYkhmVGRJa0NuK2htYTd6RW12SGRKSGxPZXZiTGlwUnY2SVZwd09BdmxBMExWNGZHNHRJVUNvUTBBbDRkZ21QejhXU21mQUpDdFUvZUZGNlIvaGQzR05vYkYwMXlWMDJPeWpqK2QvSm9ENERTZ3ZsV0hZelZ4bzZJM2ptOGlLaEVnR0ZGR1F5dVpkempMUytoTW51WXRoUTRqQzQrc0xpN2ZsR0F0aGhySHdqbGpYdDV5U1VkaXIvSDJ2b2dlb3Q5UkhrU2kzN1FQaUx2VUZ6OG9weXRxMHpUbVBrTno3VmxoZmZJUVdRazZSdDRPSEMwajB4V1IyMFJlbkIxVWNIcXVQaFdRN2Fic0VEbWlxZklrSGlOc0xUc25XMll1WmN5cE9TRGVHZ3lFZXBRRFdzK3BZRStpTUdVaXp6cW5MZUp4UWEwVEF3YUJEbkNGQ0hWUEpHbFBKR1FFSDIrZWowUUV6R1RRTmNudSszemFycGxndlVxTXVtcklTNWcySHBXWUtyT282aE1aaU5kQUtVM2NCZkF4dkc1OStGeVMxaFlXM3Z6bnJvTDIzczBiYXFacTdNQlFKVWV6cDRXU2tXWmpXTzFjbUovKzRVRzhDcmgrL2VpSEZkYmtTUDBqSVBMN3lIaTJSUVh4Wmk3QlBJcXpSUndLNCtOb2QrVmRzbElhNEFXTXgyMlVVZjQ1QURlWnN2Ni9JM0Q1RnRKbjQ5amhSUHIybW9QdU9GaHg0ZVlrRWpzaEdYaWRhTG04YkNpODBxUVo2SU9aVmdQbk1MTXgrNi9pUUo1bXNWaWIyQXBHbUpJZmd4K2ZLVm83MFlIMC85b2JKV2VRcVRtWHA4Q29BQUlFeS9TRDlFZjdkLy9uSjY5bXNBL0hNc3J4c0EvclVHZnYvcCt1eCsrRXJBRUFJQUVFQjk2eDhHMUpmMEJISk9Bc0wvNytBUC9IMEJBT1FVTkFQNEg4QnJxaE1tVHh2TTg4cG1xOHpKRXJDV0hpc1V4d3J1WEZZeEhvMXVrSkROdWp3bU45a1N4Z1Q1U1JLWDIrWG5VYmw1aVM5UENlWnRtVm5PbDAvbDV5TjVQbFhsRlFucFZUNHFOT2FLeXF3aUxZdmxEUVB2bUNBOHVZb21Yamh2Q1dkY2VQU0t4aU9jR0JpZURqSERJWnpWd25ORmVDekNZMUthTjRWSElUMC9DdWV4NHF4aW1SeXQrWUpsYnVFY0oyY2VaTXA5MGhNd0tsRHRCSlRuVTlWemd5SDVWbm8rRXNxa2pId2lQWjhwVEl6VWZNNmZQNFI4bzlxdjNlOUpvVVJCeXp3WHl1OUMrVXdHNXpQNUMrbkoxWkFSbVFsS3k2L3FNc0UrTTdueW90ajhxQzRqZ21rV1NLeHhzVW5QZDFKOXFEb1BTczdqZkxtRGFYbmN5QnppekVpVjlrak53MG8xeWZvYXZWNURwdzN6bWc0dkttTWk1eklZaGt5aGlKUDJhcFRaMVVacDdIUzdUalpIMGZaTHcvTzNzQzVabmJWVXl0S0trTTFWKzZaRHA5YXlmdWVMKzRVZm1VRDdqenNScDVXTkNLS1RBblNIZkNPVVpjSVpVTDlVS1YwcTVQYWhPWWdnRERDS2RQNy9VMW1FQ1VOYjl1OXZYV012bXAvcXVFVzhteVNQelFQT05GNlBjTTlZdWRsSW1xRFVVYUZ0cUpBNktWSjdIRnFNU2JNeU5PejRCZjRwVlRVcE5QZTk3cFVBSWdjaGdCZDA0Um93eENkb0c0Q05NV0VRZ0NzV1FMNitDSkFMV1JXNWlLelJKZkJvZHpGV0UxMGlzd1g1VXN5bDBxeDFhU3gydW13VXgyOWVKemxQZ0NzVkFLYTdDaGVLajh0RkxDbHdDUXBTcDdHMHN0QWw4bVIvdnVSY0tuZHVkR2xpODdqTHhwYVBMNkRUY2w5alNLOVVlQnl4VnlEYXc2UE9VSzBIcEJ5cm1VRnJqeXZxZmJER3hsQlRUVjhvUHJXcSs4eHRwRENLS3ZUeW5QMzZSUWVVcWF1YTFLU2JiUzhSbldLKzlrZW5kalNjWU9SZEFwaENYWE42V3BxYSt4amprS0ZTSmFNV2xvZ3hMTWs3Vzhkd2htcnJHOXJiWVFiMm5jL2dpOTVBYStpZ1FadkpkN1lleGhvYlEwMDFmU0dHSzdyVGx2NE9md1BHMTNON1RZOFVSbEdGbm5BRTNIcjJicUNGU1FpeWpwRjZXMEtkRFBIYzJoS3pkaHhHcG1aUHNxT2hqUDNLaEJEaVgyZGtpUUQvQ3d5RGd4N2RneTBVcXVELzAyWm1ZV1dqTTlnNWRIMzk5eFVqVnB4NENid1MrU1R4UzVZaVZacDBHVEpseVpZalY1NThBVUVGQ2hVcFZxSlVtWElWS2xXcFZxTlduUWFObWpScjBhcE5TTHNPbmJwMDZ4SFdUMzhERERUSVlFTU1OY3h3STR3MHltaGpuTFBlQmdkdHM5VTZqempyQms5NXdvM0dHbWUzOFo0eHdaT2U5b0puUGVkNVg1bm9GUzk2eVUwbStkRWVyM3ZWYXliN3huZTJtR3FLYVdhWWJxYlRacGxqOWw5cEMvQWx1ZEFpWDF0c3FTV1dXV0c1dTUyeHlrcXJyZkd0Ny9WNkk0UUMzT3lXZ0NpaWhESXFxQ0pIRTl6cXRrVERuZTV5dXp0c2NpMHhhSUVmUE9paFdORVdQVWJzY2NRWlY2TGlYclhmRWVvRDIrc2JudDcvVUFzYUNCYXIzdndPYmdnc04wbXJ1YjIvcjZielBHZ2o2dng3ejlsR3ZvSlNLWlpxQ1FkZ01CcHNBRzJxaXRKYVRwYVMzd1AzT3lJYWIyNkdwZXE3KzVKV1I1K3ZlelFvT1gxZlJwVVBQY1JrSFMxMm5VTDVDTnMyTUxKZURUVWRWVWJ2bm5meEdmTWFPbHEyK3FJK2VoZHl4clQzQWFIMzhPUmxUWkN3bmRmZVRPU2lGbmxrQXZMWmIwUUlHZFdjTjgwSVZHZ0ZsN29yWjMrZ0dpRFZJbFZCWVJWb2VMM0V6WmNPUGkwM1AxcFVMOVVwVjRZTDRXb2QvYXAvY0ZtNzFxL3RyQldCV3NaNzVQL1FhNzd1ZGUyMGZiTlh2eDVvT0JjPSlcXHJcXG4gICAgZm9ybWF0KCd3b2ZmMicpO1xcclxcbiAgZm9udC13ZWlnaHQ6IDUwMDtcXHJcXG4gIGZvbnQtc3R5bGU6IG5vcm1hbDtcXHJcXG59XFxyXFxuXFxyXFxuQGZvbnQtZmFjZSB7XFxyXFxuICBmb250LWZhbWlseTogJ0FmZm9nYXRvJztcXHJcXG4gIHNyYzogdXJsKGRhdGE6YXBwbGljYXRpb24vZm9udC13b2ZmMjtjaGFyc2V0PXV0Zi04O2Jhc2U2NCxkMDlHTWdBQkFBQUFBRG04QUJFQUFBQUFmdGdBQURsWUFBRUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBR2k0Ym5IZ2NnM1lHWUFDQlJBZzhDWm9XRVFnS2dhVjBnWkJRQzRNaUFBRTJBaVFEaGtBRUlBV0ZkQWVGUkF5QkRSdG9jU1hzMkN2aGRrQklEVmMxTDRwZzR5QVB3NVJHVVpzMHFUMW0vLzg1dVRGRXRCMHdxLzA5cHdRSFFtQ3NNcXBRa21IVlJBVnJRbDFZM25PMzA1NTlvR2czR0NzeWNPREEwODh5dmttRmIxSkRuY2w2K0plSzYyYjh1QnViZytkcTdCOW50S3JFWjJ4aWJRaG1KTlBMbEJ4ZmhNSDRuVnB4bXN4WFI0dm95SmZaM2N2b3RQTXpkb1RHUHNtMWdPWnNkazl6dWNoZHBDRklMNEtVMGhEY1Vob29vbldCMGxjenJFNWYxZVAvdjg3eXdudi9mOWxER3ZJQ2hyRUYxbmdDNU1yUkJCeHRHU3IzS0ZRMlc0YjRoLzNCTitlKy83MFFvaU9WQk5SMTZGQUZtZUcyYWRNbStBelFOb041SHFBVEt4R0pTRVZLb2lRa3pUa0JvMURCaE0zcXhZZUxMdWZxTTFJRG5mN1hDQVEySUlORUNrNkFjTUFwL3FUZGZERzhicThyNzZvMnZyK3gzZXZiZXV0bVpySlYzYkN1UjVPcmU3L1hNTy9ua3lwMmx4VVJ1RDZ1VWJFanpDVE9paC9UQVA4Q0FVMDFWWEpwaFhaQ1VDNjhaY3JoaHltVFc4T2V6RGUzZnlTNmxTYmVFaVdTVENOWk5McC9FNy94YmZPYlcyaExxU2dUVmpQckRSOEV5SUI2U3ZqOElXMVFlaXBxRjdXNmFuUmgyQUdyZXdFcVdOc09lT21VTENHSlArSitpRUdVT3N1S3hwSFBoRUhRQXplTmlxNTVDSEhOSzZVUHZIRUdaRHk3RjJaWnNxdlpObWxmUm4ydW13ZTd4VWtZWEpscTNmdnVCWlkyQWMveW5jRmJrL01rdm5QUlYvNCt5Qll6TzhEc0xCWUVka1VLWEhwQWh2WUVXb0dRWFFKU2dkSVp5clA0M2xIM3p1RkFnY2NqejNrZlh2VDZ5TmpNdVNUNk5EY3UvU0JNTG56b3YxOStzL3VxR1VJK05aOGdZeHdoUWFoTlRxUVowdGxMVXJ3L2hCUmxUT1ZYR0NRU1IySEpHbzN4cXlpVVJFaE1kRnBPMkFoVEVwdldYUVRiRDlQdjcyMjFBWjNUYzQ2NzY2c3RNclJTU0NHRmlLNGZYenVNVGMrajJnRUc2cVRTZU1aQUVFQzN1YnFaUkRDTzdQRXc4b2hIc2NjOGhqenVPWXdBbXFoU2ZOUXhuUU53WG52UndkdmdKQUxBSVg4anI3bnN3RzFRQVF3Z1RKNU9EQkRvYWMzL1NJd0lNQTFaWm9Pam5laDA1N3JZdFc0MjdVMi8remYrV01sUFBtSVNTVFF1QnBPUDN5d0JhWUl5aE0zWTcxNzNJU0lWU3k4alRDZnhrdm1JL0VSQnNqQVR1YThBa1pZVkRjNDJuRzRQMTJoa3hPdnZFa2pVYXNkK3pDYnR6ZEVxY0pGbWROck1wdTJIZHErUDM0ZUlCNkFwY25ScXVxQWhiVWFQeTlFU0lqRkphelFaYUdydUdLcW9vL3ExZGN4TEZQNnNjQk42Wk9sbDY3RHpBUVpXT0poQWd4U3dtU0ZWcWRocm5Dd2ljVHEwa1pDaXdXQ2k4UEpqcUtWelpPN3ByQmNMT3BHTTFRbXpreVRUcEhDSkdDYkZMUEZCTnJQRTBpeG9aVkVXcEhxZ0pieHpIb2dxNk9ONnBDQUE3eWJjRjRjUlNVY3FvOFVlaUxrYU5vRVk3RlMvNHZ1MWk2UXcwTThaaWNwSFJITlU2TktQUkh1TTZBS3ZjUTBQZGkvTTl5ODJEbjc4THpwcjkrRXQ5OXFnQjIxMHVQMzJjQmNHQk16MlNRbW9tUTJoRFJ0KzNjbCtWandvcE5taXdWYW5qbFdJbWN4dmpqNElLT0NWd2M0dDJrMDc0aDBHa1hGdWFJS3Nhdkx3eU9pMmJIbnYrcmE2cnhBbldBYlU5a01GQ3hjSXNCalM1TFRTTlBGZXkvcWdyYWZOV3lTRk10eUxWOVI5Z0xKeE1CcytWd3dRRlVQaVN1aksxSEZMU0VpenhYWkJCenBleUluT0VIZVBlMVJpSWEzSE1zdDJWVTJPWEN4UFpJNGsrVlUyVndFeVQ3cFkxUzZ1Q0NrV0s1R2dUS0p5c1FwSktxV3JrcXBhc2hvcGFxV3FrMDFDWkh1VkhPZ0k1RWl4bzZya2FNZGpKMWJaU1U2bE8wMnEweVU0dzVvVFNYQTFMMlNGalVRMGRQbTQ1R0RJd1pTYlJ5UXFVNDVJZnUzSzlhUlVLWklRakJNSkFURkxHa2d1TFZWRG0va01DMlRvcUhwMDYrSFJLME8vREFQeUdKUmhTTEpoZVN5MUowejdUUWVnY1IweU9mMXprak9keDNDQlN4Z3VkUVdQSzJsVHc5V3VaN2p4TXd3M3VZM0hIZTdrUVNhVGNjZ3dJODErMmQwcjFYMnllVUFPRDlwYllwR1Q1K3lUWkUvaGt3YWVjaUx3M1V2YXRtbkE2WDhVdndDVlhsVFlacmJzVlExNmowa2tQOVp6UDVWaEJ6ZVlhd2lDcDFUdDV2TkswSHYzN1ExdlU0M0h1U2dWdXYxNjQxTXBMUEMwdUh6MXhTUXQza00xa2ZSM05ScFZMTmZLeVRENCtIR2grZVJaNk9HRDhMak4vd3JUdFdnRHpKY2tXR2lJWXBFbERCTEw2OExyZzY1eXZTemk1cWpibmJLTks4Zmp5dlhrNm5sWW1oWnBXaVZvazJLK0JBdEVrbUlMcGVpeW1uYUp5ejRDTmtTRXV5V0xMQ1piQWl2Mm9DVmhDT2FVUXJCZ0ZRSUNuQ1EzOGs1NEw5aEdHT2Y5SWdjSDRjSmhSOWpKS1JLenVQWjhyamswWnIxZUUxTkU0MUUwYTd4akYrTmc0c2JBekg2Tnpxb3dZMktOZldBekd2WnhVQTVZQ0h3cFVQWmltQUJzaFlrY3dBUmJ6VW9PY0xNMVZyYkd4R2pKYk0rZ1NSZ21BTU93QXhoYTQ2WWNjSmVUNW03N1VEVXpGQTRrN09nbWlVSUFwWWVuQjhkcG0vU3gvdmlBU2hLUGg0d1dFN2Q2S0tpZ1Fod1JKaDdzS3Jlc3ptTUlrTTFXZlAzN2V6blJOYVpBWDRQNEQvYiszTDMrMjZ3ZUM0cDJEcEJwaTkzZ0VpZGxSUHg1eTFoTU5KTHQxeVM3NjY5Q1dtYWpKUndLQ1VjS1lGYlZPOW5NV01JYUdlRzhpTVhLcUxsUXdvZ3dETU93QmJJaUkyRzNURkFyMUVTeFFzcTFWWjA2RVNvS0Npb0tXcUdPME5GcW9VU0VZUmdaQlFVVkJRVUZGUlcyUWpJMFZMUlFyam43bnU1OW1Rbytta2MrL093MkMvRWpsUU9EcW85MDdHazk4WHpNUXRlcHM0V0xUdTNyMkxYbTJuVDBQV2szM1U3aEtjSVVjWXIwT1pseTdWVWJWNlBnMnM2MUl5aGVVRWs5clNUWDdnRVFHUWtnUXZEdEFwVnBhTnR1OGJYTzlVd1RKVWg3THkvdEZWWjBvNnZXd1pxbmcrQk5yMUZvM3FvRjZjakxwSU80KzMvZVF1SVdWS0RjS2tUMExCYkdaTHBuTU4zVG1CMFJQWWZwSkRwVFFKYW9KN0VoVDJDZEhzZVNIc1c2UElKMUlLS25zRTVFSXNxVXBWMS8zODV5elY2bGRKYzNmUlozZDFtaGMxL01HM09MQkh6UXVBSE5pdy9SZ1lxakFqaU4zM3ZSOFBzR1R4enVRaU5yTjFOSVZvZVNKZW5WWFlDTEFLRFhodzJ3YUlCd1h3Y3ZBVW1KSnYvVlBCYVJhcVZqM2VRV2R4ZzNhWStVb2lqOXUvaXNOQ3ZUQ2xzNVZwMTE5OXhNeVFETGFqY28wUm8rOE83NmR2RllBU3ZqbDNiOXVkZVdXK3Fzb3c3YmJxV3VsT1BEK2UyQmRsKzdxOTNlanJXWjcwOENTVklvVHU5V1c0Y0RmRktXSVdWM2Y2MHFLLy8xV1M2ZnNYb2JOZGlJQWhDRFlXVEF5Mzl3bnZTUzh1L253Tkk1RjRlNFF2NUxJRnY2cjRhSzExeG5Ub1JZVExUb3NBZGg5QTBKT0wydkdtckFBdnk1bzVnKzkzblI1bWcrb3B3Rm9XNDIvUkpFeGVXL2c3L3ZURlNaVzZSNzkvMWdLSXB0YWNFOFloVWxKdTNGWGdsK1RzQUsrVjlwQlZ1TEZ6R3RGL2FuZElYcjlTQ2FtU054TXlWNnd0S3NvUTZNUUdwcEFScnNBaVgxbE5VN0VTUGRHMUtvcUdCUnBLZkhnbGdiZEwyVFYxK0M4bXVqc0pkQWxNanVkTCt1ZTlrWFc5SjBHbUxuMHRTQ21oaW8zZ1dTdTJHeHZoVzFzZ0VPV1BWZ2xNRGtBMnBWRU55ZXlNK1YxbDRtU21sdjdBRnduSWtPNS8vRThEUWFsTjBZYmI4VmgvTHdodWdIOWNDUnZ5TzRnK1VNUTlBMlVFOWNmWVVvV3NRb1J4NVlZR1VpSGM5bHRPWlVDRVVwV0RRNC9QMEQ0eHdhWWZRRkl1ME1HQmxNN3Q1ZXkyZEJuSXJkRVpVMFF0RnlHZGNKMmhxNk1CeXdHVjhjNnB1VlZOdm9xR0FmanBTbXl3UEkvWkdFZnpTOGN1VHg1a21NeU45d053aWFpK1BsKzFERTk5Q3VwWHMrZXNiRlpkRnBlUG51UHVMRXVJSm45bEhnT3ZJRGR3MHBwSWVueTIwd25XeSs2QS9vU0NLTkZOU3RGc1Z6WVlybmhud211cXpmaXo3eGZ3ZGRFN0N2bzR0RW84NEpIZkI1UmhpblRFWnZ6Z0o0ZEVnaVVkK1RHQit2QndIV0N2am85NEV1OVJqUnJwNmFrdHc5SXVueDIraXVvK1hINTFYRkxLMzV6MnErWlExREZIaXFoaEVLZVlkWTBpQ1JkRWdsQ3Bsa1FDNlpVRWdES0tVaFZKTFZ2SVJpbnBmeS9lWDdvR2hKTHBOREtiSlhlNHI5N3IrcTYrSWM5LzlYOUJocjNIZlhjSUpaT0VYQkdRck9VYkJHd1FZRld4U1VLTmloNEFJbDNnUDdNUXFiUHBIR0hZUHU5Y0U0Y2pxSkFwcUd0NGh3TjN5L2ZFbDJBQ1lJWUV6VHRySmg1bzNDT1E1N2RqYzFqYmpiRnlNT1IrR2VEVTQvb0pMWnZ2Z1JlR3lyZHBKc2dWa0hOc2s3VGw4M0sveS9BQUN0aDdwZGpqRWEySmZrRE94amNyUlJvb1dWNHR0MFFYdHB2K0cxblFMRjYwdE52cUZvWVhRZGJXNFRrU25SL2p5Zk9WSFhtUkJtamxXVDFmZmxrUXpQMzhsNjMwSDR5UkVScmFWdGN0UEdhcGxqQ3V6bmUzZ2Vqd1ZvemNSSTFTdlo0RGNaWTFaMUduN3llblBxZm1wcE16ZWZSYnVHUks0Vnd6b3VOeXN5RlVYTVpHckp5S0V4THBRNjA0Sjl1MGh5U3NRc05xTDZjVW9La0NZZHAyMm5ISEpNdHBIMnNNV0lXVkR6SmFkZk1nTDFocVZ1eEJZMnhlU01ia2RRWWxITmsydjF3KzBiZW1LZ3dWTnJKSWpxL3ZaOThSdUx3eVkrQnVtUUJDNzB0cDRPaEtHYmpJSFFZbC9GWFFMMzQwREQveEhaRHFPZUYzWjE1TkxHTkF1U1VGcUgzcTBwOG13aDR1bC94T0g2eHpiOEhvdG9FVlM2bWQwTW5adGF3TDYxWlJ2REtyTC9EMjgrZGQzR2xWN0d5cC8xSnpYdjNsbmlwelVmbnFjVm9kWlc1c3AydlVqWmNpdUd6eXo0YWVsS2F2UnlUZUpvakcyREF6K3Z5N0JnWHF5L0NQNnJtRkNXT0VEeTB5ZnY2N1lUY3RTSzJRZGZOS095d2tENzhxQlV0YUp6NWtSZ3dQaFYwRGU1elI1cHpNLzVTczc3Nm56ZC9vdTZnSFlSWGxUYkwydmVSdmpWZFBDUEZDM0dPZkpBeWZ4MUhiOFJkcXk5ZmxQM0dvbldIR09TRUM5RG1KQ0FaSVZvdzVRa3BNc1FaaVI2Wi9GVG9FbGp6aVhreXhFNkxxQ3dweUFzdW9SU09jS3lDMUhwRDF1a0toRlFLME5ZbDRCR2hVaGdVeEphWlFqYkVuckhKbXgyZFltRVhqbkN2Z3Q5QUFSdzZCSkc1UWpITHBaTlVKVFIwNmVWQ01PRmU0WVJNZmM0RlJqbGkxdURabGpLdUZZeXNGNm9Hc1NOdTdoMVY5OEJYZUdlcmVBZ0EwY1o3ZlF0SHA3ZHc0dDdlSFVQYnd6QVpPQXVvejFRZkh5Nmp5LzM4ZTArZmhqQVZ3WitNa1ArK0JuMDZFeVYrM0pvb0VPSHVyTVMvSmRnRXg0SVZYWUlBRjRFZ0I0SFBBYjZXZUQrRWhCdkJMNFdRdTlCQXdBQVZ5WkV3R2pyM0dVS1dxMko5eGJlR2tKOUdwQzVlb1M4MXF0T1pwbGNSejBHalFMUmdleHVtS0ZNZ1dobHFMb0YxdDBjTlRxQkdGTS90NUtBWUFDNUNVTnYwSnRmRXBFanhCbnZ4SmdVejd5bVc4cGtyTS96K25LOUZWT1B6R25zVGlMWFhETTJ1S2Jic2ZmT1VOZVd0V1cyK0JPakZUTXpYN3V1YjExdXI0ZmhZQ1RlSnlaeFpzVmlaeHc2K1NDVkxHYnVPZmJkeUFrZHZvcGJYTTQ3dTZOZHp1ajVtbkplY0Q1eVNzWjJRcit3M0xJNjU5UVBuTitaeTR5TTFyQno2TnJ0Qm01bWpKc29FekdiaUJ4WC92cmpWODR4L0lQbHpLd1hZQ0I0a0ZDWHBTYkdYOVBBK0pnUThyMFBFUHFiYWVzem9vd3B4OVNrU1pseHFoUXNhZWZDUWtMNlhLNWN5a0xxbnBtRWY2ZlBtVi9kZzRQYmRVcktxUnlrakQrM3R2TllpbGZMY3FTNVNhYkdiVytGeFM1Yldndys0SGZwZEIvTEFWWTlVblRoeis4TDdKUHhkTTNRUGNjMXp6bVd3bUlqSUROdDE5UjMybzFKV01xcFZsTVZhdllvbnVRYUNtYVMrOTk0WS84a2J0YW1pVkpqenUzV2tJcFN1TlZZbHQ3TWFKaUF3TnpzSnhYSFF0WFFrbEllb1lZUDhCY1dRaWN4QmxCUVNwdXZQa3NjUENWUVlOcWxqbUFHSWVvdWFhcmQ5czdVdGxSVWZFditidG9iM25uSTVFMUxMNGRXQ1NPUXZuTW9PWTVaRFhDV1pqNk43ZGVzaTRCazJ6NHllTHhqNEwySnRYRVJubWhoUjlQeDZ3RWZqSkFqN0k5NXFlVnlxZC95V09GZEROYnNkNE1uOWVoTzhILy85Sy92b2p1SEpmTUYwVkRDWTRwSnQ2MHVOK0tPNUZXMSt2WmJpck1DLzE0dmN6U3M1ZTdYekNiRHhkWVVhZ1N0SDlDU3BlYjZxZkcvbWxDWjBBVE5HQmFMSitKSEVpcGx2L3dHY1dvMjA1TVd5bm1ZZ1ZhT0sxYzJ4bWJLWVVaQ3FZNGxheVhkbENZcVp4WTBXeHh0SlZkNTlMMTMyd0ttU3BBeWJnc0ViWkZKWnJaSGk3TkRmV2ZXSkVmVG9mcVlucklRaW5URGZnaGNLblJEMk12Zys3MmpYbVRFSE13U2grcWJIM1FuVEFYMVZPUFIvaUFvQmh5ZDBBVXBwUjVpWmRLUVYxa1N5aURzYWZCTjNOU1REZTc2SmU2REx2VS9EMEluMmd3MlRpWjlxcWVtb1NXT2tVOTNCSmVFWHNzKzQ5LzhHMWhia1ZWbkxzZlB6RHNzZkppZzRUWTVtUUhuZytxcGxKd0M2aEJHeDlqZTEyUjJqL2hndGpqeFFPSUlqV3JpdnFtdGZuelAyYlJIVnNqRmhobmxPTW1BNUw4SkRLdkpZNFlRSFdHVU1ralhBSTN5V0hwWWV4WjVET1ZXckJwemlWejh1OHVCK2VCcE0wMXJHKzh3VXQrTFNvcTZ2ekdNMzJzL3N2RUJicVdleXZEWmsvdXc1RWZ6cjJRSGVsVGZkOGZNRXAydUtsR1kxU08zT1l1eG1YV0NjdVRBUVBvY01CYkNqTlJCdWxzTkxFL2ZEakY0aFhPYVR4VXVEY3RFTmN6dEhpanU5a3pGMEVGQ0w1eFkzd2xucWNlMGUySUZxY3dmRVJtRVRRSWlzZTJqWVRUMGhtV2RWWDBORmhIUWhyQmJYNmR4NFdvbm9GSnpRZEZZKy9nK3ZITCtXa0lkTmJDcWcxVnJlcFZBY3hVZE5lbGlEQXZVZ2pUK0RBZFdWVEVBSHk3djJvNi9oTTdkSi96MEtXVllKb0tuUnVpTVE5Njk5M3FkWW91dnl1dkdlcHFOaEc1ZlBFbTViS2psSUZ2bllHRGNFMlZtMEw2UUIyUVhOLytPZERSSXZKL3M4cGo2bXJndlJ0UEtQWWsxTXpOcnd1NEtLM0xWNjdFTlhWTHo3MWpjclJ2YjdlZENQMTFwVEp5T3Z1Q2hPQ2xMNTBWMUxINW92aFVxdWtld29VZWdPSjZBWmoya09vYWFGYTFXTjBsRjJ5bHU3RStwZGpseHlHN0NBd3d4K3huMkk2ZlVyV3BYaVY4ODFDNVE0Z1NtMno0c3A5SFk5RFFyZHNTT2s5OURBNWZUSXpaV2c4RXQ4eWNMYldEYk1Sck5GaGZYUEtwY3FOcit5ZzdWSTFrcmlhem01dVQvaklGbTM4R2tHM0hlWTJNa3lmTVlLMi9rV1UyN3JGOWptZVVXSEs3RndEV0RwdVIxV1FtK1M0cmVkdWdTaVZsTTRmUmg1cjVPMVBJMlNwclovTGtXMjJjWHhXQkxqOU05UlMwODZUTlFNakxSSG9MVCtVUVVvcEdFdDdWSlE4ZFhEZmttTnNjYkExK0gyZlJzc2JVODFSV21nSzFleUNUTFBHU1NsRFB6bkVoQ0g1Z014cUg4WHN1MVM0Y21kc0hINHllWGJKVWFLZFd0WEVMdUorY0JDak9DTkswaHVsM3kyaHU2dG4zLzlUZGZiNi9UcGZmeFlaNnN5S0tqL3A4UW5oMmd2V0NmYUJqNExWaUNyZ3hDYnRXL2RQd2I3RDFha3ZibWhWSkFxZlBZVjB2dHBQd3RwdjJlbnBielRqajBTUzZoL0RBaEVKYklPbGlYZHdvTjdpMjVUTnZ0TGU2Y1lvdzRCK2xHNTUyTXQvenZWT1lEb2ZtVHJCdllsOTU0ZGV1RkhubjV6ZGRmMnROQSt4cFhvOWZzTHhtTzBmbFFpU0E4K3pQMmVLNUgvOW9qRlh0bm5icEhaUi82WnBCdFVGa3k3Wnk1QkhiMnUwaGh6UzFZZ1U0RCttSnN4WEljQW5ZdjI4WU14cDM4eUNpTXpqeTJvWjIyRzFxRlZZMHdHamtPdTZsZkhZaEVxYU5CQWFPa3kzUFV5aHVtOS92VENsZ3BiYVR6dHpDVHMrbUdFeWYvU2tkWjZOeVFzMDVkbERwcEhIT1JoTThkL1V2Z1l2ZHZra0QyVUswcnUyRnZJWEhCVkdtWEM2TzRUZ3pQWTBPenM5SGJUN2x4Z3liaVhjZFpWUENUR1puSUFtL1hqbXV6T2VXM0ZDaUdHV2hHaTk2ZjdDSUlMeHdvWGh0cXJSL0pxU05maHRuRjhqVWU2Zmt0c2NhOXRBcWZjNGU0UTRtWVp1TnBhMXJjWEgwMU01d25DMkZhMDVsUC9wMzhaeFZXU1ZCaGptTFVCRFgyeUVqelVaeGFpOUZnOEJobFBVWjFlOW42dFdwTXZtb0NlOVR2SHhSanN6RXN2dzNUZGJUcnlLbnVvOTBZbTUvbEh3OWl0Qm9tOWlpMlVjc3N3dVR5V3ljempqdVQ3cnZRaGE3Q0Z0QTVjWis0VUtPMm5GWnJWakR5MFlmdWVmaytoNlZnMUo3VFpzOXVpMUI0S0ljVWdDRzhIUFZjK2tPR2ZTMUs5ekJnaXdKV2k4N3lhSCtSVkpHZC9WVlc5czY3SDE5WVpvbU43dDF4MXFINGloUzFvVGFFbWpWbFpWMU56ZFR0L2VnZVhTM2c3MkpGL0hpV2REdVBRc2JzaEV6QmtmbWNIOWRsNkM5dFpFT3hhbmdDZDFvajlyRzREbzdPRmpBbHRqd1RqQnhvZlB3dnM1LzcwM3lYdVAzODkyalVWblJLWm12bWNCUkkvRzk5VG9Bb2Z5TVVWcndwOXdiVlBJUDBSbzFQY3AxdENLakJSSTVlY3NOWExiM0owMHFrVmZsbXVGTnc2bVZlRUhKaGlFN1YxVnBUby9iVWFKMlZvaHVrRDFJcCtycnl0RUY3eXVCNG1CUzk4cWZYZGg2Skhka1YzcVZtM0VsTWJSVjg3UU1MZndMWGNiN1BDUmZaQnZ6YWM1L1pNckNDSE9sUHh2bmxrcWczMmN2ZERYSjVhY01QU1p4STYrR1pYTWt1MU5QcC9QbXV1TCtlL2kyWHQrRzhOMzRBdlMzUzI5bDA3WVV6VlBqOTJUbDNpbnRRYTF0ckxTcWVsY2F3c0NuNHNrOTdaOWd1cTk1Ynl1ZTYzVnkrT21oL3B4MU42TTh2T28zQkZOOUoxbjNKZHZWMzMrdXlEYlQ3dFk4M00xdGlrT1pWMzBhdjFOWUt2ZGNQM21LU2FMVjZDczNJUGhRYUg5T0J6cHhXelA5OTBjVE9ocEtVaEZqa0p0Q1dnaTJSdCtnNGhIS0tpRlZaeVNzUlYvSzRsYkF5NTM1MVE4K0lad0d2T29tR1lSR0hYY0RtYjJ4Q3d5SjdzTUpwMWozV3hoMVhIZ3lnNTFBVURaUERzVll5Sk9KS0J0ZktZVkkwbXA2SFVUU3Exa3ptY014a3FwYUdlcmhuMDI1b1hoNGtMUThTekljRWNhRTVISFlPVHhqQzR1YndzaUorRlovckU3STRiVHdmMjVXK0FhbloySFVEUmRXU3FSYUJnT3Z6OGtRRmlRY2FVYkRRUEJZN2o4VXRZb1dwYVJJMHNzbGpmZm1ubDM1Mlc4SFVkMS8rK2VXZjNOWmtKVklGeGg3UGcrMWIzZGpBeUNoTXpTK0FPb2N3Q2ExQnA2clV3NlU1V01MMmgxMysybmlNYnlWOGx5cER1Tzl6Q0IyK09aL1l4Y2hVa0d6WFhvSXpOQ0pTdmF5RTBtS1FNOHJ3QmtzWWpvTzJpNWo0WUFMRWJWbWNyNmgwYlhHNXRucThuVys2OWY2NEtoV1Y2YnNZU3Q4ZnV0WFJlYnU3dStQMmNtZG4rR3ByOHpWb1ovejRjTnoyKzUra1VUVVN0aGUzR2lPVks3bVZzZVBVSmZnSlhrenlqUHpEMGc5cEdncG5DczYyTzN4cS9PRlNQOW5JRVBIMFppeit4K1h5dkpkeXN6N01WVUpEN2pmejVRWDV6T3dxU0VUMkR0QXVWMGE5S2Q3Q044OVlGckxrcVR2cGQxU0ZuREtqTmNXS3k1cFQxSGd3eE1neGRsbjBUQTFWRXpjUUwybFVLRWZyMWhzRzIvamlTK2VIeEZLcnlpU3BFenJpcE1RN04wTUhJZ2ZXZnhNSnNnT1FDT3ZlamRIOVRBOWk3S1lJNVYyZ1E2Nk0rcEErS05uTUtuT2ZKMHZUVjNRbmdjQlhtOTFJTnk1elBpMGNEN1MzLzlTams3VTJGeXVFcjdQWXNaV2xsUmc5R3YvNzBxKzVUOFNZMGZoME5tOTlTM1dia2F6SS81RHAyNVdOL1kveFRYTVBDL3hTWFQwZnUxekJUdzY5dDdqLzNVdU9CWFJMT0VKZ1JNRVZkSWhHajJuRGIrcDdYaStMMGFLd3BiU2xOT2JmTEhiWDQzcERqQjRDSHk4MzQ5OEZXdVVLNXoyS2FHdWRzdTBIdENWeXVwVm1WNG9yczdsY3hRY296bFU2bSs5amlxcFVFcWF2Z3FjdzdJdlNkRUFYQU9JTHY4VlROcENTZTQreUMyQ05MY3JTQVh1K0hRcUNpaC9ISVZWSWRxSTBEcS9jeEdLVm1yVDUybEtndkVkbjlPNWxHZmdSNDNpWjRpcWxtT1lkYUY3T1NxNG8vSVpJaVpIV2lMd0RRSk56YlZsK3ZGOFpMS09EeW1YYlNRS1ZmcGFUdzdRNGFBTG14SldOVjJQdTNCb1l5SDkxVFQxUEhOQkJURU1nUkE5SUtiU0VNdWo4S05TdUV3ZnFlVExNbjR4cmpKaWVZUmpzblluTVlJN1FCK250OVVMdzlpa2hDcXBkTlJwSzFKYTVJenMyM3FNcmRXb0ZkVFYxdXZkeTM1WHBxMm0zVVVUNkJ4L0dQanh1SG9ZRlA0STJmalFNUTUyLzlKM2krL0Rvd1BmSzd5TWpSTjN5ZzVnVzBHbmpZZyt3NmJtTmY3Q0w2cldBNFNiKzBaa2VpbzBORGxzc1Q5MTUrajdvU3NVbUhJd3BPcnBiZ09vNm5GdVo3U1NhajAyY295V2E0dERZZmhEeTdhNjYzelRJN0dlVDRDK2VDSG9saVZZbUl6U1h5cWtOT2hFdDlaT3Y0NENhU0VVVWhQelNHY3h4cm5taGlLVGgzVU5DdG9nS2FrNEF2bUtXdndSZXkvTDdpbVdpR3VsSW9MUy9Mbys0a3dtUDdTVG0xVGI2RlZ0cWhIeitjYU1wQWxQQ0NVcVBCUVcwQk91bm1NK3l0MzcrUzlmSnJXY0JuNHdkTENucGxFbkovN1ZYU3RuMTRyelVETkI3c3pDL2RTcFU1S2t2VXhrU2NVK2lDMDlBWko5L3U3TUFrV3cycW1OcWRqTTcxZXkyYWpQZ3UvSnJpOEl2TmIrazBzVmxTcFd1ZXBHSVcxa3BLRFkwT01EMTFLVzNjYmpUK095dUJJeTBTc3F0bHdpNTlWVXlLUlJ4WHlhVS9uNmFSRnFtTTVaSnBOT003YmpsUktuQnA4TEdWbkVJS2czM0FUbG1qSUx2TTRQM0F3akVWeGVZNFpnc0N1STNMRTFPSFZ0Q2J0Q01RMHltT3NpZUtBaUpNZUUzREtmMXZZUW9MbC9XYlVYM2djemZqd0YyTDMveng3VlFTdXhLRHhpdmd5cmZ3Skd1ZjZ4U1VIRFZIWFZjN1FNQm8rN0RQd3RVRjNPODYrSDRxN21zRTl3ZkV2Y3dpQzFuZVBDU015VFNudC9FZTBqMFVadithWWlQeGcvM2czRStrcTdrendOeFllMmo4U2plaVZ2VFVUQ0ZvRzRjaTRJNmdqMDV6a0R3NW16K0l1NzIrdGYwNnJJcFFRR2RXSWZrTTdVUXc5SFl0VWc4cUVNUTl3QW13bWZDRUc3MEwzOVdPQ2tsTlhwcVlDT3h0TmFrTGZiS3U5c3c5bjk4V2M2azVQOHBPMmNlcHBQZU4rTVl6QmZsSFF6RURaczljeTdiemFhNlI0WDlvdDVvZkZUZnp6cDk5ZG9Bb0s2N2hDOHhWdWh6b3VDcTdoUmtDbCtHN0JnbkwyNjZPTm0yOW9NK2tjcUY4Vjd1dU55bitFcjVWZDkwTE1Nd0pkNlVZektrS1FzanZMY2ZlWHZTUGVHWm1QejhJajc4MWdUTVBWczVPdzVISDc1NlRpTmNYOGN0NFhvWVdTSXZSSW9tLzg0UnZLdnVZV3JDQlFoUjNtczU4K2JaaUtGbDhhQ1Fjbk5HTHhGR3hUTG84WmpzMGtHZXNTUkVFTUdPUWg3Z1diTEhLWHc3b0NRU0p0akhMaVRCK25SNFE5VktGTERFY2pRelg4RDZZS25IMlJNRW9oS3dsMUhHczBwNTk4N0Joc2pFa0xHRU4xaWFqUmxPcFV1aVFyMUVLdTIvNnFBaldzdlpXY1hQK0xZbFpVaE9kWlY4cXpLek0xcS9lVGtqNCt0bitBMFh5bDhlN1YrQkU4N2NFeFR3cGpRNkZnSUZ0eGtBM0NFb3pLbEp0dlZaNGRaZW1lOEw2T3FBQW01d2gxcEFUTHhiWnVYNXdndkplVmxmRG9qL3ltRHZWem5kK2pWT3BDM0FsckM0SEdzRmcxZXlyb3hReThqNUExMzBEQ2I5d1R0RGdicmtWNkJzUkhxby84MTA1TkszWXBvVXE2V0ozYVJwc3Nhc3JacFdkcXZGc1RtZmw1SWxmYUdMVGMyWFdsdTdKMTFzYm1tKzdOczhMUmN2SlZuYVJrM21VVXM1bENtaDNESm10b3prbDRwbGRNeGs0ZHM5QW02MVVNeXQ4dkNGTkJQMkJiTnRIeDJMd2VQNW1QUzAyMWJiOHdZTTFiK1Q2T0p5UFR3ZTE0MG9qKy9lME0wOXlNa3YrN1NjUUxCOFNzQy9hdm44eXBlL2l1ZTlpZHZNUUJGT1o3TnVBeXl5MEw1dVIyTEtJWHNjc0lXK2N6RnlrWWJEMHk3ZzhmZG9lRnp4Ulh5Nll5WWpjell6L1dSRytvbDBNZndWTjdybjFhN2NBbFpaaDUrZVVaaVdWNUNHUEFxYjJCSndxdVFlTHRYT0V0WTg0ckpIY3BFbUQyNmJVK0MzbCtQZlUxb3JweWkraVRUMklDUU5ja2pMdnc5NGIrdmVNRGVaVllEcFFpTDJYU3pqRlJiNnMvZmNxWVZKWFVrcFo5SlR6cGRiMDROekhXY0Zlc3k4K2t6dVorOUViTnBxdHkxdVhsaDBXRFp2M2J6RjhRMmJlc0J2TDYyYWdscUFhVWYvUC9DRFNyUGJYRzZucHBibmZ6MndPdnFiNzhxdGE5UWltL0k1azdkOC8wVTI5OVNyaTM5N2dqeUl6aEoyOCtlUnl3RTdadnhtZGQzZzQ4b3doYThkVzg1VGE4WWVPeXR3NE40bjViMTBVYmNCUkt5ODkxMnBrSXJWcWFoTXpseHlTMjVhdGd5ZHUzZDRMSnFOM1BQSzNTZVNzaEtDQlE5d2tPdjd4aEgyUTlNUTRzMnMvWTFKdmRMaHhvZ0RyeTlEU1hxU3R6b01Ed3lIUWxLMm4vNnpSMDlBSHNVOWlWWitTWi9PNXlIN0hyUTlBVDZMWmlQL2FnUEdYeEtIRG1udnQ1Mkt4SlE5NVBsU3ZQZUc4MjU5cGpOOURhUWVHU3RZSW1FMU9JdjVPaE9panFOaEFnMnloN2l1UnJnQ2xCOWxiM2FTajVKVjVLUlBMKzl5S3lnYXNuMU1tWktQR0ovMmVWc0VUZjQ0WlZ0ZzI3R0xPOGVtZUVjdHFNZ1JjK3VycFRKTGlOL2t6bFFmSk03TXR1NGYrbGp2QUpzMlcybmtLYTc0Z0hxcE5GUElTN3JJdHMxNVYwWW00ZWEvdGlpWTBTNzlpcVF1WVBBWCtuckhKNmk2Tk1teDVjN0Z5QWliOFV4eEo3VWZWSE5GeWdzd0xqcnQvSVBhQUNSeWNPZVpGNkhDQkt2Y20rQjhQYjZkdVcyYmhjbVJGWndJeDNJem9aM0pEMHUvVDd1Wkowa2tYSldSbjl4T1ZmcUw5YWNLZ3RscFF0UDVLSGp0cVVkMFh6ZElHaS8wRWMzZ2QwNDhTQlEzUGxZRFNwTTY1UWJGRDlOOU16MmcwTFQ3bnlqeU5NT3V4TFVmVDdpb1o3OGxwajZkTTU0RnMzL1dMZnR6K0IrTWYxc0JZaENEN2tPanA5Q1kzaUxpMXYrZnA5RnZNZWp2MFdqZjB4SVQzR1FuRCtuQUlWMXB5RW83YXhFUlhzeXhzejVJQ0wrZnN5YUp0V0Z6VUZPc1ArcGdXZitEeE9uTS8vcVRtSCtDYWJwdFY3VTNyRUxVaXhJUFFmcnl2YzZjdk9mSER0VEllam41NjdURjhKOHFFTzZBR29GMnZmRzlmK1FrZ2QxemZEeGg3WW1LK0dkdkJGQkZRUlRhWFZEa1JyMENhREFvWnlIS2hTN1VvS2VUSGpxalB5RVZJNEdNR3BHTWxaR1N3cEtKMG10SG1weHAvZ3ZZU1A4eWdZNmZmeUVzaTZXa0lLV29yT2U1V1N3ajl5K0RSanJkTlEwaUxCOE1VYy96djQ3Yi9SUGFzbVdkNTVSVll5dHorNTVNbER3OStIWCtvNlhyaC80MzlQTlExZ0dVeXFPSzJ2NkZ1U0VGTnpXTVB1V1B3ZnlIWUxvcnVCM1NWMzMzK3plMnpKT2IrMXFPUnZPK205bit0dkxlOW5CVDVtcGM2NDdNazNnRW1oZkFQZEIrNTk0YkJqMTVtOG93TmhJckZWWUN3MTMrM0VUaTRUK1hjbVU0b3VhVU1PNEVZelYydWE5TmtpZXU1dWM2YnM0YVpienBJWHA1TWxLSGk5NVRlYUwzZEI1ZXVpTkhiUit4NHV6ejJXNFJYWDdlUjRhYjI5M3BVWTQ4czhJNnNzaUxzNVVhSWdxMW9YTEVFajFsTVFXYXRHc3I5SjZLcWpPZDVFWjNVWVpGbThvN3o3V0QzSEpuMnFMSWN0MnlhS3pZNkl5WWkyTGVLb281RXNVNjVYWGI2ejdpcE1QOEVwV0dWT3Jnb2pLZXFkUVEyNkRXTFhjYjBHZjZvMVpaeDQxRWl4U3pzR2lKbTdLR21JYmFMdTBzV3JTVUM3MCsvRnF2UkxrN2pjenZUaVpQdVpHOXAzSzBNNTF3SThxQkh1dWhIbkZuZDlMTlpodlJleXFjenJUL0c5MXVYR29Zakdrbi9oZzl0dXJoZ3VpMWcveWlsMk5GTDVIbzFTbW1hNk14YUJVUFR4bytIVnpwU3UrcG5PdE1KOVpBTzlwTFhUM2RpMWlxM0QxU1hEYk5aWDlQOVdCUGVncEg0SGlPL2s4M2ZLN2wvK2NOUnRlZmNPK09HVzhrNS9TWkx0N3ZqY0xGKy8rSHZONzNNVmthZVdxcThiZDNTK1pyRnR5WkJGUm9WMWNvOXlidHRucVNXM1UybnpnMWxGeXNvRVdiNUZ4ZnVxa0FlMmIzZVZoUHRFRXJOcFV2Vm0vQ2VIQTNXeGtWeTJVaFEwcjZUVm9FK1U0QUFvQUhEazBWRG0zNDRMb1lqcDNmQnFEbjlLeWZTWVZFKzNLZVdUK2V5WDcxVnVmeEhCSUhQRENCbm1iRUM5TXA2RTAzcHQ0czRCVkM2N3ZjSnRmSmx1enlKRlU4Q3oyOWFDVXFubGwwcEdySTRZeW5kaGZ3eEZJbUNYVFlvcWtFdE9sU1Z3Um9xOFdsMHZETC9BWEoveXdxNHVYdmtES1EyK1E2MlhwWkY2b3E3dXRGSVN0bFNlOUV5RURmSFFkYmxmYldQQUQ1TVhsWjNpZHZldG1uWlpmZnpya2xMOHVYei9oVXg0QTljMUExMEQ1emMzK0I4TU85QmxySjIrbzZYcHB0UXRLbW1ia2w1R1g1c3I5cDFTa2xsVE0rOTBDK0w5L0VCYStldDg2S1BvTlJ4eFBEVjBTblltUnNNbk5FSm1aWWRnN1B3bXlVQ1h3ckNZYWU5TUg0V0pISnlWaW9JNnpNODlQNEhsOGpYOFNTL29VTkRtT2VFSmczUEx2Y0cyZUllWVRNUyttd3VMbTB0cnFpdk9RejFxcHJKbmthQzI2RnNIZ2xxQ2tBSW5DSDVERmlIM29kVFJ6R3daT0NxWTI2Q3VwTHp3bHB6UysrbXE0N3VPakt6TFcyYmVQVldoOHAwcUhXWURLdVNoUW84aXo5YnpCcnhPWXlHdHdPNnBBUjY5N09ha0duQkhwQU1PVUpBbVFEaVMxQWNObFZYVURyTlhrZmFJV08vV2N0S3BPUkR3RGNDOGhEcmdkTzQyakY4emc4V21uNDI4eFBZcy9oNjYzdWpFS2toL2sxNnY2dXhxQk9SODdZMmlJZFhKQ0prUUI0V0JkcXZyQUJUK0V5NEFpNVltM0tPZzhpbVlkbXZSRlVCQkRpV3dCa0M4SExrV3YxUEh5M0wvR1ZBWld6b256QnZiM2xvbXUxV053SE9jeXZzKzd2eXBsY0hwTkg5ZXE4KzFXK2piMThuNTR2NmZpcEd0U01ieE1XUVdPSGlDSU53VXUyQ3Q2TXorNDdFMTlweklvcUJrQkdEODF5QURoWVBLSHIyYTNHMVY3NEQ4T2JhUWxOR0FIRXZ6S3duMkNFMWF5VEQvaGp2OG9TQ1BET3pMdGFDVUp0QTNUS2h6VUFBOWxYdEp5OG05R2VUQlBXZ0hXNEk5SjVwTmpZb3ZaTGtiWlNxRm4wczVMa3NJcmx1ZStrSWpMSThRVEpxUm5SNGtQczJCSWhmTnBBUFNtZXEwSWx3cVp0Qi9VNno5R1lEQkVNL0FLYnc3WGN6cC9LTENVRmJxWSt5a1JUbnFlTHBwTmFQQkFIVEVSNFc4UlpQbzRoY01uS2swL2NPU1FFeFd4OUFDbGRJa1NzSEZFVUFkRThtaFVaUWdUSmk0TjJ6cWk1bjhWSUlRNElrWXBKR0E4TU9ZOERNc3VkZTdFb3k4VnBjZHoyWlZmS2RkOHEvS3duUmdZSElVQUVKL20xeHdTclZUS3pKZ21RTkVrOXFSQWphdExXSkgwRS80Zm0vYjgreDBpUGdHVnl5eFZRcUhRVnRuK1h4RmRxaEpGQTBwdnZRK0dVcU5YWU8wQUlIQ0NnRVpNVmdSVS8yNVRWWk5uVzdjcm9taWVMeVpYenpqT0phRk9sMndza1hpUWxjNWhmblo2LzZpMDJXYzB6RmFFYUUxSWZZWnVuU0lTWVhLNG81Y1N0Vlk1Rk5mWkUwR3F1aldBWkovUFpUbUxBTUlvNnQ3ZFNyWkdYUzVRc1B5OUZ1VGJyVWVKOSs5ZnZ2NUt0OXVrcGFydmVDbXBoTVJSbVFVQXhTNlJnMEVoZVdMN1FWSmVKMWVQUE5Nd0NncENoM0tFdlE5eUxUSVFzejNnb0FuOCtMZXF5emhJL0QvSTNZa2psbEhXZXNXV0lBakdveDQ0ZHFpMjhMUFJPNDdMcWFwOFFrYVpvNWFSaVo5blpkYys1VUI4a2xnaVo1bWRKZXFJZmxoZHpzT3ozNlZKSW9vNUptQkx6RVRGWTZKQjhmNUtvYk1sU0hnNThxaFhldGRiTXNTWnpaVUhISERNeFoxVy9nNUR4MkU2c2dPblpIYmtGU3pnSTlZdzV0cW42SWFsS1VFUFR0eERSOHlnSFYzcE5tY1RTS2pSSXBxY2NLN0FTOTMzaGh5Wml6R1VIRjY4TjMvZGVPOFdtOVRkR3c4UnNtS1lPWU5qcmE1OE96elFiV3BBZHRhU2l4aUY0TEhTcWM4emNNdk1KTzREWU5Oc2ZMRXh0TFlFL2FNN2E1MEFjdUt0aXRSaGgyVjlCZ1YrOWl1N3ZLZ1lOaTBQbnliMjlGNFVxb1JuV3I3QXMyUENVbDUvYXJhU2JHaFR2MnJ0RWNMTVNKRkNiR1VhYlJDdjBwS2F4eitIaDhGVVJ3YXIvT2t0MUJkeGVTQlZ2QWtqcmM2eXdsSDNiazJvRTFDbGcwM1V1Q2pHK24yWTRpajFIQUQrb1EzdHNVSkIyVUZvSjhLdkNSUEZUb1BNblI3VmJFdFFMY05BWTg4bWVEWnN6d2NLUDgrQk9hSGtjOXYyMmlpRktZWUU3dGhhOXZLaVIwSldjZ1VscXV3WkR4c1pITFZYbXg1YTJlMmx1R21ybzMrSkJxZXNHM0dSQTFQUFRaU0hnODhDbnJNbWFwSHFMYlgyTDJDeGZNaTlOTkVCeWdGWUtBUUJsUUJYWTN3WEN3M3RWMXYyaWo5MzNzZUNEWDcxNlBYODEycTVqSGE0V29VRnZRZ1lOSVY5aXBtQWFuQVZZMjhla1pYZXFxZ0E5alp5RnBKTVBZYTJtM0pVZEtJczJsTTFjL3d1eTdTYlFBL3RrS09wS1RxRDdLQUo0UXh6VFdGNVZUUFNKWG5mQUFrdmhVVy83VCtPSmlPUlVaTWQwY0VoY1p4SnZZTm5XVmxmMEhmV2RyNGY0RzJpTktKS1YvbEJnTm1oWGlSUlFvZEV6Q0V0Vm5mQWpmMUYrR0FMaE9Ld1FJSkN0VHUyV1p4eHBJb2RNZ2tydWlHaWJXeEwyT1pCUFhlcTRSSWEwam1RMDBlZkgwM01hTWszVk0zcVZHTG1LRG9rdEpYZmRvVlIvcW9nU0pnWCtnc1JtdkdzVndVRCtSN0tJOUp2V3lUM3JRUVNkancxV3pzTUR5YXhBQVZNTDhERFFQeWJUWStqQ0xaZzNxUk16VThMdmZ2YjRGYVZnMXFrR2FmS0VsWjcyQXR1a1RRUHQ4L0d2YmJ1TURtTjJqYVNtU0VhdUJSMHpFVWMvd29LUURyS25NeXh1N3h0aDlva3lKVFQwM0R0WWRpVnhwcDI1ZXBwaVlaT2U0MWovS2RnSU1SMHJYUVFYeXVtUUxnMW1BaEZrNlRJZzY2RWZ2Wkx5empYekFMeVMxSlhLRDNMM3pRais4NWh5aUErb09HdG9Yc1gyazhZODlRTG5HcGNpYnI2WlkvOWxjR1lmcVZJcnpCdzNDUVRMT0pXeUxGN3NTRjdVbURjaURJSTZzT2haNWVDbjFmaG9SYUUwNndGLzkzcENMTjFYcFcvb1l3TDZDMUEyRlRwUjYxVVVUYUt4Q0xkaXJPOUUrczZzUStpZ2kwRGdHSzFZMEFZQ0lFMkFMdm9DVG1nYVRYUTN3MnJ2UUVUd21lb2lzblVUaW85QlBiVzluN3BPRStvZ09NLytPWlpZdEd1cDl6R1luWjNXV0VzV0FCMFZ4TE1qUkNabUg2TGhtbGdOV05TQkdFL3dwOVUxVjFFR2FTcXZuUnFPSEVGeS9uMjFpaXBGMWI2NGsvcHE5ZFhzU1NxbUVxc0xJTkhGY2wrY3dMY1ZDUitoNkVnMWdqR0lGVXM4RVdxUkR0TThWOUU2eHJqV3RXMlRzSzVCNUNTaEVEci8vaUwra2hQckNVcHF3S0xNbVVSQmxqbFR5cjhRQnJoQkNDaW0ybVloK0J5QVJKc21maXY0a1dGdi9abHVVYWlKbHFMZnZFdnhQd2owd0FiQ1dFZ2JRSzkwSStLTDZtSWk2alBtMEFCc0x0M21GT0RRZ2s4eW9vL05QV3oySHNzclNIL2UyNmFtdUlDWWhKWnkwZnhESlBaT0l1dEdBSGJvcklQOXNRTEptU0p0VXFIclNsYXhZRHZGWFFhVUJuVDhBR2s2QXhYbTNUSTFRVUtiWHY4QUhaY3Zpam1HaGtXVzdzd1dsSVhtZkpPdTdaSGRrbStzMnBMT1BGdVZhdGFPQnFKeElqTkdJcTVGZEYzVTNxZFFMU2ltYmpZMllRZHdTSVNRL1AzNXFZamFWa1JhMk9OU3U3cUdCQjJIQWxRdkpjUlhFaXBidTJxeVN6QWVObWk5aVFOZjdFZTQ4NGhTK25pL3JFakdXMEVyK1RhMWVBRFFBcG9hZ21WdXlvTFZwVTRsSnIwcExSZ1VaOXo4L0RMbEhKZytwNC96Y2RzdkpKL3djUnJEdzhGVGFUM2pESzArSC92YmF6V2V2V3BaTFJSYVg2dTNXU05kZjYzTExPejRxRjBkcnF2NEY2bzJxQjl6MUp4WE9rMk5ONXRtaFRjMzl5WHExNHR1UGdOaVV4VTZtTXBnN3BuT0cxbFZSK2Rva1NLM2EvRFJtL3l1MUg2Vlo2eVhhb0V5WForaVVta2pqZjAvQitNeWlaUVBiZmlqbm1GLzJqTTVKSG5Ca3NjU3cyejF1Yy9ac3pJQWtBYnVLaHJDTFhZbHRaWXRwZlJscmNSS3dpZ0FFYmdTOE9CTTJNTHhYaWMvUDU5a1MwdmVBTVUwcm51U0QwaU5ZSkFrbzlUQ2dvWEpxWDRPOE1vOEFSQ1VqNzdBODRwQ0hmYmxzbXdzaVViSXRBc09wajJUS2tHU0QxaWRmc2tMY25tY1dldVJyV1Q2cDZ6eEQvYVNKWnI0NUxrc1JtbnRMUmVHUFd3SlAwSHFKekxkaTNXTHRiUTZwRVlNcHowem5FQ3FBSW8yNFlFNmE0SGJwWmF4VDZZSG9JY1JNNUdPZkNnUmJ0YURhUWJtNThWaWhiaDJOWkxwWjAvSTE5S1BrRjdEQ0pxdENjWHRwREZzSU5FSWFzNVlDTURxalo2eUY2cjB2akVSY2FlK1NpY0xzSy9QYlYvbVNUU1RYblZVTFpQeklsUzZSa3RYbGhqT212K0RMbVlUcmNXYlI2MjJOL0pXQTZXSGlPRkM0aE5WWTRpaUV0MlZBNkw3N1NWazBJcm5iakJZc0tDV1hVMUx0Y2RFTEZ5QUxRV1FNU2gxYW9vZFkxZFFPc3k0OCtyVVlFcjNERWJIVDFkMU92VTljSHAzZXRzZis4TnVpelhXVWpaQlc0LzgzVm1ybGlUak9hV1NkN1JRS28zYmdTWWZReFVEa3R2TkRWZ3A3cVdiUlRKakpMTFYzMXNBWjV3MFNTeUNyb1BTYWMrbFk3UjBoS3ptbFRSRTRTQ21EcHg0M3FNNGxrV2VKbEVZK0RZL1lSeVhOc20vMmFkZk5YUDVXU1JGSzBDd1Rrc2JCMjA3UU4wQjAzWHFDRm5QUW1UR1p2SWNNeG5waHYzLzB3VzFwcGpNcmM1SkhPbmlZNGVjaGJYc0F2clNDbndjZlRvTWR5L1pyV2hqa2M3a1BIUUpwQXNrNG1NVVM4MER3MTQyRUU4YnB5dTA0ZUplOXJDTWVhS0c0czQwWHEwamRGb3JucWg5Uk4wcHdVQXZMZHVKNWl6N1B0V2loZlQvR3c2dy9qOEVvbklUeno1U3M2T1ZTOVhhMWJtWFJZMWVjeGR1VmkwaE5COXg2UzY4YXAzTy9PRHphUEZ3R3l0NTR6MVdEWlpKck9QQXgyWFJ0Wm5XVnJmUnB1Q202cGpMWU5ucENRMjJxVEZaS3pPcWZUUWgwTFhUTVFvVVFWZDdSZnRYcjBuRWY0d2JxbHNWOG9DRUI3MGpkMEZET3JJYTVvS0prcnNpVmEwdFdyMlBGZ0FadlVQVmJ4allqYWxaYmtGcmw3VmRoNnE2bnlKL0xQT3VBeDYzNDc3YmRQMXFDUW5aZEUwaFdJTC93clltS0FxcWFvUkVIMHNkRHNOTm9YZmZGUHlQRFpHQmxSNmYyYU50N0tRdWVQVExPakxOWDFhRFQ5S2tXMUVsWW1TbXIrWG1RYkNoMU9lUHRwNm4zeGxQbkFWZ3JpSzA2ZVo0OFBQSDhkWTlHYU1SdlhjbDV6VlhRVWExcnM4c0owWHFQaUtrR1R4Zmg3WnpWYTk4bW5rSFNYRFFCVDFrbkxuUVNFVmNUSHFOeWJ3K3pjNnlyTnFGckJGbmpDcG4xeVpXSVF6aytQaXA2SGlVOHZqdStQWitsUWU1NzFlQkdJdzJ6UDFsSEdsUlhtQkpEWmxvZkZDaWNJa1c1RkxjVVlxcE5HTzV0SXJKcTRWc203bncyNDRIZkMvbXJONE8zd2w4WlhMbk9DaHhPWGQ2MDNXaXZmaWkxYkRHMFhScm0wMmhGblBaOTRxbnZ6THRJRmhOSlZhbzFWZllOelVleFVaMzZIUWFScUZNOGxRck0wMVdEZ3dBenA3cEFDMWJhdlBUY0tTYTE4UDB1ZkF3ejEwRThFZVQ0TFFkVmlmeFBxV1YvUldkNVMyVVVrRFlmaDlWSG8rQUlBdnN0OHVGYk1abDdQazRUT21EbXU1RjFpUCttZThrclFCSlVvUTBDa1NMT3FFOWpiSWJTcDZDNGlqc2FrRHVyOE5rYUhHUnZVTTFvSlQxR1F6UEJ5SExoQktZRmgzb1VUTWdnSjl2Y2hUVlN4VUVvTWgvM2hINU5QVktmcXZNWHJZRDhNcERtMjhDd0ZzYmV4NzRmeWVsODhoaUJLZ1lBQkFJSjhCWkd5QjhFb0hpQk1qbWZ3Y3Y1Zy9MQWFBOWdkWUErRVpaVHFWUG92emVNbS9hQlNZdTZoNytwTXRKT21mMnFaMUM5WFl5YzVsMno0dWtpRDQ2OGxQRm4zM3k4NkE1K1VGV0hwYWZGNFZ5bHF4OEtEK3ZpUGhlb1IrWmVWLzFlTlhuZmZXNWxyWmNwM3lDWm8wZGlTbFFNR2tTK1ZBaTF5UkdwR0F5SkpJaW1TN21lQ1d5SkRGWEpFWXBNVEx4dkNjeFluUHpsMFNlTlM4WGNVeFkxUWpRWm9ablNubnlIamtmaWFkS2V6ajltVVJzMGpUUGZaMzVsWlZQVkdlM1VENWw1UzNabWNQS2wyYm5TOVYrRXZkUFQvZXM2dmhVelhPcTg2WHF2Q09rYzBQK2pKVUdGYm1TbFJaWitVSkpwc216bHBaM3VmS2hrdHdzbGcyeVVtNVpnbkluS01mL2F2S2tuRHdsa0xmSXkyT1daQjlQTm9xN1NUQ1Q4akZKKzJ3L1dRS254K1JERlFHd1U3b0xDa29yalVPZWk5SEkwTGRlL2RSUnBBTW85UDlCY3RZZ2dVczZFVnNhaGJBaTBpRXEvZFF4d1N2U1h5eTczcWRteTVFZ1pUenE4d0VYVms0Z1lMOGgvazdNekpxTEpES3BhTmtpdnZoRXd0QUdLVzBIcXRML2Y0VXZTbE5LZEQ2clNYbmFwLytHVkZEUmE3SzhLamZqTWpNdTJ3ZThjNmZNT1ZQMjVBcU9SeUwvQ0UwOXkwL2lpOEVhQ2FGWnhwcVBoYVpQNFRRb1ZMM2txNW1RaWljQklRUjQwUUthUmlJV1Z1SXN3TEdKRVJIQUgyZktZVG5TWUlBNGxIOTdtYUxGS3doSWVrVU9hMUNTeDdMbE9xK043bWl2enVsMHI1dnEwcU0yaUs0bG9CVTJBQ051QkM4Snh1bGx6dVI1QmZHVWEySmMzcUJKa0kvUGxxWFhKcEFydmJxTVRIdmQzSG4ra3d4cTNpOS9ZcGg1eC9SZmRTQ2ZDMjkzZHE3NWJhdThxVmMvck56L05lTlRtb0lieGphdVBuanM5MXV5TDBiZHB5Z1dqNWZXdkU5M3FHYVdOTTk1algxUUtrVjAxRUUrSjg0WUlWYzNHc0FueXhjZ1dvelo3Z2dIMm15alRRNW11WU9sV0Z5Uk1wWTFqbUJwZzNhc1pla3M1MXBqbmZWR2pJaXhORjFrVzhYMWcyNW82eWRjLzVmeG9kWmJKNmJKQmh1TTJXaTFnNDJ4TkJzellwMCs2MjEwaUJHckhhaElURnhjcVJxRE9nenJVbE93ZUY2R21mcFEzVi9ySUp1TjJjYXFOTE91NkljZFRCUXowc0VKUjYydkk3QnFzZjIzbW9vb0ZucnhReVA5bng3NVE2U3kwZGpwSEp4YzNBd21EKytudFYxdzZUSmt5aktiSlNRc0lpcGJqbHg1NXNnM1Y0RjVZZ3JGOU45QXNSS2x5cFNyVUtsS3RScTE2dFJyMEtoSnMxWnRFdVpydDBCU2gwNExkZW5XbzFlZmZnTUdEUm0yeUdKTExMWE1jaXVzdE1wcU56blpLUzUxbGpPZDVCRTN1c2RUbmpCdWpiWE90ODR6MW52UzAxN3dyT2M4N3lzYnZPSkZMNW13MFk4dThMcFh2V2FUYjN6bkRGdHN0dFdvRWR0Y2I4d0J0aTlFSElMYjZLRU84N1hESGVrSVJ6bkcwZmE2d1hHT2Rid1RmT3Q3TTk3SUdoSXdhU29BU1NTVFFpclpTQ003cHUzSVd1eTJ4MDY3bk9hdUpKRVRQM2pRUTBrbWQ0eVk4Y1FiWC95WmxVQUdwd0dkL3M0dzBOWi9mVmlrbzVuTjVZa1F2OGg0ZE9EbkFYY2g2aHNpNFF1YXpYa2NSUnpjbk9hNFkvRFBaSkdrSkthdUFwdFhCbnd2TGh2UnpQeWtneFNudzRTSUdyeGdVK3lURVh4ejBSYjN3VWJYblZIZVAyRXN1UEozRUpFUEhxUWJWWDNVWWFob2EvODdZczJyUjFkK2RPSERQblBhUVlIUnphaUd2YUdwc2RWdEI2dDFsOGMybkI4Sk9sN0hreWYvZllxZzU1NDFTVzl5bStmR0tTaEh2SmhHeUFmZEwrbHdVbGZLL2ZKdzlZZzNCUVZpWTdESnlLMURXbCtJMHVrbkxacHNQSDBSZzEvS1NaaFJoOUdLczcxMllORnNrcnpPdE1NSkp6My9kYklhZXo0V1h0Qk4zNWNrL3lwSTYxRUFBQUE9KVxcclxcbiAgICBmb3JtYXQoJ3dvZmYyJyk7XFxyXFxuICBmb250LXdlaWdodDogYm9sZDtcXHJcXG4gIGZvbnQtc3R5bGU6IG5vcm1hbDtcXHJcXG59XFxyXFxuXFxyXFxuQGZvbnQtZmFjZSB7XFxyXFxuICBmb250LWZhbWlseTogJ0FmZm9nYXRvJztcXHJcXG4gIHNyYzogdXJsKGRhdGE6YXBwbGljYXRpb24vZm9udC13b2ZmMjtjaGFyc2V0PXV0Zi04O2Jhc2U2NCxkMDlHTWdBQkFBQUFBRGdZQUJFQUFBQUFlcXdBQURlMUFBRUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBR2k0Ym5IZ2NnM1lHWUFDQlJBZzhDWm9XRVFnS2daNG9nWWdrQzRNZ0FBRTJBaVFEaGp3RUlBV0ZJd2VGT1F5QkRSdmNiRFhzbUNYaWRnQWw0VlZSUGpJUWJCd0VFUDRyakNLUEE5blU2dXovLzV6Y2tDRllvV3lXcjhmSzVQSXk5aUlYa2xxVTZOU054MWd6WktNMUdLK0s4amZodnZBN2VQaXJEYkZacEVDaWhKR3hUL3JUWnJHaU9ySWpuLzcrU05RWlN0R3JLRFBEMXFFU3JDQ1B6WUlpeFhPWmRWNkpyUGhQT2s4bEZkcEZ5dzF2TnhhMVVWRmJpY0ZUK0lJdmRhUG9nYUk4UW1PZjVGbzh1Zm16N3dySGNjQWRJR0xOaVZnYUlqYnN4TkpRZzYwa2tVUnNLZmhyNitydjV1ZlgyczcrZjYzUHFycjNQdWpocFZrQWpDYnVQMEdZMDZIWmpnUWlSK2pRN1ltS1MyeU1qU1VaUmZ6enNEK2VmdTF6M3loQnJKT0VSSVVNWnpEa2NhaHdTQk1iOVA4Wm9HMEd6REZkQ2FnelpoMUlIY2NWRlI0Y1lISFFBbWIrZEc2dWpLMTErMWg4NjZMQ1JicXE4dmRWOFB3MzEzdmYwQUltV1o0bC9nVkFsVjlXMDdMd1BiN0dzR1ZaNFdwa0pRcUhObE56byswNktXMjBTS1lFcnBPOW16VzFOc1hNWHYvWHJmL3VRQVlOVEJJZ21BZWJZWjc1eVlwSTYzMWwvM3RYYmxXdWxicC9xU2docEdhVkMzdnNBSDF3U0k4K3dsMVFlbFRVS2NxTXVtcmxjSUxqQXFBTWJpVklvVWZ3Lzh1cC9iR0xmK3dTeFFFQUIwa2xHR2xzSzQyMzZIMHZ4eVdTcnZhMVNDRW9nUjBteVNwd2R2bTRFTUxhZHUrR3k4QkxYSXFVVUxISzFuYmZITE5CcG1aZnBwT0lyc3RST2EwY2twQXNRNEY1V3k2SG9vQVE4dmxmKzFaNTUrNnMrR1UrVWszU2hJeTAxWkN3RXI2OC8zZUh5ME44R014M2ZWaTBybG5jekNFVVNHNGhiaVJheUhnTjlNci9iN3JQWGNkM256U1FOMFRjYlpKajZEZkcxbFdxdG5YMTlONmIwY3diYVJBelJBMHJpMkhoZ0lUL0Z4cjRIdUREVVdJdDJKUlluT09tek5kUGhCL0JLZWVpQ3lIVkxpcTNaU3BkdEpYZHVSTllZSkZYV2l4WFhUV2ltNEVZRVFNaS83TnZyKzBXenRJNSs1VVlrVEFNS1lOdkVQSFo4bnVsM3UrbjljemlsbEtUS0hhUVFaQVpFTXQ5Zk4zbElJQkNmV3RHd0xrVnVkdkR5Q01leFR6bU1lUnh6MkVJSVBPcHdCNXM3eG1DN2VYWTNqdGh3d1BBSWYvSmwrSjc3b1FFWUFEQ2lOTURCdUFvdGRML2lCOFBjQmd4WmRiQmpuUzhVNTN0VWxkYjlhYmYvVnNydmNJS0VRZWVRR2FuY1VqaWxzd2pSYXAwWG10MnVjOXVoS2RqMG5iRUswRGc0cEZFNWFaSzVlSFZpZXhlZ0FnUGJCSjF0ckN2enlmeklLNTh5TzJoWDl4RlluNzZ2QjE1Yit3N29uWGgyaHJ1UW5oZnJuVTNkbnNBb2VtNUNZV0JCN0hObWx1cnAxcEt6ZnJNYVVJUnBqTU0xNHh1QWthL2R3RGpvdktPR2NaMWVLVHRTcWNleW43Nkpudmp5R0Rjbzk1aC9OaXJSVHVaVkdxNjJ6QVl0NkF2TVhGeFV4aW1LYkdHTHJvd3FaRWtmVlhDV0FnVXlUU3hrMmdpeTBpUUJKb2xrMGtSNXhUeE1rSEpBekZocFRiQXA3aUpKSXhIQUR5SmFGL2tSWVJzWVNUZlFOYmZUdWJEb0s5TjQ4bjNaOHhPQ29kbVp1TlRpUEFLVk9zemlQaTJneWg4RDZkbGJLZ0xzRStPS0t6Y3JiOVVQOWdPdjQwV3BaTVNxb3dlRDM1SmdHZzR6K2lUOHpNYU1veitaMm40SGN1SllMODcxeDFQNUVZYnh1OHdtR0tGNHB6TjBXTlZxM1RqZ2FvMEUrQ3pqZnpTb2xsM3RHSmJZc2FudGdIMUY0Y1ZvTExGYnNFL2lsOGY0cE1yVjc3R1RaaHVlYnNHVmZkOExkNkhCSTUzM21DL1Z4bi9mVjdHek1rSjhQRWpBZVVVbFJxbzJyVkxzV2hKcWowZExzdVJUaEJ3aTF1RU1GbE9FWk1UZzdKY2VaaDhrZ0lLQ29OTWtXS2toQXAvMENLZ0RBbVNLU2Vua3J3cU10VVVoS2lvb2FTV29qcWExRlBTUUxOMmtxVWcyZE1CeUlGa0RncVNneDJPT1RMSUhPVllpdU1vT1o2Y0V5UUhZVGpWOGtKa1lpWVNHUXFUMkdtbDBjcEJsWlBFUjRkY2trSWJTcEpVcUVBU0JBWWJCSERnSTBFVDBhNGxxR25UUWRORlRTVG90RUdVVXo4MWc5UU0wV21ZbWhHS1J1azBLV2VjSW9jOVlFTUhpWUsrS0RqUmFSK0NaemlINWx3WGhCZXlvT1ppbDlOYytYTE5WYTdqZElNYk9ZbUp5SzJnWm8yeVhiUzRqNUxkTkh1QVZnL0s5Uk1MMFRndlBrbjBGTm8wYktxNDZ1WVBqblFXS2NEcGY1VjBQcnJBSWhKVjVURmcrMzNHSDZ5Y1RtV2R6Qi9halNiMHlhUHAwSjN0T0xyWDQ5TkcvUTcwS3VQVTBYU0J5MFdBVHU4WEM0eFVHWGVncXNCeCs2SDdNRncydzBiUi9aL2JIWlBJOC9IQXlSeGlGaHB3RkFiYi8yd1lSWXMyUUlkdW5GNGpUTVpNMEpLWUxtY21VMTNrY3BtSkcvbGNINW5qVnVaNm5IbWVYRFVmazZLRnNsWnkybWpTUVU0WFNUZVpYcHIwU2NvN3cvd0JITXpnd1YwdkdETk9OQUdadWdQWmNHbUk1UlE0Y1owQ0J3N01DQXJ6amx5TUEvSE9QQ3NyN285RDZJMjB5WGJKWEJ2bEtSaFlwSmgrWlZrZWhTeVpkMlJuSERpZ1FvTWo2UllXSmtHTUVzbnNBeVpHaHBJNEtQTG9CWktNeCsvSHdPQUJrNG1KNUtFRVpzdEs4bkN6WkZhV3pNU1FqU00rZ1N6QndPQUJBd09UaDBMSjNCUjUzQlFwdTFsSnBJb3hGS3dRWUlFaWtqREJBOU1jVmg1TzAwVU5zUDd0QU1YVVZoZ2Y2dmwrYVl1S2hmYldqcXI3ZnR2bU9HWHVxaEZsUUdVVHphZnY5THRMMHZoMjBZekVSdzdOZVhmYmxybTg0aC9OYkNhWDVNY3cvam94VHd6MDBHUnJ6MkkwZlJJTWRsN1lDNG1scGlYa2NoSm1md0I3RnhlNlVLVzZRaURCMnB5Yy9CbVZmaWdoT0FSQkVDUkxWaVFFQmtvSnFweWF5TXBKdVdheHNFQVVaR1FVWkRSZXlhYWp5ZzhsSElJZ0pHUmtGR1JrWkJRVVNEbkowS0NnY2JuUDJWUS9PdDc3ZENoK2Z6N3h2b2sySFlFSDFnL3BxSDFnWU5qVit2RHhsSTYrWjRZTHg1NFppT3pZMGpmTlBSbnRwSk1TVnNLVjhDWEN4MFNtbHhmbVlpaCtPYkYxTzRLWENLRVJyZWhlTXdvZ0lnUUFQQWdzNWtpOTRNSW9YdlMxaTFndlc5dzQ2ZUpIWEVJbVY5ZW5WYXBtZUNvMC8rQksvVXZxZ0Rtd2kwVHc1ZVFpZ1NvMStUWGRwZVN6R0MvR28zcm1CNlR0YVl4RnIrZUtuMXFnY1BESTVQTWtac1FUbUI2UFk3bzlpdW56Q0NhQzhKN0M5eE1CTDBPbVRvTk5Lek0wdWF6TVRab2ZlemZMR0dOS2c5dGl6elNYQU96T1VRSE5sNXVsMndTVEFFQ2dqbTN5amh0K2VMUVBZZm8xVE0xZFZ2bVI2NFdyZ0xNQW9GOG5BTkRKZ0hpNzRNSWhzU2R2K2JjMW40NG4yZXhRVjduR0RXNjE3RzRHblcxUVQ2cmlLcSthU2xTUDFWOTdIZjlUZ0M3bUNpdDQ0UFFHZEdjVlZkbHZ6dm9XbFNxV0sxV3ljS0gwaHZiRE81WlpZb0V1MDhTOHo0aWkvUERhbGlpWkFMQW5hQTBNM1RGb2FLWnk0ZDZrM1F2amlwOU95VG1pR01Td0Rnelkrd2ViczBmeC9xT3k0b1Q1cjNHT1BQeENadW0vRkFhb0pqSjIzaFBqUkl2ME94QVlRMDBDOVh4ZWt3RlQ4RUdiZlByWTVjZUVnOG1BWXFhZW5ObnBwelJTdk10akY0emUvTnJEcis0UGh3WkNyNFppMlpXbXpDZTVRR280SUFKVzZNRTB6SkZQVEF1U3RYZ1N1bDdJWTF5RnFqNEtvcGs1a3BzSkVkV1pXVTBPR0lDOHBTa284RmdwYUtDb3dYbHZwTHdtRC9IaU1TMUNHWEJKT3h0MmpkT0g0S0liNU5kRmJ1TUxyem1SOWIvbFJTK0I3b0Y4T3RGNDdOS3BxWmczTUh5dlhEaTU1TFlKWDFzQVRhdzZNSkNRcUpvb0lTQlVYeUlyNTBLcnpDZ0ttNW9tb0p2cEZrNys4YUUwR25nc25OdHhLL1pQTmllaE00MERCK0dSaHgyWmM0Y2hMTmV3ZFhJaFdzaGJ4Q0JuRjVoQ1pTSU56dFhVVHhnR2FBZzVrOVN2L3B4WWlqYlI5d0ZRa0NHRlNqTjNaeG0xTS9WT3ZEM3kzR05GWWEyTU13KzZhdHBnVkNDbWNMZG9jRXBxTUZwL3dBQlkzVFh0QUZWMWVQQ1BEMVhPTHI0Y3dJZzhyZHFLU09aU3NYZXVoYS83ZHVmK0hvMThWN1hUbVNlNmQzYlI1THp4T2UvWmdRSzdlcUhhaDFHa0l0RHVKazJTV1NqS0pWZzlwSDBCT2ZPaUtNNU4za0krRVUxMmJMeThVYjdDTGd1eFlNZXUwNDBLUjdRaW1NbWpwMkswdDJRQnpwVStpVVJqUnpGZWZSUTRzVkNFNmVkS3V3WU1hTkZBV1VsNVFDUVZ2N1d0UlpuaE91VHBmMGRQZVVKMWN0dHF1bERnckdvbW9kQWJjbU9Ha2pHSFBKaEhLVmhBcVZoRWFkaUUwckdFTXJBNVhnQ0J2Q3pGZk85Y0JRM3BjM1FRWFZwNHBOTHQvemwwVVdXdS8vYzZuWWtGNXQ0M1dBZVpvSU5BRmdoNFFTQWJCSHdna0FNQ3VTQ1FCd0w1SU4zRlFHdWlxQ1FqVXN2UmExNzA5RWpIblNpMlU0OGZMSEdXYk9TQnBRQkdoUWZRa2JRdVpGaDhwbkE5UndINWZQMjB6OUpORWVMZVFKK1lkSG9aS01VZDZ3NENMMFhWeXA5Y0RGa0ROc2tiTG5ob1ViaC9BWGp3cmF5WFlPd2x1MFlxZ0JhanpyWVRMWXJvVzZrU3pmVzJabFUrQXBJTjN2VldvN0N3ZnhlTmpCSFpZNkp2SjU4NDBwaE0wTEVqVmErR3JpcXl0L3FJRFE2QmNGTkZFMjh0eXpNM3pheG0yYTlBbTBQbHc2bHBSbE9QUTE0REY1bkVOR0o0dzdmNmsxMHNyOTJRVE10VEN5aWFrb2ljelJtVm9iMUlucTRvSXBMeGtMRU94amdWY2t4VHE3SlJjNnVJS0phWHZ6MEoxRUo4a21GYWQwS0pRekliV1FzWEc4SENncGNxMzFBTnZHREJFb1VhWStSVGIzVHJRSlZGanBOWjdhaldHTFVRYU1pMENDbHBsM2I5dXJMT29wU2xEa0VicEFObjFCOW1rc2pnZWpHa0RWcng3aFM2bUFFSzZtOFNiVGRsSjdCenpSVTBhWG1RaE5xMTBYREhnSmV2UmZUL2VlVlZkSnRzaEtBQmtIVHpxOVJqZDJxSzFwcmlqMTFWT1d6VGFVL2Q4ZG1IeXhYTi9TS3ZCMFBlV0hveldPTlpkOVMyTG1FTzVSdEVuZzM5ajFHTEJiZGQraEkzM29TZ2hZcXMxL2hOdEJWRjZsZ2czRGQvRnlPYnBUMmcrUFM4cmF3N2J4MHQzc1JEYlhHRUtnaTA5aDF4TFY1U3VSY2hpYUVqbkRTNnpRNXVySzdrcWlvMlI2YXpyd3NGdEdsaUplL3FCcXRIRk5rVTNBTkJnMkhPTGtBeWUyQytUWXdzZzNyUklRSk5nb2xEVmcyQmpVUE9ucUNEaTBOZURZR1BHeHpnSjBBV0VQcENVUzFCN0FzbGV3RWg5WVd5V29MY2x5amFBeFdYZEllcUdvSWFoNW85d1lBV2g3b2FnaDZIYkJDSjBxaUowcXhGcXpidGZxRGdkdTN0L05IU21paG8vd1dpdUJYT2RpQ3B6MldFMmVpVjZQc2tvcjhOWUhRMXdoaS9Ec2I2ZGZxNGhOM0NlUGtXVFpEb3FFV2lhNjFOcFI3YS9IcG85K3Rob2w4UGsrUUVUWmJvYUlwRTE2YWkwZ0RUL0FhWTdqZkFETDhCT3VRRWRVcDBORk9pcnpFTDJoNFJ4cGlvcW1hN1puamxsbjVwcnZFaCtPMHVOUldFbHBvQWdCY0FvSzhCajREeUlhaS9BL3lud040R01pNEYyYjNPTmdldU9rZkEwTlYwN0V0d0FGdENKcDVZR0F6T0pqOGtkdVFJR0FjbTdwZGpzbTRjblJ3K2dOSlYzRlBSb0U1RjJqNWpoazZta3pIWGxSUENpU3lTUUlVNExvczZScWo1WitOWVE1YUdFYklSemxDbjYyTXdET0ltY2wyV0lXWUVjN1drY2J1Y3RXTTM0KzlocmNUdjVFVWxsbG5aTnJZRVJnUnJqc1dZWS91TW1hdmg2dzYyTEFNWkdzcGR6Nm00azVoOEloemptYk03eWNpaHMzODZUMm1OYUl3eEVrOFJJVmtybkZZOUZWR3ZjV0xiZXVURnVqT3ZlNExSVnJYZTlLT01EZVlZUTFyY1BZSHVFN2pFSjFqNmx5dzdOQWNHRkJBb1FVSUplOU9ZVVE3WWxKVHZCUHZhRjVBbzJTejNEbk5LM05TQmVwdW83ZFRYQ2tvTGVoaTFJWFQrVkJ0T3F5bWpoNGo0eUtCL1RmZURvakZBTWhLTXlyczZieWZQWmdhSWFnaUV3ckFlbVhOdElSZUMvcFBrUVIrOEdpUnFvQkFhQmwvaW13V2lMbExmUENoejJOMHJieEgwdmdERlQvL1l2VTJXbUloWmMrZ05Cb2xxY01rSzZCemtkdTJJcEdsd1U2ZHVnYUYrb1JVY0ZsRjBNYi9DTUlnYWxJcDBYVEN2TEtaSUluS1c5bTUwdWloUnhsTlBvUHlJSUhybElyY3ptZHBrYm5mVHVuMTdNRWhVMURDRVI5Y0JGRTNETmVoZjF5QjZOUUJGcCs1bGFHYmtCRmdJNzc1UDFBWDB6dGx5YitjTmNydVkvZldtYXRRWEhBakx1eXBXNEpzZEpPckFESHJ2YkVyakZtSUZKc0F0WjVHcGcvSWFvTW1YT1paUUtGc0JXZk5rOXNzWGpDWkUzWHJkNEVZNnZkQ1hvS1U4cHE4TXdVemJoZFRkVUljeWtyOU9aTkNhOXJUOVgyam5DQ2VQKzRKem9NeXZZbEZvV2lwNmIwYVlVejNKVnY3YWRFVmpXZ3BlSGt3MjBoK2NzVDROaVFETkNML2NBajE5eFdTNWdJbjVlN2hVNUhSd05lVDZZRys3ZlZBTmVtMStldmt5bjNSc3V3QWFzT1pQcER2UEkxMC9GWE9uWm05c296K1IyRTFYL1M1cThBdGFQVTAxZmZ1MEIwSTFTWUJ4SW55Y0xDTmRNMnlESjVDaG14OUZ5ZVZ3TjllODk4NGVONk1zVzRhM0dzNzNqSThMSWd4b1oyWitWd3R5dWxaNlFZK0c3bEd1dlJnaTU2ZWRzSE5NYmdjYVlnWExjaXQ4cVNoejZqbXRtSFBMTklocE1RR2NobVZJZVBzRkV6WFRNZHBneXBCN2lVZGIwaHUxaThoSVBPeUlSNmJNaVNmQWdwSEx2bHVHWmdlNlRGZE5Udm10T1AxeE1hZk14aGp1VGJOYjFmL3J0Y2hweXg3bFR2TUpWbDVRTlZ1TDNwTHh2ZlN6a0tIU2EvMmw1WXNvbmNGem1rdlg3Q25CVEZRblpwRVVUQ2N3VVRqaDRMUWllaDM4T0dhc0E4VS9YakNPQldVMDlPQXlYSTdFMmwxSHpuTW9qWFFUTTNWQ2tWNkg5WUpUL202MFhJNExsWnA1clJKRDJTV0l2TWJoNUlCRU9rNHExN2lWOERqSkwrU1RIWVZxcndGMDA2TW9Dc3RyQ1YyQkhvbVZjbEcwMml4TG5TWFlaRXNUd21zYzJtUXk0WWJTS0l5ZWlZZGh3K1VDZEJ0ajVtVnVlc0F3YjRmM2lxbjVsL1JwaHhSMGFQSVpSWkdPcVNhMHR6ckVESDAvYmFaejAzR3dLN0NyY2tOSFdGS0REeTh3SUpjSnpVam9lQndjYTJ0Q2o5VDZ1S1g4SVdlMTA0cGFWVFpEdmJhbHJTdWx4TGRaMUJ4REdDUGNOcUZaZ3A0N2N3bW1Qb1c1VFdIKzVmc1dpQ3c0bEU0N0JmeWYwNTVLT1B2TnYvQ2RPTkdjSnk0SzU2bHZPclhib0hYQzFKNW1RWnkwQ1dhcE9NcHErWEhGOXF1cFU4K3lXdk5BWGZEbHJFdEgzOHhlZFd5T09MY3pJNWhJR2FBSEIzYmtVU0xoQXpPN0gwMEVhS3dqTk9mUzQzbWZkSUF5dmV2aGVEOG9mUnB5UUd5QmNNVUtRY21qbWRKcDk1aFFhb0hVSVdiQlJIcGxqWFRaNDBDWDRKUy9jcGhoclN1djQ0U0lxb1pMNUxsUVR1Mms5SXVETUEwcGlzeEpDaFlpMi9qSWdCQjFJSmM4N2syaVY1ZnJQSWQzV2dDVUZ6SFEySS9Yb2pYV3R6WDBETHFGRmFqSGhaK2x2cTNON1lTb2cvRkVrWDF0Y1JqV2JEUS9UL3J0OEtDdlVBSjU5K3d4OFRDMnNYR0lQUThwd0l2MnVLWkhtTm1TOEFaSHQxWW5VK2VTRVZKd1Jjc1JhNk5IOUhMbGdpU3doM3FvOGRvbldoNFVSMDBOZS8yOXhwWHNRRUs3dWh5WVFyN2lxNG5iS2VCRnVLb2xRRFAxTmNZMlBxUyt4L0Z5QkJFQm4wbWYrUGdzL1dUbzNEK0NrV1dhamNHc0dZa3BBWU85U21XcExScStLWGQ0ejNkT3ltdHVCU1VtRTlNUWtKKy9UTlJ6Vzg2NWN3UlRoeHlsckMwcTJ5NTB0T1MzOUFXNHR2Q2FBTGhtV1c5M3lHWFNRT1liSXNpd3dRb256YkZFL3NKbStsNVFwdEQ3YkV0eTYzb0x0UlAxV1Z3T0gvRWFjNThROHlWV3lLVWlrUmQ0aE9LNE13NG1jUndaZGlUeDkweFBXNEdlcGF5VG5hU2JqVVdVSGF0OWR0aEJ0RDZObFQybzA1Rnc1b3dCZGJiNjcvTDI3MS8zbEQ2K2x4Z29iR3NiR2k2SHRIZXJNMWVyNThEUm5DQWJLc0lMekFJa0w2Z3Fib2Y3MURUdTQyd1phUXZFblJ0eDJsOWVXREZLWDZLNmMxS3RpSFAwQ0NNemw3UzlMeEJSVVRKYjFubWlCZyt6cENPQjNhWGpKUWNTOTg3cjhMRnoyWnJPR2JLbloxYXdURDZOZmpEdm5sU2NWRGJ3TUlsbGlSOVRlZHZFckduTXovWmt0U3NQWXp6K1BKVUZCMzQzNkZRNTJRUGFTNnp3UlhkQ3RKb1B5SHo1UXlvMGdwQk56MHE3dExqd1JtcGdCbkdMMXFlTEtmVThsZFZMTEltTDlmZWRxK3BzbytkOFNFRVBubXZhMG42WjU5QjdZVnM5Qlh3UGdQVStnQ25DVHdranJyY1R0UTI5TFQ1Slphdk44dFR1c2tLaU1ld0J2SVlaejlCejlIUkdCMzZZZkYxNUxWMENPMThXbStudkt0YTlqWFF1OFFMSmtoSVNlbWxpR1V3Unc5WXA2MmNVOE15UFVzT1Y2VHFWcldEcDNxZmo1YW1PYytudjB6K1p2U2ErR1ZnTmtIeVN1MnBLN1dvZWFRT3NRQnBnS2dYTWZETlFZU09CNGVZWjNOVVZGUzFxYml5QVZMaUFwdFZOcXphTVdqMEtjRlVnRmRPckFKc1Y1cTdtVnR2Z1ZDRGVWcTVtSGhYMFgrWm5zU3hzdG96TnNySXNaOXNreDVzWE5pZk5SRnU5OTZLOVlXSEQ4WURHQlkxSkhWYkhrU1F4Y3NIaVh2ZGgxTnVpU0ZwZUQybXp2SllCV1hqV1M0Zkg5RTZlOTkzamJWTURZb1dENnNuQWJSMk83TEo3QWJmMWNvZHYvOVI5VlZlVHRqVTlGL0kvYkQ4bnZJQ0lteENRbWRVdEZuZUJEU0ZpdkIyOCtEaFpmRHd2amdqT2lXZnZoMS91ZzBXb0NTMVFIci9qME9haHVGZGhMNmgyaHBmdkI5RTd4OGVvV2VUR25SY3pKcnpJN0VkNXRJTzhibXZqNEluYy9xOUVjZTFoNmhOVnRkcFRhdS9uY3J0eVgxbUpmS2ZNMGMyMDR3NUVTOG9PNUtLOVcrVXQvVldzclZLZFVIcVlqN2UxYUN3Tk9jeE80WURPaGh4ZnE2WlZSemJhQjh3VU1tYzIyTDM4dlM4V3I4UFhMVVlXcjhYWExnYkU0OEU3bzduM21FWFJKeGVkakhQUWdleUwvL2cxZXFpZEkrb3NvMEN2bWhDTUN5b3l0V2cwMy9aUVRpaGNOd2tIRzBmR2pRdzBXQ3pCQmhEM2FVZEM2ekFjLzgvUG9TbFRFZFF1dWZEUDhUMnA0UGNpcUdUdDNUK2RMWHFSaFM4MGk0V0EyYkQ5UHNvSnVDR0pFMFpodHh2Qm9FekJlOWVES3RLSXBtMGJucFltV2NZZFBPTXFiK1B1Y0trWldiRkIyVGtibVlQUFlkUXN3ZklhajlJK01oNGd3dVE4Q241YmpTQUloZXova1I3NGdkUmphZHVIODlJU3Q2Y2wraGxuV0FPamtlZURqaGE2RXZUU0JnOE9lakc1MU9mRDFKcGNCWlFub05Pb1lGZFZxUUlTMHhmeW0yR0RRVXNxREdxc09TNjlMc2RsbE5pZ3B3dVRkSGEzVVZtRW5FQVVQZi8vanFhTUZ5bmRtRlJNK1JDRDFnOURGSXlwM0x5K25HeXRseUxOWGtyTDAvVk52ckJTTE40Skk5K0p4U3RoMndzcnBVaSsvUnhGbjk5T1ZtYlpTY09XNHZhZVNMSkUwNjIyMlcxTlI0eWRtUmRoczdVSi95Y1V6LzUrOGhmTVpIOGtISDdLbi84Ti81ZndUenh6U2hmQWlTTkgrOTZuQWJMLzVTZnZuSU1paUtDVG9QTHliSmpFM0p6OE1pa0s0SGJGOVIrM0hsL3lpa2EyWm45YmtCOGR1Qzk3eGg2QVpxcUVsV2E5c0RyTGdFWDNtN0cxbGZ5NVUwQlNzdVhUYVJTdE1OaTlNRmdlL0RFL2YwbFpWZUhDcmtESVdKTE11bDFyYnFaVmJDcXYyZDdVVUwxdFExWEZpQzJsbGV2b05mM0hIbXFrM2J0Y0FhaklTc3BqTGxMTkc5bnlLYWNGM3dJUi9UYWp1R3hObmEvV0o4bUhHL3VuWjNyc0puZlhsNG9jQlNiTnlFbURUbTlWWVhvWWVnNnJuNXo1aXFrZ0RUSzRSYmJnanVGbFdMV1JhQTF4UXBaTVhtMTZHZEd6b2o0YmZaN3VRdkZLT3llSENMM25JVHdieTkreHRvd2c0SHpZVzBJMzFLdXRreXVYTHhoVjhOV1hXRjU5UTdORFZwY3JrNW5vRjZBdmFZOU9JNmVQRGtHTXFCRkJ2cUk5MzRmc2U0K2JPY1F2dzJxTnh2YjhnZmxFYU9jSVc0T1BUYnk3NGlGVXVBZkZhcHdEblZqMXYwOEhhVFlrOFduRE4wZ2ZTYk8xRGFWYXJYSXZndUp2LzM2THc1eVl2Nk9GaTNDVUU4WEcydktva3N5RWYvK01YU0NxbVVjanY0T1I4SXlXSHpmalNKVHFINW0yKzFCdm80WmJBQ04wbU1OSUtZYWsrTmxEeFNtSHl5L2lVdG1GOXJqRFNXK2xNQUxmdVl0THVlRE5HMmt2dzZvTjZXMGhUb2dJeGZXNm1oa0NyKzZoQzhXcjdCeUtFWmd3TFBlZ09IYmtmSE5DZXRsbm9Sb041bkdBU3hyM3lwQmwrWFJHTm5lSlE1S1ZaVFZDNWxnMCtwTysxbWhxQ3c0SkVxRit2YTdPYUtiNVhKcFI5Tm9GM2ZKS0R3YkRYc3pHc29ma1lFOEU5aXlkTXdSWUs5Y0VudFNjMXBidUp3WTE3dmY1NlF4NXVDcWZyZjN6bkV4TFJoWnBMR0hFVkdON3duTEVJTUY5bDIzU3k5VzNwQ25Ed2FYUlc3c2tRZ21Sa3lZMUY5akgzeXV3eUNHdWR1Mnc1UENCODZKN044QWl2aVZIcklLTC81OEx4MXpVTS94SldFaUJsNW9Zb1UrVVovZm1tMGhYSHBXSDBmSk5XR2xJb1FYMnd2dGd2SjJidC9UeDBrZXBYOE1kTUR6ekVBK21lVGdqcjNVY0ZuVWNHWG1kV3JmaE43emZOQ2VTOXJPYWxyOWIyZGYwUU16SlJPdmI5eC93RDJzSjdtd1c0eXNXTjZsRkNvZGt2UE04YVVBQm5JRkdyUjJKWDk1eEJSL0pqV0MvUGx2NmxSMlh0MnFTK3Y0T3JHNXJieHRQWC9qZHdtNW0zZURUampPcE0vUFhpWkUreW1rN2I4bWdaWHkzN1VzZWcwRkxQektRL0dFb2JlTEtkNm5aOExkeUlMTm9oeS85UUlaZVVHbXdTQ3F5NWJEcFlmd3cxTTkrZk5nbUFJQnZNd3NEZHFKU0dVRmMwMXR1M2oySzdRc0xxUEJ5QTh1QWx3ZFVDbzJmU09qWVJNZ2hJUUVLS0l5RjhlMG1VQ0FsWkFmSGdmNTBOVHpMN1VGNGtYMVBoZTE0bVEvZFBPVERyUmI4WHhQYkYrYlhJSlVtQXEzTTFTcGxmaGxXb0l1TnlLQ0ZrODBlTW9KbU1QTjhjNzVCTzRzdTRadWY4d1YvQ0N3Q3d4Rm9Wb3F4RENwcndWdTBrSmFRa3dUT1c3ZGJrRGp0ek9RUzVuODhIK282TThVb1I3MjVzRnFYSnl2TkZOcUVzTkhoMENSczN5dzB5Z05xV2FsZUp5c0xxT1YwR2cyZkgrVG9FbEFtaVZCb2t2QXBGT0ZUaEVRb01ra0VkclNxNktBcllPWGl3OVE2RThyODZaZDVSSVc3T0M5MlVCQUlSMFI4K0xOOHJ3NGNqNjQvOTFZNzlZZXVGRG4zeXhFazdTeUhka3k2Zm5JaWxwSlM0UGd6T1ExWHA4Y0s4ZUVxQnpTNGQwVWdqMmJGZTU3U3pTTldsVVNDdnpPVzJzVWllV0hsNVR5N21LN0Jkek5vZTVjNXBHTHFZRmhJSlh2M1NVK211RXFaTjBNd3I3S2RCQVVVenNJRkRqTW9GcHVCSFlpNkNCRVUzUWUrRU1adFlkREpoNWFBY0k2NXdQdGQxcEczelVhcy9zdWVkazc0ZnZMRHMrbVZ4eFlKT1lXem0yU1hmK25rTXVtbnZXYlIzTDlFZzBzWXhFQ0ZOY3RKK3cvZit4TWphekM1T0l6Z21XejNFeWs3YWtqaWxVL2JsRWx4WlY3U29ITWE5OTR2bUMwRzFtQ1JLYWo3WVcySklFVkZBZ2o4SjRxbDZFZVF0Ti9WcUxxVDg3a2Y5ZFBlUzlkUDlxL3MyWTNSeVlOMlBrZzRjNjNET1d6dEhJU2ZMWjFHVXhYTzI3VmdsNmFkbHpGemV1ZDBJTGVudlVkUlhWOVRyMGhwUDlVZlVqY2F4TStkdW5hS2RudkJiZFcwbnVrOXFvVjNGdDBoTy9kMzd2TWtyK2k1NHFrbzlVS090Smh2SGhOSlBHMU9SbnFCMmVMeS9sK0RXcE03ODBYb0paS0NQQSs5UUZLRVBRMjl3cE1BcWpKV2g0c1A4VS93b3Z0SjUwYWljVkZId2NiZmhWZGwvRk14d3dqMlNPanBNR1BOWm80UVp4T05YZ2dOajBDSm1KaFQvTEpYL2ExczE5RW9FUm92eGRtOEUveERvb2hxbzVBQVRncDdlUWJCNzZQeWs0WTFMbHE0THpLYU9yT2I3ekZGVDFyNFdSS0xjOUt1OXYyZGJFOU1HM2czR2RHTERLMzRmQzMwUzN2ZFM0YUpTQTl6YUtFaURhdFBPRFZoWVllcndTQmYydlMvNU9TSGIrQ0grTW41OFFtdG9kcWVLSUY1MTNabE1aUTQzdzNxQVFTQW9TeTdXS29Ka3MvbS9HQ1dTMlEyVWhiL3g1QjVzOEcyY2ZFRHhibmZNL2JHc25jSFF3bkRZc0RCMU4rV0NsNnp1eGxvSG9lUG13NU1kMDl2V3JxNHpPWFZUS2phVWwyOXBhYTJJOG1zclprU1QrR3R5VU82OC9LNjh3dTgwNVZYVUlDcWduelU3VkhNeXBWamVVb2xTSnBQTHJRbXIrL2JZQkNhaFFLcldJd2RNNHVFNmpOOVhaWWtRZEV5VVFDWEJlUXlXUzRTY2p3WHQ2ck1hZ0Y2ME5tWklKZ0pnV0JXTlpUWkFFSmc1ZzhiQ0g3djN2cC9hcmZwbDlRTExDUUJ5Vml5WmNoZ3gxVFQ0SUdvY2MyVWVaa1I4ZE9xdzkvTUFQc3RGbVBsY2xJbXpScjZOZ2FRM1ZPZ2U1MlNjQ0xrSW1RNW9DaExpa0ZrR2VzbXpPRDV3ME9jRmU3ejR5c2dwdTQxVDVFbkl4NGszVXNzVDgvd1FGTUJWUHBEUHZveVV6QVlBQXRGdkh1TnpSUVk5M2Q4VEVLZkMyYTFuNVEzTzZjVHVydCsva1F2MHVQL216MHY4cXU1VVkxTXpiUG5uZzFqUGpncElzdkQ4TVprK2REYjlmZE1aRExoOTlOYmczMzhYeFQzVnVHcEthTFo1bVIrYU41QWVjSDNQSEJHbGtDRWVHNWQwY0FGTS83R2l5OVQzendhUnpuTisvcVMvY0ZIeHZTYTkydmV1dFQ1SzJsdXlrbWFQZW15eEd4dy9wd0JFWURobUtsSGlJbk5Ga0NvNDcrZURjOGxaQ3JSM0xyZTlWR0RUbHlKNDhad0ExSllwS1p0UUdzandqUGlSR3kraFBGZnBmVDhER29LYW1WZkU5RlArdlpGR1orT3BBbzNTbkRZeEMvTG1yalhEaDc3dGlrU2oweDV1V2ZRWTBPRTgzOWhCbzZURnlIQ1l5eU5VZnMxVDk3TTFJcnpWY0ZNdUFXa1QrKysweDhWSys0KzFRM29oL3QwU0xtUmtGVUVOQXA5Q1pVZXpnNHE1MFNiRGZWL1haM3JQZlhLV1pjMHdiQzR1R0dwd0cyV2lzU2tOSGtVU29IWExCV0xRV0FyNVJGU1gvQlZwWm05N0kyT1drbnR3aFYvSGxmMmJWVXdHOW5IaTYzSkc3bzdMbVJray81V1JMYms5ZDNqaW40ZC8reU5NcGhDOUd2eGJUWFAzaXcyaXIyQXJoQjRpZ2ozdjF6REdpWW5qblB0UE1GTlpmT3MrUEw1YWN6RUNXM24wSGJoVVM4YWgwMUhyNlQxZnJWSnI0LzB5T2JxbWU2M0doSHE0ZlNPMjg1Rkg3bzJrRGRTa09XZ1NyTU5LcitsR2crckhJNkNiS01XTC9Ed3NNNVNsemRnQXNxRGNRMDBDZXhpUUFONjlleVl2ZC81QjJkVUNabjA4amVjZDVReFd5SGVNLzdjd3RFb2N5ODJ2SnZPcmFwaUpnN3hPSnlPZDQxMWpiWE1kK3FKNGlHMUNhK3lJb1o4TENzcGdoK3Qrd3RJZU1ZY2RHU1U0cFQvREhnbVZUWGN6Mlpyd2NGY0hFRmx4UHFrbExVcFNWM1lzZmxKMStTUkxFVmtwSlVWYVlsVTV3L21OZkRpOExNMG9xZ2hqbDUzUVhBaEx1a0h3Wk5wU2MrWXZPL2puMFh6bmpBNXVyMlI4WEVwOGJHUmNYRjljY2svMWYzWHVXbWM0Y3cwSDJNYjdmditrRFdZRzJPZEZlOE00eVlSV2p5MXY3QjhMRjlxeWg5czBuUFZzVU01SEordlYxOXpaN1UxVDA4RnlyOFVYdXVqVDAvSDYySWp5dUROM3VYc09NZE4vbWJ2alpQZVRSdHFOdlRZNC82NCtLRlN0ZUJjSEMvSXVmcWVXVEhiOTFWUnZSWmt0NEU2a1ArZzNnZ2FSeHMxRWRxNW13SzF2TmZiMmM2NkFSNyt2MGUrLytIVnFWNjRFYlRUY0tjTHRnUHZ0dWpLbmFlTDJ2NjlsWUd2YTdsVSs0dkdLNTNXZUxYNXBiZVh3TDdYcVRmQzgxVmdDVjNQZThvZTV2aXUxbHU3Zkw5TWQ3aVg3ODRvV0xoRldFOStGZmJuTXc1QU1aZGRWMERqbGRKVHEzNnpyaXY1eWRMWjRyYm51b0U4LzQ0bVhGbkhlWWFsN1VHdkZiVjVRYXdWQlNzNnl3VmRkR0hBWHRDYmcxOWR5Qk1iekhzaHQxcXdjQ2ZCdXZxZHB2bXRtS3UzNWdKbVhZdGs4aEt2eFowc0xWd2N0bHZjYmlDdnhTODFQc2NmMzYvdzc2b1JIZkZ5VG1zckc2OTBmR3ExV0Y3NGhjYUxEKzhiTjNZdE8zdG5hTHlTT2JYcTQzdzA1cjYvdmJJSDNuTFJydkpnQSt6c0QxRkk1bUhSQW9zOHJFc0x2SmQ1WTNUbWNsbXk4VXJucGxaTDVGMzlldVBNRi9maUpxM2pzM2Nqck5tdk5TWjhmcWNvYlh1K1BJTXhmRXozL3orb1F0Ly9xZGZDbXN1enMzenR2MFc3WEx4azBhNi9DSm50dVozd3RXWXlOcVBWV1Q1eVkvYWNQTnYxMjduaWdiN1JrYjFXais2Q2E4bHRDMVoyN285azJUZjRmM1BSSzJVZmY3U1A1UTUrcmVZbTM2VXFCdmpIUzIyWm83eUJYMnBpWDBrVS9BTHdDejlVOC82VndMTVpoeUVETUlCN0dZQU84T1Vpd3k0Mi9XZFhHTzM2ZytabitFRlRFY21vODd3V2haa1I1M0FiYTd6SkZkcUhOY0FiaGJOSm5MZUtjQjVmY1loc1pRWHlxeVUvRlEydDBnZjNWc2RvdWUrWVp2dWN5NFhmM2NCKzZYeFBmTEpNZVZJdDIxRnJ2Znkzb1JnQi9OWmJHL3MzWFlEM0Q3MUNPSU5PT1BMQlA2N1hYM3Y4anBHSHd4TWJXcS8vdm50M29ZSjh4Q2s0a3hIT2E4VkErbFpxbHBvZXMyNVVaWkRON0VycFREMHh4NGFSejNVcytvQlVJRzVCZm1sc0JnVGY1T1ZPd0RyMjVNelQyZmF4SzRWMHBtSzZhUWx1eUdoTjdDSklKOEY4Z09zYmRySStUdEhPTGRWYjdnQTUzN21CcmZJKzJmUWMyN0VTUmM5eVVVWjRoUzVPZ1B6QUpnZnd0eHhyV2pUVno3cUdqT3RIQmdoMGFyM3pwRExXc2dEZjE2WW5lR1lrK3g5RHFSOUhnUjc1M1F2emQ1OGU3cTZ2enVlaEs1T0lVMks2MEp6V3o1NEYwWjhsQnlHV2dIb0trblVHczdtNzhOSUhFSUdyMTE3SElMSG5Qdkh4Z1pwczgxdy9lNVpHZjViakxnbGhxdnJhbHFoMXZGYXRjc3U1TE11SlNwa1pRcHBvNGFWNHdkNTR4aWo1ckl0U2FWV1FCYkE5eTJ1Q3gvZmlhTE0yRzZuNnd0UjNxT3hPVHdiUk5tV1JScFE0dzVxbUltd2grQnJBMDE0Y0tubWp5dTlBOEpEM0phS2hwYkNlaEZKVGVhaENIVEt6NWg1UVhZT2NjTEVlczR3UTVJZS80OW02ejRaTU5CVkpTY0w5UjVFWjNEOGdjcGZUYmQ3N0RER0ZxMDJmVGRHZlpRbkd3anhleEV4THBQR2FJd0tkQU5TdzhMTE43QWJVOHJ5bjJFSE9XUVRwRGdNdmVCN1NzR0Y2M3FJeUFJUzRGU0JMQ0Y0YkVTVnYwcGNqZ2FjSE1DMHBHMHAydzBGVFMwNG1qaFRCZVRNNGxkMk9uMWJKSWxoNFlOQ3dndlNVKzR3Rm5GOW5STXRiOWFVUlQ3YzFWbklBNlJRZ2pRS1UwT3gzQVhZVFFQQWFEc2w4ODAyZ2hBN1FTcmVZdlFHRDVvdkdESWhIckloRGlLaXZ0S0lUTWhCcXFZRkNvT0lNaTVqVnFKcXlCM2Nrb3hHbWxpdWpROXBrNXRpR1pkNk1MdDNGUUcvS3lmTzZTbFhaMW14UW5kbFMwQlRoWnIxbGVtYmRTbXV6Ry9raWlLMkNGK2cwdWdnNnptSjJveWVDUzNrNE9JdnBlWnZLMjJxajJEYkZBNjkzYmtkQURQVzRteml1bVFzd1kxbzkxczN6cEJQbFc0dGdMbnNJMGp4YTNYTXZOTWlCd1RhZjJocjYrUDZIYzdjSm1LcTd1TmZGMXNoMUJ6VEMzbVM2NWZGcWw3RVVTU0xPeGRsaFNmcWttNWZlVUZOeWowa1haaU1Pd3RsanBscmVpdG9QT3pKbDR5SUUxL0ptZlE3NmlUWitQcDhjMGpsaTlKZmtCVnZxWlJCUDc2czNQTDQ0Y09QbGJVWjJja0YrQlBSaUVsQkVvNlozYWxqSjNGdU1TbUMwTGFlK2hTSER4UUxBMjlaTFlxWG84c3VSNXJXY2VTa0JhOU5uZmZSbmVZUWNYTmw3QWluU0E1UWl2bXVMV2RTNld6Vlp3NHc5MXNzRDl6VnNnRFdVb3FNeHl0NEozaS9lK1h3V25lZ25aYlkyK2d5TUpsMXE0d1pUSlZtYS9HbytxSTNnRHFWdXZuZTNPNTJ4RVljUXJsaGh0ZVJwYnc1M0MxdU9UeWlweTZSSm15Z2dNWTNuRTBOcTk1S2xlT0JDdGdpZEtZZU94d0pHREZmOVlQZjlFNGpoWHIwWk5WR2w5bkxsZEVOdGI4dzJIdXB0cmNZZTN5bjJLT1BDa214WW4xUnFsekF3ZTJhNWhzaDdBWXVoVTZ5bVhIc1ZVSm1zeVhNOGtJdDY1UTZUMjBwa003cVd6TG1mOUMrWVI3NWlWVGQzWUgvT3l2bXExbFJjNXhlQVlyenNBZ3JPckc5dmtNb0UxWGI5WWd3dTZLcGhzbTdmcW1kVWFTYW5nMWVyZVRWa08wN3NNelZUei9aUVp6c2hMRE1UdXlaRGxOc1BmSzJXMFhLMVlZTFlHbGZHb0V1R0FnNnB3M1lTdFBnSU05YWs4Y0JCbzRHc0o3aHJhWkhDMU5MVkhHZ2x6cnlZU3huTjdLRGpleWNZSC91NW5VK3QybkNvS002MUttU1F0QjZCQ0s1Q3ZSakxFaGFQcC9UVUE5dTlKREV5Qjc1RVZPMFZBQmpmZmV4bHorSWdSRlNEWEZtSU9FMkNiRUlVKzltQm5ITDNrUkFucmUva1c5T1FJRlZLbW5NYzBzekhyT0R0UURLRHNVMmZ4ZEdmcGJkMTliSm1RdjdWNUFDOWJYZ3hJM1RsRGRJUlVNWlFoWm1GMm1hU1RZQldCYWRodDhVempLdGFMQVkxSzN0NERXRnNpK3E2d0lSOWdZbG1zRFNTbUFGTVlYTlo3dW1WY0ZYSUhFcktxVmFQbVc0ZGczSFp0Y0FWQ0srMEFGTFZFQUpDRFRnVVlpOGRXUHdrcFprcjRaemtFVWFabTFXa09VSU4wSjRaZ2czOUROOWlBT1JlZngvek1vMFdkRHMyTFd4MGtPWjVFSDFObzRpeGNzMnpYWFc0eFpoVHN6Q3JzN1dGeGtPWmJodGlvc2dUMmxrQmlqdXkzZFFhUno2cW1sYklybVRjRHAwODVNQkRrK2F5bzg0ZEQ1UlRrYk41djNKYThMdTBYZ0wwcG5Gc21VT1h6aXdRUG5LMDFaQmlQVWpUUEFnU3VjNTBTblZFVE9sK09KWUdJS0pDMWQrQXdaVWl3amlnMlhubDQxMHlCcHQ1R2tUcTg0U0pmSWxBdXlSTkdqUE1NejBEeWtXcFJsajRGaFRUVWxUZ2c5d29YWmZwaFBXL2NVSjd5RDhqTDNPSVQwcG5XWFRBN3VPNCsxUDBpNzB3eC9sMDRIUkk3NUNlT0VsaEFuVkgzUE9tQW9oVlJvZS93NXpTcWtWamxxZmtDR1lXVk51clRoTTRVaVUwKzlyZEczbGE1QXJqNENwUlFiVWFNcnBjb0lndGhoeDFZTXlHOVRKb0kwOHQraHR4RmJ2VnZEOWtwcWMrR2dvaDZLSE11ZElvbUpCN2wwM0xSN0U3M3B6UDNPcmhuUHpydVFVS1Ivb2xzNGtYMDRWWTd6aG1EWHZaT1BDNS9ObDJrSDRqQncxWkh2SG1pRm5mT3E1Q1VLWnQwMEQ5dUlkYVpGT25zaWp4RFFrTkNidWRJVjNVN2tXUGNldXlQUkxUb2tRcHNIVTY4Rk8wcldiL2xicXU4SVk2ejJyU21XMEpPZm9mN3BaNzI3QmVMRDJuWlQyL1JIYUFXaHBVVVplU0FJVUk1SDVKSm5IRmxadkJMZDlPaUpsZUo2NkJxVEtaRkZOZm05bUNpdkZGazFua2ZSMVJiQW15MWVJaU9Bc2ZOSERuWEZVdWVIYWtaa2R5MXBPYU9ha2xteWZTUlAreFYvbE9iaVZybnFENzVoajBCVWFvQ2FMYzFNenIrbmFuZC9nVWg2NlppckZlaE9ZaWlER3R2S0wzWkVQczcrbkp4UU9ZckkwMjVEVit4TmNidDlObmcreDZYQ3VXZTlzRE0xeHZFbm44OUcxeHh6ZlU3cFVqQjBtRHRVQ01zQmNOWnErQ2tWVU5Zd2RGdHVkMDlYbDR5VHc0Tkd3V004c3NnNnNCSllmM1VPTHRpN1lFZGYwOGlFWjBGblpXN3dIRHJzcEJ6N1NrYWVVTUtFK2lOUjR0TW5HUXlZS051R1VjVTJhb0pzRW9FSVlXRGpGdW5nRGI0YVczWFExbzNIYzBvaEIrSHd2bXF6UjhqVDR0QzhYaWdyZFN5NENndFdVcXIzRllwdVFydWFLQUtPeUo4QTczcVVHdFU4dXlwMjhIeW50Qnc2NnhGZ1VIWFBrYjFPNDh5TDB5ejdxQnBJczlhMVhjNEJCc253eGJ0TG5INkwwZzh3a0czOXZ5dTV2clpVWXAyQUtVUXoyT1NCNDlxV0cybFBzQ1J0cnRCV3hDK2RmZGVQMjRJZ1FZbjY3dXJpN1cvU2hJU1lxSVF3M2pnMm5lQ0RLdE9mbGFVS3BtRCtZTlgraU1aQ1VlYnNSVHFwZStURFVEVWRPcWxQaEt2cUx0NVdXUjUxZ0tlekZOQnRrY0R1SkY5NTZJWCtiVjVYNlpwM0dvS3hHbG5Gc1JyUmNzYkt2eFdaOWhKaEdZWjVzYUlwZHhnTTY5Rlg3RzJuckpVbmVZRkE1OHdRUUZrejFnaUNwMDhiNnpZamhLQkV3RXR4RGo5UWxhT2ZhdnR1amMvcy9PMzZSOThSSXl2SWNsbGpWRXZrODN5T3N3cUx3aXF5SUZydUtyQWptbkpTbk50eXhMU3NHSjF1TllCVFhaTElTOTRmQWFmamxQcWp5bkhTQm5PdGMzaXJtM0VHNTA4TWdpc2NrTWF0d21qVFE4Nk52OGEvSVlSeGVUMDNVSFp0NDJLNGZEQzc0cGZUSU8rRm5NRGk4WjZtdnVvYk1RS3JvNlVGT1lPRU9PNyt6UU1VdmowQmsyMVRRZ3pKWWNXWE40WnpNdGdrQm9jekJmOEMweW5lQVlJc3kyeWN1QTdYWVlQR3pUNEdWQUFqMHpLN3IxR1BLL29IUC9ubWxOa1cwQnpRMy9EVHdjamhtOGN5ekdDMDBjeUwzR1pDOXpmSjZoclBadEJIOC94ME9lUnJ5eE0vc25nNlNGM3lzUS9vRGhyeVdXTFl1NEdEbnRhclVwcDJ1MzVFQVdOUGMzMUhDZ2dHVUpLQTZaMGVSVk5WVXAzamxmMDZNTk9MRUE2YlFqOFhua01PMHBwK0NVZmZGNS9kbk5DcDEzYVJQSHdHVEpHMzZvZ2l4bHA4UFlhZzdTblp4YjRHWGxkSmdXd285ZHNucDhYRmZnN05YSDk5K1I2OE42ZjMwSmU5azdDMFRyOWUzT0FZK2VMYkl1aTNySEx6RDhCaDdKR2U2QkdBS1dQNlViR2R0SlZSWlp1bnJlWS9GcVZnWFpsRSs1ekRoNG5BYnhYbFRFYWdBd3FTNmRQUkNOTDZDN00xQUljaFB4elBCNHdORXRqbEFqdVJDUEd0eDFPKzdSNVhhdUQ1SVRJRjl4Vi82ZkZReUJJUnFRWjNHa1VBUGhwOWRrMDNDZ3cyeXBYSFBSaW5ySFp4QytBR0hUSXA4UWdzOWRpNC9YQzU3eldveEp2VENscy9kVEU2VThCMllRYXY3L0RyWEdJRmRHNmpBWnphckFRRDVSem5iZnU4bE1Gc1ZvRXZacU55NjRCTzRodUcyMEFnemo1cHQ2N05QMmptM1dKOTNMc3lLTnNET29sZEhaS2ZJM3QxM1hKWGg4TXJRaDZvMzVKTitrUEM3WkVHcEpEUU1wVnZsVU9hOG1tQ1pPNTFjclhnM0F1VE9YNThOeFdOV3FsaGx5NVY0M2RIMkx0eHFyR0EyUEdOaERpT1A1Y3RHWGRxRENjczYxL0I4Vy9DVm50U05acUZnWVJhS0l5d0FkakViUGZLTkVvU2lub3A3TUJnblA4cVhCS090K0hQVDR2MENlZ0pGTGNhMmVwWWNVUllUVzRIMUVmcCtFNksrMXJFdExkamFySklMcUJ1aUV3TDhqRUFOaHpZbGsvem9XZTdtYjgzdG4zSnFzb0NjOVRlRkZSc3hDck50RXZFUWJ2MStHbVpoTVpHRVVqMUNlVmlHTFpXVTJWc28vR1Z5S3NxNmxBZlU2eDVSeDYwc05ZcW5XRi9nN0NNOTlKdjhEUXJvMGNqOWZYUmUzTHQrYktaME43M0VUK1FnQUFsRGlmdTd0MzdydDliOUxvMk1KQUY3NTRtMEE4TmFaZ1FzTjliTEhESmNMa0RBQVFNRGRzQ3h3djFYUWFCYVErOVFML1c1anZuL3Yxd04rQnp5a3VSemM5RUxzQ2EwemlZTHhDOW5JR28rMmVHUjFvZm94SWVJNmhSMkVZYnZWVkNnd0ZsU255bTVaZFUrbzdHNDV2YUN1ajFXMEV6bDlvYnJ2MUh0WHhMMEt1MURkQUpFdVZOOVdzR01FUmYwa2J5eVlHbDNUZUUzMXJLa3VOalZObXNaaktndTJ0d2p2TUV4MUtLWm10Nm5wdk9zSTl3cHZPaUNDMnI3NkF1dFY0WGJDTmlFalBVdWJHeVgzdCtTdXBYWXBiMFgycXBCY2tZN3UwakFYaXZlNXNqNHczcVBLK2tSWm42cktqcEorVmpvQ3huMG00cnVkekRIamNSZ2VRM1huOEJqdld4ZjQvS09tMkdnWHFDeFgyUURSVnF5Yi9hRDN1TnorRisxMG9ZcTBKR0NoSWtVOUpzOWptcnBYZG84cTZsenE4YmhZWFMwM2lrNUhDUGFTZGtvSzNqbHo5dDVwb2hUbGlqMHN4cmthTVhEUHNJNFhlZEhWYnlKSlpOQ1VJeGpjbjl2ZXI2YkNLaVNHSEg2VlBTcHkwT0N6SFZUclE5d2FDeFlVSUM5WS9FbUNnaWxSd2FpS1BhSkxMTXRueGpzQVV5VXdlSXdnZkF5aUpnNWRZTmdZV0FHQUtGREJ0bnR1cEZjTno3cVBxWjViNGt5WlR1V3JVbXBsMHQwb2JiSTFOUWMyamNvSDZPMVhKZU5RNGpPUnc2V2tmNVZNbVpKNVNPbjRSRVlUc2YzQW1WRUlSZzhDdktDUHJCV1A4U3AzRXVEZ0pzQWpnTVA3Q0FBQVZUQU5FRWxWZ0RGcERIRFN0QVY0cXVtQXdHcXBWTlFGekJTSGJGMWhjd0lPblpnQmJIY2VBa1NOQ3pDMm5BRk9WVmtCbnQ1b1FKRGFmcVVpQW1hZXpuZ2VSWG8zck5ESHZHSDNRUytncTIyTzlTUzI3SHFtK2s3UGx5YXNyQWY0dVBXenM0bTUyTjZKVFJiT0tQT2ZuRnpjejBQWHFOTkdTbzd5RnVVVkdiTHFPYlhRSlRsRnRqZjNOdDBSUjR1RUpRZlkwNEk1OC9hbXU0RXVLS0JNSmQwV0I5QzFHUmZhU3RjallZc1pjZHVqNW9lK2ZseXF1K3Q3RmJSNGd2anY4MzNGemZCYmI5YXNoRGt4ZTBzWUVEZG5IOXZGN0ttTVgwQkFoVHJESWtiMXFiT2ZwdVJrY2laOXBQRWIyc3VDaEozMEJvb0xSdDl2cFBxUkwwVFhEbkdNZXJUR05FSEdDNnRzVTViZTlqMGtNWk5aS0t4czdGUWFCeWZYMHBLME5QVzJ5WkJwSFYwV3IydytPWExseVZlZ1VKRmlKZnhLSS9LZlFGQzVDcFdxVkF1cFVhdE92UWFObW9TdDE2eFZtM1lkT25YcEZ0R2pWNThOb3ZvTkdEUmsySWhSWThaTm1EUmxvMDAybXhaemxhTWQ0MXduT2RGUkhuR2xXenpsQ2JmYVlxdlR6WGhHM0pPZTlvSm5QZWQ1WDVuMWloZTk1RFp6Zm5TRzE3M3FOZk8rOFowVExGcXd6UTdiN1hTNWhEMHNIV3Y3c00vSWZlM25hL3M3MEFFT2NvaUQzZU1LaHpuVTRZN3dyZSt0ZVNNR2NWaTJFazhDaVdRaWljd2trd1dyYmsvQlhlNTJoenNkNTZhc1pNTVBIdlJRa2FTbTVjaVpxNlRjSmVjNTZabEo3TTF2NzIvY3RNL09oVUR3L05yY0h0cXA4VjF6VFpsalcvZlplOHowYXJscU4vZGV1SmRUaWx3OFNkZjRIZnBKNW9pZHY4K3ZsVkxNdk9DZnovaW9vWUdJTkx0NTNqOWY4dUJVc2VqZk83SkhhWXJyQUdpRk4yK0ZERjNwRnpzN2RCTDdPdURWc3ZkTlZqeTJZL05xdys3NHdsUDJpdTlZcUJxeHRQVGxXSC9admpjaXYrTEpwOFpXaUU1OWtUUm55VEt2cjhCMC8yb0tvZkI1NEhaRkl1bW8xaTJPbE81ZjQ4SWdab1hNRXVZMnRIN25vK09mMU9Yd2p6R0ZabkJ1MnBwME9EbzV4cmFlajcydHZSam11OTBta1ZMNEt3M0QrU25mNlNMekIyRkdST3VEQUFBPSlcXHJcXG4gICAgZm9ybWF0KCd3b2ZmMicpO1xcclxcbiAgZm9udC13ZWlnaHQ6IG5vcm1hbDtcXHJcXG4gIGZvbnQtc3R5bGU6IG5vcm1hbDtcXHJcXG59XFxyXFxuXFxyXFxuQGZvbnQtZmFjZSB7XFxyXFxuICBmb250LWZhbWlseTogJ0FmZm9nYXRvJztcXHJcXG4gIHNyYzogdXJsKGRhdGE6YXBwbGljYXRpb24vZm9udC13b2ZmMjtjaGFyc2V0PXV0Zi04O2Jhc2U2NCxkMDlHTWdBQkFBQUFBRFhnQUJFQUFBQUFkdWdBQURWK0FBRUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBR2k0Ym1HQWNnM1lHWUFDQlJBZzhDWm9XRVFnS2dab2dnWVJsQzRNZ0FBRTJBaVFEaGp3RUlBV0dBQWVGT1F5QkRSdGlhU1ZzbTBiMGJnZWdTRmIzRjBWUnRsZDdVY1FZQnpDZWJNNysvMXNDRnpJU1RoZG90ZTlta2dxMHF0UmpVVkJzZHoxYTltcFo3QjNJeUQ0L3hTT0V4ekVHc0sycWMrOXR4Y1NmKy9SeUdYQThXSVlhK3JocEhaVmlHZGhrQ3VNUlF6Y1p2MlJZT3QwNEIrWi9QUDQ2dnIyYjZyMnlMcTZoVmYxWnYrbG9UK2hraUo2N2o5RFlKN24yUE0zWnZMK2FqVU1DbmxvT3RseW9iTnBpU3pVTnJZZXFwbTRDZGFRaXlvbWxkODZKdFU3OEwxWHpoZjkzRndBVGxPbVVTNDJuZDZrQThSeGl4WUVUamV0Y2RGRlhGbGVhNS8vWkgzejczUGZGa09UNEl6eFdzL3BNcVBUcTR1b1Q4alN3aTJlQXR2bC9LRG94QVFOT1VRK2toSU03YUtrUUVEQUF3WGpPQW93WnZYeWJMcUpjNXQ5ejBlMjJGN2xvOS83ZTFqNm84NnNuV1dZNWxneWN4REVtY1p4UE1LUUJ6TzRlWTFGZTA5eDAxUzYzQy9HODI5NUJMeXZUb0E2VGZqdEFHeXN4dXNFQmNMSCtaR2Mvayt2ZXRLRjJnL3YwV1ltN3o3SUp0WWtQNXVKRHZ1V3Y3WjQ0YWtFeTJaTzhwdUtkdEtoOG5SNmFrcTREL2g5dDM1Q2lGRXR6dzBOc0JyR1Z3ZklOZk5jVE5QTmxpNXFpVGxlZERIN2tWczdDdmMxQVJOK2NxTFNtNWNJQyszL0VlU2xqdHJSY0cxVTVpVXNaZ3RUcjliOFZxZ094U0ZndHJrd3RYMzU2Qi9zRVNSbk84MlFOWkUxK1BCbGpVa1ZLRlExbWRvSGRIU3pzR1dCeEJpVFBFZWNBTEk4Q3JlRDREOTdkTzU0TTMxT0szdm9JaDNNMGI4aTN4bVhLckkxVmlqNklsSVl1Y2tFYWlPZDU5bk4xLzl6TjB4d2llU1ZSSWltWVA2ekNiMVRUYXBJeXFYRHdaVDhyWHhKQW5CWldFYWRZc0c2OTluMzdlOVVxNkJwT2w3TjRQa29JcDlnNkt2c293Y1F2WDEzcjN0L0UwZEtKT0hoQzdLSVhBL3IrSisxQkFKUGltbVlFbktQSUdaZVJLNjVpcnJtR1hIY1BRd0NGV3czczdIa09EMkM1NythT0pzQ0NCeUNGL0JkMDcrMXRUWUFNWUFEQ2lPUEFBQnhUWW5JV1NjSURMUHlhYVdld2tjYWJhYm5USHZyVmY4cVVJUlk4Z1NLQ1U1UVlzZUpVVktCUWtXS0VwMkxpKzBSRk9vR0RpNU5ERkljNExoVjFRdXJRRVF1QUVXZ1VMaHlCU3VGU1NHRWdORVJwS1d0TDJGdWlvS1VLVzZxb0ljVU51ZEFTSW9HZlFsZmcwdDJsaUVNeGx4WTZRUUJVMEVGdDB6R09VRjV4UWdLNFpTN3gvVW9uL0R3OFlCME14VEZBdUVTUkVsN1p2eHN5WVM1M2Q5bzVoTy9mdllKSUhQelk0eVZndU5waVRGd2dKT0ZOQ2FNUWlFZ2hFaXNoZGtHV01VRTBDQk1yT1BzWXp3VWl1eEFuckpJRTNEem9IcUs4Rk1TdHZTSWlJR1Vnajgzd0Fnd0RjR3dXdFZkRVNqOGlFWGlvNThTNHBTQzh5dEswMEJweEk4ZE4xSnVKS1ZnVzQ0RytuTkVVa1JCK3RkamNVZ3JhUWkzb3JTRGQvNlNBSG1DTy9iUlIvT3YzV1RDOGwvcXpqMXpGQzZkRzZGMWdXQ2VSbG5pdzl5VjBxaFZqU2E4VVROM3YvdnI0a1ZCcU5JWk1HVkwzeWQrdldrQjhUVFhSeHBoRUVnSGNjWklVRkZkZU5WNEdOYVV4eTVETnhzL1BhYURob293MFhhS1padktZWjc1VVJ4eFJGUk9QWTJlU0pHT1VZcVF5RTBFS0haRlBlZEtycVk1b0lJeVhjR29TWGkzQ3BCRkJCcEZsRWxFV2tlaEVsazBNL0lRTWYxY3kwZ1JrSW1FbTJjbGswekZxd0NpSWJMN2dDQW9PSFlTWXhFQ0VLTmhFSWxpSmhaMVlSQkxpSmxaSmhLUW9sR09rQmd3aVc0OHd3d0xtTUI4VE5NQzdtaldVdzZ3eE1XdjZyall0QmRqa0VyUFd4S3dOc1dsTHpOb1JVWHRpMDFuWWVJOVpqWURpSFNaTWJZS0ZsaDE0MXhYV01GdHJnNzZSMnN3MjJ4N0pUanZmZVpkOWJBNDR5SG1Ja2FORXpBcUlvcEFZRlJGWk1URzRRQ3d1Q25zZXdTTFkybTRTM2NKSk1XUFpqQWY2ZHVvWlJFR1M0OTMrM2VzS0FwY3ZCZ0lsY2lQaGtsU0JYdEV2NFFmRkN5K1NYM1ZSM0Rob1gyRVd0V3BlaGRtVjZDUTQ3YWtyMVdqWTBmL0NpK2xYWFhuUURGQkZLY1Q3bjNMNnk5UVNVb0V2NktCUnZJbm00WFpoNW1xbHRUYmFhcWVEampwWmFaWFYxdGhrc3kyMjJtYTduZlk3MnNsdFRCUmZJSnlHUkpKRE9JMEphVUtZNWtMQ0ZleEFjS0dNWmN4alRnaDE2YUtqVHBmY3E5ZmdiQklzUURFWDQrd1BoSE9VY0s0VDVxWXVKSkpORUJIUmlzVVl6MHdEdVJ5bFZ3SngrTVF1UzFhWm5IQ0lyRW92Y3FvaFI0NVpaallXVnJZd3J3djVPQWZ6dDRNbE1uNjNuZFJ2SWJKdzluTXhqQk9MSVlyajlKMFVlMFRIbWJnaXA2eWwySjFsN2tvczM3YVpid0U1b2pHTUU4T3dPQm1MSE5kSFRvZENWM1k0a1J5R1JUY1RnY0lZa2d5Y0RCWFc5bndhcFlGK1pRU29tZWxOZWZwR3VJQkdqOU9uY2JPdFpPYlB3ZFZRbjdET1hPQ2lqa3NvTmV2czBxVmpPMWRyV3EzODZNcDRtM0ZXRXNPQTlOTElMbUlnV2pKeVlHRjdVaGh0UjRUSXpCR0l1Rk1lazVvL3d2SUVoc2N3RE1Od3hBaUJSb3dVWXFSSXdUVXBhNllaSXBOSVpCS0ZIRU5ZUmM0V2VBekRpQ1FTbVVRaWtjbFlwR0Noa0NtNzByYkZYUE45M1kzZytWc2xucnJKREtIYUdiMEhRdVlaVnp6MFhUdzhnZERpbXQycER0ZTQ3UHU5dGtGV3kwSUhkTkJnRGE3Qk40VC9STko5ZDlkVUFwNzdtcXNiQU8xVXV0cDhta3dHQUVRa0FCNWhqem15Q08xRzVVQy91dHhtRkc2Y3ZPMVFCWEZBSk5lOUZ0ckVhYjdHUWZyZjdGWEZqMHdnRTZWTm50Y1VYNzN3QmhMWXhQR29wUWZDdTR1cGlCR1ozTUdZM01ZWXorQmUzRVFZeG9pWVliaTRtWHowRzVFMGM1MDBjWlcwY0VVMHRZZGI3OW9NRWZBU2h6YlN1bTdoOGswNHJPQ1E2Qy9Od3hPTHFlcmRNZVpHWUFLd280TUgxRC9kTEIyaEpRSUFlTVZIU2k2eHRoZjdjb0c2eXU4a2hrTFZlQmZJL2UzQUtnRG8wNmtHS0UrQjdyYkJnVU9DOEk3L3Vhcks0OG02bTJxWFBRNDQ2cmd6d25RUjkzWW5CRUtwRUExaVFtcG9teGZ4UFF3b3I2Y2RWbkRoRzdtMlIwSmtpUEtuczM3WFVDLzJRb3Q2dG1lYTE0T2QwTTVmRit5MDNXWWJ6T0w4ZWpvaTlWaURZcGlQbzdLTGNnREMyWXU3M3BIMGZmODFSL3ErM3R1cEJRY09BcitMa3lTOS9ZZkY3VnVNKzArUjZ4TzJyL2xJNVhjdlVPdi9XNkVYeW9YTm5mZmdUK0MxalFlUXdCd2FDS2l6b3dZS0xjWFBXN0QwYWRoR2g1UEZCR01SUFpxbG5jL1JtM2ZsanhmODhzWkgxYXU3Uy9kTDcxK1RxbVZ6djJSTHFrS1hwSFBqM0FyOW5LSWpsYy81QXpsNkhobTEzbkFtMGkyNkRlYWtDUWZ4R0RVdzFsYVhDN3hCZ3lhQ1diOFVPcmNpdWdZTURjNzdCTWthR015YjE3THFSWkNXa2ZXNTJ0bU5ld1c5TmFQTi9NenBwMHI5OTNYMGV0N3VZV2s3NWkzWDc2Um95U2VoN3FNRW5TZFAzVlI2NnNEa3JRR1VKV1JvSmlWTXdDM3VvY1dSMFVzZlJaOTV5NFNhbWVweThZK0Z3dXNRUzJYcDdrZ2V5ODFaR014aDRDVGM5THdqTzc4YmZBNUNqTGpsTmdhenJFbHBjeTI1Q3FQa2N3WDFDWW9oYWpWYjlJMy8vcHE0eTRib0RnQ0s3aUxPL3BuS2d6dG9McUozNXROTkwxa2VLbTBzK08rRzVvWUZ2Q1pZbkcrV2RYZEpEUWxQZ1YrRFoyL3dJY1Q5a2FWL0xKU2x6WTlvdEZyeE5ORlpaSlVFM3U3RnlxcHh1cnkrb2JZZm1oek4zNDV2ZDQ5Q3puc2N2bkdBQ3AvN21oOHpJWG5BOTNETmdGcW8vQnE4Yk1pK0NjMjIxckI3emc2elVENWZyREkyODdiSE0vTTVFNkx1bXArbUpqaG5lSEJuQ2h6VFV5bmFHN2NDb1kwaEJNOEhFdU96RzBDSVl4VjBzUmZ4TldpQ3F3RkhJVmxRaHVTLzVkWnhySWZyVVA3NUgzUW0vdThubDFKRGhJcndWa09NU2o2aFJLSW9sVFNVU1F6bGtvNEt5VUNsWktKS3N0QlNzdWZ1WUpCWHhjamU3a1ZUQy9uMERscVc3M3RxRXNmUDFGUE40UGc5WEs5d2pMWExCbXRZUVEwQ0d4Qm9RS0FGZ1E0RWVoQVlRR0FFZ1MxSTZ3SHFiQlROR1JtWmFVUmZqUFNva1lGeGNOT3NJNWlkZVdaZmZRWnBWdHlBTGRhdldUUXNmZEJ3a3FOejlmSDZ5VDVuczZySHZVbThtNFFURjZDVTF0ZDZDVDNpVmIvYXNoWXVLRmdRcDF5OGEwd2t2d0FBYjU3WldyMk1zV0NIeWpYVWFjWnNGTHgyRDZPR0c3VG51b2JiY1VGSTFyMDIrdzZWaHYwcmFxMEZXcDlZL0xwOFhtbEk5b3B6RjFXek5ReTNrZXlkdnNucDl3QUpBaUZtYjN4TVpXemVXcFdqU2wyNW41L0dRMFR0bzZSZ0dpWlo0cCtJa2ExdTQwOTZjYkoyTVpsT0ZpbWc2QktMS3UzRW9FMnJRUmxEMGNoSXB1U01kVkRtcGFHeFgxWWFiWFgzTkRLS0ZadytxZDRrV0xKcHYrWU1pMU9vTWQ5Z3JWbXR6L0JTWTFlbWdiM1hyVWNuYU1HU05NSVljRnBXY0RKbkd5MWQvWThRNk1yTTBGTVR0VzV0dXVaSkJHdEltNEpSWklielArM21ncWpnWnVPM3NWVm4zbzI4VDRZSVhmMGh3M29EWG1kMlJYTkZiVm8xa3FGdVhmNk1Dei8xWk9UMFgxQmNqMjZUejJGcUFhVDF5SUp4eSsya3FDNjE5UmlqV3d0TlgzejJqdHRhdlZwVzh1UjkvUkxjTzdXdXI4Q0RsL3FpYzYzdnNOeVBTNE94NWNqb2RRU0pXK0trV0cvQzFNbVphd1JUM3FCYUxhdStwMGllL0UzTVhKWkp3UEJwejUydE9lOGNNM3ppRDcyZGkvdGJFT2p2ZXZRMHc5dE5sY0lyTUx6M3hkNGRIaERHMnFtYzgzcjJnWHhZL0JFVjVDWEVqVFIvQW5jdE9tMEt5Y1RVYWxyYUhLVHdGN0RmRUtkSDJwY1lzQlQ0TENRbFFxazZBRW9pbENhQ2hwQ1JDR1hyQU9Ra1NzOTdUZ2hRejBBQkV5cldBeWhoUXVXdEJBUVZUS2hhRDZDR3lhaHZCdzJrQnJ1Z1poMkFsa1NvVFFSKzZFaUV1blVBZWhJSm55ZW9qd04yUmYxNkFBTk1ZdGl3QmthWTBMZ2V3QVRUaXFrblR6SzFKMlkvaEg2S2xZNFE0c1pjNGZ3Q0NXMHhhVEtNbGpKNEpZUFdzeVNMSUd3Y1diQjFaSWxkdzEvQ1huMkpEakxvS0tPZnJqVTZuQjA2WEJ3NlJBNGRybXFEYmpMb0xxTS9VSk1OVDBjMnZCelo4SFprdzBkdDBGY0cvV1E2L0E4blhKNFZxcHFoNnVqMGVaZHpYekVzQjYvTUE2R0c3eExCZzkvK29OY0FWOEQwRnRoUEF1QmZBUFlZeFAwTUJRQUFyR0hDRVRBa09sb1ZteG1jTFNWV0I2OEk1b2FwaUpUWkIwYkFjbTRFNFNyeWd5VWdSb2Z3R0ZKT3daRktCK1pVb3UxYTJIVXdNdWFEd29qQ1pJa01lcGhUWkVta0psUFo0QVp6RE02WXkzakZldE5rWE5NeWwzbGVrS0UrT3dpTW9sMTBtV2hEM0pmcmkxSHoxNHVtQ2NldVhaYzdBMmMrTnp3bkNEd2VCZEtkcmRqMHVPTll6REpZS1NKZUo0dkNUaWFSY0w1UGdpRGlpUkJ6RksyNHlHcG5aR1BPMmZDaUVLSVN3bk01NTdYUUhuamh1aEcvUFM3c2gxRndObCtOVmNFWTJCNWpSdDQ4Z3hVSlh2TnJqUDh2WGoyN25BTUJBakZreEhpcGMrL1J4SW1ORWdhZnZRQ1FxV2ErOElRRnNZQmN6SVFZaFVrcWlGUUFRazdGQ0NHdTZzdW9sampUVWZQWEYvcDFzWU1VNndCa1ovbGRwU1hKZGVrWEwzZHhKUFF3Z2p1Y3daemp1eUY3MDhkdVg2TTNBbzc0Zm1pbkZueDNpNk03a3JwQjZob09iZUZvRStKMXBEYklEN2pRdnJIM25EZ21EVEhQNDBod095YWdkMGpRVWF6UGoxa1dLWTRqZ2NVeFp6QWFLcGF6RzcycW9NdWFabzA3a2RJdWRtd1V2RlE0WmJaRFhKVE1Ra0NlRUduMmRycTRZeXIyT2hwUVV6K1Y1ekdMQk1GbmN4d0N4Ykp3cWVycXJ1aVVBVFNWVzhVRTVuRTJDd3dtcjgxTnU2WDVXazNuMTNOUXJIZU9kek41NjR2Qm1VOVNnakMvMnpPbDIyQW1jRFlTaGlUWG9ZWTEralYyRThkVzJtOEM4a05ud3lvVTFQVE9QU1JwUjc5cjVNMDBqMElPcXIwSkE0UDllaFlhT1B1dllkSWtrZHAreHEvTkdSYnNOWGVlNzkvNkNVZjZIcFF6QjE2bVUvaHkwcVJzNEhiOVZPRlluaXNpVlhwclM3YTJ0NTdRUTJCdzdZRUgxdXZ5Q0VwREcxN0cySmwzcVYyV2dKNUdvaGJHU0FOSXVvbTJiSkNVNEw3bDNPamMwSkdTeCtQb01Nc0puODlhbXE1ZUd1TzZmK05rbHNFeEdObU1qdThHc29XdEM1VG5BRW9CWnp2Z2Zka2hnbDZIUGpaUG1wTE9waitrcGxrSTdtV1ZoVmd3VTIxWUZHZ0VDQ1lZZVNaODA5SG1rMm1hQ3d2WXZianExOTJlUUdZQTVsbWFxVk03ZnJ1bVdJanRLb2Frc0VRVzh1Nk1rTGlIczc1MlRpeEtvTzZpcjVtUUp3K0cyaEt5bHRZOGk1ejJJOTgvWXpQVzZCYWY1endJOXE2VGRzUjQ3dWZ1cFZqN2xXbTEwVm45akt0UnBKL0JzRm1Vc1VrcUxidW5iMDREWGQ5YndaNHpDN1ZQUTIyY3ZENXgvSzdRamduTVEyYnlPMXRhTGh5dFdDZnZjV29USnExbXVhZ04rYTVQOHlSNTBqUVZwVy9ac3NIMUJDQXJnaDRaRmxoRzZDZS9vYk1EZ25HSjhZQUJOYU05TVc4Q28zd01IZDVIMkxaWmJIeHJEQkN2S3UwcHhxell6SUU1MG1jdElTd2NKUkFHcENVOTlLcDZOZ2c5enA5NE51K2daUzdBTzlXWVUrYU02NmlFSVFldlpGUUd2bmRHTTlQTjZTd1Nmd1RsV0g2aDZ2Vi9XZ2NRb0lZNk1vcDdtWlM4Q0tGemdiRTUxc3FNMTg2eHF5b29NQ3lsTEI5VG5DZHhwc09EOTdJd3R6VFVMVDFwbm1mdmlZVFNwbGI1cEdWSk1wTGExY09CTkFnQi9wKzRxSEJ1alg2bjcyL0oxQzBiY2ozN2hOKzVLWUdRWkFOdTlCTWRDNEtNR3B2Vy9MQ3VNTkdvUkxUUnQrejF0Ulo4ZFpNT1BUSGVTV3FUTDdLczJzTlZPSE5wZytnRzNkazJWMThzbm01R3RPVEp4dDZjYWxBOWV0RjM1alVLdFkyZ2dKdXg2MkVXTVV2VlRQSmtxS0Z6bU9aOHJGdWFVYXI0UXhkOXk1UHpYR2QwK0ZuQ1JvZWpjTnhTMFJCcXloQlNkRERNbHFJbWczSUFzL1pPbUVXYk5ENDNsWXcxcmtjTVFWeEdvTmJOaU5sQm9DcFNVYVlJUUdEbFkwYXFDaGFkYTVoRmV4YThkNU1tWFlWWXJBeVQxQW9DMVhpT0N1c0lGSWhEYTZNb3hURG54Rk9xdnM2SlJicTRpS0ZsNnk5RVhkSWt5ZnRtbmNzNmE3RHVybUgycnFlV3F1L1ljSHpXN3ZuNXFQaWl3ZUthc05JRFlIUjBWcFBDTUszYStUWlNEWnVDQUc1eHhLQmtLWnRnS0dZaHhwWXMvb2xRTnlBMWdlbzlHaVZNL1Y5TXFCcDhWYmxjRWNnT0RiRlpkKzMyWUxYWXlpeThXemF0U3lNNkkvZFZrREkvaGdFSUtOYkZaNXpTMEhja1JxVkVubHA2MmtvZXFaZGZMVy83WU14RVpZaTFmVnJDVzFPcU9HN0g5UTB4NU5odXdtemQvZWFwVVN4ZlZ5VXVrRHFYeFp0U1MzREZMdHZDMGVvTGFJdm1qOHJDN3Vid0hzTHBhWXZ1b1ZFOWVOR0QwVDVpZElmN0U3Mi9DNzdOV1BDdGZmYVJWSkhuS3lJWGxacmVDVGwzbzBqVnJZRUlVaFdxc29FUTgwOXAxVVpFcnZxbVdzVlJQQzZyVGVFSWlSWWhEV2NoRCtOaUY1NGc4TGU1Qktkd2F0ai9TeTBZdy9SZlY4UFVBWGVxVXFGWWc3UHhraTBPdmFzZjJRSGVOZTJKTTZSeHhJL3pVbkcxdjN5Z0hpbVo5b0pEbitOWGpyN3pkUGVEM0FTaktQWGZVT25yN2Uvc0xidDF0cGJuSER4OTJaUFBCMDZheUozVEdndGlmWWZuZmt2RGVjWm5ZM0xrQ0RuWjJNOFo4a2JaQXVwY2xXdDZEdVlYbnVYUFFSbEowNGsvckZ1WTBqM1oxeTVPaXQ0OG1jbXM1S2FhcDJrVnlncXJxQXlzTFVyZkVpR0lJL1BEQ1BBakJQU0pOdEVXMmdpdXczWWVONHd5dHJCU3RyTTBpdzNmQkVQK2I4dmVCWE5Wb0JxcURDM0RwNUpzN3hwOUMrSWxtL2hBV01TYitMOEpTRTB6TXRwb2RWa2FtTFA2TmdjQnJpWW1YVUhHamsxQ3l3U0RJb29qNW53cHdLYnpGdmU3bDlvQkEwM1BNRkEzVW8wTUkyMURUOTNHREdNMjFVeWxVL1dWVk1Qa2pjK2ZiYVNtR0NiUU52cjlJK1EwRWhYeDUxTmJON1p1Mk5hMnNZMmE3MGY4NDRQVWJET2Z0cEZXazgySHFLQ2pJaTNrVWxMb3d1OUc0NXZSOUNvNjZuVTA0K1FVNUZHM3BSdWFEMEx6KzIraXd5M0RoN1JKakVpYkNWclJMeE9qTEF2N3h6ZXlmZ3MvWWVkU2JwYmRiUSsxZ0pZL2pCeDFhc0JoTXJlSG4xemp6WlRrMjA2YlFkTUp0elVZcUxBcU1RTkxPdXlaL05qem1uRnhzVjR2Rk9wazl6L25ua0hJVFFnWTVoTXhHRUx4UmlMR3hzS1U1SWFVd3VSZGswSjAvUEU2NlgxNWtlNDV4UzJncE9vTWhlb1NBZUtWNUZiVXViSFYrMVBBdC85c0daTm1jMDFZOVNoTE55Tk02b0NaVmk0LzA1N0xsV3B4bytlRS9KNkVueEF1T1ZZZGxKK1NGRGpGVHNraC83bmdLa2Y0a1NaNHp2OUNCOVJvQmRNVERGWkxqb2tMd3UvdUhLbDUzRzRMblFaaXAzWFlIdk9KSEttNzEybkhUZ2REcDNmWUh6TTJ2VmkxRmR5NmluVHoyRzJDVWF6YkJSbDN3d2RISGJBY0lPZGpHRjBNZnA0WGMreGFJZjRLcGtRcEhWYVVYT1JvdHlPWmJDN3J2end4MHVoS2RsRWlWeVFRaUNwbzVvNkx3dk1GUXBEc0RpV25qeUNSdGFUYlViaGY2SWhKd3hQZCtTWDQveHl0a2o3UXhHUkRodkt6bjlEcm5saHhIcHFaQ3lPOHZEdytDbHRZbDUzRGxqbk1za3dqaTJsaVo3Sk5SaWFMeUJwMzVHb3FTVTNhZlZyYXRoVHBCWHRERythbjFJejQ4MFhQTTRSTkxzcERlUGtJbjVlLzlQdmFXSStjTlljZHBpekVuRGliQTUybHI4UkhScEhmeFg1WHNUTTFpMUh2UmxHM1VNaEJ0OERSNS9rbThBalpvQTIySVNaVlVVR3lyTVJhdS9HOWp1dXpjak50WERqVGF1SHdZQ3VIWTRYN2JuUGFwUG5JT1lSeW5CUk9UbS9sS2IxQ21PVndvUnFGbTg5eDhvUTQrWE8wTTVpeVBKdE9sMmVUTVdkb0Q1bU5Lb25Vb09ieHk0b1gxK1Q1VkRSSVorWEk1VFhGUTRUR3BCdXRtV0pwc3JRUjVjS0c3cERyZzNLNGNTTktjUVFsK0RIYTh2enJrNit4SXVGNXBIY3R0di9yL01va2pwdktTcVFqL2tENktLYkNabFhMTEtiQzlqR2VYSjNWNnpYeFlaUEx0SEU0S1lHRm45YnlmK2V6QlBsUEFOekR2TENNSnBvODJKak9FRmhsN0tCSnhRem1xRVVFZjIrVnFzY0ZZS1N3eGpSMzFpeWdOVkJSdW54TlNiQzR0NnhzWGJDK2ZNMnlvaElkVUVVYnVybXpnV0dvMkZRZTNOSGE0UDlwUTNWRncvWnkvM3BNTUx6eDF0V3hvY2F6RE02L3RCTFpZSHU5NWxMckJBeG5BdGpIMC9jaG9IRDUwT0hEaG5PckVTL1dZWFpiOWNMa1hVdmtkcm1sekdNOXRBM0pVbWFMeFRhVlJHY05lYm9xVVoxclVVZzBKdFhPTCtwbldMOWFPNnFZV056UWJnSnlUWmxxbDJwbGdVUXVLSmJLVzkxRUZ5aXVXNmk4UURMRHZuYXdTczJ2UnRibGFocWsyYU5ydHE1b0tCc3pCZ3lPR0RhaFNOVlJKWkhiWE4vUWthU3dPK1E3ZjVMSktJcVNrVkdrOEpQa2s1OUFGQ0ZuUHNmV3FOVS9sa1dVZ1dKU1duTzlLNjdyZnBsVkxTK1Z5dHE5RVY1WlczSDVDajBpUWJVWmQ0TDhnT3FRTjVkbnlTVjlDQXArb253Q2tlNDBTaHByRG9qMkVBZWhFenlXSDZ6b20vR2JlVjFyZ0Y3cmtwREl3SXhOUi9KbnRBRE1UVnU4NSt4d0NzMUhJditMZEpQVFMzaDg4T1A5R2NUK1daOUIzcU5CWXF0Uy94bE9KRDhDQi9LUE96QVkrbk5zUUswZFdVSXNhV2kzSTRWaXJnSzdSQ3B2Y1JQZDhsYUVSQ0pJcmM2V1lnMzI1Mlc5YTBpV01EK1h6UnA1S2hrMWhtYUgrNWhHT3RzaThIZ2M1dlRFUGpXYStFeFJxOWFQS280cGJpaWJDamxTV2Zib0ZlUDNsRWtWTGU0WXQ2SVZJWkVJcUJXNTBBL2pzVlpMTllXWW1xdHAxZWNHNGlhZFFmM2Z4TkpRVU5POHJOQ1ZXK0RKTVVPSnJZcWhndjFZRzZjNUxaQm56MWFiTEVZeG8yRG1Id2w5aTdtTWJSWWFyQ3V5MVFTcW5FcFI1cTl2UVhyZTZKdU1FMXRnVllISERidElDOGtnZVFIWmxQSVk2NU9nRlpyUXdhMGhGYkpNajRPUE9rcUNuZ29RNks1QktueVNyTXoxeUdHRWZCanAyUUVjYTZVVU1oVUI1ejlmOEJ5Y2luU1AvanIvWjNEKzQ5RmZuRDhkR25SNFVOcUZ0R054Ti9xKzdLWWJKeE12cG5MdURMd0QzMjNTdTNzaFRDL1VuVnFibUdTbmlENkxrbXpwZ2c5d3oxb1B1UHIrYXRCRGkxOURSdkx5NXJWWTkxT1N2WGZVeUpHZHhKbVRac3dJYjQzY0p0c0cvV2greEFQWlYyYzFHeUhtUStpeGQxNjlxTzBwQk41R0pkZm1oaE9BbjlzOEdKNHN5MEtQQ0cxS3BsOWx6Z3pZcEdoMGZvWk9JQVVMdS9zTlNuZk9PbnRkZVJhOTFDUzQ5YzVpeE5rVk1zOEpyRmNxcXRJUU5hSXFyMVNvY0JuZjUvUlpsU0k0QjRXOWNxSU05dVVnWEpGTmNVTHgyRzFROEVkN0NzbHhVVTVER3IweEI5RWZWRitkRzBMaTcxYk5FYXhYamdRTWVtSFFKeGNqYmxSVXBJekhsUUlSN1VycWNtQWJ2SzFtVjZGVXN2eWprSk5uNFhGaGh3QXVnTlY3REsrb2VmWGsrdW5nZEJWWmxjZjlHVTdkM0NXampMdTRhSGpFVm5HbE9wTnNLMldiTXNSSXZvY25sL3BZVXdaOHVSbENKSWZOenVha2YvcHo4ZWNNb1ZjbXFsU3JSWlZlbVRDbTRuU1VlQjdzczZOY3JoMkZmVklwN00xNUFueVplcVdOcFVkZFBqTU5UTldhYmZJSUFzTWtHR3NEWFQzLy9PWGljbms0M0J0Nys3aVpJREsyKzU4d3FHZHVMNTFDbS9rMEMvaDhCdkJsYXRnckJhU2tWUzM3VytQMjNwR0ZLVnlRcVZZWWhURWhXOVhaUUQ2NHJ3b3doV2owR3dtRE9Ecm13Tys1ckV4eFNYM0hiVVRINW9EN1c0R2NmL000TU84VXRxZ2xhQmVVaUd0RFBBZmlFY1hublFqUEt5ZktlVDRId3VjN0NzbUh2SVB5NE5aRzhSdi9PR2Q4VDZSUklUSnNkdGY1ZDU3SWJFT1VRWVROR0x0M1JNLzNaU3I5LytsNDNqN2tZdXRYWGQvOWlmcHVieWkyQmErVDhubHpyV3htVFA0Z3R4N2lHRlNBTS9aZ0M4WVdrYm9TZXhLZjNiV3JRNVIxaDA0SmU3LzFTTEdkaHVicGxPeGY4bVFUZFRvUnlvS0hFZWtMMXYweW9wbEJ3ZXFvQ1A4VkdhUklubVlCTVJuaHZKM2VNN09ZWEF5UVV4L3g4dGZ1Mnc5aXNuOHZZUEoxZVQ0enBRZlVHbTFTcnB0M0JoamtUZDYzYWwrNnFkeTlhUG5DNWRUQ2ZUMzdvSTRGMEtDVTBqMTBlZWM4aUdqN0crNTgzYitpUDNYT3VYbm5VbGYxcjNtMGV0R2xoUmRYazlidSs5a3h1RFNQNDZBbUR2eGhTbVBvUEE1VHd4OXVGdjcvalI3a2JvN0swZnZmdURka0F1WDl1TmRrQW5OdVFQMWJzdklwbXpOQXV3c2hGTnhiYm5sY1FoS2huMHZwRDd0SVpmeWFFSnBJYUFtOUVhVm8zRHcyR2NRcmdqZENXd2lKb1FtL01xZ1h3L29wM0g1Q1VrTGM3TkMzaGdRRXVrc2I0TENmS3BOL1Uyc1ZySytqajVLVGVsYk9mQlFINzNmUWo2Y241TzJZR1VzZzNHdVE1QzNQbll0alJOaEw4V3lKQ0hueE50SXRtNDdPcFNsQ0NtUm9oWXFvYW1pM09FUkpnK2xUcTdrVm9UZDM3U3pTR0FXSk1tMUUwWDRDeS9oNG5TSUFVK09kSkgxblFRYk10ZGpZc0x6UWNDdHd5Q1pIR0c4ZHpPUkJNYzhXa0tiY3pPRHpmOWdEV0JJSS9iWjZCWWtFcGpuK2lCeVNOQlJUUEN4cDJIaHcvUFNrNmNXWWFVbGpldWxycyt5c0VkVTdnc0VkdGJVMVRkVG16ckxLVTlhVWw2K3BxR0RLbEhObGxtUlpvVmhZTEpVdzVaSEZUQ05sS2ZDdGoyZm53YmtJQXVjVkkvSjBYNEQxcDVJWmc5ZXhmU0tSVDR4VXIwOG9GbnFGb29sdW1zK21DemM2WU5qQlorUUFmb01ENWpQNHVmSXY0Y1Jya0g3MDM1UmY0cEVrMkhUOFRHenl1NExvU0oycGRsenZRSHE0UEdKZ0RkZW5DbWRqSlZKR0RvdE5IOEpVV0xMVk1yT3hjUDdtamN5TnNkMFJPaGNmSWUvWFQ0RmcxcVdjbVNBVjBaRFJsb2FqUXl6RjhRT0RuL2VoWWZtUm5KUU10b3BCdjY3SkhCS1drcUtqSkdsUmVpelRaNUIwdWpZdmhITUZ5aFU3V3Z6MTA0emwzNnY4ZzVYRXQ1YzU1bURmdkRGeG1lRDFGWUxPQUJsOWxXTkRmSmxQeklSZDVrMDY2L3BjSnJlLzNzQ01JVnE5Zlp1SHh4Zm5jb0dzWUxENEwrdU1nL3FsRFVSNzJwOWtpTDhjYnBtMWVLdE1LcWp1QTVybTJKUWF1eEpOKzFHeGJmYWdTRUhqbjNPZnNrU3czcFRLb0owdnYzMG5TMkJYNlBqL0hYcThoWWliZHpORElTVXhMNHZFTzdSOVpEUmk5c04wZjNTMVpkbnFibEE5MkRBMDNFVG5tNFBaNFBqY2NwdXFyeml3SnlkZnovc1d1SmRSSXB6cHZZVFBsREVXZnQvWXgyZW1OY0x3ZnFpZnpjbmlsR2IxYnhRYVRpOWo0bVVNYlVyek9nY0xqc0FTM1FyRXI5R0xna1Z5Q2VKQ3BJVTFLS3RjczZ6TG92L0RwRG0vNGVUNWo5cmZVdzhZMTFaUDNNQXJjUWg1ZktkLzV4S0ZnbGZxRVBMNU5PMVpJWTU0V2gxa0I3NnV0SmhjdkdSRlpabHlYbDJkZmQzZW0yMkZsZytqOW5xZGFaK3J2UW1Od0I5YzFJZ1hHYWsrVkZCUVFiMlNCd3hKY3dmRC9aZjQ3NlA0MTVBZXNPZUdQc3U0ZTNKdVdmUXhSdUZmVEdMMTNwNERJQkdIQ3lOdW9CN2tsQlJUZzFVNzRNdlNORnBUVEZOUXNxN3UvYUJQQ1ovQkhOZmE4LzZZS3oxNFMxeDJUYUZSa3I4MllhejF4bG53RnI5WGY3cTJNVGhRdk5uUjhodnRhamxDTG1mOWlSUTBmZWtwTXl2MENHUHpHUGJDMWhQaG01bHhuZXhsOWVIRUdJL0g1WUdDZXQ2RjN4SjJ6VXlLcWsvNUN4Lzd5bFg3anZQYnRFOVU3djhIR1ZlTmsrelBQa0E2QUxISjMyTE0zMHdPekJXU0NtTk1ZTEl4R2N3bzNwZ09QcEhFNGFVVnZmaTRRcng4TU9iN3JCbE4xbXF4a2pFZE8wazd5YW5MTXg0VXBEOE1wL1VtUDV6akhyZjh6T2FFK0UwSnhNM0UrQzNFdEw4QzIwRUh2eHRiZit2dHlRbGJTNUV3UVdlTHFJNmZwVTlhVjV4NnRKaW5MNHMwYUVCRkNwNllnTXNDVlRpTHJ1b0hnU0E1bkc1dVBrZFJGS0U3Q3A3QUpSRHhLY2ZCdzFzVkJVNVdabDRlcHBoY0hJNVRSRWpoWkg0M20yK2NNeTcyck1XazRUTUFCWHRBTUVCNUJWc3lZSWVEbWdraGdOMmhqR1lpSmlFY3NNSnBZd0tYVWJHalh5WS9uZ1ljQkNrQnB5enBTOGpIWW12NlIycXpoOS81UElPVEV2ZUs0N0VaTHo0ekwxTStNejhkWDNBaVhkN0l0Zys0SDdjYksrNjdiSUs1OFhTcW1pb3VpVGRUVnMzNVVnRXpDQXBTNDJBenlUMnpzSWNjdDhzRG41a1gyNVI4cFlyckcvblIrSzJpY1MwTm5OeDRNdTNNNnNUeExGTWpWZTVUcHVRbFR3VnpDU2d1OG5LRm9qbkpZL3pLVEVjaTJZSnl1bmxRVWNDY0M0cHJZN2NnK1ZNZlU3ZkdiVkdEaUczcEREOGtCeTl3OEFJSEQ0aGRJTU5QWmc0QU13Y1hXK1VjUEZuT3dSM01IQ1RaaFM4cHdVU09XK1pSUGpQUGh5bjVTdFRPMEI2RFFlMnB2OHdBVlR6YXpLV0JvK1ZjUEZ2T05YdEl4VVh1clpDU1MvQXRSL3RGcWRqL3hXZm1aZG1VL0F4UytXOE05SC95dEs4Q25hMUZTSGpNY2doZTRxcEw3a2RmczhFT1Y1QUR0S0FTSzdBa29USCtVUm9MemE4ci9MM1ZiamVvalJHTnNjNEgzS2p4WUVUclZGYmhjODFXQzlDaWNQUXFldHpFNDFwejdJV2Irb2Zjem14dGRqeDJUajgxZFpBOVc1THMyUVFPTVBycmJKa3BBbUFnZlZ2RkRnWThBeTVLTDJUbmx1UW5DOENLclJ4ZzhoRjRFSjhBSUFadzRVUjQyNGs2djZZSDg3Wi9BWUJlZDJ0NnRHMlpSZGxGNjJxejBrbkFxaHhNWDIwQVM2WkdRL1ZhTTNWa0tURWlzVWdGK25peGw4K1pNdms3ODJzVFlRanUzRE5MUERqa0Y4M1BmZnRHMkxYWTlhMmxMZU81QUtYelRSemd4L25GSnY3VkhJUE9QODN2L0gwLzRjaUg1N0F5K2J1R3IzWC9Xdmx0dnNyUDBpOXlBRDJlTzNocExjdUZXUUx5UkxsT0RzSlU2MzIyeTN5UTU2NnJiMzhBTEp2SldoWHdBWlJYbDB3ZE1mNTRiRDVvYi9lNXJUamttbGZLYytVQjMxeGZuVnFXZGJOVW5nU2R3U3RQRW8yd0ozUERvTG9ESFo1OHNlbjF3d3hIK2xMZnpqQk5lWDBIMWFBQlBUMWRBSDVRdXBycHRnTDdhRUc5NlRYQmIrT2wxVHMxbzlXMnAzSjFOa2pJNjR4d1dWUVRwQkU2Y0k4NUdWVmZveXRrVXRIdEV2dXhXeGRaSW9VZFFuODdxUVlnZUFiRlowaWVHWHZyQTh2WXh1WmpLZlI2UGFrM2ZGUGI3RHhYdFBxSDM0VzBLUERrNnJyTkV5TnRkUUIrLy9jTWQwU0pzc2l6UDJzeUlGOWYxdWJia3pwZGpGMjlEcnhhY2lRb21uSVNuNUhVSXh4K0JzRlh5SXdaRVZjblV5bVlLU0RGRndmVkxrMlZ0bGxXWlNGbGJERjBNL29OaEVqRjRzcWVMdWtGQmEwcmJmRjBLMVoyZFFHd2VBSzU1V0c3clNvaFdIeDJ0YjA4SHFxeEdwcGFsS0pJSWpHbHhabC9tcWVocml6SkNVSVc1WUlJSDJGdm5nRDRUR1Z6Qm5sTkRwbG1OOWtta3pKdVFrWnZUTW9ENFFIQS93SlNMNmZ2VnNuYkNPVkNWWTBVL21yb3UxYUx4VFhJQ1NCNEJYSkhEbGxFNjlWMCtucFNmMVF4REtkWW9FWFFPQ0ZpWklkU0xjRWN6ejNOZ1BaRFc5MDRVakJlL0VuWngrc3V3cWh2VE4rWjIxV05BVUw4QUlBY2wxZ3ZwS0RSWFNVQXlFeUJVZ0dBaS80anJWNU9tc0lWMkZOMW1tMEhLc3dnTWxwMGo0T05HUVJBMEFaTm1VTkNqTVpjdmFKMk9tb2tvQXlzbktFalI4bldxVG92MWpKTldOTWsrd3pwNnNRRThJNjE1Y2o3VVZwZDhLcTg2RGJWcHcwSlBnTFFCR3NEWlczbVRFa1BVUmtPYXRSaXA2bmU3UlU3a002VUJ6SFR0b0ZBcUo0ZmlicXR5NElQU1hFeUpNU1VwaU9reENKbGFGMHRHaGtOdzJEV3Zac2VFOUlWQklmOEVxUXNORVNNSGkzTGdHek1obnFGRkVsK1lOdGR3ZUs4eWhlR09ObTBBVFVqZExnNkdUS0phb1AydUI2dXR0MDQ5V3hncjRzaFFBUVh0R2pXcVpTUkwzaXQ2L0llMzRELzA1OWZYMzJXUG1rbVh6dGx5WGRKM3Y3dU9lRURPQWhlU2QwS0lzaU1nUDVLQXBTZzJCS3pJVjZNZjZocm9KN3EvZEJoalhVL2lYMWhoMWxLbSs3ZUptWjA3Zk1MbXZCMCtqcFdmMVFYMEZHeS9JYUlPcVBXM1FtdHVZUnRmM0owbmZqTHQwK3dXNjNjQldQdk01Z0kxVmhtOSsvNUxEVlBQcFFONk1hclZCNys5Q2NWdk5hVVg3Nyt4WDdvVFhJYXV0WkZzQ1ZibXlHMzhxRjFTa2hqaldhcDFodkZ0ZEJONjZQRnZQWVNNcFFuMkRoRk8xTUVqMVJPU0ZsSXNWa1hUZGxrc2NobHZqKzMxTlUyVlNVZlRnYTlCTUVKZUtNenVrNEZzTVpxUFBHbXl3eGlYQkNGbENvdmEyWktHMVRqNDF5NmwveXkzK2lFV3c4QTBKdTVsUzJPaU5oY21OMkw3ZE80aXlHU2NBZnpEMk4zb0FzTk5kN0hZU1BtY0hGZmRla3llSlFJV09FVDIrR2NLWVd2OWFhdFJ5Y2p4d2szZEdCT2hHVTBFVDNZRk9DREFic2ZFaDdRSFJZazB0UWVURnNocUlueHRUQmVhMXRnYzlhMkNrcGYyNFVHOGEwcFBvQ2sweEpFZ1RZb3F0OHcvL3g0T0dZV2JsZU1YUFlDOExrK2tOVTJsZ1Z4WWlGN0VHVEFBdzFkQmowSFI2ZE9Qb0JyWTJiVWcvMWhIY1BaRTcvR1hVd2dEYjJieFEwNCtyRVByN0lPTFlib0tlNjFTTzE5MUczVHNUYk8waU1sRSsxY1JQS1VvM0pOY3JkU0Z1OHZaQk0yMDNlNVRKNDR5MUVsendiZjRvQ3BuNGRFUmdrcVB6NWhEdzIyWlh4Z1ZMdXBUUUtnTThqaTJvS1dSQWpEbllJanRUNEtORVRMR1NkYkRKUXhRZlg2YVdnMlRQd1FvYWpHeHROVmxiTm40UVFzeDQyL0JyeS9UZjJUOGdyQWcvTk1jbVZrakU0TkJqMEJBcXdaeWtMMnA1MHBsNnkxTUF6WHllUEpESFVQTzZmSkVkNUFxNmEwWWpiZ1gvdlNTcEN0SDd4dXJ2d0NxQ0lwbU0xQXRCWkNRS2dEcG9MMVhTQnU3NnJ5KzV1VVQvTUlZMXhuS1EyL2x4aEdhTkk5ekh2ZW40eW1la0FyTlhOZjdycG02QUlQM1hTeDMwcnlDQUFPWTdVVW1uY25BUGtKRVhKbXNjN1BEVDh6dFd1WDJ0ZlJTa2FEYUlyRXR3ODA3MlBmV2NRaVkvUDQwdUJ0UmdSMkN6Tkhlb3pQaDc0UStmbEUvVWxGU1FJa2JkSXNTOFNJaDA3V2xDMlBTVXpaTWN6Z2NDaVBMNGVSVWhSQTBZVFU5Ukk1c25ZdmYyaHpUbEx5dkxCVkxOTllsb29vNDVtN0RORWVSd2FRa1pQbE1jaHRKU05NWjhnZHEvWTNxeHg2WmhpeUxHTjROOHRQbmYwQ3hJaGFxV3I1R1g3TVNqaDVKaW5GQVN6VE9yQVlUNkthT1k1UzRBaHNrZElvd1RvNkRReUlSY3ZZdkJGbjlVL0srVm81YlB2WnJHOU9haDk0QWpsSlFmMEFVbS8rZlJ4UkdMUGlOdFJlajIvSS84TXZFWDJHUDRwRTQybU9SdW1IcTNtb1ZQR24xUytXRldWK3NzbzFVSGl4V2Vac2RtWHVUNno2YjQ4ZHRtUFVwaTAwdHIwVWxPYVpWaVd6bTQvV0gyUnUxY3VxdW4valFuQmF6R1gzQVBKbnZpRjhxOXpFb09JK0M3VU0wV0dpaFB1WTZ0dWpoV1BXRW0zWEo5MXg2S1BPbS9sZG1zZ2hGNWZwcGptSXFjaVpBNS9mMzc1K09MVDdmdWlsQjdlY216RldvLzZ4d1BSRVR2ZEV4eUJUUFAxV3VjQWlHRUswTUloTmFtamRCNDdMOHhhWEh6YmpidTMxTVQ1MmRqaTJxR2V1NHJwZTdjQ3g1ZGsxNzFJelNlTUhOSDZBWSsvSTdXcHg0bUdRVG5FTmRIOVlKYjRkclhxSExTWHhvSHM0dU8wUkN2NmdkYVJ2MTV2YjZraUVQTVVaWStPcHIwSXkrQTNZaEpOejU1UDRNQmRHcHZnUnNUeEZlN3o0ZjBLNHF2SlhBQWIwYzN0b0N4NGRUNWE2U3dqMTNqcDJsU0JwZUVvQmVQSC9wR1UvaUpCMmJwVkx0VDBmWk53UVVkUmZwQkYrRVNVcU82OEU5VlduUnNNd3p3dGR6MEZweW45WmVzTi9BQ2NPcEFMQnIvZ084RzJJYk5hN1Jja0lQWTIzSHNzKzB4UVptZ3prNCtIRi83SytDQ3c3WnhOMVgzU1VhZUROSmZWeHZhTE9MeTRwMjRvZEI2S0x5ZUJLTmV1RUJuYU55ejJCNWJzVHVxNnlTMzM2T01xMEgycXJhNXl5L0ZXM0NVRzN6SUxLd3RaUzhuQVdPVG4zS0FRT0p4bDVGa2R5YzdVQ0tlcDVEcFB0Ti9kMzA1NGQrZDhFb0FHZFdHU0pYRkI2VnBlNjJFejZKeHNGa0hYbXphL3FXZ2lnZmxJLzNsNGZEOXRCck1VcVMrQmo4NGxiTHhYS0NTLzUyMEJLbDArTWNwZWkvQy95eDlTNmFBdlhvV1JYVHU0RDdHS25icDZEODEyNGp6ZFhoMm0vMjQ1TnZVVVR6NWhYQmZ0MEVsZ0hwaHJPZGMydkFxRXVhUUZmZjQ3RVNmdXZGcXRNckNhTVRZU2dzUHdiazVnRnlVUTdDMFk3TnRCeVpHaXRWM202dHFRZmh1THI4Vng5UWhZVGZzU3kxQnRwUHU0eHFJVk9UanlXVUl1VHJkWnlSQ2tIbFlqdXhxQUppaUE0NGZ2RzFuQXowOW42ZEpnMFJTM3ZFdFNMa0RvOGdRZ3pGcVRZZGxjblM2M081QTMrRS9NbVBRQzR4MTIvNi9ydU1yYnJtL3RnbUZuYUp5UnBGdUlIUE40dk9mTzd0a2FZMkg2OHJ1bHhITWFoS3ZNczlWWkRQN2hFejl2NXR1eDIwK0RoNmxHK3hFOUk1WDEraktoanhRZU9DQitWTnFqaE9XaFE1bEtBS1BXY1c1UmRhTFFzYUZsRElUd3U3NVNtKzgzMXhkbXF5cExHT1pDQkpuejYydjc2ajBwY2RCdXRIMjdsb3RYc3FxWXlWK00yYmF2M3BoWVpwLzFKbFpYSGVJU3pZdTM2ZWtMbWVNYUF3aG54cW9WaEtEMUsyWjg4WFhjZ1diNTlBc0N1eWtMZzllSjVpNkhIbkJEL0tYY0ZZQU41N1NXQ05QVzJmWHFNYlBNOGFIL1NYenBVL2ZUcDhRZzhmZlAwdFhweGZISjh2TG5DakxtTmh6YnNXejk0UGpSN1pFeEtEVmo2WnhCODM2SXVRdUpLR1cyenFWZkxVK1c1RGg4T3Vid2E5N2gzeXRYRnRCdmV1TUFWbGVYcUhqRGlsRUFPZUJORVp2elVMV2RUUm42Rkcvd09zT2YvOE1DakZsaGhkWmt4ZVZpNTVkdjd6aG9JKzhuNzN6UE80ZitTUDRPa1YwQUlSVlFiWGx1eWVObW9qdlhNaHBlTGxBLzNRaUJRaGlVelFCSnNIMU9DMnBLLzk3ZzVvN1dvdHdvZ3FRNWhxWlc3VXVZMU8reTNuYXphcUFweFBTY2ZsNlNWVGF0R2FrTHJtV2g1Y2xlVlVqK0hUZmJsb0NmNDRRRjRlUG1nbmoyOXVUcnNNV0RveHE1dmVjcTNHa0poaDF1TFhObmpOMS9NTVh5b25sK3JINXlCcmFtZ2VXSGZ0YVh2aGoxRDVXV2RnNm5uUkh3YnpLeWxiYnAxZHVVcm9oK2N0bE1QbGI5Wm4yYjBCZ2tpL3RMVml6TU1lLzFCdGo2bGJWeE41WW40WWxuUktKWUdhakpGNHoyOCsyQlRUdzdpS1djTzU0YmhIdHU2cjNCNWRwd1BNdXhiR1VlYlY5K2VpT3N1eldDcjF3TGIrT016MXRWVGFQbVVlZDYwWnlkdjV2SFRnL0pPZUxJZkFGZ0FlWGw1aWdmdVRhdGFIcWY2cmFVdkxRQThlZmtsQUh5MjJmZFMyRk50cVZvZ2dJd0JBQUp1ZXpYZ3ZoRDB3ODRnMm90L0RRL3luNjRBMEI3QVg0QVQvQWtEMk9XVVhOWjBGTlJCNmVwVGZCRHdnWnJaOUh3VXNKT1dOcDJjVlM5cytrUkNUeWpVYktmbmdveXNwK2FXdXZtWm5nQTF6K2o1bWVhNXR2YlNNbzZlVHdMbDVQT0JPMGJObjFJbkNzR2g4ZzlETUdkdmFGNW9ESDFJYXNOaGZHcTJ2UHFMWUxyMFl3VDJOZ2QvcmdHVjF1WlAvUzVmZmxXc1UwZjNIT1NZOVdMeldHem1jV1FTVjVobVJ1VUlVeUFMNkRQZDBQd2hMYjhJNW56Uy8yVDQ2K0lKaDVaUDBpWVdRZDlwNCtlR2NrTFFSOTBYdk9ERUlKZ0JGM2lzYytqRUxxYUhJbTBpMENsOTFCbE56VEdwcWo0bG4wNFc4TCtoZEFKVHM0a3FYOTNzVmlrbmFSbkRzZmc3MXYvRXhpVmdqS3c4RXVDazZGWExqT3ZmUERHTzhrVURMdnkyRm4zQk5TUnVHRkFRR0xZN0dVazg1VWtPOXIrTXoydEJYb29KMjhLZzU3ekloeGY1cmovVWFnWEtjbkVNU0lXQ3dNTEluUXd2TndYbDlKd1hhYjRUVEF1cTFlcSs1UE12ZnZXNllRR0Uyd0ZvNElFY3VCR2JrN1BIRU9ZaXlNNldtY1JsckVxSlFXd2lFR3M5Vjk1cm1ueGc1MExabWNjdEV3cXRpMU9XQkZwZWNlM1Ezbm1mdEVuUWRqRE0xcjJOMVdOZFE5RnpydVZTK1BDWWlyd1dBZVpsSFI0Qm9oSWJiMUJMbWJtSVJTMFhJL0c1T0xHYTZ2eXlISFFKekVhV2l6cVhnY2swTU1tTFhEYXlEY2R1SjlpQlF5c01BQWJiSzF3a0lVUVhZMGtWRjBlTFN1ZEpibklKNGpLMVhCUXVnNWk4WkFHNHZPNFM4UG0rSnluU3oyOFZFdDZzcjlQUDNoRFdjb1JWWDJwUjB6Zkt1NVI2UGw5MEZYMFFiSzZwN0dpR0hDZnFSNkxORVBCUlZLeDg1VmEvMG9SNUJSVDFUZEw0b25tclllOFJZemJVT0xQUlg0THZYb2lBVWJNV3c3V3BVNk5XQjhobUlvUVNrSUJVR1E1aU5wN1lhaENIWmxYOEFobzA0SVBvSitXUXUyaFg5RUNDZ043RjZYNThlc0dRM3F4R3BRNWlPQjdyZEplQUdwMW52Ukp0QW54b2VPREZsQXJaK2VSU3VrN0ZLMTB2dkFUMDl2NmVtaldCa0V2elNBd2RhWHdVOG5Obkd3VnF5ZDJQY0RaVGZOM3dMQnIvZzNlTzhyeUYxSStkekVCaFpHSm1ZV1ZqRnlHU2cxT1U2RGNudWZVbGNpbW52QW9xcXNUdEUwbVNxU3BMOFNtUFZGVlVWVTExR3E4YWFxb2xUYm9NbWJMb3N0VldSMTMxMU9mVGtQOGw2ZzkrVTgwMDErS0Y2czMyQi85MmRkWkZWOTEwMTBOUHU4dzJ4MXFMTERUTEZUc2RjY3NOUi9YUzIzSkJkL1J4MDIwUDNIWFBmYi9vNjRtSEhqbW1uNytzOE54VHovVDNtOTh0TU5BQWd3d3gyRkRiRFRQQ2NDT05Nc1pvWTQzenEvRW1tbUNTS1NZN2E0ZHBwcHB1aGxKL0tQQWlJY1RodUx6d0pKQklFc2xrSUlXTXlIY2lKcHgyeGttbnpITW9ackxnVHhkZFNoelpRZ2d4OFVsSVlwSXlHQWxEeGpyOHpSM1lodWFvQjNVMjFhRkNrUXozcFV3SEJyNGg2QkpjWlhWbng0VHJOWkdMNGpycTF1VlZUSEVweXlROWkzb0ZMSkVKKzlGNExGd2QvMFd3dTNoYzlvaGdlUzMvUmJQZDNaYjFqZzZ6dFRJZzRYZVk4cFYvRlJMMjNrUDhhT3BFbmpxVXhYSi9JS201bFkzbDcxNzB0SDBHMndPTmRZdWFVUTA5Q2Z6S2hnN0F2aCs0MlFwS1VSL1IwaHVQMDhzZVZubW9EOUxwOTJNSlNCa3YvY0Frazd4WEh5VjJsazkvenRWRkRBNFpaRlRXNFh2UFRaT3Y3UEJUM2ZrZEhBcEtTU2tINWVsb3hkRHEzYWJvYnYxR0hXbVhSU1pUeXFlRTU3ekxscnhISnpJL0VJS3JBTjlaQUE9PSlcXHJcXG4gICAgZm9ybWF0KCd3b2ZmMicpO1xcclxcbiAgZm9udC13ZWlnaHQ6IDMwMDtcXHJcXG4gIGZvbnQtc3R5bGU6IG5vcm1hbDtcXHJcXG59XFxyXFxuXCJdLFwic291cmNlUm9vdFwiOlwiXCJ9XSk7XG4vLyBFeHBvcnRzXG5leHBvcnQgZGVmYXVsdCBfX19DU1NfTE9BREVSX0VYUE9SVF9fXztcbiIsIi8vIEltcG9ydHNcbmltcG9ydCBfX19DU1NfTE9BREVSX0FQSV9JTVBPUlRfX18gZnJvbSBcIi4uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvY3NzLWxvYWRlci9hcGkuanNcIjtcbnZhciBfX19DU1NfTE9BREVSX0VYUE9SVF9fXyA9IF9fX0NTU19MT0FERVJfQVBJX0lNUE9SVF9fXyh0cnVlKTtcbi8vIE1vZHVsZVxuX19fQ1NTX0xPQURFUl9FWFBPUlRfX18ucHVzaChbbW9kdWxlLmlkLCBcIjpyb290IHtcXHJcXG4gIC0tc3BhY2U6IDFyZW07XFxyXFxuICAtLXNwYWNlLWdyaWQ6IDEuNXJlbTtcXHJcXG4gIC0tc3BhY2UtczogMC44cmVtO1xcclxcbiAgLS1zcGFjZS14czogMC41cmVtO1xcclxcbiAgLS1zcGFjZS1sOiAxLjVyZW07XFxyXFxuICAtLXNwYWNlLXhsOiAzcmVtO1xcclxcbiAgLS1tZW51LXdpZHRoOiA0MDBweDtcXHJcXG59XFxyXFxuXFxyXFxuQG1lZGlhIChtYXgtd2lkdGg6IDgwMHB4KSB7XFxyXFxuICA6cm9vdCB7XFxyXFxuICAgIC0tc3BhY2UtZ3JpZDogMC41cmVtO1xcclxcbiAgfVxcclxcbn1cXHJcXG5cIiwgXCJcIix7XCJ2ZXJzaW9uXCI6MyxcInNvdXJjZXNcIjpbXCJ3ZWJwYWNrOi8vc3R5bGVzL2dyaWQuY3NzXCJdLFwibmFtZXNcIjpbXSxcIm1hcHBpbmdzXCI6XCJBQUFBO0VBQ0UsYUFBYTtFQUNiLG9CQUFvQjtFQUNwQixpQkFBaUI7RUFDakIsa0JBQWtCO0VBQ2xCLGlCQUFpQjtFQUNqQixnQkFBZ0I7RUFDaEIsbUJBQW1CO0FBQ3JCOztBQUVBO0VBQ0U7SUFDRSxvQkFBb0I7RUFDdEI7QUFDRlwiLFwic291cmNlc0NvbnRlbnRcIjpbXCI6cm9vdCB7XFxyXFxuICAtLXNwYWNlOiAxcmVtO1xcclxcbiAgLS1zcGFjZS1ncmlkOiAxLjVyZW07XFxyXFxuICAtLXNwYWNlLXM6IDAuOHJlbTtcXHJcXG4gIC0tc3BhY2UteHM6IDAuNXJlbTtcXHJcXG4gIC0tc3BhY2UtbDogMS41cmVtO1xcclxcbiAgLS1zcGFjZS14bDogM3JlbTtcXHJcXG4gIC0tbWVudS13aWR0aDogNDAwcHg7XFxyXFxufVxcclxcblxcclxcbkBtZWRpYSAobWF4LXdpZHRoOiA4MDBweCkge1xcclxcbiAgOnJvb3Qge1xcclxcbiAgICAtLXNwYWNlLWdyaWQ6IDAuNXJlbTtcXHJcXG4gIH1cXHJcXG59XFxyXFxuXCJdLFwic291cmNlUm9vdFwiOlwiXCJ9XSk7XG4vLyBFeHBvcnRzXG5leHBvcnQgZGVmYXVsdCBfX19DU1NfTE9BREVSX0VYUE9SVF9fXztcbiIsIi8vIEltcG9ydHNcbmltcG9ydCBfX19DU1NfTE9BREVSX0FQSV9JTVBPUlRfX18gZnJvbSBcIi4uLy4uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvY3NzLWxvYWRlci9hcGkuanNcIjtcbnZhciBfX19DU1NfTE9BREVSX0VYUE9SVF9fXyA9IF9fX0NTU19MT0FERVJfQVBJX0lNUE9SVF9fXyh0cnVlKTtcbi8vIE1vZHVsZVxuX19fQ1NTX0xPQURFUl9FWFBPUlRfX18ucHVzaChbbW9kdWxlLmlkLCBcIkAtd2Via2l0LWtleWZyYW1lcyBzcGlubmVyIHtcXHJcXG4gIDAlIHtcXHJcXG4gICAgdHJhbnNmb3JtOiByb3RhdGUoMGRlZyk7XFxyXFxuICB9XFxyXFxuXFxyXFxuICAxMDAlIHtcXHJcXG4gICAgdHJhbnNmb3JtOiByb3RhdGUoMzYwZGVnKTtcXHJcXG4gIH1cXHJcXG59XFxyXFxuQGtleWZyYW1lcyBzcGlubmVyIHtcXHJcXG4gIDAlIHtcXHJcXG4gICAgdHJhbnNmb3JtOiByb3RhdGUoMGRlZyk7XFxyXFxuICB9XFxyXFxuXFxyXFxuICAxMDAlIHtcXHJcXG4gICAgdHJhbnNmb3JtOiByb3RhdGUoMzYwZGVnKTtcXHJcXG4gIH1cXHJcXG59XFxyXFxuXCIsIFwiXCIse1widmVyc2lvblwiOjMsXCJzb3VyY2VzXCI6W1wid2VicGFjazovL3N0eWxlcy9rZXlmcmFtZXMvc3Bpbm5lci5jc3NcIl0sXCJuYW1lc1wiOltdLFwibWFwcGluZ3NcIjpcIkFBQUE7RUFDRTtJQUNFLHVCQUF1QjtFQUN6Qjs7RUFFQTtJQUNFLHlCQUF5QjtFQUMzQjtBQUNGO0FBUkE7RUFDRTtJQUNFLHVCQUF1QjtFQUN6Qjs7RUFFQTtJQUNFLHlCQUF5QjtFQUMzQjtBQUNGXCIsXCJzb3VyY2VzQ29udGVudFwiOltcIkBrZXlmcmFtZXMgc3Bpbm5lciB7XFxyXFxuICAwJSB7XFxyXFxuICAgIHRyYW5zZm9ybTogcm90YXRlKDBkZWcpO1xcclxcbiAgfVxcclxcblxcclxcbiAgMTAwJSB7XFxyXFxuICAgIHRyYW5zZm9ybTogcm90YXRlKDM2MGRlZyk7XFxyXFxuICB9XFxyXFxufVxcclxcblwiXSxcInNvdXJjZVJvb3RcIjpcIlwifV0pO1xuLy8gRXhwb3J0c1xuZXhwb3J0IGRlZmF1bHQgX19fQ1NTX0xPQURFUl9FWFBPUlRfX187XG4iLCIvLyBJbXBvcnRzXG5pbXBvcnQgX19fQ1NTX0xPQURFUl9BUElfSU1QT1JUX19fIGZyb20gXCIuLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NvbXBpbGVkL2Nzcy1sb2FkZXIvYXBpLmpzXCI7XG52YXIgX19fQ1NTX0xPQURFUl9FWFBPUlRfX18gPSBfX19DU1NfTE9BREVSX0FQSV9JTVBPUlRfX18odHJ1ZSk7XG4vLyBNb2R1bGVcbl9fX0NTU19MT0FERVJfRVhQT1JUX19fLnB1c2goW21vZHVsZS5pZCwgXCIvKiBCb3ggc2l6aW5nIHJ1bGVzICovXFxyXFxuKixcXHJcXG4qOjpiZWZvcmUsXFxyXFxuKjo6YWZ0ZXIge1xcclxcbiAgYm94LXNpemluZzogYm9yZGVyLWJveDtcXHJcXG59XFxyXFxuXFxyXFxuLyogUmVtb3ZlIGRlZmF1bHQgcGFkZGluZyAqL1xcclxcbnVsW2NsYXNzXSxcXHJcXG5vbFtjbGFzc10ge1xcclxcbiAgcGFkZGluZzogMDtcXHJcXG59XFxyXFxuXFxyXFxuLyogUmVtb3ZlIGRlZmF1bHQgbWFyZ2luICovXFxyXFxuYm9keSxcXHJcXG5oMSxcXHJcXG5oMixcXHJcXG5oMyxcXHJcXG5oNCxcXHJcXG5wLFxcclxcbnVsW2NsYXNzXSxcXHJcXG5vbFtjbGFzc10sXFxyXFxubGksXFxyXFxuZmlndXJlLFxcclxcbmZpZ2NhcHRpb24sXFxyXFxuYmxvY2txdW90ZSxcXHJcXG5kbCxcXHJcXG5kZCB7XFxyXFxuICBtYXJnaW46IDA7XFxyXFxufVxcclxcblxcclxcbi8qIFNldCBjb3JlIGJvZHkgZGVmYXVsdHMgKi9cXHJcXG5ib2R5IHtcXHJcXG4gIG1pbi1oZWlnaHQ6IDEwMHZoO1xcclxcbiAgc2Nyb2xsLWJlaGF2aW9yOiBzbW9vdGg7XFxyXFxuICB0ZXh0LXJlbmRlcmluZzogb3B0aW1pemVTcGVlZDtcXHJcXG4gIGxpbmUtaGVpZ2h0OiAxLjU7XFxyXFxufVxcclxcblxcclxcbi8qIFJlbW92ZSBsaXN0IHN0eWxlcyBvbiB1bCwgb2wgZWxlbWVudHMgd2l0aCBhIGNsYXNzIGF0dHJpYnV0ZSAqL1xcclxcbnVsW2NsYXNzXSxcXHJcXG5vbFtjbGFzc10ge1xcclxcbiAgbGlzdC1zdHlsZTogbm9uZTtcXHJcXG59XFxyXFxuXFxyXFxuLyogQSBlbGVtZW50cyB0aGF0IGRvbid0IGhhdmUgYSBjbGFzcyBnZXQgZGVmYXVsdCBzdHlsZXMgKi9cXHJcXG5hOm5vdChbY2xhc3NdKSB7XFxyXFxuICAtd2Via2l0LXRleHQtZGVjb3JhdGlvbi1za2lwOiBpbms7XFxyXFxuICAgICAgICAgIHRleHQtZGVjb3JhdGlvbi1za2lwLWluazogYXV0bztcXHJcXG59XFxyXFxuXFxyXFxuLyogTWFrZSBpbWFnZXMgZWFzaWVyIHRvIHdvcmsgd2l0aCAqL1xcclxcbmltZyB7XFxyXFxuICBtYXgtd2lkdGg6IDEwMCU7XFxyXFxuICBkaXNwbGF5OiBibG9jaztcXHJcXG59XFxyXFxuXFxyXFxuLyogTmF0dXJhbCBmbG93IGFuZCByaHl0aG0gaW4gYXJ0aWNsZXMgYnkgZGVmYXVsdCAqL1xcclxcbi8qYXJ0aWNsZSA+ICogKyAqIHtcXHJcXG4gIG1hcmdpbi10b3A6IDFlbTtcXHJcXG59Ki9cXHJcXG5cXHJcXG4vKiBJbmhlcml0IGZvbnRzIGZvciBpbnB1dHMgYW5kIGJ1dHRvbnMgKi9cXHJcXG5pbnB1dCxcXHJcXG5idXR0b24sXFxyXFxudGV4dGFyZWEsXFxyXFxuc2VsZWN0IHtcXHJcXG4gIGZvbnQ6IGluaGVyaXQ7XFxyXFxufVxcclxcblxcclxcbmlucHV0W3R5cGU9J251bWJlciddIHtcXHJcXG4gIC1tb3otYXBwZWFyYW5jZTogdGV4dGZpZWxkO1xcclxcbn1cXHJcXG5cXHJcXG4vKiBSZW1vdmUgYWxsIGFuaW1hdGlvbnMgYW5kIHRyYW5zaXRpb25zIGZvciBwZW9wbGUgdGhhdCBwcmVmZXIgbm90IHRvIHNlZSB0aGVtICovXFxyXFxuQG1lZGlhIChwcmVmZXJzLXJlZHVjZWQtbW90aW9uOiByZWR1Y2UpIHtcXHJcXG4gICoge1xcclxcbiAgICAtd2Via2l0LWFuaW1hdGlvbi1kdXJhdGlvbjogMC4wMW1zICFpbXBvcnRhbnQ7XFxyXFxuICAgICAgICAgICAgYW5pbWF0aW9uLWR1cmF0aW9uOiAwLjAxbXMgIWltcG9ydGFudDtcXHJcXG4gICAgLXdlYmtpdC1hbmltYXRpb24taXRlcmF0aW9uLWNvdW50OiAxICFpbXBvcnRhbnQ7XFxyXFxuICAgICAgICAgICAgYW5pbWF0aW9uLWl0ZXJhdGlvbi1jb3VudDogMSAhaW1wb3J0YW50O1xcclxcbiAgICB0cmFuc2l0aW9uLWR1cmF0aW9uOiAwLjAxbXMgIWltcG9ydGFudDtcXHJcXG4gICAgc2Nyb2xsLWJlaGF2aW9yOiBhdXRvICFpbXBvcnRhbnQ7XFxyXFxuICB9XFxyXFxufVxcclxcblwiLCBcIlwiLHtcInZlcnNpb25cIjozLFwic291cmNlc1wiOltcIndlYnBhY2s6Ly9zdHlsZXMvcmVzZXQuY3NzXCJdLFwibmFtZXNcIjpbXSxcIm1hcHBpbmdzXCI6XCJBQUFBLHFCQUFxQjtBQUNyQjs7O0VBR0Usc0JBQXNCO0FBQ3hCOztBQUVBLDJCQUEyQjtBQUMzQjs7RUFFRSxVQUFVO0FBQ1o7O0FBRUEsMEJBQTBCO0FBQzFCOzs7Ozs7Ozs7Ozs7OztFQWNFLFNBQVM7QUFDWDs7QUFFQSwyQkFBMkI7QUFDM0I7RUFDRSxpQkFBaUI7RUFDakIsdUJBQXVCO0VBQ3ZCLDZCQUE2QjtFQUM3QixnQkFBZ0I7QUFDbEI7O0FBRUEsaUVBQWlFO0FBQ2pFOztFQUVFLGdCQUFnQjtBQUNsQjs7QUFFQSwwREFBMEQ7QUFDMUQ7RUFDRSxpQ0FBOEI7VUFBOUIsOEJBQThCO0FBQ2hDOztBQUVBLG9DQUFvQztBQUNwQztFQUNFLGVBQWU7RUFDZixjQUFjO0FBQ2hCOztBQUVBLG1EQUFtRDtBQUNuRDs7RUFFRTs7QUFFRix5Q0FBeUM7QUFDekM7Ozs7RUFJRSxhQUFhO0FBQ2Y7O0FBRUE7RUFDRSwwQkFBMEI7QUFDNUI7O0FBRUEsaUZBQWlGO0FBQ2pGO0VBQ0U7SUFDRSw2Q0FBcUM7WUFBckMscUNBQXFDO0lBQ3JDLCtDQUF1QztZQUF2Qyx1Q0FBdUM7SUFDdkMsc0NBQXNDO0lBQ3RDLGdDQUFnQztFQUNsQztBQUNGXCIsXCJzb3VyY2VzQ29udGVudFwiOltcIi8qIEJveCBzaXppbmcgcnVsZXMgKi9cXHJcXG4qLFxcclxcbio6OmJlZm9yZSxcXHJcXG4qOjphZnRlciB7XFxyXFxuICBib3gtc2l6aW5nOiBib3JkZXItYm94O1xcclxcbn1cXHJcXG5cXHJcXG4vKiBSZW1vdmUgZGVmYXVsdCBwYWRkaW5nICovXFxyXFxudWxbY2xhc3NdLFxcclxcbm9sW2NsYXNzXSB7XFxyXFxuICBwYWRkaW5nOiAwO1xcclxcbn1cXHJcXG5cXHJcXG4vKiBSZW1vdmUgZGVmYXVsdCBtYXJnaW4gKi9cXHJcXG5ib2R5LFxcclxcbmgxLFxcclxcbmgyLFxcclxcbmgzLFxcclxcbmg0LFxcclxcbnAsXFxyXFxudWxbY2xhc3NdLFxcclxcbm9sW2NsYXNzXSxcXHJcXG5saSxcXHJcXG5maWd1cmUsXFxyXFxuZmlnY2FwdGlvbixcXHJcXG5ibG9ja3F1b3RlLFxcclxcbmRsLFxcclxcbmRkIHtcXHJcXG4gIG1hcmdpbjogMDtcXHJcXG59XFxyXFxuXFxyXFxuLyogU2V0IGNvcmUgYm9keSBkZWZhdWx0cyAqL1xcclxcbmJvZHkge1xcclxcbiAgbWluLWhlaWdodDogMTAwdmg7XFxyXFxuICBzY3JvbGwtYmVoYXZpb3I6IHNtb290aDtcXHJcXG4gIHRleHQtcmVuZGVyaW5nOiBvcHRpbWl6ZVNwZWVkO1xcclxcbiAgbGluZS1oZWlnaHQ6IDEuNTtcXHJcXG59XFxyXFxuXFxyXFxuLyogUmVtb3ZlIGxpc3Qgc3R5bGVzIG9uIHVsLCBvbCBlbGVtZW50cyB3aXRoIGEgY2xhc3MgYXR0cmlidXRlICovXFxyXFxudWxbY2xhc3NdLFxcclxcbm9sW2NsYXNzXSB7XFxyXFxuICBsaXN0LXN0eWxlOiBub25lO1xcclxcbn1cXHJcXG5cXHJcXG4vKiBBIGVsZW1lbnRzIHRoYXQgZG9uJ3QgaGF2ZSBhIGNsYXNzIGdldCBkZWZhdWx0IHN0eWxlcyAqL1xcclxcbmE6bm90KFtjbGFzc10pIHtcXHJcXG4gIHRleHQtZGVjb3JhdGlvbi1za2lwLWluazogYXV0bztcXHJcXG59XFxyXFxuXFxyXFxuLyogTWFrZSBpbWFnZXMgZWFzaWVyIHRvIHdvcmsgd2l0aCAqL1xcclxcbmltZyB7XFxyXFxuICBtYXgtd2lkdGg6IDEwMCU7XFxyXFxuICBkaXNwbGF5OiBibG9jaztcXHJcXG59XFxyXFxuXFxyXFxuLyogTmF0dXJhbCBmbG93IGFuZCByaHl0aG0gaW4gYXJ0aWNsZXMgYnkgZGVmYXVsdCAqL1xcclxcbi8qYXJ0aWNsZSA+ICogKyAqIHtcXHJcXG4gIG1hcmdpbi10b3A6IDFlbTtcXHJcXG59Ki9cXHJcXG5cXHJcXG4vKiBJbmhlcml0IGZvbnRzIGZvciBpbnB1dHMgYW5kIGJ1dHRvbnMgKi9cXHJcXG5pbnB1dCxcXHJcXG5idXR0b24sXFxyXFxudGV4dGFyZWEsXFxyXFxuc2VsZWN0IHtcXHJcXG4gIGZvbnQ6IGluaGVyaXQ7XFxyXFxufVxcclxcblxcclxcbmlucHV0W3R5cGU9J251bWJlciddIHtcXHJcXG4gIC1tb3otYXBwZWFyYW5jZTogdGV4dGZpZWxkO1xcclxcbn1cXHJcXG5cXHJcXG4vKiBSZW1vdmUgYWxsIGFuaW1hdGlvbnMgYW5kIHRyYW5zaXRpb25zIGZvciBwZW9wbGUgdGhhdCBwcmVmZXIgbm90IHRvIHNlZSB0aGVtICovXFxyXFxuQG1lZGlhIChwcmVmZXJzLXJlZHVjZWQtbW90aW9uOiByZWR1Y2UpIHtcXHJcXG4gICoge1xcclxcbiAgICBhbmltYXRpb24tZHVyYXRpb246IDAuMDFtcyAhaW1wb3J0YW50O1xcclxcbiAgICBhbmltYXRpb24taXRlcmF0aW9uLWNvdW50OiAxICFpbXBvcnRhbnQ7XFxyXFxuICAgIHRyYW5zaXRpb24tZHVyYXRpb246IDAuMDFtcyAhaW1wb3J0YW50O1xcclxcbiAgICBzY3JvbGwtYmVoYXZpb3I6IGF1dG8gIWltcG9ydGFudDtcXHJcXG4gIH1cXHJcXG59XFxyXFxuXCJdLFwic291cmNlUm9vdFwiOlwiXCJ9XSk7XG4vLyBFeHBvcnRzXG5leHBvcnQgZGVmYXVsdCBfX19DU1NfTE9BREVSX0VYUE9SVF9fXztcbiIsIi8vIEltcG9ydHNcbmltcG9ydCBfX19DU1NfTE9BREVSX0FQSV9JTVBPUlRfX18gZnJvbSBcIi4uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvY3NzLWxvYWRlci9hcGkuanNcIjtcbnZhciBfX19DU1NfTE9BREVSX0VYUE9SVF9fXyA9IF9fX0NTU19MT0FERVJfQVBJX0lNUE9SVF9fXyh0cnVlKTtcbi8vIE1vZHVsZVxuX19fQ1NTX0xPQURFUl9FWFBPUlRfX18ucHVzaChbbW9kdWxlLmlkLCBcIjpyb290IHtcXG4gIC0tZnM6IDFyZW07XFxuICAtLWZzLXNtYWxsOiAwLjlyZW07XFxuICAtLWZzLXhzbWFsbDogMC43cmVtO1xcbiAgLS1mcy1iaWc6IDEuMnJlbTtcXG59XFxuXFxuaHRtbCB7XFxuICAvL2ZvbnQtc2l6ZTogMnZtaW47XFxufVxcblxcbmJvZHkge1xcbiAgZm9udC1mYW1pbHk6IEFmZm9nYXRvLCBzYW5zLXNlcmlmO1xcbiAgZm9udC13ZWlnaHQ6IDQwMDtcXG4gIGZvbnQtc2l6ZTogMTAwJTtcXG4gIGxpbmUtaGVpZ2h0OiAxLjQ7XFxuICBjb2xvcjogdmFyKC0tYy1wKTtcXG59XFxuXFxuYiB7XFxuICBmb250LXdlaWdodDogNzAwO1xcbn1cXG5cXG5oMSxcXG5oMixcXG5oMyB7XFxuICBmb250LWZhbWlseTogQWZmb2dhdG8sIHNhbnMtc2VyaWY7XFxuICBmb250LXdlaWdodDogNzAwO1xcbiAgbGluZS1oZWlnaHQ6IDEuMTtcXG4gIGZvbnQtc2l6ZTogMS44ZW07XFxufVxcblxcbmgyIHtcXG4gIGZvbnQtc2l6ZTogMS41ZW07XFxufVxcblxcbmgzIHtcXG4gIGZvbnQtc2l6ZTogMS4yZW07XFxufVxcblxcbi8qIGJ1dHRvbiByZXNldCAqL1xcbmJ1dHRvbiB7XFxuICBiYWNrZ3JvdW5kLWNvbG9yOiB0cmFuc3BhcmVudDtcXG4gIGJvcmRlcjogbm9uZTtcXG4gIHBhZGRpbmc6IDA7XFxufVxcblxcbmEge1xcbiAgY29sb3I6IHZhcigtLWMtcHJpbWFyeSk7XFxufVxcblxcbi5mcy0tc21hbGwge1xcbiAgZm9udC1zaXplOiAwLjlyZW07XFxuICBmb250LXNpemU6IHZhcigtLWZzLXNtYWxsKTtcXG59XFxuXFxuLmZzLS14c21hbGwge1xcbiAgZm9udC1zaXplOiAwLjdyZW07XFxuICBmb250LXNpemU6IHZhcigtLWZzLXhzbWFsbCk7XFxufVxcblwiLCBcIlwiLHtcInZlcnNpb25cIjozLFwic291cmNlc1wiOltcIndlYnBhY2s6Ly9zdHlsZXMvdHlwb2dyYXBoeS5jc3NcIl0sXCJuYW1lc1wiOltdLFwibWFwcGluZ3NcIjpcIkFBQUE7RUFDRSxVQUFVO0VBQ1Ysa0JBQWtCO0VBQ2xCLG1CQUFtQjtFQUNuQixnQkFBZ0I7QUFDbEI7O0FBRUE7RUFDRSxrQkFBa0I7QUFDcEI7O0FBRUE7RUFDRSxpQ0FBaUM7RUFDakMsZ0JBQWdCO0VBQ2hCLGVBQWU7RUFDZixnQkFBZ0I7RUFDaEIsaUJBQWlCO0FBQ25COztBQUVBO0VBQ0UsZ0JBQWdCO0FBQ2xCOztBQUVBOzs7RUFHRSxpQ0FBaUM7RUFDakMsZ0JBQWdCO0VBQ2hCLGdCQUFnQjtFQUNoQixnQkFBZ0I7QUFDbEI7O0FBRUE7RUFDRSxnQkFBZ0I7QUFDbEI7O0FBRUE7RUFDRSxnQkFBZ0I7QUFDbEI7O0FBRUEsaUJBQWlCO0FBQ2pCO0VBQ0UsNkJBQTZCO0VBQzdCLFlBQVk7RUFDWixVQUFVO0FBQ1o7O0FBRUE7RUFDRSx1QkFBdUI7QUFDekI7O0FBRUE7RUFDRSxpQkFBMEI7RUFBMUIsMEJBQTBCO0FBQzVCOztBQUVBO0VBQ0UsaUJBQTJCO0VBQTNCLDJCQUEyQjtBQUM3QlwiLFwic291cmNlc0NvbnRlbnRcIjpbXCI6cm9vdCB7XFxuICAtLWZzOiAxcmVtO1xcbiAgLS1mcy1zbWFsbDogMC45cmVtO1xcbiAgLS1mcy14c21hbGw6IDAuN3JlbTtcXG4gIC0tZnMtYmlnOiAxLjJyZW07XFxufVxcblxcbmh0bWwge1xcbiAgLy9mb250LXNpemU6IDJ2bWluO1xcbn1cXG5cXG5ib2R5IHtcXG4gIGZvbnQtZmFtaWx5OiBBZmZvZ2F0bywgc2Fucy1zZXJpZjtcXG4gIGZvbnQtd2VpZ2h0OiA0MDA7XFxuICBmb250LXNpemU6IDEwMCU7XFxuICBsaW5lLWhlaWdodDogMS40O1xcbiAgY29sb3I6IHZhcigtLWMtcCk7XFxufVxcblxcbmIge1xcbiAgZm9udC13ZWlnaHQ6IDcwMDtcXG59XFxuXFxuaDEsXFxuaDIsXFxuaDMge1xcbiAgZm9udC1mYW1pbHk6IEFmZm9nYXRvLCBzYW5zLXNlcmlmO1xcbiAgZm9udC13ZWlnaHQ6IDcwMDtcXG4gIGxpbmUtaGVpZ2h0OiAxLjE7XFxuICBmb250LXNpemU6IDEuOGVtO1xcbn1cXG5cXG5oMiB7XFxuICBmb250LXNpemU6IDEuNWVtO1xcbn1cXG5cXG5oMyB7XFxuICBmb250LXNpemU6IDEuMmVtO1xcbn1cXG5cXG4vKiBidXR0b24gcmVzZXQgKi9cXG5idXR0b24ge1xcbiAgYmFja2dyb3VuZC1jb2xvcjogdHJhbnNwYXJlbnQ7XFxuICBib3JkZXI6IG5vbmU7XFxuICBwYWRkaW5nOiAwO1xcbn1cXG5cXG5hIHtcXG4gIGNvbG9yOiB2YXIoLS1jLXByaW1hcnkpO1xcbn1cXG5cXG4uZnMtLXNtYWxsIHtcXG4gIGZvbnQtc2l6ZTogdmFyKC0tZnMtc21hbGwpO1xcbn1cXG5cXG4uZnMtLXhzbWFsbCB7XFxuICBmb250LXNpemU6IHZhcigtLWZzLXhzbWFsbCk7XFxufVxcblwiXSxcInNvdXJjZVJvb3RcIjpcIlwifV0pO1xuLy8gRXhwb3J0c1xuZXhwb3J0IGRlZmF1bHQgX19fQ1NTX0xPQURFUl9FWFBPUlRfX187XG4iLCIvLyBJbXBvcnRzXG5pbXBvcnQgX19fQ1NTX0xPQURFUl9BUElfSU1QT1JUX19fIGZyb20gXCIuLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NvbXBpbGVkL2Nzcy1sb2FkZXIvYXBpLmpzXCI7XG52YXIgX19fQ1NTX0xPQURFUl9FWFBPUlRfX18gPSBfX19DU1NfTE9BREVSX0FQSV9JTVBPUlRfX18odHJ1ZSk7XG4vLyBNb2R1bGVcbl9fX0NTU19MT0FERVJfRVhQT1JUX19fLnB1c2goW21vZHVsZS5pZCwgXCI6cm9vdCB7XFxyXFxuICAgIC0tcy1uZWFyOiAxMHM7XFxyXFxuICAgIC0tcy1taWQ6IGNhbGModmFyKC0tcy1uZWFyKSAqIDIpO1xcclxcbiAgICAtLXMtZmFyOiBjYWxjKHZhcigtLXMtbmVhcikgKiAzKTtcXHJcXG4gICAgLS1lYXNlLW91dC1xdWFkOiBjdWJpYy1iZXppZXIoLjI1LCAuNDYsIC40NTAsIC45NCk7XFxyXFxuICAgIC0tZm9ybS1pbnB1dC1ib3JkZXItcmFkaXVzOiA0cHg7XFxyXFxufVwiLCBcIlwiLHtcInZlcnNpb25cIjozLFwic291cmNlc1wiOltcIndlYnBhY2s6Ly9zdHlsZXMvdmFycy5jc3NcIl0sXCJuYW1lc1wiOltdLFwibWFwcGluZ3NcIjpcIkFBQUE7SUFDSSxhQUFhO0lBQ2IsZ0NBQWdDO0lBQ2hDLGdDQUFnQztJQUNoQyxrREFBa0Q7SUFDbEQsK0JBQStCO0FBQ25DXCIsXCJzb3VyY2VzQ29udGVudFwiOltcIjpyb290IHtcXHJcXG4gICAgLS1zLW5lYXI6IDEwcztcXHJcXG4gICAgLS1zLW1pZDogY2FsYyh2YXIoLS1zLW5lYXIpICogMik7XFxyXFxuICAgIC0tcy1mYXI6IGNhbGModmFyKC0tcy1uZWFyKSAqIDMpO1xcclxcbiAgICAtLWVhc2Utb3V0LXF1YWQ6IGN1YmljLWJlemllciguMjUsIC40NiwgLjQ1MCwgLjk0KTtcXHJcXG4gICAgLS1mb3JtLWlucHV0LWJvcmRlci1yYWRpdXM6IDRweDtcXHJcXG59XCJdLFwic291cmNlUm9vdFwiOlwiXCJ9XSk7XG4vLyBFeHBvcnRzXG5leHBvcnQgZGVmYXVsdCBfX19DU1NfTE9BREVSX0VYUE9SVF9fXztcbiIsIi8vIEltcG9ydHNcbnZhciBfX19DU1NfTE9BREVSX0FQSV9JTVBPUlRfX18gPSByZXF1aXJlKFwiLi4vLi4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jb21waWxlZC9jc3MtbG9hZGVyL2FwaS5qc1wiKTtcbnZhciBfX19DU1NfTE9BREVSX0VYUE9SVF9fXyA9IF9fX0NTU19MT0FERVJfQVBJX0lNUE9SVF9fXyh0cnVlKTtcbi8vIE1vZHVsZVxuX19fQ1NTX0xPQURFUl9FWFBPUlRfX18ucHVzaChbbW9kdWxlLmlkLCBcIi5CdXR0b25fcm9vdF9fOXV0QWgge1xcbiAgICBjdXJzb3I6IHBvaW50ZXI7XFxuICAgIGZvbnQtd2VpZ2h0OiA3MDA7XFxuICAgIHBhZGRpbmc6IDAuNWVtIDFlbTtcXG4gICAgcG9zaXRpb246IHJlbGF0aXZlO1xcbiAgICBjb2xvcjogdmFyKC0tYy1wKTtcXG4gICAgYmFja2dyb3VuZC1jb2xvcjogY3VycmVudENvbG9yO1xcbiAgICBib3JkZXI6IDFweCBzb2xpZCBjdXJyZW50Q29sb3I7XFxuICAgIGRpc3BsYXk6IGZsZXg7XFxuICAgIGFsaWduLWl0ZW1zOiBjZW50ZXI7XFxuICAgIHRyYW5zaXRpb246IGFsbCAyMDBtcyBlYXNlLWluLW91dFxcbn1cXG5cXG5cXG4uQnV0dG9uX3Jvb3RfXzl1dEFoOmhvdmVyIHtcXG4gICAgLy9iYWNrZ3JvdW5kLWNvbG9yOiB2YXIoLS1jLWhlbGxncmF1KTtcXG4gICAgfVxcblxcblxcbi5CdXR0b25fcm9vdF9fOXV0QWg6Zm9jdXMge1xcbiAgICAgICAgb3V0bGluZTogbm9uZTtcXG4gICAgICAgIGJveC1zaGFkb3c6IDAgMCAwIDNweCByZ2JhKDY2LCAxNTMsIDIyNSwgMC41KTtcXG4gICAgfVxcblxcblxcbi5CdXR0b25fZm9udFdlaWdodC1ub3JtYWxfX3FtRktaIHtcXG4gICAgZm9udC13ZWlnaHQ6IG5vcm1hbDtcXG59XFxuXFxuLkJ1dHRvbl96ZXJvcGFkZGluZ19fMjAzV2sge1xcbiAgICBwYWRkaW5nOiAwIDA7XFxufVxcblxcbi5CdXR0b25faWNvbl9fMTVYMTUge1xcbiAgICBjb2xvcjogI2ZmZjtcXG4gICAgd2lsbC1jaGFuZ2U6IG9wYWNpdHk7XFxuICAgIHRyYW5zaXRpb246IG9wYWNpdHkgMjAwbXMgZWFzZS1pbi1vdXQ7XFxuICAgIHRyYW5zZm9ybTogc2NhbGUoMS4zKTtcXG59XFxuXFxuLkJ1dHRvbl9pY29uTGVmdF9fM2N4d1Qge1xcbiAgICBtYXJnaW4tcmlnaHQ6IDAuNmVtO1xcbn1cXG5cXG4uQnV0dG9uX2ljb25SaWdodF9fcl81dngge1xcbiAgICBtYXJnaW4tbGVmdDogMC42ZW07XFxufVxcblxcbi5CdXR0b25fdHlwZS1naG9zdF9fMnBnWC0sXFxuLkJ1dHRvbl90eXBlLWVtcHR5X18zWkpGeCB7XFxuICAgIGJhY2tncm91bmQtY29sb3I6IHRyYW5zcGFyZW50O1xcblxcbiAgICAuQnV0dG9uX2NvbnRlbnRfXzNHWWxhLCAuQnV0dG9uX2ljb25fXzE1WDE1LCAuQnV0dG9uX2xvYWRlcl9fMmlnNnEge1xcbiAgICAgICAgY29sb3I6IGN1cnJlbnRDb2xvcjtcXG4gICAgfVxcbn1cXG5cXG4uQnV0dG9uX3R5cGUtZW1wdHlfXzNaSkZ4IHtcXG4gICAgYm9yZGVyOiBub25lO1xcbn1cXG5cXG4uQnV0dG9uX3NpemUtc21hbGxfXzNwWm5hIHtcXG4gICAgZm9udC1zaXplOiAwLjhyZW07XFxufVxcblxcbi5CdXR0b25fc2l6ZS1sYXJnZV9fM1h2R3oge1xcbiAgICBmb250LXNpemU6IDEuMnJlbTtcXG59XFxuXFxuXFxuLkJ1dHRvbl9pc1JvdW5kX18xMkdBRSB7XFxuICAgIGJvcmRlci1yYWRpdXM6IDVyZW07XFxufVxcblxcbi5CdXR0b25faXNEaXNhYmxlZF9fM2V6Q0Ige1xcbiAgICBwb2ludGVyLWV2ZW50czogbm9uZTtcXG4gICAgb3BhY2l0eTogMC44O1xcbn1cXG5cXG5cXG4uQnV0dG9uX2xvYWRlcl9fMmlnNnEge1xcbiAgICBwb3NpdGlvbjogYWJzb2x1dGU7XFxuICAgIGxlZnQ6IDUwJTtcXG4gICAgdG9wOiA1MCU7XFxuICAgIHRyYW5zZm9ybTogdHJhbnNsYXRlWCgtNTAlKSB0cmFuc2xhdGVZKC01MCUpO1xcbiAgICB3aWR0aDogMWVtO1xcbiAgICBoZWlnaHQ6IDFlbTtcXG4gICAgY29sb3I6ICNmZmY7XFxuICAgIG9wYWNpdHk6IDA7XFxuICAgIHdpbGwtY2hhbmdlOiBvcGFjaXR5O1xcbiAgICB0cmFuc2l0aW9uOiBvcGFjaXR5IDIwMG1zIGVhc2UtaW4tb3V0O1xcbiAgICBwb2ludGVyLWV2ZW50czogbm9uZTtcXG59XFxuXFxuLkJ1dHRvbl9jb250ZW50X18zR1lsYSB7XFxuICAgIHBvc2l0aW9uOiByZWxhdGl2ZTtcXG4gICAgei1pbmRleDogMTtcXG4gICAgY29sb3I6ICNmZmY7XFxuICAgIG9wYWNpdHk6IDE7XFxuICAgIHdpbGwtY2hhbmdlOiBvcGFjaXR5O1xcbiAgICB0cmFuc2l0aW9uOiBvcGFjaXR5IDIwMG1zIGVhc2UtaW4tb3V0O1xcbn1cXG5cXG4uQnV0dG9uX2lzTG9hZGluZ19fMUpuc2sge1xcbiAgICAuQnV0dG9uX2xvYWRlcl9fMmlnNnEge1xcbiAgICAgICAgb3BhY2l0eTogMTtcXG4gICAgfVxcblxcbiAgICAuQnV0dG9uX2NvbnRlbnRfXzNHWWxhLFxcbiAgICAuQnV0dG9uX2ljb25fXzE1WDE1IHtcXG4gICAgICAgIG9wYWNpdHk6IDA7XFxuICAgIH1cXG59XFxuXFxuLkJ1dHRvbl9jb2xvci1yZWRfXzJGMXE3IHtcXG4gICAgY29sb3I6IHZhcigtLWMtcHJpbWFyeSk7XFxufVxcblwiLCBcIlwiLHtcInZlcnNpb25cIjozLFwic291cmNlc1wiOltcIndlYnBhY2s6Ly90aGVtZS9CdXR0b24vQnV0dG9uLm1vZHVsZS5jc3NcIixcIndlYnBhY2s6Ly9zdHlsZXMvbWl4aW5zL2ExMXktZm9jdXMuY3NzXCJdLFwibmFtZXNcIjpbXSxcIm1hcHBpbmdzXCI6XCJBQUFBO0lBQ0ksZUFBZTtJQUNmLGdCQUFnQjtJQUNoQixrQkFBa0I7SUFDbEIsa0JBQWtCO0lBQ2xCLGlCQUFpQjtJQUNqQiw4QkFBOEI7SUFDOUIsOEJBQThCO0lBQzlCLGFBQWE7SUFDYixtQkFBbUI7SUFDbkI7QUFTSjs7O0FBUEk7SUFDQSxxQ0FBcUM7SUFDckM7OztBQUVBO1FDZkYsYUFBYTtRQUNiLDZDQUE2QztJRGdCM0M7OztBQUlKO0lBQ0ksbUJBQW1CO0FBQ3ZCOztBQUVBO0lBQ0ksWUFBWTtBQUNoQjs7QUFFQTtJQUNJLFdBQVc7SUFDWCxvQkFBb0I7SUFDcEIscUNBQXFDO0lBQ3JDLHFCQUFxQjtBQUN6Qjs7QUFFQTtJQUNJLG1CQUFtQjtBQUN2Qjs7QUFFQTtJQUNJLGtCQUFrQjtBQUN0Qjs7QUFFQTs7SUFFSSw2QkFBNkI7O0lBRTdCO1FBQ0ksbUJBQW1CO0lBQ3ZCO0FBQ0o7O0FBRUE7SUFDSSxZQUFZO0FBQ2hCOztBQUVBO0lBQ0ksaUJBQWlCO0FBQ3JCOztBQUVBO0lBQ0ksaUJBQWlCO0FBQ3JCOzs7QUFHQTtJQUNJLG1CQUFtQjtBQUN2Qjs7QUFFQTtJQUNJLG9CQUFvQjtJQUNwQixZQUFZO0FBQ2hCOzs7QUFHQTtJQUNJLGtCQUFrQjtJQUNsQixTQUFTO0lBQ1QsUUFBUTtJQUNSLDRDQUE0QztJQUM1QyxVQUFVO0lBQ1YsV0FBVztJQUNYLFdBQVc7SUFDWCxVQUFVO0lBQ1Ysb0JBQW9CO0lBQ3BCLHFDQUFxQztJQUNyQyxvQkFBb0I7QUFDeEI7O0FBRUE7SUFDSSxrQkFBa0I7SUFDbEIsVUFBVTtJQUNWLFdBQVc7SUFDWCxVQUFVO0lBQ1Ysb0JBQW9CO0lBQ3BCLHFDQUFxQztBQUN6Qzs7QUFFQTtJQUNJO1FBQ0ksVUFBVTtJQUNkOztJQUVBOztRQUVJLFVBQVU7SUFDZDtBQUNKOztBQUVBO0lBQ0ksdUJBQXVCO0FBQzNCXCIsXCJzb3VyY2VzQ29udGVudFwiOltcIi5yb290IHtcXG4gICAgY3Vyc29yOiBwb2ludGVyO1xcbiAgICBmb250LXdlaWdodDogNzAwO1xcbiAgICBwYWRkaW5nOiAwLjVlbSAxZW07XFxuICAgIHBvc2l0aW9uOiByZWxhdGl2ZTtcXG4gICAgY29sb3I6IHZhcigtLWMtcCk7XFxuICAgIGJhY2tncm91bmQtY29sb3I6IGN1cnJlbnRDb2xvcjtcXG4gICAgYm9yZGVyOiAxcHggc29saWQgY3VycmVudENvbG9yO1xcbiAgICBkaXNwbGF5OiBmbGV4O1xcbiAgICBhbGlnbi1pdGVtczogY2VudGVyO1xcbiAgICB0cmFuc2l0aW9uOiBhbGwgMjAwbXMgZWFzZS1pbi1vdXQ7XFxuXFxuICAgICY6aG92ZXIge1xcbiAgICAvL2JhY2tncm91bmQtY29sb3I6IHZhcigtLWMtaGVsbGdyYXUpO1xcbiAgICB9XFxuXFxuICAgICY6Zm9jdXMge1xcbiAgICAgICAgQG1peGluIGExMXktZm9jdXM7XFxuICAgIH1cXG59XFxuXFxuXFxuLmZvbnRXZWlnaHQtbm9ybWFsIHtcXG4gICAgZm9udC13ZWlnaHQ6IG5vcm1hbDtcXG59XFxuXFxuLnplcm9wYWRkaW5nIHtcXG4gICAgcGFkZGluZzogMCAwO1xcbn1cXG5cXG4uaWNvbiB7XFxuICAgIGNvbG9yOiAjZmZmO1xcbiAgICB3aWxsLWNoYW5nZTogb3BhY2l0eTtcXG4gICAgdHJhbnNpdGlvbjogb3BhY2l0eSAyMDBtcyBlYXNlLWluLW91dDtcXG4gICAgdHJhbnNmb3JtOiBzY2FsZSgxLjMpO1xcbn1cXG5cXG4uaWNvbkxlZnQge1xcbiAgICBtYXJnaW4tcmlnaHQ6IDAuNmVtO1xcbn1cXG5cXG4uaWNvblJpZ2h0IHtcXG4gICAgbWFyZ2luLWxlZnQ6IDAuNmVtO1xcbn1cXG5cXG4udHlwZS1naG9zdCxcXG4udHlwZS1lbXB0eSB7XFxuICAgIGJhY2tncm91bmQtY29sb3I6IHRyYW5zcGFyZW50O1xcblxcbiAgICAuY29udGVudCwgLmljb24sIC5sb2FkZXIge1xcbiAgICAgICAgY29sb3I6IGN1cnJlbnRDb2xvcjtcXG4gICAgfVxcbn1cXG5cXG4udHlwZS1lbXB0eSB7XFxuICAgIGJvcmRlcjogbm9uZTtcXG59XFxuXFxuLnNpemUtc21hbGwge1xcbiAgICBmb250LXNpemU6IDAuOHJlbTtcXG59XFxuXFxuLnNpemUtbGFyZ2Uge1xcbiAgICBmb250LXNpemU6IDEuMnJlbTtcXG59XFxuXFxuXFxuLmlzUm91bmQge1xcbiAgICBib3JkZXItcmFkaXVzOiA1cmVtO1xcbn1cXG5cXG4uaXNEaXNhYmxlZCB7XFxuICAgIHBvaW50ZXItZXZlbnRzOiBub25lO1xcbiAgICBvcGFjaXR5OiAwLjg7XFxufVxcblxcblxcbi5sb2FkZXIge1xcbiAgICBwb3NpdGlvbjogYWJzb2x1dGU7XFxuICAgIGxlZnQ6IDUwJTtcXG4gICAgdG9wOiA1MCU7XFxuICAgIHRyYW5zZm9ybTogdHJhbnNsYXRlWCgtNTAlKSB0cmFuc2xhdGVZKC01MCUpO1xcbiAgICB3aWR0aDogMWVtO1xcbiAgICBoZWlnaHQ6IDFlbTtcXG4gICAgY29sb3I6ICNmZmY7XFxuICAgIG9wYWNpdHk6IDA7XFxuICAgIHdpbGwtY2hhbmdlOiBvcGFjaXR5O1xcbiAgICB0cmFuc2l0aW9uOiBvcGFjaXR5IDIwMG1zIGVhc2UtaW4tb3V0O1xcbiAgICBwb2ludGVyLWV2ZW50czogbm9uZTtcXG59XFxuXFxuLmNvbnRlbnQge1xcbiAgICBwb3NpdGlvbjogcmVsYXRpdmU7XFxuICAgIHotaW5kZXg6IDE7XFxuICAgIGNvbG9yOiAjZmZmO1xcbiAgICBvcGFjaXR5OiAxO1xcbiAgICB3aWxsLWNoYW5nZTogb3BhY2l0eTtcXG4gICAgdHJhbnNpdGlvbjogb3BhY2l0eSAyMDBtcyBlYXNlLWluLW91dDtcXG59XFxuXFxuLmlzTG9hZGluZyB7XFxuICAgIC5sb2FkZXIge1xcbiAgICAgICAgb3BhY2l0eTogMTtcXG4gICAgfVxcblxcbiAgICAuY29udGVudCxcXG4gICAgLmljb24ge1xcbiAgICAgICAgb3BhY2l0eTogMDtcXG4gICAgfVxcbn1cXG5cXG4uY29sb3ItcmVkIHtcXG4gICAgY29sb3I6IHZhcigtLWMtcHJpbWFyeSk7XFxufVxcblwiLFwiQGRlZmluZS1taXhpbiBhMTF5LWZvY3VzIHtcXG4gIG91dGxpbmU6IG5vbmU7XFxuICBib3gtc2hhZG93OiAwIDAgMCAzcHggcmdiYSg2NiwgMTUzLCAyMjUsIDAuNSk7XFxufVxcblwiXSxcInNvdXJjZVJvb3RcIjpcIlwifV0pO1xuLy8gRXhwb3J0c1xuX19fQ1NTX0xPQURFUl9FWFBPUlRfX18ubG9jYWxzID0ge1xuXHRcInJvb3RcIjogXCJCdXR0b25fcm9vdF9fOXV0QWhcIixcblx0XCJmb250V2VpZ2h0LW5vcm1hbFwiOiBcIkJ1dHRvbl9mb250V2VpZ2h0LW5vcm1hbF9fcW1GS1pcIixcblx0XCJ6ZXJvcGFkZGluZ1wiOiBcIkJ1dHRvbl96ZXJvcGFkZGluZ19fMjAzV2tcIixcblx0XCJpY29uXCI6IFwiQnV0dG9uX2ljb25fXzE1WDE1XCIsXG5cdFwiaWNvbkxlZnRcIjogXCJCdXR0b25faWNvbkxlZnRfXzNjeHdUXCIsXG5cdFwiaWNvblJpZ2h0XCI6IFwiQnV0dG9uX2ljb25SaWdodF9fcl81dnhcIixcblx0XCJ0eXBlLWdob3N0XCI6IFwiQnV0dG9uX3R5cGUtZ2hvc3RfXzJwZ1gtXCIsXG5cdFwidHlwZS1lbXB0eVwiOiBcIkJ1dHRvbl90eXBlLWVtcHR5X18zWkpGeFwiLFxuXHRcImNvbnRlbnRcIjogXCJCdXR0b25fY29udGVudF9fM0dZbGFcIixcblx0XCJsb2FkZXJcIjogXCJCdXR0b25fbG9hZGVyX18yaWc2cVwiLFxuXHRcInNpemUtc21hbGxcIjogXCJCdXR0b25fc2l6ZS1zbWFsbF9fM3BabmFcIixcblx0XCJzaXplLWxhcmdlXCI6IFwiQnV0dG9uX3NpemUtbGFyZ2VfXzNYdkd6XCIsXG5cdFwiaXNSb3VuZFwiOiBcIkJ1dHRvbl9pc1JvdW5kX18xMkdBRVwiLFxuXHRcImlzRGlzYWJsZWRcIjogXCJCdXR0b25faXNEaXNhYmxlZF9fM2V6Q0JcIixcblx0XCJpc0xvYWRpbmdcIjogXCJCdXR0b25faXNMb2FkaW5nX18xSm5za1wiLFxuXHRcImNvbG9yLXJlZFwiOiBcIkJ1dHRvbl9jb2xvci1yZWRfXzJGMXE3XCJcbn07XG5tb2R1bGUuZXhwb3J0cyA9IF9fX0NTU19MT0FERVJfRVhQT1JUX19fO1xuIiwiLy8gSW1wb3J0c1xudmFyIF9fX0NTU19MT0FERVJfQVBJX0lNUE9SVF9fXyA9IHJlcXVpcmUoXCIuLi8uLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NvbXBpbGVkL2Nzcy1sb2FkZXIvYXBpLmpzXCIpO1xudmFyIF9fX0NTU19MT0FERVJfRVhQT1JUX19fID0gX19fQ1NTX0xPQURFUl9BUElfSU1QT1JUX19fKHRydWUpO1xuLy8gTW9kdWxlXG5fX19DU1NfTE9BREVSX0VYUE9SVF9fXy5wdXNoKFttb2R1bGUuaWQsIFwiLkNsb3NlQnV0dG9uX3Jvb3RfXzJ0X3BTIHtcXHJcXG4gIHBvc2l0aW9uOiByZWxhdGl2ZTtcXHJcXG4gIHdpZHRoOiAxLjVlbTtcXHJcXG4gIGhlaWdodDogMS41ZW07XFxyXFxuICB0ZXh0LWluZGVudDogLTk5OTlweDtcXHJcXG4gIGN1cnNvcjogcG9pbnRlcjtcXHJcXG4gIGJvcmRlci1yYWRpdXM6IDUwJVxcclxcbn1cXG4uQ2xvc2VCdXR0b25fcm9vdF9fMnRfcFM6OmFmdGVyLFxcclxcbiAgLkNsb3NlQnV0dG9uX3Jvb3RfXzJ0X3BTOjpiZWZvcmUge1xcclxcbiAgICBjb250ZW50OiAnJztcXHJcXG4gICAgcG9zaXRpb246IGFic29sdXRlO1xcclxcbiAgICB0b3A6IDUwJTtcXHJcXG4gICAgbGVmdDogNTAlO1xcclxcbiAgICB0cmFuc2Zvcm06IHRyYW5zbGF0ZVkoLTUwJSkgdHJhbnNsYXRlWCgtNTAlKSByb3RhdGUoNDVkZWcpO1xcclxcbiAgICB3aWR0aDogNjAlO1xcclxcbiAgICBoZWlnaHQ6IDFweDtcXHJcXG4gICAgYmFja2dyb3VuZC1jb2xvcjogY3VycmVudENvbG9yO1xcclxcbiAgfVxcbi5DbG9zZUJ1dHRvbl9yb290X18ydF9wUzo6YmVmb3JlIHtcXHJcXG4gICAgdHJhbnNmb3JtOiB0cmFuc2xhdGVZKC01MCUpIHRyYW5zbGF0ZVgoLTUwJSkgcm90YXRlKC00NWRlZyk7XFxyXFxuICB9XFxuLkNsb3NlQnV0dG9uX3Jvb3RfXzJ0X3BTOmhvdmVyIHtcXHJcXG4gICAgYmFja2dyb3VuZC1jb2xvcjogI2UyZTJlMjtcXHJcXG4gICAgb3BhY2l0eTogMTtcXHJcXG4gIH1cXG4uQ2xvc2VCdXR0b25fcm9vdF9fMnRfcFM6Zm9jdXMge1xcclxcbiAgICBvdXRsaW5lOiBub25lO1xcclxcbiAgICBib3gtc2hhZG93OiAwIDAgMCAzcHggcmdiYSg2NiwgMTUzLCAyMjUsIDAuNSk7XFxyXFxuICB9XFxyXFxuXCIsIFwiXCIse1widmVyc2lvblwiOjMsXCJzb3VyY2VzXCI6W1wid2VicGFjazovL3RoZW1lL0Nsb3NlQnV0dG9uL0Nsb3NlQnV0dG9uLm1vZHVsZS5jc3NcIixcIndlYnBhY2s6Ly9zdHlsZXMvbWl4aW5zL2ExMXktZm9jdXMuY3NzXCJdLFwibmFtZXNcIjpbXSxcIm1hcHBpbmdzXCI6XCJBQUFBO0VBQ0Usa0JBQWtCO0VBQ2xCLFlBQVk7RUFDWixhQUFhO0VBQ2Isb0JBQW9CO0VBQ3BCLGVBQWU7RUFDZjtBQTBCRjtBQXhCRTs7SUFFRSxXQUFXO0lBQ1gsa0JBQWtCO0lBQ2xCLFFBQVE7SUFDUixTQUFTO0lBQ1QsMERBQTBEO0lBQzFELFVBQVU7SUFDVixXQUFXO0lBQ1gsOEJBQThCO0VBQ2hDO0FBRUE7SUFDRSwyREFBMkQ7RUFDN0Q7QUFFQTtJQUNFLHlCQUF5QjtJQUN6QixVQUFVO0VBQ1o7QUFFQTtJQzVCQSxhQUFhO0lBQ2IsNkNBQTZDO0VENkI3Q1wiLFwic291cmNlc0NvbnRlbnRcIjpbXCIucm9vdCB7XFxyXFxuICBwb3NpdGlvbjogcmVsYXRpdmU7XFxyXFxuICB3aWR0aDogMS41ZW07XFxyXFxuICBoZWlnaHQ6IDEuNWVtO1xcclxcbiAgdGV4dC1pbmRlbnQ6IC05OTk5cHg7XFxyXFxuICBjdXJzb3I6IHBvaW50ZXI7XFxyXFxuICBib3JkZXItcmFkaXVzOiA1MCU7XFxyXFxuXFxyXFxuICAmOjphZnRlcixcXHJcXG4gICY6OmJlZm9yZSB7XFxyXFxuICAgIGNvbnRlbnQ6ICcnO1xcclxcbiAgICBwb3NpdGlvbjogYWJzb2x1dGU7XFxyXFxuICAgIHRvcDogNTAlO1xcclxcbiAgICBsZWZ0OiA1MCU7XFxyXFxuICAgIHRyYW5zZm9ybTogdHJhbnNsYXRlWSgtNTAlKSB0cmFuc2xhdGVYKC01MCUpIHJvdGF0ZSg0NWRlZyk7XFxyXFxuICAgIHdpZHRoOiA2MCU7XFxyXFxuICAgIGhlaWdodDogMXB4O1xcclxcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiBjdXJyZW50Q29sb3I7XFxyXFxuICB9XFxyXFxuXFxyXFxuICAmOjpiZWZvcmUge1xcclxcbiAgICB0cmFuc2Zvcm06IHRyYW5zbGF0ZVkoLTUwJSkgdHJhbnNsYXRlWCgtNTAlKSByb3RhdGUoLTQ1ZGVnKTtcXHJcXG4gIH1cXHJcXG5cXHJcXG4gICY6aG92ZXIge1xcclxcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiAjZTJlMmUyO1xcclxcbiAgICBvcGFjaXR5OiAxO1xcclxcbiAgfVxcclxcblxcclxcbiAgJjpmb2N1cyB7XFxyXFxuICAgIEBtaXhpbiBhMTF5LWZvY3VzO1xcclxcbiAgfVxcclxcbn1cXHJcXG5cIixcIkBkZWZpbmUtbWl4aW4gYTExeS1mb2N1cyB7XFxuICBvdXRsaW5lOiBub25lO1xcbiAgYm94LXNoYWRvdzogMCAwIDAgM3B4IHJnYmEoNjYsIDE1MywgMjI1LCAwLjUpO1xcbn1cXG5cIl0sXCJzb3VyY2VSb290XCI6XCJcIn1dKTtcbi8vIEV4cG9ydHNcbl9fX0NTU19MT0FERVJfRVhQT1JUX19fLmxvY2FscyA9IHtcblx0XCJyb290XCI6IFwiQ2xvc2VCdXR0b25fcm9vdF9fMnRfcFNcIlxufTtcbm1vZHVsZS5leHBvcnRzID0gX19fQ1NTX0xPQURFUl9FWFBPUlRfX187XG4iLCIvLyBJbXBvcnRzXG52YXIgX19fQ1NTX0xPQURFUl9BUElfSU1QT1JUX19fID0gcmVxdWlyZShcIi4uLy4uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvY3NzLWxvYWRlci9hcGkuanNcIik7XG52YXIgX19fQ1NTX0xPQURFUl9FWFBPUlRfX18gPSBfX19DU1NfTE9BREVSX0FQSV9JTVBPUlRfX18odHJ1ZSk7XG4vLyBNb2R1bGVcbl9fX0NTU19MT0FERVJfRVhQT1JUX19fLnB1c2goW21vZHVsZS5pZCwgXCIuQ29udGVudE1vZGFsX2xvYWRlcl9fM28zanIge1xcbiAgICBmb250LXNpemU6IDEuOHJlbVxcbn1cXG5cXG4uQ29udGVudE1vZGFsX2xvYWRlcl9fM28zanI6YWZ0ZXIge1xcbiAgICAgICAgbWFyZ2luOiAwIGF1dG87XFxuICAgIH1cXG5cXG4uQ29udGVudE1vZGFsX2NvbnRlbnRfXzFYang0IHtcXG59XCIsIFwiXCIse1widmVyc2lvblwiOjMsXCJzb3VyY2VzXCI6W1wid2VicGFjazovL3RoZW1lL0NvbnRlbnRNb2RhbC9Db250ZW50TW9kYWwubW9kdWxlLmNzc1wiXSxcIm5hbWVzXCI6W10sXCJtYXBwaW5nc1wiOlwiQUFBQTtJQUNJO0FBS0o7O0FBSEk7UUFDSSxjQUFjO0lBQ2xCOztBQUdKO0FBQ0FcIixcInNvdXJjZXNDb250ZW50XCI6W1wiLmxvYWRlciB7XFxuICAgIGZvbnQtc2l6ZTogMS44cmVtO1xcblxcbiAgICAmOmFmdGVyIHtcXG4gICAgICAgIG1hcmdpbjogMCBhdXRvO1xcbiAgICB9XFxufVxcblxcbi5jb250ZW50IHtcXG59XCJdLFwic291cmNlUm9vdFwiOlwiXCJ9XSk7XG4vLyBFeHBvcnRzXG5fX19DU1NfTE9BREVSX0VYUE9SVF9fXy5sb2NhbHMgPSB7XG5cdFwibG9hZGVyXCI6IFwiQ29udGVudE1vZGFsX2xvYWRlcl9fM28zanJcIixcblx0XCJjb250ZW50XCI6IFwiQ29udGVudE1vZGFsX2NvbnRlbnRfXzFYang0XCJcbn07XG5tb2R1bGUuZXhwb3J0cyA9IF9fX0NTU19MT0FERVJfRVhQT1JUX19fO1xuIiwiLy8gSW1wb3J0c1xudmFyIF9fX0NTU19MT0FERVJfQVBJX0lNUE9SVF9fXyA9IHJlcXVpcmUoXCIuLi8uLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NvbXBpbGVkL2Nzcy1sb2FkZXIvYXBpLmpzXCIpO1xudmFyIF9fX0NTU19MT0FERVJfRVhQT1JUX19fID0gX19fQ1NTX0xPQURFUl9BUElfSU1QT1JUX19fKHRydWUpO1xuLy8gTW9kdWxlXG5fX19DU1NfTE9BREVSX0VYUE9SVF9fXy5wdXNoKFttb2R1bGUuaWQsIFwiLkZvcm1Db250cm9sc19yb290X18zNkQ3RSB7XFxyXFxuICBtYXJnaW4tdG9wOiB2YXIoLS1zcGFjZSk7XFxyXFxuICBkaXNwbGF5OiBmbGV4O1xcclxcbiAganVzdGlmeS1jb250ZW50OiBmbGV4LWVuZFxcclxcbn1cXG4uRm9ybUNvbnRyb2xzX3Jvb3RfXzM2RDdFID4gKiArICoge1xcclxcbiAgICBtYXJnaW4tbGVmdDogdmFyKC0tc3BhY2UpO1xcclxcbiAgfVxcclxcblwiLCBcIlwiLHtcInZlcnNpb25cIjozLFwic291cmNlc1wiOltcIndlYnBhY2s6Ly90aGVtZS9Gb3JtL0Zvcm1Db250cm9scy5tb2R1bGUuY3NzXCJdLFwibmFtZXNcIjpbXSxcIm1hcHBpbmdzXCI6XCJBQUFBO0VBQ0Usd0JBQXdCO0VBQ3hCLGFBQWE7RUFDYjtBQUtGO0FBSEU7SUFDRSx5QkFBeUI7RUFDM0JcIixcInNvdXJjZXNDb250ZW50XCI6W1wiLnJvb3Qge1xcclxcbiAgbWFyZ2luLXRvcDogdmFyKC0tc3BhY2UpO1xcclxcbiAgZGlzcGxheTogZmxleDtcXHJcXG4gIGp1c3RpZnktY29udGVudDogZmxleC1lbmQ7XFxyXFxuXFxyXFxuICAmID4gKiArICoge1xcclxcbiAgICBtYXJnaW4tbGVmdDogdmFyKC0tc3BhY2UpO1xcclxcbiAgfVxcclxcbn1cXHJcXG5cIl0sXCJzb3VyY2VSb290XCI6XCJcIn1dKTtcbi8vIEV4cG9ydHNcbl9fX0NTU19MT0FERVJfRVhQT1JUX19fLmxvY2FscyA9IHtcblx0XCJyb290XCI6IFwiRm9ybUNvbnRyb2xzX3Jvb3RfXzM2RDdFXCJcbn07XG5tb2R1bGUuZXhwb3J0cyA9IF9fX0NTU19MT0FERVJfRVhQT1JUX19fO1xuIiwiLy8gSW1wb3J0c1xudmFyIF9fX0NTU19MT0FERVJfQVBJX0lNUE9SVF9fXyA9IHJlcXVpcmUoXCIuLi8uLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NvbXBpbGVkL2Nzcy1sb2FkZXIvYXBpLmpzXCIpO1xudmFyIF9fX0NTU19MT0FERVJfRVhQT1JUX19fID0gX19fQ1NTX0xPQURFUl9BUElfSU1QT1JUX19fKHRydWUpO1xuLy8gTW9kdWxlXG5fX19DU1NfTE9BREVSX0VYUE9SVF9fXy5wdXNoKFttb2R1bGUuaWQsIFwiLkZvcm1GaWVsZHNldF9yb290X191YTRlbyB7XFxyXFxufVxcclxcblxcclxcbi5Gb3JtRmllbGRzZXRfbGFiZWxfXzNVSzh1IHtcXHJcXG4gICAgbWFyZ2luLWJvdHRvbTogdmFyKC0tc3BhY2UpO1xcclxcbn1cXHJcXG5cXHJcXG4uRm9ybUZpZWxkc2V0X2ZpZWxkc19fMTZVd3kge1xcclxcbiAgICB3aWR0aDogMTAwJTtcXHJcXG4gICAgZGlzcGxheTogZ3JpZDtcXHJcXG4gICAgZ3JpZC1nYXA6IHZhcigtLXNwYWNlKSB2YXIoLS1zcGFjZSk7XFxyXFxuICAgIGdyaWQtdGVtcGxhdGUtY29sdW1uczogMWZyIDFmcjtcXHJcXG59XFxyXFxuXFxyXFxuLkZvcm1GaWVsZHNldF9pc1N0YWNrZWRfX1h1blFxIHtcXHJcXG4gICAgLkZvcm1GaWVsZHNldF9maWVsZHNfXzE2VXd5IHtcXHJcXG4gICAgICAgIGdyaWQtdGVtcGxhdGUtY29sdW1uczogMWZyO1xcclxcbiAgICB9XFxyXFxufVxcclxcblwiLCBcIlwiLHtcInZlcnNpb25cIjozLFwic291cmNlc1wiOltcIndlYnBhY2s6Ly90aGVtZS9Gb3JtL0Zvcm1GaWVsZHNldC5tb2R1bGUuY3NzXCJdLFwibmFtZXNcIjpbXSxcIm1hcHBpbmdzXCI6XCJBQUFBO0FBQ0E7O0FBRUE7SUFDSSwyQkFBMkI7QUFDL0I7O0FBRUE7SUFDSSxXQUFXO0lBQ1gsYUFBYTtJQUNiLG1DQUFtQztJQUNuQyw4QkFBOEI7QUFDbEM7O0FBRUE7SUFDSTtRQUNJLDBCQUEwQjtJQUM5QjtBQUNKXCIsXCJzb3VyY2VzQ29udGVudFwiOltcIi5yb290IHtcXHJcXG59XFxyXFxuXFxyXFxuLmxhYmVsIHtcXHJcXG4gICAgbWFyZ2luLWJvdHRvbTogdmFyKC0tc3BhY2UpO1xcclxcbn1cXHJcXG5cXHJcXG4uZmllbGRzIHtcXHJcXG4gICAgd2lkdGg6IDEwMCU7XFxyXFxuICAgIGRpc3BsYXk6IGdyaWQ7XFxyXFxuICAgIGdyaWQtZ2FwOiB2YXIoLS1zcGFjZSkgdmFyKC0tc3BhY2UpO1xcclxcbiAgICBncmlkLXRlbXBsYXRlLWNvbHVtbnM6IDFmciAxZnI7XFxyXFxufVxcclxcblxcclxcbi5pc1N0YWNrZWQge1xcclxcbiAgICAuZmllbGRzIHtcXHJcXG4gICAgICAgIGdyaWQtdGVtcGxhdGUtY29sdW1uczogMWZyO1xcclxcbiAgICB9XFxyXFxufVxcclxcblwiXSxcInNvdXJjZVJvb3RcIjpcIlwifV0pO1xuLy8gRXhwb3J0c1xuX19fQ1NTX0xPQURFUl9FWFBPUlRfX18ubG9jYWxzID0ge1xuXHRcInJvb3RcIjogXCJGb3JtRmllbGRzZXRfcm9vdF9fdWE0ZW9cIixcblx0XCJsYWJlbFwiOiBcIkZvcm1GaWVsZHNldF9sYWJlbF9fM1VLOHVcIixcblx0XCJmaWVsZHNcIjogXCJGb3JtRmllbGRzZXRfZmllbGRzX18xNlV3eVwiLFxuXHRcImlzU3RhY2tlZFwiOiBcIkZvcm1GaWVsZHNldF9pc1N0YWNrZWRfX1h1blFxXCJcbn07XG5tb2R1bGUuZXhwb3J0cyA9IF9fX0NTU19MT0FERVJfRVhQT1JUX19fO1xuIiwiLy8gSW1wb3J0c1xudmFyIF9fX0NTU19MT0FERVJfQVBJX0lNUE9SVF9fXyA9IHJlcXVpcmUoXCIuLi8uLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NvbXBpbGVkL2Nzcy1sb2FkZXIvYXBpLmpzXCIpO1xudmFyIF9fX0NTU19MT0FERVJfRVhQT1JUX19fID0gX19fQ1NTX0xPQURFUl9BUElfSU1QT1JUX19fKHRydWUpO1xuLy8gTW9kdWxlXG5fX19DU1NfTE9BREVSX0VYUE9SVF9fXy5wdXNoKFttb2R1bGUuaWQsIFwiLklucHV0X3Jvb3RfXzFUZDBYIHtcXHJcXG4gICAgd2lkdGg6IDEwMCU7XFxyXFxuICAgIHBvc2l0aW9uOiByZWxhdGl2ZTtcXHJcXG4gICAgZGlzcGxheTogZmxleDtcXHJcXG4gICAgZmxleC1kaXJlY3Rpb246IGNvbHVtbjtcXHJcXG59XFxyXFxuXFxyXFxuLklucHV0X2xhYmVsX19Fcmt1QSB7XFxyXFxuICAgIGZvbnQtd2VpZ2h0OiBib2xkO1xcclxcbiAgICBjb2xvcjogdmFyKC0tYy1wKTtcXHJcXG4gICAgZm9udC1zaXplOiB2YXIoLS1mcy1zbWFsbCk7XFxyXFxuICAgIG1hcmdpbi1ib3R0b206IDAuNmVtO1xcclxcbn1cXHJcXG5cXHJcXG4uSW5wdXRfZWxlbWVudF9fM1hCbloge1xcclxcbiAgICBkaXNwbGF5OiBibG9jaztcXHJcXG4gICAgd2lkdGg6IDEwMCU7XFxyXFxuICAgIGJvcmRlci1yYWRpdXM6IHZhcigtLWZvcm0taW5wdXQtYm9yZGVyLXJhZGl1cyk7XFxyXFxuICAgIGJvcmRlcjogMXB4IHNvbGlkIHZhcigtLWMtYm9yZGVyKTtcXHJcXG4gICAgY29sb3I6IHZhcigtLWMtcCk7XFxyXFxuICAgIGxpbmUtaGVpZ2h0OiAxLjI1O1xcclxcbiAgICBwYWRkaW5nOiAwLjhlbSAxZW07XFxyXFxuICAgIG91dGxpbmU6IG5vbmU7XFxyXFxuLy9ib3gtc2hhZG93OiAwIDFweCAzcHggMCByZ2JhKDAsIDAsIDAsIDAuMSksIDAgMXB4IDJweCAwIHJnYmEoMCwgMCwgMCwgMC4wNilcXHJcXG59XFxyXFxuXFxyXFxuLklucHV0X2VsZW1lbnRfXzNYQm5aOmZvY3VzIHtcXHJcXG4gICAgICAgIG91dGxpbmU6IG5vbmU7XFxyXFxuICAgICAgICBib3gtc2hhZG93OiAwIDAgMCAzcHggcmdiYSg2NiwgMTUzLCAyMjUsIDAuNSk7XFxyXFxuICAgIH1cXHJcXG5cXHJcXG4uSW5wdXRfaXNFcnJvcl9fLTRINWYge1xcclxcbiAgICAuSW5wdXRfZWxlbWVudF9fM1hCbloge1xcclxcbiAgICAgICAgYm9yZGVyLWNvbG9yOiB2YXIoLS1jLWZlZWRiYWNrLWVycm9yKSAhaW1wb3J0YW50O1xcclxcbiAgICB9XFxyXFxufVxcclxcblxcclxcbi5JbnB1dF9lcnJvcl9fWlFkaGsge1xcclxcbiAgICBjb2xvcjogdmFyKC0tYy1mZWVkYmFjay1lcnJvcik7XFxyXFxuICAgIGZvbnQtc2l6ZTogdmFyKC0tZnMteHNtYWxsKTtcXHJcXG4gICAgbWFyZ2luLXRvcDogMC41ZW07XFxyXFxuICAgIHRleHQtYWxpZ246IHJpZ2h0O1xcclxcbiAgICB3aWR0aDogMTAwJTtcXHJcXG4gICAgcG9zaXRpb246IGFic29sdXRlO1xcclxcbiAgICByaWdodDogMDtcXHJcXG4gICAgYm90dG9tOiAtMC41ZW07XFxyXFxuICAgIHRyYW5zZm9ybTogdHJhbnNsYXRlWSgxMDAlKTtcXHJcXG59XFxyXFxuXCIsIFwiXCIse1widmVyc2lvblwiOjMsXCJzb3VyY2VzXCI6W1wid2VicGFjazovL3RoZW1lL0Zvcm0vSW5wdXQubW9kdWxlLmNzc1wiLFwid2VicGFjazovL3N0eWxlcy9taXhpbnMvYTExeS1mb2N1cy5jc3NcIl0sXCJuYW1lc1wiOltdLFwibWFwcGluZ3NcIjpcIkFBQUE7SUFDSSxXQUFXO0lBQ1gsa0JBQWtCO0lBQ2xCLGFBQWE7SUFDYixzQkFBc0I7QUFDMUI7O0FBRUE7SUFDSSxpQkFBaUI7SUFDakIsaUJBQWlCO0lBQ2pCLDBCQUEwQjtJQUMxQixvQkFBb0I7QUFDeEI7O0FBRUE7SUFDSSxjQUFjO0lBQ2QsV0FBVztJQUNYLDhDQUE4QztJQUM5QyxpQ0FBaUM7SUFDakMsaUJBQWlCO0lBQ2pCLGlCQUFpQjtJQUNqQixrQkFBa0I7SUFDbEIsYUFBYTtBQUNqQjtBQUtBOztBQUhJO1FDeEJGLGFBQWE7UUFDYiw2Q0FBNkM7SUR5QjNDOztBQUdKO0lBQ0k7UUFDSSxnREFBZ0Q7SUFDcEQ7QUFDSjs7QUFFQTtJQUNJLDhCQUE4QjtJQUM5QiwyQkFBMkI7SUFDM0IsaUJBQWlCO0lBQ2pCLGlCQUFpQjtJQUNqQixXQUFXO0lBQ1gsa0JBQWtCO0lBQ2xCLFFBQVE7SUFDUixjQUFjO0lBQ2QsMkJBQTJCO0FBQy9CXCIsXCJzb3VyY2VzQ29udGVudFwiOltcIi5yb290IHtcXHJcXG4gICAgd2lkdGg6IDEwMCU7XFxyXFxuICAgIHBvc2l0aW9uOiByZWxhdGl2ZTtcXHJcXG4gICAgZGlzcGxheTogZmxleDtcXHJcXG4gICAgZmxleC1kaXJlY3Rpb246IGNvbHVtbjtcXHJcXG59XFxyXFxuXFxyXFxuLmxhYmVsIHtcXHJcXG4gICAgZm9udC13ZWlnaHQ6IGJvbGQ7XFxyXFxuICAgIGNvbG9yOiB2YXIoLS1jLXApO1xcclxcbiAgICBmb250LXNpemU6IHZhcigtLWZzLXNtYWxsKTtcXHJcXG4gICAgbWFyZ2luLWJvdHRvbTogMC42ZW07XFxyXFxufVxcclxcblxcclxcbi5lbGVtZW50IHtcXHJcXG4gICAgZGlzcGxheTogYmxvY2s7XFxyXFxuICAgIHdpZHRoOiAxMDAlO1xcclxcbiAgICBib3JkZXItcmFkaXVzOiB2YXIoLS1mb3JtLWlucHV0LWJvcmRlci1yYWRpdXMpO1xcclxcbiAgICBib3JkZXI6IDFweCBzb2xpZCB2YXIoLS1jLWJvcmRlcik7XFxyXFxuICAgIGNvbG9yOiB2YXIoLS1jLXApO1xcclxcbiAgICBsaW5lLWhlaWdodDogMS4yNTtcXHJcXG4gICAgcGFkZGluZzogMC44ZW0gMWVtO1xcclxcbiAgICBvdXRsaW5lOiBub25lO1xcclxcbi8vYm94LXNoYWRvdzogMCAxcHggM3B4IDAgcmdiYSgwLCAwLCAwLCAwLjEpLCAwIDFweCAycHggMCByZ2JhKDAsIDAsIDAsIDAuMDYpO1xcclxcblxcclxcbiAgICAmOmZvY3VzIHtcXHJcXG4gICAgICAgIEBtaXhpbiBhMTF5LWZvY3VzO1xcclxcbiAgICB9XFxyXFxufVxcclxcblxcclxcbi5pc0Vycm9yIHtcXHJcXG4gICAgLmVsZW1lbnQge1xcclxcbiAgICAgICAgYm9yZGVyLWNvbG9yOiB2YXIoLS1jLWZlZWRiYWNrLWVycm9yKSAhaW1wb3J0YW50O1xcclxcbiAgICB9XFxyXFxufVxcclxcblxcclxcbi5lcnJvciB7XFxyXFxuICAgIGNvbG9yOiB2YXIoLS1jLWZlZWRiYWNrLWVycm9yKTtcXHJcXG4gICAgZm9udC1zaXplOiB2YXIoLS1mcy14c21hbGwpO1xcclxcbiAgICBtYXJnaW4tdG9wOiAwLjVlbTtcXHJcXG4gICAgdGV4dC1hbGlnbjogcmlnaHQ7XFxyXFxuICAgIHdpZHRoOiAxMDAlO1xcclxcbiAgICBwb3NpdGlvbjogYWJzb2x1dGU7XFxyXFxuICAgIHJpZ2h0OiAwO1xcclxcbiAgICBib3R0b206IC0wLjVlbTtcXHJcXG4gICAgdHJhbnNmb3JtOiB0cmFuc2xhdGVZKDEwMCUpO1xcclxcbn1cXHJcXG5cIixcIkBkZWZpbmUtbWl4aW4gYTExeS1mb2N1cyB7XFxuICBvdXRsaW5lOiBub25lO1xcbiAgYm94LXNoYWRvdzogMCAwIDAgM3B4IHJnYmEoNjYsIDE1MywgMjI1LCAwLjUpO1xcbn1cXG5cIl0sXCJzb3VyY2VSb290XCI6XCJcIn1dKTtcbi8vIEV4cG9ydHNcbl9fX0NTU19MT0FERVJfRVhQT1JUX19fLmxvY2FscyA9IHtcblx0XCJyb290XCI6IFwiSW5wdXRfcm9vdF9fMVRkMFhcIixcblx0XCJsYWJlbFwiOiBcIklucHV0X2xhYmVsX19Fcmt1QVwiLFxuXHRcImVsZW1lbnRcIjogXCJJbnB1dF9lbGVtZW50X18zWEJuWlwiLFxuXHRcImlzRXJyb3JcIjogXCJJbnB1dF9pc0Vycm9yX18tNEg1ZlwiLFxuXHRcImVycm9yXCI6IFwiSW5wdXRfZXJyb3JfX1pRZGhrXCJcbn07XG5tb2R1bGUuZXhwb3J0cyA9IF9fX0NTU19MT0FERVJfRVhQT1JUX19fO1xuIiwiLy8gSW1wb3J0c1xudmFyIF9fX0NTU19MT0FERVJfQVBJX0lNUE9SVF9fXyA9IHJlcXVpcmUoXCIuLi8uLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NvbXBpbGVkL2Nzcy1sb2FkZXIvYXBpLmpzXCIpO1xudmFyIF9fX0NTU19MT0FERVJfRVhQT1JUX19fID0gX19fQ1NTX0xPQURFUl9BUElfSU1QT1JUX19fKHRydWUpO1xuLy8gTW9kdWxlXG5fX19DU1NfTE9BREVSX0VYUE9SVF9fXy5wdXNoKFttb2R1bGUuaWQsIFwiLkxhenlJbWFnZV9yb290X18xTGZBSyB7XFxyXFxuICAgIGRpc3BsYXk6IGlubGluZS1ibG9jaztcXHJcXG4gICAgcG9zaXRpb246IHJlbGF0aXZlO1xcclxcbn1cXHJcXG5cXHJcXG4uTGF6eUltYWdlX2ltYWdlX18zbk9BbSB7XFxyXFxuICAgIGRpc3BsYXk6IGJsb2NrO1xcclxcbiAgICBwb3NpdGlvbjogcmVsYXRpdmU7XFxyXFxuICAgIG9wYWNpdHk6IDA7XFxyXFxuICAgIGhlaWdodDogYXV0bztcXHJcXG4gICAgdHJhbnNpdGlvbjogb3BhY2l0eSAyMDBtcztcXHJcXG4gICAgd2lsbC1jaGFuZ2U6IG9wYWNpdHk7XFxyXFxufVxcclxcblxcclxcbi5MYXp5SW1hZ2VfaW1hZ2VMYXp5bG9hZF9fTWxGUlYge1xcclxcbn1cXHJcXG5cXHJcXG4uTGF6eUltYWdlX2ltYWdlTGF6eWxvYWRpbmdfXzNKa2lfIHtcXHJcXG59XFxyXFxuXFxyXFxuLkxhenlJbWFnZV9pbWFnZUxhenlsb2FkZWRfXzFuUGV0IHtcXHJcXG4gICAgb3BhY2l0eTogMTtcXHJcXG59XFxyXFxuXFxyXFxuLkxhenlJbWFnZV9wcmV2aWV3X18zZ3FYUiB7XFxyXFxuLy9maWx0ZXI6IHVybCgjbHMtc2hhcnAtYmx1cik7IHBvc2l0aW9uOiBhYnNvbHV0ZTsgbGVmdDogMDsgdG9wOiAwO1xcclxcbiAgICB3aWR0aDogMTAwJTtcXHJcXG4gICAgdHJhbnNpdGlvbjogb3BhY2l0eSAyMDBtcztcXHJcXG4gICAgd2lsbC1jaGFuZ2U6IG9wYWNpdHk7XFxyXFxufVxcclxcblxcclxcbi5MYXp5SW1hZ2VfYmFja2dyb3VuZF9fMkw0YXgge1xcclxcbiAgICBwb3NpdGlvbjogYWJzb2x1dGU7XFxyXFxuICAgIGJvdHRvbTogMDtcXHJcXG4gICAgcmlnaHQ6IDA7XFxyXFxuICAgIGxlZnQ6IDA7XFxyXFxuICAgIHRvcDogMDtcXHJcXG5cXHJcXG4gICAgLkxhenlJbWFnZV9pbWFnZV9fM25PQW0sXFxyXFxuICAgIC5MYXp5SW1hZ2VfcHJldmlld19fM2dxWFIge1xcclxcbiAgICAgICAgcG9zaXRpb246IGFic29sdXRlO1xcclxcbiAgICAgICAgYm90dG9tOiAwO1xcclxcbiAgICAgICAgcmlnaHQ6IDA7XFxyXFxuICAgICAgICBsZWZ0OiAwO1xcclxcbiAgICAgICAgdG9wOiAwO1xcclxcbiAgICAgICAgYmFja2dyb3VuZDogY2VudGVyIGNlbnRlciBuby1yZXBlYXQ7XFxyXFxuICAgICAgICBiYWNrZ3JvdW5kLXNpemU6IGNvdmVyO1xcclxcbiAgICB9XFxyXFxufVxcclxcblxcclxcbi5MYXp5SW1hZ2VfaXNMb2FkZWRfXzJlYmtzIHtcXHJcXG4gICAgLkxhenlJbWFnZV9wcmV2aWV3X18zZ3FYUltzcmMkPScucG5nJ10ge1xcclxcbiAgICAgICAgb3BhY2l0eTogMDtcXHJcXG4gICAgfVxcclxcbn1cXHJcXG5cXHJcXG4uTGF6eUltYWdlX2xhenlzaXplcy1zdmdmaWx0ZXJfX0xlZ3UxIHtcXHJcXG4gICAgYm9yZGVyOiAwO1xcclxcbiAgICBjbGlwOiByZWN0KDAgMCAwIDApO1xcclxcbiAgICBoZWlnaHQ6IDFweDtcXHJcXG4gICAgbWFyZ2luOiAtMXB4O1xcclxcbiAgICBvdmVyZmxvdzogaGlkZGVuO1xcclxcbiAgICBwYWRkaW5nOiAwO1xcclxcbiAgICBwb3NpdGlvbjogYWJzb2x1dGU7XFxyXFxuICAgIHdpZHRoOiAxcHg7XFxyXFxufVxcclxcblwiLCBcIlwiLHtcInZlcnNpb25cIjozLFwic291cmNlc1wiOltcIndlYnBhY2s6Ly90aGVtZS9JbWFnZS9MYXp5SW1hZ2UubW9kdWxlLmNzc1wiXSxcIm5hbWVzXCI6W10sXCJtYXBwaW5nc1wiOlwiQUFBQTtJQUNJLHFCQUFxQjtJQUNyQixrQkFBa0I7QUFDdEI7O0FBRUE7SUFDSSxjQUFjO0lBQ2Qsa0JBQWtCO0lBQ2xCLFVBQVU7SUFDVixZQUFZO0lBQ1oseUJBQXlCO0lBQ3pCLG9CQUFvQjtBQUN4Qjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7SUFDSSxVQUFVO0FBQ2Q7O0FBRUE7QUFDQSw2QkFBNkIsRUFBRSxrQkFBa0IsRUFBRSxPQUFPLEVBQUUsTUFBTTtJQUM5RCxXQUFXO0lBQ1gseUJBQXlCO0lBQ3pCLG9CQUFvQjtBQUN4Qjs7QUFFQTtJQUNJLGtCQUFrQjtJQUNsQixTQUFTO0lBQ1QsUUFBUTtJQUNSLE9BQU87SUFDUCxNQUFNOztJQUVOOztRQUVJLGtCQUFrQjtRQUNsQixTQUFTO1FBQ1QsUUFBUTtRQUNSLE9BQU87UUFDUCxNQUFNO1FBQ04sbUNBQW1DO1FBQ25DLHNCQUFzQjtJQUMxQjtBQUNKOztBQUVBO0lBQ0k7UUFDSSxVQUFVO0lBQ2Q7QUFDSjs7QUFFQTtJQUNJLFNBQVM7SUFDVCxtQkFBbUI7SUFDbkIsV0FBVztJQUNYLFlBQVk7SUFDWixnQkFBZ0I7SUFDaEIsVUFBVTtJQUNWLGtCQUFrQjtJQUNsQixVQUFVO0FBQ2RcIixcInNvdXJjZXNDb250ZW50XCI6W1wiLnJvb3Qge1xcclxcbiAgICBkaXNwbGF5OiBpbmxpbmUtYmxvY2s7XFxyXFxuICAgIHBvc2l0aW9uOiByZWxhdGl2ZTtcXHJcXG59XFxyXFxuXFxyXFxuLmltYWdlIHtcXHJcXG4gICAgZGlzcGxheTogYmxvY2s7XFxyXFxuICAgIHBvc2l0aW9uOiByZWxhdGl2ZTtcXHJcXG4gICAgb3BhY2l0eTogMDtcXHJcXG4gICAgaGVpZ2h0OiBhdXRvO1xcclxcbiAgICB0cmFuc2l0aW9uOiBvcGFjaXR5IDIwMG1zO1xcclxcbiAgICB3aWxsLWNoYW5nZTogb3BhY2l0eTtcXHJcXG59XFxyXFxuXFxyXFxuLmltYWdlTGF6eWxvYWQge1xcclxcbn1cXHJcXG5cXHJcXG4uaW1hZ2VMYXp5bG9hZGluZyB7XFxyXFxufVxcclxcblxcclxcbi5pbWFnZUxhenlsb2FkZWQge1xcclxcbiAgICBvcGFjaXR5OiAxO1xcclxcbn1cXHJcXG5cXHJcXG4ucHJldmlldyB7XFxyXFxuLy9maWx0ZXI6IHVybCgjbHMtc2hhcnAtYmx1cik7IHBvc2l0aW9uOiBhYnNvbHV0ZTsgbGVmdDogMDsgdG9wOiAwO1xcclxcbiAgICB3aWR0aDogMTAwJTtcXHJcXG4gICAgdHJhbnNpdGlvbjogb3BhY2l0eSAyMDBtcztcXHJcXG4gICAgd2lsbC1jaGFuZ2U6IG9wYWNpdHk7XFxyXFxufVxcclxcblxcclxcbi5iYWNrZ3JvdW5kIHtcXHJcXG4gICAgcG9zaXRpb246IGFic29sdXRlO1xcclxcbiAgICBib3R0b206IDA7XFxyXFxuICAgIHJpZ2h0OiAwO1xcclxcbiAgICBsZWZ0OiAwO1xcclxcbiAgICB0b3A6IDA7XFxyXFxuXFxyXFxuICAgIC5pbWFnZSxcXHJcXG4gICAgLnByZXZpZXcge1xcclxcbiAgICAgICAgcG9zaXRpb246IGFic29sdXRlO1xcclxcbiAgICAgICAgYm90dG9tOiAwO1xcclxcbiAgICAgICAgcmlnaHQ6IDA7XFxyXFxuICAgICAgICBsZWZ0OiAwO1xcclxcbiAgICAgICAgdG9wOiAwO1xcclxcbiAgICAgICAgYmFja2dyb3VuZDogY2VudGVyIGNlbnRlciBuby1yZXBlYXQ7XFxyXFxuICAgICAgICBiYWNrZ3JvdW5kLXNpemU6IGNvdmVyO1xcclxcbiAgICB9XFxyXFxufVxcclxcblxcclxcbi5pc0xvYWRlZCB7XFxyXFxuICAgIC5wcmV2aWV3W3NyYyQ9Jy5wbmcnXSB7XFxyXFxuICAgICAgICBvcGFjaXR5OiAwO1xcclxcbiAgICB9XFxyXFxufVxcclxcblxcclxcbi5sYXp5c2l6ZXMtc3ZnZmlsdGVyIHtcXHJcXG4gICAgYm9yZGVyOiAwO1xcclxcbiAgICBjbGlwOiByZWN0KDAgMCAwIDApO1xcclxcbiAgICBoZWlnaHQ6IDFweDtcXHJcXG4gICAgbWFyZ2luOiAtMXB4O1xcclxcbiAgICBvdmVyZmxvdzogaGlkZGVuO1xcclxcbiAgICBwYWRkaW5nOiAwO1xcclxcbiAgICBwb3NpdGlvbjogYWJzb2x1dGU7XFxyXFxuICAgIHdpZHRoOiAxcHg7XFxyXFxufVxcclxcblwiXSxcInNvdXJjZVJvb3RcIjpcIlwifV0pO1xuLy8gRXhwb3J0c1xuX19fQ1NTX0xPQURFUl9FWFBPUlRfX18ubG9jYWxzID0ge1xuXHRcInJvb3RcIjogXCJMYXp5SW1hZ2Vfcm9vdF9fMUxmQUtcIixcblx0XCJpbWFnZVwiOiBcIkxhenlJbWFnZV9pbWFnZV9fM25PQW1cIixcblx0XCJpbWFnZUxhenlsb2FkXCI6IFwiTGF6eUltYWdlX2ltYWdlTGF6eWxvYWRfX01sRlJWXCIsXG5cdFwiaW1hZ2VMYXp5bG9hZGluZ1wiOiBcIkxhenlJbWFnZV9pbWFnZUxhenlsb2FkaW5nX18zSmtpX1wiLFxuXHRcImltYWdlTGF6eWxvYWRlZFwiOiBcIkxhenlJbWFnZV9pbWFnZUxhenlsb2FkZWRfXzFuUGV0XCIsXG5cdFwicHJldmlld1wiOiBcIkxhenlJbWFnZV9wcmV2aWV3X18zZ3FYUlwiLFxuXHRcImJhY2tncm91bmRcIjogXCJMYXp5SW1hZ2VfYmFja2dyb3VuZF9fMkw0YXhcIixcblx0XCJpc0xvYWRlZFwiOiBcIkxhenlJbWFnZV9pc0xvYWRlZF9fMmVia3NcIixcblx0XCJsYXp5c2l6ZXMtc3ZnZmlsdGVyXCI6IFwiTGF6eUltYWdlX2xhenlzaXplcy1zdmdmaWx0ZXJfX0xlZ3UxXCJcbn07XG5tb2R1bGUuZXhwb3J0cyA9IF9fX0NTU19MT0FERVJfRVhQT1JUX19fO1xuIiwiLy8gSW1wb3J0c1xudmFyIF9fX0NTU19MT0FERVJfQVBJX0lNUE9SVF9fXyA9IHJlcXVpcmUoXCIuLi8uLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NvbXBpbGVkL2Nzcy1sb2FkZXIvYXBpLmpzXCIpO1xudmFyIF9fX0NTU19MT0FERVJfRVhQT1JUX19fID0gX19fQ1NTX0xPQURFUl9BUElfSU1QT1JUX19fKHRydWUpO1xuLy8gTW9kdWxlXG5fX19DU1NfTE9BREVSX0VYUE9SVF9fXy5wdXNoKFttb2R1bGUuaWQsIFwiLkxvYWRlcl9yb290X18zeENQMiB7XFxyXFxuICAgIHRleHQtYWxpZ246IGNlbnRlclxcclxcbn1cXG4uTG9hZGVyX3Jvb3RfXzN4Q1AyOjphZnRlciB7XFxyXFxuICAgICAgICBjb250ZW50OiAnJztcXHJcXG4gICAgICAgIGJhY2tncm91bmQtY29sb3I6IHRyYW5zcGFyZW50O1xcclxcbiAgICAgICAgYm9yZGVyOiAwLjA4ZW0gc29saWQgY3VycmVudENvbG9yO1xcclxcbiAgICAgICAgYm9yZGVyLXJhZGl1czogNTAlO1xcclxcbiAgICAgICAgYm9yZGVyLXRvcC1jb2xvcjogdHJhbnNwYXJlbnQ7XFxyXFxuICAgICAgICBib3JkZXItcmlnaHQtY29sb3I6IHRyYW5zcGFyZW50O1xcclxcbiAgICAgICAgZm9udC1zaXplOiAxZW07XFxyXFxuICAgICAgICB3aWR0aDogMWVtO1xcclxcbiAgICAgICAgaGVpZ2h0OiAxZW07XFxyXFxuICAgICAgICBkaXNwbGF5OiBibG9jaztcXHJcXG4gICAgICAgIHZlcnRpY2FsLWFsaWduOiBtaWRkbGU7XFxyXFxuICAgICAgICBib3gtc2l6aW5nOiBib3JkZXItYm94O1xcclxcbiAgICAgICAgLXdlYmtpdC1hbmltYXRpb246IExvYWRlcl9zcGlubmVyX19zcENlOCAwLjY1cyBpbmZpbml0ZSBsaW5lYXI7XFxyXFxuICAgICAgICAgICAgICAgIGFuaW1hdGlvbjogTG9hZGVyX3NwaW5uZXJfX3NwQ2U4IDAuNjVzIGluZmluaXRlIGxpbmVhcjtcXHJcXG4gICAgfVxcclxcblwiLCBcIlwiLHtcInZlcnNpb25cIjozLFwic291cmNlc1wiOltcIndlYnBhY2s6Ly90aGVtZS9Mb2FkZXIvTG9hZGVyLm1vZHVsZS5jc3NcIixcIndlYnBhY2s6Ly9zdHlsZXMvbWl4aW5zL3NwaW5uZXIuY3NzXCJdLFwibmFtZXNcIjpbXSxcIm1hcHBpbmdzXCI6XCJBQUFBO0lBQ0k7QUFNSjtBQUpJO1FBQ0ksV0FBVztRQ0ZqQiw2QkFBNkI7UUFDN0IsaUNBQWU7UUFDZixrQkFBa0I7UUFDbEIsNkJBQTZCO1FBQzdCLCtCQUErQjtRQUMvQixjQUFnQjtRQUNoQixVQUFZO1FBQ1osV0FBYTtRQUNiLGNBQWM7UUFDZCxzQkFBc0I7UUFDdEIsc0JBQXNCO1FBQ3RCLDhEQUE0QztnQkFBNUMsc0RBQTRDO0lEUDFDXCIsXCJzb3VyY2VzQ29udGVudFwiOltcIi5yb290IHtcXHJcXG4gICAgdGV4dC1hbGlnbjogY2VudGVyO1xcclxcblxcclxcbiAgICAmOjphZnRlciB7XFxyXFxuICAgICAgICBjb250ZW50OiAnJztcXHJcXG4gICAgICAgIEBtaXhpbiBzcGlubmVyO1xcclxcbiAgICB9XFxyXFxufVxcclxcblwiLFwiQGRlZmluZS1taXhpbiBzcGlubmVyICRzaXplOiAxZW0sICRib3JkZXI6IDAuMDhlbSBzb2xpZCBjdXJyZW50Q29sb3IsXFxyXFxuICAkZHVyYXRpb246IDAuNjVzLCAkYmFja2dyb3VuZDogdHJhbnNwYXJlbnQge1xcclxcbiAgYmFja2dyb3VuZC1jb2xvcjogdHJhbnNwYXJlbnQ7XFxyXFxuICBib3JkZXI6ICRib3JkZXI7XFxyXFxuICBib3JkZXItcmFkaXVzOiA1MCU7XFxyXFxuICBib3JkZXItdG9wLWNvbG9yOiAkYmFja2dyb3VuZDtcXHJcXG4gIGJvcmRlci1yaWdodC1jb2xvcjogJGJhY2tncm91bmQ7XFxyXFxuICBmb250LXNpemU6ICRzaXplO1xcclxcbiAgd2lkdGg6ICRzaXplO1xcclxcbiAgaGVpZ2h0OiAkc2l6ZTtcXHJcXG4gIGRpc3BsYXk6IGJsb2NrO1xcclxcbiAgdmVydGljYWwtYWxpZ246IG1pZGRsZTtcXHJcXG4gIGJveC1zaXppbmc6IGJvcmRlci1ib3g7XFxyXFxuICBhbmltYXRpb246IHNwaW5uZXIgJGR1cmF0aW9uIGluZmluaXRlIGxpbmVhcjtcXHJcXG59XFxyXFxuXCJdLFwic291cmNlUm9vdFwiOlwiXCJ9XSk7XG4vLyBFeHBvcnRzXG5fX19DU1NfTE9BREVSX0VYUE9SVF9fXy5sb2NhbHMgPSB7XG5cdFwicm9vdFwiOiBcIkxvYWRlcl9yb290X18zeENQMlwiLFxuXHRcInNwaW5uZXJcIjogXCJMb2FkZXJfc3Bpbm5lcl9fc3BDZThcIlxufTtcbm1vZHVsZS5leHBvcnRzID0gX19fQ1NTX0xPQURFUl9FWFBPUlRfX187XG4iLCIvLyBJbXBvcnRzXG52YXIgX19fQ1NTX0xPQURFUl9BUElfSU1QT1JUX19fID0gcmVxdWlyZShcIi4uLy4uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvY3NzLWxvYWRlci9hcGkuanNcIik7XG52YXIgX19fQ1NTX0xPQURFUl9FWFBPUlRfX18gPSBfX19DU1NfTE9BREVSX0FQSV9JTVBPUlRfX18odHJ1ZSk7XG4vLyBNb2R1bGVcbl9fX0NTU19MT0FERVJfRVhQT1JUX19fLnB1c2goW21vZHVsZS5pZCwgXCIuTG9nb19yb290X18zcmp0RSB7XFxyXFxuICAjTG9nb19wX18yLVVFZCxcXHJcXG4gICNMb2dvX2FfXzJiNlpRIHtcXHJcXG4gICAgZmlsbDogdmFyKC0tYy1wcmltYXJ5KTtcXHJcXG4gIH1cXHJcXG5cXHJcXG4gICNMb2dvX3dfXzFoWkFuIHtcXHJcXG4gICAgZmlsbDogdmFyKC0tYy1zZWNvbmRhcnkpO1xcclxcbiAgfVxcclxcbn1cXHJcXG5cIiwgXCJcIix7XCJ2ZXJzaW9uXCI6MyxcInNvdXJjZXNcIjpbXCJ3ZWJwYWNrOi8vdGhlbWUvTG9nby9Mb2dvLm1vZHVsZS5jc3NcIl0sXCJuYW1lc1wiOltdLFwibWFwcGluZ3NcIjpcIkFBQUE7RUFDRTs7SUFFRSxzQkFBc0I7RUFDeEI7O0VBRUE7SUFDRSx3QkFBd0I7RUFDMUI7QUFDRlwiLFwic291cmNlc0NvbnRlbnRcIjpbXCIucm9vdCB7XFxyXFxuICAjcCxcXHJcXG4gICNhIHtcXHJcXG4gICAgZmlsbDogdmFyKC0tYy1wcmltYXJ5KTtcXHJcXG4gIH1cXHJcXG5cXHJcXG4gICN3IHtcXHJcXG4gICAgZmlsbDogdmFyKC0tYy1zZWNvbmRhcnkpO1xcclxcbiAgfVxcclxcbn1cXHJcXG5cIl0sXCJzb3VyY2VSb290XCI6XCJcIn1dKTtcbi8vIEV4cG9ydHNcbl9fX0NTU19MT0FERVJfRVhQT1JUX19fLmxvY2FscyA9IHtcblx0XCJyb290XCI6IFwiTG9nb19yb290X18zcmp0RVwiLFxuXHRcInBcIjogXCJMb2dvX3BfXzItVUVkXCIsXG5cdFwiYVwiOiBcIkxvZ29fYV9fMmI2WlFcIixcblx0XCJ3XCI6IFwiTG9nb193X18xaFpBblwiXG59O1xubW9kdWxlLmV4cG9ydHMgPSBfX19DU1NfTE9BREVSX0VYUE9SVF9fXztcbiIsIi8vIEltcG9ydHNcbnZhciBfX19DU1NfTE9BREVSX0FQSV9JTVBPUlRfX18gPSByZXF1aXJlKFwiLi4vLi4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jb21waWxlZC9jc3MtbG9hZGVyL2FwaS5qc1wiKTtcbnZhciBfX19DU1NfTE9BREVSX0VYUE9SVF9fXyA9IF9fX0NTU19MT0FERVJfQVBJX0lNUE9SVF9fXyh0cnVlKTtcbi8vIE1vZHVsZVxuX19fQ1NTX0xPQURFUl9FWFBPUlRfX18ucHVzaChbbW9kdWxlLmlkLCBcIi5Ob3RpZmljYXRpb25fcm9vdF9fMnAwZDMge1xcbiAgICBwYWRkaW5nOiAwLjhlbSAxZW07XFxuICAgIGJvcmRlcjogMXB4IHNvbGlkIHZhcigtLWMtZmVlZGJhY2spO1xcbiAgICBib3JkZXItcmFkaXVzOiA0cHg7XFxuICAgIHBvc2l0aW9uOiByZWxhdGl2ZVxcbn1cXG5cXG4uTm90aWZpY2F0aW9uX3Jvb3RfXzJwMGQzOmFmdGVyIHtcXG4gICAgICAgIGNvbnRlbnQ6ICcnO1xcbiAgICAgICAgcG9zaXRpb246IGFic29sdXRlO1xcbiAgICAgICAgYm90dG9tOiAwO1xcbiAgICAgICAgcmlnaHQ6IDA7XFxuICAgICAgICBsZWZ0OiAwO1xcbiAgICAgICAgdG9wOiAwO1xcbiAgICAgICAgYmFja2dyb3VuZC1jb2xvcjogdmFyKC0tYy1mZWVkYmFjayk7XFxuICAgICAgICBvcGFjaXR5OiAwLjA1O1xcbiAgICAgICAgei1pbmRleDogMTtcXG4gICAgfVxcblxcbi5Ob3RpZmljYXRpb25fcm9vdF9fMnAwZDMgYSB7XFxuICAgIGNvbG9yOiB2YXIoLS1jLWZlZWRiYWNrKTtcXG59XFxuXFxuLk5vdGlmaWNhdGlvbl90ZXh0X18zeHN0RiB7XFxuICAgIHBvc2l0aW9uOiByZWxhdGl2ZTtcXG4gICAgei1pbmRleDogMjtcXG59XFxuXFxuLk5vdGlmaWNhdGlvbl90eXBlLWVycm9yX19obV9HcyB7XFxuICAgIGJvcmRlci1jb2xvcjogdmFyKC0tYy1mZWVkYmFjay1lcnJvcik7XFxuICAgIGNvbG9yOiB2YXIoLS1jLWZlZWRiYWNrLWVycm9yKVxcbn1cXG5cXG4uTm90aWZpY2F0aW9uX3R5cGUtZXJyb3JfX2htX0dzOmFmdGVyIHtcXG4gICAgICAgIGJhY2tncm91bmQtY29sb3I6IHZhcigtLWMtZmVlZGJhY2stZXJyb3IpO1xcbiAgICB9XFxuXFxuLk5vdGlmaWNhdGlvbl90eXBlLWVycm9yX19obV9HcyBhIHtcXG4gICAgY29sb3I6IHZhcigtLWMtZmVlZGJhY2stZXJyb3IpO1xcbn1cXG5cXG4uTm90aWZpY2F0aW9uX3R5cGUtc3VjY2Vzc19fM1B6Wk8ge1xcbiAgICBib3JkZXItY29sb3I6IHZhcigtLWMtZmVlZGJhY2stc3VjY2Vzcyk7XFxuICAgIGNvbG9yOiB2YXIoLS1jLWZlZWRiYWNrLXN1Y2Nlc3MpXFxufVxcblxcbi5Ob3RpZmljYXRpb25fdHlwZS1zdWNjZXNzX18zUHpaTzphZnRlciB7XFxuICAgICAgICBiYWNrZ3JvdW5kLWNvbG9yOiB2YXIoLS1jLWZlZWRiYWNrLXN1Y2Nlc3MpO1xcbiAgICB9XFxuXFxuLk5vdGlmaWNhdGlvbl90eXBlLXN1Y2Nlc3NfXzNQelpPIGEge1xcbiAgICBjb2xvcjogdmFyKC0tYy1mZWVkYmFjay1zdWNjZXNzKTtcXG59XFxuXCIsIFwiXCIse1widmVyc2lvblwiOjMsXCJzb3VyY2VzXCI6W1wid2VicGFjazovL3RoZW1lL01pc2MvTm90aWZpY2F0aW9uLm1vZHVsZS5jc3NcIl0sXCJuYW1lc1wiOltdLFwibWFwcGluZ3NcIjpcIkFBQUE7SUFDSSxrQkFBa0I7SUFDbEIsbUNBQW1DO0lBQ25DLGtCQUFrQjtJQUNsQjtBQWFKOztBQVhJO1FBQ0ksV0FBVztRQUNYLGtCQUFrQjtRQUNsQixTQUFTO1FBQ1QsUUFBUTtRQUNSLE9BQU87UUFDUCxNQUFNO1FBQ04sbUNBQW1DO1FBQ25DLGFBQWE7UUFDYixVQUFVO0lBQ2Q7O0FBR0o7SUFDSSx3QkFBd0I7QUFDNUI7O0FBRUE7SUFDSSxrQkFBa0I7SUFDbEIsVUFBVTtBQUNkOztBQUVBO0lBQ0kscUNBQXFDO0lBQ3JDO0FBS0o7O0FBSEk7UUFDSSx5Q0FBeUM7SUFDN0M7O0FBR0o7SUFDSSw4QkFBOEI7QUFDbEM7O0FBRUE7SUFDSSx1Q0FBdUM7SUFDdkM7QUFLSjs7QUFISTtRQUNJLDJDQUEyQztJQUMvQzs7QUFHSjtJQUNJLGdDQUFnQztBQUNwQ1wiLFwic291cmNlc0NvbnRlbnRcIjpbXCIucm9vdCB7XFxuICAgIHBhZGRpbmc6IDAuOGVtIDFlbTtcXG4gICAgYm9yZGVyOiAxcHggc29saWQgdmFyKC0tYy1mZWVkYmFjayk7XFxuICAgIGJvcmRlci1yYWRpdXM6IDRweDtcXG4gICAgcG9zaXRpb246IHJlbGF0aXZlO1xcblxcbiAgICAmOmFmdGVyIHtcXG4gICAgICAgIGNvbnRlbnQ6ICcnO1xcbiAgICAgICAgcG9zaXRpb246IGFic29sdXRlO1xcbiAgICAgICAgYm90dG9tOiAwO1xcbiAgICAgICAgcmlnaHQ6IDA7XFxuICAgICAgICBsZWZ0OiAwO1xcbiAgICAgICAgdG9wOiAwO1xcbiAgICAgICAgYmFja2dyb3VuZC1jb2xvcjogdmFyKC0tYy1mZWVkYmFjayk7XFxuICAgICAgICBvcGFjaXR5OiAwLjA1O1xcbiAgICAgICAgei1pbmRleDogMTtcXG4gICAgfVxcbn1cXG5cXG4ucm9vdCBhIHtcXG4gICAgY29sb3I6IHZhcigtLWMtZmVlZGJhY2spO1xcbn1cXG5cXG4udGV4dCB7XFxuICAgIHBvc2l0aW9uOiByZWxhdGl2ZTtcXG4gICAgei1pbmRleDogMjtcXG59XFxuXFxuLnR5cGUtZXJyb3Ige1xcbiAgICBib3JkZXItY29sb3I6IHZhcigtLWMtZmVlZGJhY2stZXJyb3IpO1xcbiAgICBjb2xvcjogdmFyKC0tYy1mZWVkYmFjay1lcnJvcik7XFxuXFxuICAgICY6YWZ0ZXIge1xcbiAgICAgICAgYmFja2dyb3VuZC1jb2xvcjogdmFyKC0tYy1mZWVkYmFjay1lcnJvcik7XFxuICAgIH1cXG59XFxuXFxuLnR5cGUtZXJyb3IgYSB7XFxuICAgIGNvbG9yOiB2YXIoLS1jLWZlZWRiYWNrLWVycm9yKTtcXG59XFxuXFxuLnR5cGUtc3VjY2VzcyB7XFxuICAgIGJvcmRlci1jb2xvcjogdmFyKC0tYy1mZWVkYmFjay1zdWNjZXNzKTtcXG4gICAgY29sb3I6IHZhcigtLWMtZmVlZGJhY2stc3VjY2Vzcyk7XFxuXFxuICAgICY6YWZ0ZXIge1xcbiAgICAgICAgYmFja2dyb3VuZC1jb2xvcjogdmFyKC0tYy1mZWVkYmFjay1zdWNjZXNzKTtcXG4gICAgfVxcbn1cXG5cXG4udHlwZS1zdWNjZXNzIGEge1xcbiAgICBjb2xvcjogdmFyKC0tYy1mZWVkYmFjay1zdWNjZXNzKTtcXG59XFxuXCJdLFwic291cmNlUm9vdFwiOlwiXCJ9XSk7XG4vLyBFeHBvcnRzXG5fX19DU1NfTE9BREVSX0VYUE9SVF9fXy5sb2NhbHMgPSB7XG5cdFwicm9vdFwiOiBcIk5vdGlmaWNhdGlvbl9yb290X18ycDBkM1wiLFxuXHRcInRleHRcIjogXCJOb3RpZmljYXRpb25fdGV4dF9fM3hzdEZcIixcblx0XCJ0eXBlLWVycm9yXCI6IFwiTm90aWZpY2F0aW9uX3R5cGUtZXJyb3JfX2htX0dzXCIsXG5cdFwidHlwZS1zdWNjZXNzXCI6IFwiTm90aWZpY2F0aW9uX3R5cGUtc3VjY2Vzc19fM1B6Wk9cIlxufTtcbm1vZHVsZS5leHBvcnRzID0gX19fQ1NTX0xPQURFUl9FWFBPUlRfX187XG4iLCIvLyBJbXBvcnRzXG52YXIgX19fQ1NTX0xPQURFUl9BUElfSU1QT1JUX19fID0gcmVxdWlyZShcIi4uLy4uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvY3NzLWxvYWRlci9hcGkuanNcIik7XG52YXIgX19fQ1NTX0xPQURFUl9FWFBPUlRfX18gPSBfX19DU1NfTE9BREVSX0FQSV9JTVBPUlRfX18odHJ1ZSk7XG4vLyBNb2R1bGVcbl9fX0NTU19MT0FERVJfRVhQT1JUX19fLnB1c2goW21vZHVsZS5pZCwgXCIuU25vd19yb290X19zUkhzMCB7XFxufVxcblxcbi5Tbm93X2xldmVsX19BN1AxUSB7XFxuICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcXG4gICAgdG9wOiAwO1xcbiAgICByaWdodDogMDtcXG4gICAgYm90dG9tOiAwO1xcbiAgICBsZWZ0OiAwO1xcbiAgICAtd2Via2l0LWFuaW1hdGlvbjogU25vd19mYWxsaW5nX19LZndLOCBsaW5lYXIgaW5maW5pdGUgYm90aDtcXG4gICAgICAgICAgICBhbmltYXRpb246IFNub3dfZmFsbGluZ19fS2Z3SzggbGluZWFyIGluZmluaXRlIGJvdGg7XFxuICAgIHRyYW5zZm9ybTogdHJhbnNsYXRlM0QoMCwgLTEwMCUsIDApO1xcbn1cXG5cXG4uU25vd19wb3NpdGlvbi1uZWFyX18yVVVtMCB7XFxuICAgIC13ZWJraXQtYW5pbWF0aW9uLWR1cmF0aW9uOiB2YXIoLS1zLW5lYXIpO1xcbiAgICAgICAgICAgIGFuaW1hdGlvbi1kdXJhdGlvbjogdmFyKC0tcy1uZWFyKTtcXG4gICAgYmFja2dyb3VuZC1pbWFnZTogdXJsKCcvYXNzZXRzL3N0YXRpYy9zbm93L25lYXIucG5nJyk7XFxuICAgIGJhY2tncm91bmQtc2l6ZTogY29udGFpbjtcXG59XFxuXFxuLlNub3dfcG9zaXRpb24tbmVhcl9fMlVVbTAuU25vd19sZXZlbEFsdF9fM0V1eEoge1xcbiAgICAtd2Via2l0LWFuaW1hdGlvbi1kZWxheTogY2FsYyh2YXIoLS1zLW5lYXIpIC8gMik7XFxuICAgICAgICAgICAgYW5pbWF0aW9uLWRlbGF5OiBjYWxjKHZhcigtLXMtbmVhcikgLyAyKTtcXG59XFxuXFxuLlNub3dfcG9zaXRpb24tbWlkX190YkI0YyB7XFxuICAgIC13ZWJraXQtYW5pbWF0aW9uLWR1cmF0aW9uOiB2YXIoLS1zLW1pZCk7XFxuICAgICAgICAgICAgYW5pbWF0aW9uLWR1cmF0aW9uOiB2YXIoLS1zLW1pZCk7XFxuICAgIGJhY2tncm91bmQtaW1hZ2U6IHVybCgnL2Fzc2V0cy9zdGF0aWMvc25vdy9taWQucG5nJyk7XFxuICAgIGJhY2tncm91bmQtc2l6ZTogY29udGFpbjtcXG59XFxuXFxuLlNub3dfcG9zaXRpb24tbWlkX190YkI0Yy5Tbm93X2xldmVsQWx0X18zRXV4SiB7XFxuICAgIC13ZWJraXQtYW5pbWF0aW9uLWRlbGF5OiBjYWxjKHZhcigtLXMtbWlkKSAvIDIpO1xcbiAgICAgICAgICAgIGFuaW1hdGlvbi1kZWxheTogY2FsYyh2YXIoLS1zLW1pZCkgLyAyKTtcXG59XFxuXFxuLlNub3dfcG9zaXRpb24tZmFyX18zMS1iWCB7XFxuICAgIC13ZWJraXQtYW5pbWF0aW9uLWR1cmF0aW9uOiB2YXIoLS1zLWZhcik7XFxuICAgICAgICAgICAgYW5pbWF0aW9uLWR1cmF0aW9uOiB2YXIoLS1zLWZhcik7XFxuICAgIGJhY2tncm91bmQtaW1hZ2U6IHVybCgnL2Fzc2V0cy9zdGF0aWMvc25vdy9mYXIucG5nJyk7XFxuICAgIGJhY2tncm91bmQtc2l6ZTogY29udGFpbjtcXG59XFxuXFxuLlNub3dfcG9zaXRpb24tZmFyX18zMS1iWC5Tbm93X2xldmVsQWx0X18zRXV4SiB7XFxuICAgIC13ZWJraXQtYW5pbWF0aW9uLWRlbGF5OiBjYWxjKHZhcigtLXMtZmFyKSAvIDIpO1xcbiAgICAgICAgICAgIGFuaW1hdGlvbi1kZWxheTogY2FsYyh2YXIoLS1zLWZhcikgLyAyKTtcXG59XFxuXFxuQC13ZWJraXQta2V5ZnJhbWVzIFNub3dfZmFsbGluZ19fS2Z3Szgge1xcbiAgICAwJSB7XFxuICAgICAgICB0cmFuc2Zvcm06IHRyYW5zbGF0ZTNEKC03LjUlLCAtMTAwJSwgMCk7XFxuICAgIH1cXG5cXG4gICAgMTAwJSB7XFxuICAgICAgICB0cmFuc2Zvcm06IHRyYW5zbGF0ZTNEKDcuNSUsIDEwMCUsIDApO1xcbiAgICB9XFxufVxcblxcbkBrZXlmcmFtZXMgU25vd19mYWxsaW5nX19LZndLOCB7XFxuICAgIDAlIHtcXG4gICAgICAgIHRyYW5zZm9ybTogdHJhbnNsYXRlM0QoLTcuNSUsIC0xMDAlLCAwKTtcXG4gICAgfVxcblxcbiAgICAxMDAlIHtcXG4gICAgICAgIHRyYW5zZm9ybTogdHJhbnNsYXRlM0QoNy41JSwgMTAwJSwgMCk7XFxuICAgIH1cXG59XFxuXCIsIFwiXCIse1widmVyc2lvblwiOjMsXCJzb3VyY2VzXCI6W1wid2VicGFjazovL3RoZW1lL01pc2MvU25vdy5tb2R1bGUuY3NzXCJdLFwibmFtZXNcIjpbXSxcIm1hcHBpbmdzXCI6XCJBQUFBO0FBQ0E7O0FBRUE7SUFDSSxrQkFBa0I7SUFDbEIsTUFBTTtJQUNOLFFBQVE7SUFDUixTQUFTO0lBQ1QsT0FBTztJQUNQLDJEQUF1QztZQUF2QyxtREFBdUM7SUFDdkMsbUNBQW1DO0FBQ3ZDOztBQUVBO0lBQ0kseUNBQWlDO1lBQWpDLGlDQUFpQztJQUNqQyxxREFBcUQ7SUFDckQsd0JBQXdCO0FBQzVCOztBQUVBO0lBQ0ksZ0RBQXdDO1lBQXhDLHdDQUF3QztBQUM1Qzs7QUFFQTtJQUNJLHdDQUFnQztZQUFoQyxnQ0FBZ0M7SUFDaEMsb0RBQW9EO0lBQ3BELHdCQUF3QjtBQUM1Qjs7QUFFQTtJQUNJLCtDQUF1QztZQUF2Qyx1Q0FBdUM7QUFDM0M7O0FBRUE7SUFDSSx3Q0FBZ0M7WUFBaEMsZ0NBQWdDO0lBQ2hDLG9EQUFvRDtJQUNwRCx3QkFBd0I7QUFDNUI7O0FBRUE7SUFDSSwrQ0FBdUM7WUFBdkMsdUNBQXVDO0FBQzNDOztBQUVBO0lBQ0k7UUFDSSx1Q0FBdUM7SUFDM0M7O0lBRUE7UUFDSSxxQ0FBcUM7SUFDekM7QUFDSjs7QUFSQTtJQUNJO1FBQ0ksdUNBQXVDO0lBQzNDOztJQUVBO1FBQ0kscUNBQXFDO0lBQ3pDO0FBQ0pcIixcInNvdXJjZXNDb250ZW50XCI6W1wiLnJvb3Qge1xcbn1cXG5cXG4ubGV2ZWwge1xcbiAgICBwb3NpdGlvbjogYWJzb2x1dGU7XFxuICAgIHRvcDogMDtcXG4gICAgcmlnaHQ6IDA7XFxuICAgIGJvdHRvbTogMDtcXG4gICAgbGVmdDogMDtcXG4gICAgYW5pbWF0aW9uOiBmYWxsaW5nIGxpbmVhciBpbmZpbml0ZSBib3RoO1xcbiAgICB0cmFuc2Zvcm06IHRyYW5zbGF0ZTNEKDAsIC0xMDAlLCAwKTtcXG59XFxuXFxuLnBvc2l0aW9uLW5lYXIge1xcbiAgICBhbmltYXRpb24tZHVyYXRpb246IHZhcigtLXMtbmVhcik7XFxuICAgIGJhY2tncm91bmQtaW1hZ2U6IHVybCgnL2Fzc2V0cy9zdGF0aWMvc25vdy9uZWFyLnBuZycpO1xcbiAgICBiYWNrZ3JvdW5kLXNpemU6IGNvbnRhaW47XFxufVxcblxcbi5wb3NpdGlvbi1uZWFyLmxldmVsQWx0IHtcXG4gICAgYW5pbWF0aW9uLWRlbGF5OiBjYWxjKHZhcigtLXMtbmVhcikgLyAyKTtcXG59XFxuXFxuLnBvc2l0aW9uLW1pZCB7XFxuICAgIGFuaW1hdGlvbi1kdXJhdGlvbjogdmFyKC0tcy1taWQpO1xcbiAgICBiYWNrZ3JvdW5kLWltYWdlOiB1cmwoJy9hc3NldHMvc3RhdGljL3Nub3cvbWlkLnBuZycpO1xcbiAgICBiYWNrZ3JvdW5kLXNpemU6IGNvbnRhaW47XFxufVxcblxcbi5wb3NpdGlvbi1taWQubGV2ZWxBbHQge1xcbiAgICBhbmltYXRpb24tZGVsYXk6IGNhbGModmFyKC0tcy1taWQpIC8gMik7XFxufVxcblxcbi5wb3NpdGlvbi1mYXIge1xcbiAgICBhbmltYXRpb24tZHVyYXRpb246IHZhcigtLXMtZmFyKTtcXG4gICAgYmFja2dyb3VuZC1pbWFnZTogdXJsKCcvYXNzZXRzL3N0YXRpYy9zbm93L2Zhci5wbmcnKTtcXG4gICAgYmFja2dyb3VuZC1zaXplOiBjb250YWluO1xcbn1cXG5cXG4ucG9zaXRpb24tZmFyLmxldmVsQWx0IHtcXG4gICAgYW5pbWF0aW9uLWRlbGF5OiBjYWxjKHZhcigtLXMtZmFyKSAvIDIpO1xcbn1cXG5cXG5Aa2V5ZnJhbWVzIGZhbGxpbmcge1xcbiAgICAwJSB7XFxuICAgICAgICB0cmFuc2Zvcm06IHRyYW5zbGF0ZTNEKC03LjUlLCAtMTAwJSwgMCk7XFxuICAgIH1cXG5cXG4gICAgMTAwJSB7XFxuICAgICAgICB0cmFuc2Zvcm06IHRyYW5zbGF0ZTNEKDcuNSUsIDEwMCUsIDApO1xcbiAgICB9XFxufVxcblwiXSxcInNvdXJjZVJvb3RcIjpcIlwifV0pO1xuLy8gRXhwb3J0c1xuX19fQ1NTX0xPQURFUl9FWFBPUlRfX18ubG9jYWxzID0ge1xuXHRcInJvb3RcIjogXCJTbm93X3Jvb3RfX3NSSHMwXCIsXG5cdFwibGV2ZWxcIjogXCJTbm93X2xldmVsX19BN1AxUVwiLFxuXHRcImZhbGxpbmdcIjogXCJTbm93X2ZhbGxpbmdfX0tmd0s4XCIsXG5cdFwicG9zaXRpb24tbmVhclwiOiBcIlNub3dfcG9zaXRpb24tbmVhcl9fMlVVbTBcIixcblx0XCJsZXZlbEFsdFwiOiBcIlNub3dfbGV2ZWxBbHRfXzNFdXhKXCIsXG5cdFwicG9zaXRpb24tbWlkXCI6IFwiU25vd19wb3NpdGlvbi1taWRfX3RiQjRjXCIsXG5cdFwicG9zaXRpb24tZmFyXCI6IFwiU25vd19wb3NpdGlvbi1mYXJfXzMxLWJYXCJcbn07XG5tb2R1bGUuZXhwb3J0cyA9IF9fX0NTU19MT0FERVJfRVhQT1JUX19fO1xuIiwiLy8gSW1wb3J0c1xudmFyIF9fX0NTU19MT0FERVJfQVBJX0lNUE9SVF9fXyA9IHJlcXVpcmUoXCIuLi8uLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NvbXBpbGVkL2Nzcy1sb2FkZXIvYXBpLmpzXCIpO1xudmFyIF9fX0NTU19MT0FERVJfRVhQT1JUX19fID0gX19fQ1NTX0xPQURFUl9BUElfSU1QT1JUX19fKHRydWUpO1xuLy8gTW9kdWxlXG5fX19DU1NfTE9BREVSX0VYUE9SVF9fXy5wdXNoKFttb2R1bGUuaWQsIFwiLkljb25fcm9vdF9fMktRelYge1xcclxcbiAgICBkaXNwbGF5OiBpbmxpbmUtYmxvY2s7XFxyXFxuICAgIGxpbmUtaGVpZ2h0OiAxO1xcclxcbn1cXHJcXG5cXHJcXG4uSWNvbl9yb290X18yS1F6ViBzdmcge1xcclxcbiAgICB0ZXh0LWFsaWduOiBjZW50ZXI7XFxyXFxuICAgIHZlcnRpY2FsLWFsaWduOiBtaWRkbGU7XFxyXFxuICAgIGZpbGw6IGN1cnJlbnRDb2xvcjtcXHJcXG4gICAgaGVpZ2h0OiAxZW07XFxyXFxuICAgIHdpZHRoOiAxZW07XFxyXFxuICAgIGRpc3BsYXk6IGJsb2NrO1xcclxcbn1cXHJcXG5cXHJcXG4uSWNvbl9pc1JvdW5kX18yVGpqZSB7XFxyXFxuICAgIGJvcmRlci1yYWRpdXM6IDk5OTlweDtcXHJcXG59XFxyXFxuXFxyXFxuLkljb25fYW5pbWF0aW9uU3Bpbl9fWmcwMDAge1xcclxcbiAgICAtd2Via2l0LWFuaW1hdGlvbjogSWNvbl9zcGlubmVyX19NR1N0cyAycyBpbmZpbml0ZSBsaW5lYXI7XFxyXFxuICAgICAgICAgICAgYW5pbWF0aW9uOiBJY29uX3NwaW5uZXJfX01HU3RzIDJzIGluZmluaXRlIGxpbmVhcjtcXHJcXG59XFxyXFxuXFxyXFxuLkljb25fcm90YXRlLTkwX18xemsydCB7XFxyXFxuICAgIHRyYW5zZm9ybTogcm90YXRlKDkwZGVnKTtcXHJcXG59XFxyXFxuXFxyXFxuLkljb25fcm90YXRlLTE4MF9fM1hnTXQge1xcclxcbiAgICB0cmFuc2Zvcm06IHJvdGF0ZSgxODBkZWcpO1xcclxcbn1cXHJcXG5cXHJcXG4uSWNvbl9yb3RhdGUtMjcwX19ZenBUWiB7XFxyXFxuICAgIHRyYW5zZm9ybTogcm90YXRlKDI3MGRlZyk7XFxyXFxufVxcclxcblxcclxcbi5JY29uX2NpcmNsZV9fM0FHTGkge1xcclxcbiAgICBib3JkZXI6IDFweCBzb2xpZCBjdXJyZW50Q29sb3I7XFxyXFxuICAgIGJvcmRlci1yYWRpdXM6IDUwJTtcXHJcXG59XFxyXFxuXFxyXFxuLkljb25fY2lyY2xlX18zQUdMaSBzdmcge1xcclxcbiAgICB0cmFuc2Zvcm06IHNjYWxlKDAuNyk7XFxyXFxufVwiLCBcIlwiLHtcInZlcnNpb25cIjozLFwic291cmNlc1wiOltcIndlYnBhY2s6Ly90aGVtZS9TVkcvSWNvbi5tb2R1bGUuY3NzXCJdLFwibmFtZXNcIjpbXSxcIm1hcHBpbmdzXCI6XCJBQUFBO0lBQ0kscUJBQXFCO0lBQ3JCLGNBQWM7QUFDbEI7O0FBRUE7SUFDSSxrQkFBa0I7SUFDbEIsc0JBQXNCO0lBQ3RCLGtCQUFrQjtJQUNsQixXQUFXO0lBQ1gsVUFBVTtJQUNWLGNBQWM7QUFDbEI7O0FBRUE7SUFDSSxxQkFBcUI7QUFDekI7O0FBRUE7SUFDSSx5REFBcUM7WUFBckMsaURBQXFDO0FBQ3pDOztBQUVBO0lBQ0ksd0JBQXdCO0FBQzVCOztBQUVBO0lBQ0kseUJBQXlCO0FBQzdCOztBQUVBO0lBQ0kseUJBQXlCO0FBQzdCOztBQUVBO0lBQ0ksOEJBQThCO0lBQzlCLGtCQUFrQjtBQUN0Qjs7QUFFQTtJQUNJLHFCQUFxQjtBQUN6QlwiLFwic291cmNlc0NvbnRlbnRcIjpbXCIucm9vdCB7XFxyXFxuICAgIGRpc3BsYXk6IGlubGluZS1ibG9jaztcXHJcXG4gICAgbGluZS1oZWlnaHQ6IDE7XFxyXFxufVxcclxcblxcclxcbi5yb290IHN2ZyB7XFxyXFxuICAgIHRleHQtYWxpZ246IGNlbnRlcjtcXHJcXG4gICAgdmVydGljYWwtYWxpZ246IG1pZGRsZTtcXHJcXG4gICAgZmlsbDogY3VycmVudENvbG9yO1xcclxcbiAgICBoZWlnaHQ6IDFlbTtcXHJcXG4gICAgd2lkdGg6IDFlbTtcXHJcXG4gICAgZGlzcGxheTogYmxvY2s7XFxyXFxufVxcclxcblxcclxcbi5pc1JvdW5kIHtcXHJcXG4gICAgYm9yZGVyLXJhZGl1czogOTk5OXB4O1xcclxcbn1cXHJcXG5cXHJcXG4uYW5pbWF0aW9uU3BpbiB7XFxyXFxuICAgIGFuaW1hdGlvbjogc3Bpbm5lciAycyBpbmZpbml0ZSBsaW5lYXI7XFxyXFxufVxcclxcblxcclxcbi5yb3RhdGUtOTAge1xcclxcbiAgICB0cmFuc2Zvcm06IHJvdGF0ZSg5MGRlZyk7XFxyXFxufVxcclxcblxcclxcbi5yb3RhdGUtMTgwIHtcXHJcXG4gICAgdHJhbnNmb3JtOiByb3RhdGUoMTgwZGVnKTtcXHJcXG59XFxyXFxuXFxyXFxuLnJvdGF0ZS0yNzAge1xcclxcbiAgICB0cmFuc2Zvcm06IHJvdGF0ZSgyNzBkZWcpO1xcclxcbn1cXHJcXG5cXHJcXG4uY2lyY2xlIHtcXHJcXG4gICAgYm9yZGVyOiAxcHggc29saWQgY3VycmVudENvbG9yO1xcclxcbiAgICBib3JkZXItcmFkaXVzOiA1MCU7XFxyXFxufVxcclxcblxcclxcbi5jaXJjbGUgc3ZnIHtcXHJcXG4gICAgdHJhbnNmb3JtOiBzY2FsZSgwLjcpO1xcclxcbn1cIl0sXCJzb3VyY2VSb290XCI6XCJcIn1dKTtcbi8vIEV4cG9ydHNcbl9fX0NTU19MT0FERVJfRVhQT1JUX19fLmxvY2FscyA9IHtcblx0XCJyb290XCI6IFwiSWNvbl9yb290X18yS1F6VlwiLFxuXHRcImlzUm91bmRcIjogXCJJY29uX2lzUm91bmRfXzJUamplXCIsXG5cdFwiYW5pbWF0aW9uU3BpblwiOiBcIkljb25fYW5pbWF0aW9uU3Bpbl9fWmcwMDBcIixcblx0XCJzcGlubmVyXCI6IFwiSWNvbl9zcGlubmVyX19NR1N0c1wiLFxuXHRcInJvdGF0ZS05MFwiOiBcIkljb25fcm90YXRlLTkwX18xemsydFwiLFxuXHRcInJvdGF0ZS0xODBcIjogXCJJY29uX3JvdGF0ZS0xODBfXzNYZ010XCIsXG5cdFwicm90YXRlLTI3MFwiOiBcIkljb25fcm90YXRlLTI3MF9fWXpwVFpcIixcblx0XCJjaXJjbGVcIjogXCJJY29uX2NpcmNsZV9fM0FHTGlcIlxufTtcbm1vZHVsZS5leHBvcnRzID0gX19fQ1NTX0xPQURFUl9FWFBPUlRfX187XG4iLCIvLyBJbXBvcnRzXG52YXIgX19fQ1NTX0xPQURFUl9BUElfSU1QT1JUX19fID0gcmVxdWlyZShcIi4uLy4uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvY3NzLWxvYWRlci9hcGkuanNcIik7XG52YXIgX19fQ1NTX0xPQURFUl9FWFBPUlRfX18gPSBfX19DU1NfTE9BREVSX0FQSV9JTVBPUlRfX18odHJ1ZSk7XG4vLyBNb2R1bGVcbl9fX0NTU19MT0FERVJfRVhQT1JUX19fLnB1c2goW21vZHVsZS5pZCwgXCIuU1ZHX3Jvb3RfX3hsWjByIHN2ZyB7XFxuICAgIHdpZHRoOiAxMDAlO1xcbiAgICBoZWlnaHQ6IGF1dG87XFxuICAgIGRpc3BsYXk6IGJsb2NrO1xcbn1cXG5cXG4uU1ZHX2lzSW5saW5lX18zNXZDTiB7XFxuICAgIHdpZHRoOiAxZW07XFxuICAgIGhlaWdodDogMWVtO1xcbiAgICBkaXNwbGF5OiBpbmxpbmUtYmxvY2s7XFxufVxcblwiLCBcIlwiLHtcInZlcnNpb25cIjozLFwic291cmNlc1wiOltcIndlYnBhY2s6Ly90aGVtZS9TVkcvU1ZHLm1vZHVsZS5jc3NcIl0sXCJuYW1lc1wiOltdLFwibWFwcGluZ3NcIjpcIkFBQUE7SUFDSSxXQUFXO0lBQ1gsWUFBWTtJQUNaLGNBQWM7QUFDbEI7O0FBRUE7SUFDSSxVQUFVO0lBQ1YsV0FBVztJQUNYLHFCQUFxQjtBQUN6QlwiLFwic291cmNlc0NvbnRlbnRcIjpbXCIucm9vdCBzdmcge1xcbiAgICB3aWR0aDogMTAwJTtcXG4gICAgaGVpZ2h0OiBhdXRvO1xcbiAgICBkaXNwbGF5OiBibG9jaztcXG59XFxuXFxuLmlzSW5saW5lIHtcXG4gICAgd2lkdGg6IDFlbTtcXG4gICAgaGVpZ2h0OiAxZW07XFxuICAgIGRpc3BsYXk6IGlubGluZS1ibG9jaztcXG59XFxuXCJdLFwic291cmNlUm9vdFwiOlwiXCJ9XSk7XG4vLyBFeHBvcnRzXG5fX19DU1NfTE9BREVSX0VYUE9SVF9fXy5sb2NhbHMgPSB7XG5cdFwicm9vdFwiOiBcIlNWR19yb290X194bFowclwiLFxuXHRcImlzSW5saW5lXCI6IFwiU1ZHX2lzSW5saW5lX18zNXZDTlwiXG59O1xubW9kdWxlLmV4cG9ydHMgPSBfX19DU1NfTE9BREVSX0VYUE9SVF9fXztcbiIsIi8vIEltcG9ydHNcbnZhciBfX19DU1NfTE9BREVSX0FQSV9JTVBPUlRfX18gPSByZXF1aXJlKFwiLi4vLi4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jb21waWxlZC9jc3MtbG9hZGVyL2FwaS5qc1wiKTtcbnZhciBfX19DU1NfTE9BREVSX0VYUE9SVF9fXyA9IF9fX0NTU19MT0FERVJfQVBJX0lNUE9SVF9fXyh0cnVlKTtcbi8vIE1vZHVsZVxuX19fQ1NTX0xPQURFUl9FWFBPUlRfX18ucHVzaChbbW9kdWxlLmlkLCBcIi5TaGFkb3dCb3hfcm9vdF9fRnpYSGMge1xcbiAgICBwb3NpdGlvbjogZml4ZWQ7XFxuICAgIGJvdHRvbTogMDtcXG4gICAgcmlnaHQ6IDA7XFxuICAgIGxlZnQ6IDA7XFxuICAgIHRvcDogMDtcXG4gICAgei1pbmRleDogOTk5OTtcXG4gICAgdHJhbnNpdGlvbjogb3BhY2l0eSAwLjJzIGVhc2UtaW47XFxuICAgIHdpbGwtY2hhbmdlOiBvcGFjaXR5O1xcbn1cXG5cXG4uU2hhZG93Qm94X3NoYWRvd19fMm9kb0cge1xcbiAgICBwb3NpdGlvbjogYWJzb2x1dGU7XFxuICAgIGJvdHRvbTogMDtcXG4gICAgcmlnaHQ6IDA7XFxuICAgIGxlZnQ6IDA7XFxuICAgIHRvcDogMDtcXG4gICAgYmFja2dyb3VuZC1jb2xvcjogIzAwMDtcXG4gICAgY3Vyc29yOiBwb2ludGVyO1xcbn1cXG5cXG4uU2hhZG93Qm94X2hlYWRlcl9fMXFPOWYge1xcbiAgICBkaXNwbGF5OiBmbGV4O1xcbiAgICBqdXN0aWZ5LWNvbnRlbnQ6IHNwYWNlLWJldHdlZW47XFxuICAgIGFsaWduLWl0ZW1zOiBjZW50ZXI7XFxuICAgIHBvc2l0aW9uOiBzdGlja3k7XFxuICAgIHRvcDogMDtcXG4gICAgYmFja2dyb3VuZC1jb2xvcjogdmFyKC0tYy1ia2ctbGlnaHQpO1xcbiAgICBwYWRkaW5nOiB2YXIoLS1zcGFjZS1sKTtcXG4gICAgei1pbmRleDogMTBcXG59XFxuXFxuLlNoYWRvd0JveF9oZWFkZXJfXzFxTzlmOjpiZWZvcmUge1xcbiAgICAgICAgY29udGVudDogJyc7XFxuICAgICAgICBwb3NpdGlvbjogYWJzb2x1dGU7XFxuICAgICAgICB0b3A6IDA7XFxuICAgICAgICBsZWZ0OiAwO1xcbiAgICAgICAgcmlnaHQ6IDA7XFxuICAgICAgICBib3R0b206IDA7XFxuICAgICAgICBiYWNrZ3JvdW5kLWNvbG9yOiB2YXIoLS1jLWJrZy1saWdodCk7XFxuICAgICAgICB6LWluZGV4OiAtMTtcXG4gICAgfVxcblxcbi5TaGFkb3dCb3hfaGVhZGVyX18xcU85Zjo6YWZ0ZXIge1xcbiAgICAgICAgY29udGVudDogJyc7XFxuICAgICAgICBwb3NpdGlvbjogYWJzb2x1dGU7XFxuICAgICAgICBsZWZ0OiAwO1xcbiAgICAgICAgYm90dG9tOiAwO1xcbiAgICAgICAgd2lkdGg6IDEwMCU7XFxuICAgICAgICBoZWlnaHQ6IDJyZW07XFxuICAgICAgICBiYWNrZ3JvdW5kOiBsaW5lYXItZ3JhZGllbnQoXFxuICAgICAgICAgICAgICAgIDE4MGRlZyxcXG4gICAgICAgICAgICAgICAgcmdiYSgxODksIDE4OSwgMTg5LCAxKSAwJSxcXG4gICAgICAgICAgICAgICAgcmdiYSgwLCAwLCAwLCAwKSAxMDAlXFxuICAgICAgICApO1xcbiAgICAgICAgdHJhbnNpdGlvbjogdHJhbnNmb3JtIDEwMG1zIGVhc2UtaW47XFxuICAgICAgICB3aWxsLWNoYW5nZTogdHJhbnNmb3JtO1xcbiAgICAgICAgdHJhbnNmb3JtOiB0cmFuc2xhdGVZKDApO1xcbiAgICAgICAgei1pbmRleDogLTI7XFxuICAgIH1cXG5cXG4uU2hhZG93Qm94X2hlYWRlclNoYWRvd19fMV9sS3I6OmFmdGVyIHtcXG4gICAgdHJhbnNmb3JtOiB0cmFuc2xhdGVZKDMwJSk7XFxufVxcblxcbi5TaGFkb3dCb3hfaGVhZGVySW9zX19aVW1FaCA6OmFmdGVyIHtcXG4gICAgZGlzcGxheTogbm9uZTtcXG59XFxuXFxuLlNoYWRvd0JveF90aXRsZV9fM2pFQWwge1xcbiAgICBkaXNwbGF5OiBmbGV4O1xcbiAgICB2ZXJ0aWNhbC1hbGlnbjogY2VudGVyO1xcbn1cXG5cXG4uU2hhZG93Qm94X2Nsb3NlX18zUVN3aCB7XFxuICAgIGZvbnQtc2l6ZTogMS41cmVtO1xcbn1cXG5cXG4uU2hhZG93Qm94X2JveF9fd2c3bXIge1xcbiAgICBwb3NpdGlvbjogYWJzb2x1dGU7XFxuICAgIGxlZnQ6IDUwJTtcXG4gICAgdG9wOiA1MCU7XFxuICAgIHRyYW5zZm9ybTogdHJhbnNsYXRlWCgtNTAlKSB0cmFuc2xhdGVZKC01MCUpO1xcbiAgICBtYXgtaGVpZ2h0OiBjYWxjKDEwMHZoIC0gKHZhcigtLXNwYWNlLWwpICogMikpO1xcbiAgICB3aWR0aDogOTAwcHg7XFxuICAgIG1heC13aWR0aDogY2FsYygxMDB2dyAtICh2YXIoLS1zcGFjZS1sKSAqIDIpKTtcXG4gICAgYmFja2dyb3VuZC1jb2xvcjogdmFyKC0tYy1ia2ctbGlnaHQpO1xcbiAgICB0cmFuc2l0aW9uOiBvcGFjaXR5IDAuMnMgZWFzZS1pbjtcXG4gICAgd2lsbC1jaGFuZ2U6IHRyYW5zZm9ybTtcXG4gICAgb3ZlcmZsb3c6IGF1dG87XFxufVxcblxcbi5TaGFkb3dCb3hfc2l6ZS1zbWFsbF9fZTJRZU0gLlNoYWRvd0JveF9ib3hfX3dnN21yIHtcXG4gICAgd2lkdGg6IDUwMHB4O1xcbn1cXG5cXG4uU2hhZG93Qm94X2NvbnRlbnRfXzNaemdSIHtcXG4gICAgcGFkZGluZzogdmFyKC0tc3BhY2UpIHZhcigtLXNwYWNlLWwpIGNhbGModmFyKC0tc3BhY2UtbCkgKiAyKSB2YXIoLS1zcGFjZS1sKTtcXG59XFxuXFxuLlNoYWRvd0JveF9sb2FkZXJfXzJrUFhTIHtcXG4gICAgbWFyZ2luOiA2dmggYXV0byAxMHZoIGF1dG87XFxuICAgIGZvbnQtc2l6ZTogMnJlbTtcXG4gICAgd2lkdGg6IDJyZW07XFxufVxcblxcbi5TaGFkb3dCb3hfYm94X193ZzdtcixcXG4uU2hhZG93Qm94X3NoYWRvd19fMm9kb0cge1xcbiAgICBvcGFjaXR5OiAwO1xcbiAgICB3aWxsLWNoYW5nZTogb3BhY2l0eTtcXG4gICAgdHJhbnNpdGlvbjogYWxsIDIwMG1zIGVhc2UtaW4tb3V0O1xcbn1cXG5cXG4uU2hhZG93Qm94X2JveF9fd2c3bXIge1xcbiAgICB0cmFuc2Zvcm06IHRyYW5zbGF0ZVgoLTUwJSkgdHJhbnNsYXRlWSgtMzAlKSBzY2FsZSgwLjkpO1xcbn1cXG5cXG5bZGF0YS12aXNpYmxlPSd0cnVlJ10gLlNoYWRvd0JveF9ib3hfX3dnN21yIHtcXG4gICAgb3BhY2l0eTogMTtcXG4gICAgdHJhbnNmb3JtOiB0cmFuc2xhdGVYKC01MCUpIHRyYW5zbGF0ZVkoLTUwJSkgc2NhbGUoMSk7XFxufVxcblxcbltkYXRhLXZpc2libGU9J3RydWUnXSAuU2hhZG93Qm94X3NoYWRvd19fMm9kb0cge1xcbiAgICBvcGFjaXR5OiAwLjc7XFxufVxcblxcbi5TaGFkb3dCb3hfc2l6ZS1sYXJnZV9fMWlENVUge1xcbiAgICAgICAgQG1lZGlhIChtYXgtd2lkdGg6IDcwMHB4KSB7XFxuICAgIC5TaGFkb3dCb3hfYm94X193ZzdtciB7XFxuICAgICAgICAgICAgd2lkdGg6IDEwMCU7XFxuICAgICAgICAgICAgbWF4LXdpZHRoOiAxMDAlO1xcbiAgICAgICAgICAgIGJvdHRvbTogMDtcXG4gICAgICAgICAgICB0b3A6IDA7XFxuICAgICAgICAgICAgbWF4LWhlaWdodDogMTAwdmg7XFxuICAgICAgICAgICAgaGVpZ2h0OiBhdXRvO1xcbiAgICAgICAgICAgIHRyYW5zZm9ybTogdHJhbnNsYXRlWCgtNTAlKSB0cmFuc2xhdGVZKDEwJSkgc2NhbGUoMC45KVxcbiAgICB9XFxuICAgICAgICB9XFxufVxcblxcbi5TaGFkb3dCb3hfc2l6ZS1sYXJnZV9fMWlENVVbZGF0YS12aXNpYmxlPSd0cnVlJ10ge1xcbiAgICAgICAgICAgIEBtZWRpYSAobWF4LXdpZHRoOiA3MDBweCkge1xcbiAgICAgICAgLlNoYWRvd0JveF9ib3hfX3dnN21yIHtcXG4gICAgICAgICAgICAgICAgdHJhbnNmb3JtOiB0cmFuc2xhdGVYKC01MCUpIHRyYW5zbGF0ZVkoMCkgc2NhbGUoMSlcXG4gICAgICAgIH1cXG4gICAgICAgICAgICB9XFxuICAgIH1cXG5cIiwgXCJcIix7XCJ2ZXJzaW9uXCI6MyxcInNvdXJjZXNcIjpbXCJ3ZWJwYWNrOi8vdGhlbWUvU2hhZG93Qm94L1NoYWRvd0JveC5tb2R1bGUuY3NzXCJdLFwibmFtZXNcIjpbXSxcIm1hcHBpbmdzXCI6XCJBQUFBO0lBQ0ksZUFBZTtJQUNmLFNBQVM7SUFDVCxRQUFRO0lBQ1IsT0FBTztJQUNQLE1BQU07SUFDTixhQUFhO0lBQ2IsZ0NBQWdDO0lBQ2hDLG9CQUFvQjtBQUN4Qjs7QUFFQTtJQUNJLGtCQUFrQjtJQUNsQixTQUFTO0lBQ1QsUUFBUTtJQUNSLE9BQU87SUFDUCxNQUFNO0lBQ04sc0JBQXNCO0lBQ3RCLGVBQWU7QUFDbkI7O0FBRUE7SUFDSSxhQUFhO0lBQ2IsOEJBQThCO0lBQzlCLG1CQUFtQjtJQUNuQixnQkFBZ0I7SUFDaEIsTUFBTTtJQUNOLG9DQUFvQztJQUNwQyx1QkFBdUI7SUFDdkI7QUE4Qko7O0FBNUJJO1FBQ0ksV0FBVztRQUNYLGtCQUFrQjtRQUNsQixNQUFNO1FBQ04sT0FBTztRQUNQLFFBQVE7UUFDUixTQUFTO1FBQ1Qsb0NBQW9DO1FBQ3BDLFdBQVc7SUFDZjs7QUFFQTtRQUNJLFdBQVc7UUFDWCxrQkFBa0I7UUFDbEIsT0FBTztRQUNQLFNBQVM7UUFDVCxXQUFXO1FBQ1gsWUFBWTtRQUNaOzs7O1NBSUM7UUFDRCxtQ0FBbUM7UUFDbkMsc0JBQXNCO1FBQ3RCLHdCQUF3QjtRQUN4QixXQUFXO0lBQ2Y7O0FBR0o7SUFDSSwwQkFBMEI7QUFDOUI7O0FBRUE7SUFDSSxhQUFhO0FBQ2pCOztBQUVBO0lBQ0ksYUFBYTtJQUNiLHNCQUFzQjtBQUMxQjs7QUFFQTtJQUNJLGlCQUFpQjtBQUNyQjs7QUFFQTtJQUNJLGtCQUFrQjtJQUNsQixTQUFTO0lBQ1QsUUFBUTtJQUNSLDRDQUE0QztJQUM1Qyw4Q0FBOEM7SUFDOUMsWUFBWTtJQUNaLDZDQUE2QztJQUM3QyxvQ0FBb0M7SUFDcEMsZ0NBQWdDO0lBQ2hDLHNCQUFzQjtJQUN0QixjQUFjO0FBQ2xCOztBQUVBO0lBQ0ksWUFBWTtBQUNoQjs7QUFFQTtJQUNJLDRFQUE0RTtBQUNoRjs7QUFFQTtJQUNJLDBCQUEwQjtJQUMxQixlQUFlO0lBQ2YsV0FBVztBQUNmOztBQUVBOztJQUVJLFVBQVU7SUFDVixvQkFBb0I7SUFDcEIsaUNBQWlDO0FBQ3JDOztBQUVBO0lBQ0ksdURBQXVEO0FBQzNEOztBQUVBO0lBQ0ksVUFBVTtJQUNWLHFEQUFxRDtBQUN6RDs7QUFFQTtJQUNJLFlBQVk7QUFDaEI7O0FBRUE7UUFFUTtJQURKO1lBRVEsV0FBVztZQUNYLGVBQWU7WUFDZixTQUFTO1lBQ1QsTUFBTTtZQUNOLGlCQUFpQjtZQUNqQixZQUFZO1lBQ1o7SUFFUjtRQURJO0FBVVI7O0FBUEk7WUFFUTtRQURKO2dCQUVRO1FBRVI7WUFESTtJQUVSXCIsXCJzb3VyY2VzQ29udGVudFwiOltcIi5yb290IHtcXG4gICAgcG9zaXRpb246IGZpeGVkO1xcbiAgICBib3R0b206IDA7XFxuICAgIHJpZ2h0OiAwO1xcbiAgICBsZWZ0OiAwO1xcbiAgICB0b3A6IDA7XFxuICAgIHotaW5kZXg6IDk5OTk7XFxuICAgIHRyYW5zaXRpb246IG9wYWNpdHkgMC4ycyBlYXNlLWluO1xcbiAgICB3aWxsLWNoYW5nZTogb3BhY2l0eTtcXG59XFxuXFxuLnNoYWRvdyB7XFxuICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcXG4gICAgYm90dG9tOiAwO1xcbiAgICByaWdodDogMDtcXG4gICAgbGVmdDogMDtcXG4gICAgdG9wOiAwO1xcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiAjMDAwO1xcbiAgICBjdXJzb3I6IHBvaW50ZXI7XFxufVxcblxcbi5oZWFkZXIge1xcbiAgICBkaXNwbGF5OiBmbGV4O1xcbiAgICBqdXN0aWZ5LWNvbnRlbnQ6IHNwYWNlLWJldHdlZW47XFxuICAgIGFsaWduLWl0ZW1zOiBjZW50ZXI7XFxuICAgIHBvc2l0aW9uOiBzdGlja3k7XFxuICAgIHRvcDogMDtcXG4gICAgYmFja2dyb3VuZC1jb2xvcjogdmFyKC0tYy1ia2ctbGlnaHQpO1xcbiAgICBwYWRkaW5nOiB2YXIoLS1zcGFjZS1sKTtcXG4gICAgei1pbmRleDogMTA7XFxuXFxuICAgICY6OmJlZm9yZSB7XFxuICAgICAgICBjb250ZW50OiAnJztcXG4gICAgICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcXG4gICAgICAgIHRvcDogMDtcXG4gICAgICAgIGxlZnQ6IDA7XFxuICAgICAgICByaWdodDogMDtcXG4gICAgICAgIGJvdHRvbTogMDtcXG4gICAgICAgIGJhY2tncm91bmQtY29sb3I6IHZhcigtLWMtYmtnLWxpZ2h0KTtcXG4gICAgICAgIHotaW5kZXg6IC0xO1xcbiAgICB9XFxuXFxuICAgICY6OmFmdGVyIHtcXG4gICAgICAgIGNvbnRlbnQ6ICcnO1xcbiAgICAgICAgcG9zaXRpb246IGFic29sdXRlO1xcbiAgICAgICAgbGVmdDogMDtcXG4gICAgICAgIGJvdHRvbTogMDtcXG4gICAgICAgIHdpZHRoOiAxMDAlO1xcbiAgICAgICAgaGVpZ2h0OiAycmVtO1xcbiAgICAgICAgYmFja2dyb3VuZDogbGluZWFyLWdyYWRpZW50KFxcbiAgICAgICAgICAgICAgICAxODBkZWcsXFxuICAgICAgICAgICAgICAgIHJnYmEoMTg5LCAxODksIDE4OSwgMSkgMCUsXFxuICAgICAgICAgICAgICAgIHJnYmEoMCwgMCwgMCwgMCkgMTAwJVxcbiAgICAgICAgKTtcXG4gICAgICAgIHRyYW5zaXRpb246IHRyYW5zZm9ybSAxMDBtcyBlYXNlLWluO1xcbiAgICAgICAgd2lsbC1jaGFuZ2U6IHRyYW5zZm9ybTtcXG4gICAgICAgIHRyYW5zZm9ybTogdHJhbnNsYXRlWSgwKTtcXG4gICAgICAgIHotaW5kZXg6IC0yO1xcbiAgICB9XFxufVxcblxcbi5oZWFkZXJTaGFkb3c6OmFmdGVyIHtcXG4gICAgdHJhbnNmb3JtOiB0cmFuc2xhdGVZKDMwJSk7XFxufVxcblxcbi5oZWFkZXJJb3MgOjphZnRlciB7XFxuICAgIGRpc3BsYXk6IG5vbmU7XFxufVxcblxcbi50aXRsZSB7XFxuICAgIGRpc3BsYXk6IGZsZXg7XFxuICAgIHZlcnRpY2FsLWFsaWduOiBjZW50ZXI7XFxufVxcblxcbi5jbG9zZSB7XFxuICAgIGZvbnQtc2l6ZTogMS41cmVtO1xcbn1cXG5cXG4uYm94IHtcXG4gICAgcG9zaXRpb246IGFic29sdXRlO1xcbiAgICBsZWZ0OiA1MCU7XFxuICAgIHRvcDogNTAlO1xcbiAgICB0cmFuc2Zvcm06IHRyYW5zbGF0ZVgoLTUwJSkgdHJhbnNsYXRlWSgtNTAlKTtcXG4gICAgbWF4LWhlaWdodDogY2FsYygxMDB2aCAtICh2YXIoLS1zcGFjZS1sKSAqIDIpKTtcXG4gICAgd2lkdGg6IDkwMHB4O1xcbiAgICBtYXgtd2lkdGg6IGNhbGMoMTAwdncgLSAodmFyKC0tc3BhY2UtbCkgKiAyKSk7XFxuICAgIGJhY2tncm91bmQtY29sb3I6IHZhcigtLWMtYmtnLWxpZ2h0KTtcXG4gICAgdHJhbnNpdGlvbjogb3BhY2l0eSAwLjJzIGVhc2UtaW47XFxuICAgIHdpbGwtY2hhbmdlOiB0cmFuc2Zvcm07XFxuICAgIG92ZXJmbG93OiBhdXRvO1xcbn1cXG5cXG4uc2l6ZS1zbWFsbCAuYm94IHtcXG4gICAgd2lkdGg6IDUwMHB4O1xcbn1cXG5cXG4uY29udGVudCB7XFxuICAgIHBhZGRpbmc6IHZhcigtLXNwYWNlKSB2YXIoLS1zcGFjZS1sKSBjYWxjKHZhcigtLXNwYWNlLWwpICogMikgdmFyKC0tc3BhY2UtbCk7XFxufVxcblxcbi5sb2FkZXIge1xcbiAgICBtYXJnaW46IDZ2aCBhdXRvIDEwdmggYXV0bztcXG4gICAgZm9udC1zaXplOiAycmVtO1xcbiAgICB3aWR0aDogMnJlbTtcXG59XFxuXFxuLmJveCxcXG4uc2hhZG93IHtcXG4gICAgb3BhY2l0eTogMDtcXG4gICAgd2lsbC1jaGFuZ2U6IG9wYWNpdHk7XFxuICAgIHRyYW5zaXRpb246IGFsbCAyMDBtcyBlYXNlLWluLW91dDtcXG59XFxuXFxuLmJveCB7XFxuICAgIHRyYW5zZm9ybTogdHJhbnNsYXRlWCgtNTAlKSB0cmFuc2xhdGVZKC0zMCUpIHNjYWxlKDAuOSk7XFxufVxcblxcbltkYXRhLXZpc2libGU9J3RydWUnXSAuYm94IHtcXG4gICAgb3BhY2l0eTogMTtcXG4gICAgdHJhbnNmb3JtOiB0cmFuc2xhdGVYKC01MCUpIHRyYW5zbGF0ZVkoLTUwJSkgc2NhbGUoMSk7XFxufVxcblxcbltkYXRhLXZpc2libGU9J3RydWUnXSAuc2hhZG93IHtcXG4gICAgb3BhY2l0eTogMC43O1xcbn1cXG5cXG4uc2l6ZS1sYXJnZSB7XFxuICAgIC5ib3gge1xcbiAgICAgICAgQG1lZGlhIChtYXgtd2lkdGg6IDcwMHB4KSB7XFxuICAgICAgICAgICAgd2lkdGg6IDEwMCU7XFxuICAgICAgICAgICAgbWF4LXdpZHRoOiAxMDAlO1xcbiAgICAgICAgICAgIGJvdHRvbTogMDtcXG4gICAgICAgICAgICB0b3A6IDA7XFxuICAgICAgICAgICAgbWF4LWhlaWdodDogMTAwdmg7XFxuICAgICAgICAgICAgaGVpZ2h0OiBhdXRvO1xcbiAgICAgICAgICAgIHRyYW5zZm9ybTogdHJhbnNsYXRlWCgtNTAlKSB0cmFuc2xhdGVZKDEwJSkgc2NhbGUoMC45KTtcXG4gICAgICAgIH1cXG4gICAgfVxcblxcbiAgICAmW2RhdGEtdmlzaWJsZT0ndHJ1ZSddIHtcXG4gICAgICAgIC5ib3gge1xcbiAgICAgICAgICAgIEBtZWRpYSAobWF4LXdpZHRoOiA3MDBweCkge1xcbiAgICAgICAgICAgICAgICB0cmFuc2Zvcm06IHRyYW5zbGF0ZVgoLTUwJSkgdHJhbnNsYXRlWSgwKSBzY2FsZSgxKTtcXG4gICAgICAgICAgICB9XFxuICAgICAgICB9XFxuICAgIH1cXG59XFxuXCJdLFwic291cmNlUm9vdFwiOlwiXCJ9XSk7XG4vLyBFeHBvcnRzXG5fX19DU1NfTE9BREVSX0VYUE9SVF9fXy5sb2NhbHMgPSB7XG5cdFwicm9vdFwiOiBcIlNoYWRvd0JveF9yb290X19GelhIY1wiLFxuXHRcInNoYWRvd1wiOiBcIlNoYWRvd0JveF9zaGFkb3dfXzJvZG9HXCIsXG5cdFwiaGVhZGVyXCI6IFwiU2hhZG93Qm94X2hlYWRlcl9fMXFPOWZcIixcblx0XCJoZWFkZXJTaGFkb3dcIjogXCJTaGFkb3dCb3hfaGVhZGVyU2hhZG93X18xX2xLclwiLFxuXHRcImhlYWRlcklvc1wiOiBcIlNoYWRvd0JveF9oZWFkZXJJb3NfX1pVbUVoXCIsXG5cdFwidGl0bGVcIjogXCJTaGFkb3dCb3hfdGl0bGVfXzNqRUFsXCIsXG5cdFwiY2xvc2VcIjogXCJTaGFkb3dCb3hfY2xvc2VfXzNRU3doXCIsXG5cdFwiYm94XCI6IFwiU2hhZG93Qm94X2JveF9fd2c3bXJcIixcblx0XCJzaXplLXNtYWxsXCI6IFwiU2hhZG93Qm94X3NpemUtc21hbGxfX2UyUWVNXCIsXG5cdFwiY29udGVudFwiOiBcIlNoYWRvd0JveF9jb250ZW50X18zWnpnUlwiLFxuXHRcImxvYWRlclwiOiBcIlNoYWRvd0JveF9sb2FkZXJfXzJrUFhTXCIsXG5cdFwic2l6ZS1sYXJnZVwiOiBcIlNoYWRvd0JveF9zaXplLWxhcmdlX18xaUQ1VVwiXG59O1xubW9kdWxlLmV4cG9ydHMgPSBfX19DU1NfTE9BREVSX0VYUE9SVF9fXztcbiIsIm1vZHVsZS5leHBvcnRzID1cbi8qKioqKiovIChmdW5jdGlvbigpIHsgLy8gd2VicGFja0Jvb3RzdHJhcFxuLyoqKioqKi8gXHR2YXIgX193ZWJwYWNrX21vZHVsZXNfXyA9ICh7XG5cbi8qKiovIDE0OTpcbi8qKiovIChmdW5jdGlvbihtb2R1bGUpIHtcblxudmFyIGc7XG5cbi8vIFRoaXMgd29ya3MgaW4gbm9uLXN0cmljdCBtb2RlXG5nID0gKGZ1bmN0aW9uKCkge1xuXHRyZXR1cm4gdGhpcztcbn0pKCk7XG5cbnRyeSB7XG5cdC8vIFRoaXMgd29ya3MgaWYgZXZhbCBpcyBhbGxvd2VkIChzZWUgQ1NQKVxuXHRnID0gZyB8fCBuZXcgRnVuY3Rpb24oXCJyZXR1cm4gdGhpc1wiKSgpO1xufSBjYXRjaCAoZSkge1xuXHQvLyBUaGlzIHdvcmtzIGlmIHRoZSB3aW5kb3cgcmVmZXJlbmNlIGlzIGF2YWlsYWJsZVxuXHRpZiAodHlwZW9mIHdpbmRvdyA9PT0gXCJvYmplY3RcIikgZyA9IHdpbmRvdztcbn1cblxuLy8gZyBjYW4gc3RpbGwgYmUgdW5kZWZpbmVkLCBidXQgbm90aGluZyB0byBkbyBhYm91dCBpdC4uLlxuLy8gV2UgcmV0dXJuIHVuZGVmaW5lZCwgaW5zdGVhZCBvZiBub3RoaW5nIGhlcmUsIHNvIGl0J3Ncbi8vIGVhc2llciB0byBoYW5kbGUgdGhpcyBjYXNlLiBpZighZ2xvYmFsKSB7IC4uLn1cblxubW9kdWxlLmV4cG9ydHMgPSBnO1xuXG5cbi8qKiovIH0pXG5cbi8qKioqKiovIFx0fSk7XG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKioqKi8gXHQvLyBUaGUgbW9kdWxlIGNhY2hlXG4vKioqKioqLyBcdHZhciBfX3dlYnBhY2tfbW9kdWxlX2NhY2hlX18gPSB7fTtcbi8qKioqKiovIFx0XG4vKioqKioqLyBcdC8vIFRoZSByZXF1aXJlIGZ1bmN0aW9uXG4vKioqKioqLyBcdGZ1bmN0aW9uIF9fbmNjd3Bja19yZXF1aXJlX18obW9kdWxlSWQpIHtcbi8qKioqKiovIFx0XHQvLyBDaGVjayBpZiBtb2R1bGUgaXMgaW4gY2FjaGVcbi8qKioqKiovIFx0XHRpZihfX3dlYnBhY2tfbW9kdWxlX2NhY2hlX19bbW9kdWxlSWRdKSB7XG4vKioqKioqLyBcdFx0XHRyZXR1cm4gX193ZWJwYWNrX21vZHVsZV9jYWNoZV9fW21vZHVsZUlkXS5leHBvcnRzO1xuLyoqKioqKi8gXHRcdH1cbi8qKioqKiovIFx0XHQvLyBDcmVhdGUgYSBuZXcgbW9kdWxlIChhbmQgcHV0IGl0IGludG8gdGhlIGNhY2hlKVxuLyoqKioqKi8gXHRcdHZhciBtb2R1bGUgPSBfX3dlYnBhY2tfbW9kdWxlX2NhY2hlX19bbW9kdWxlSWRdID0ge1xuLyoqKioqKi8gXHRcdFx0Ly8gbm8gbW9kdWxlLmlkIG5lZWRlZFxuLyoqKioqKi8gXHRcdFx0Ly8gbm8gbW9kdWxlLmxvYWRlZCBuZWVkZWRcbi8qKioqKiovIFx0XHRcdGV4cG9ydHM6IHt9XG4vKioqKioqLyBcdFx0fTtcbi8qKioqKiovIFx0XG4vKioqKioqLyBcdFx0Ly8gRXhlY3V0ZSB0aGUgbW9kdWxlIGZ1bmN0aW9uXG4vKioqKioqLyBcdFx0dmFyIHRocmV3ID0gdHJ1ZTtcbi8qKioqKiovIFx0XHR0cnkge1xuLyoqKioqKi8gXHRcdFx0X193ZWJwYWNrX21vZHVsZXNfX1ttb2R1bGVJZF0obW9kdWxlLCBtb2R1bGUuZXhwb3J0cywgX19uY2N3cGNrX3JlcXVpcmVfXyk7XG4vKioqKioqLyBcdFx0XHR0aHJldyA9IGZhbHNlO1xuLyoqKioqKi8gXHRcdH0gZmluYWxseSB7XG4vKioqKioqLyBcdFx0XHRpZih0aHJldykgZGVsZXRlIF9fd2VicGFja19tb2R1bGVfY2FjaGVfX1ttb2R1bGVJZF07XG4vKioqKioqLyBcdFx0fVxuLyoqKioqKi8gXHRcbi8qKioqKiovIFx0XHQvLyBSZXR1cm4gdGhlIGV4cG9ydHMgb2YgdGhlIG1vZHVsZVxuLyoqKioqKi8gXHRcdHJldHVybiBtb2R1bGUuZXhwb3J0cztcbi8qKioqKiovIFx0fVxuLyoqKioqKi8gXHRcbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqKioqLyBcdC8qIHdlYnBhY2svcnVudGltZS9jb21wYXQgKi9cbi8qKioqKiovIFx0XG4vKioqKioqLyBcdF9fbmNjd3Bja19yZXF1aXJlX18uYWIgPSBfX2Rpcm5hbWUgKyBcIi9cIjsvKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKioqKi8gXHQvLyBtb2R1bGUgZXhwb3J0cyBtdXN0IGJlIHJldHVybmVkIGZyb20gcnVudGltZSBzbyBlbnRyeSBpbmxpbmluZyBpcyBkaXNhYmxlZFxuLyoqKioqKi8gXHQvLyBzdGFydHVwXG4vKioqKioqLyBcdC8vIExvYWQgZW50cnkgbW9kdWxlIGFuZCByZXR1cm4gZXhwb3J0c1xuLyoqKioqKi8gXHRyZXR1cm4gX19uY2N3cGNrX3JlcXVpcmVfXygxNDkpO1xuLyoqKioqKi8gfSkoKVxuOyIsIm1vZHVsZS5leHBvcnRzID1cbi8qKioqKiovIChmdW5jdGlvbigpIHsgLy8gd2VicGFja0Jvb3RzdHJhcFxuLyoqKioqKi8gXHR2YXIgX193ZWJwYWNrX21vZHVsZXNfXyA9ICh7XG5cbi8qKiovIDkzMTpcbi8qKiovIChmdW5jdGlvbihtb2R1bGUpIHtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihvcmlnaW5hbE1vZHVsZSkge1xuXHRpZiAoIW9yaWdpbmFsTW9kdWxlLndlYnBhY2tQb2x5ZmlsbCkge1xuXHRcdHZhciBtb2R1bGUgPSBPYmplY3QuY3JlYXRlKG9yaWdpbmFsTW9kdWxlKTtcblx0XHQvLyBtb2R1bGUucGFyZW50ID0gdW5kZWZpbmVkIGJ5IGRlZmF1bHRcblx0XHRpZiAoIW1vZHVsZS5jaGlsZHJlbikgbW9kdWxlLmNoaWxkcmVuID0gW107XG5cdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KG1vZHVsZSwgXCJsb2FkZWRcIiwge1xuXHRcdFx0ZW51bWVyYWJsZTogdHJ1ZSxcblx0XHRcdGdldDogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHJldHVybiBtb2R1bGUubDtcblx0XHRcdH1cblx0XHR9KTtcblx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkobW9kdWxlLCBcImlkXCIsIHtcblx0XHRcdGVudW1lcmFibGU6IHRydWUsXG5cdFx0XHRnZXQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRyZXR1cm4gbW9kdWxlLmk7XG5cdFx0XHR9XG5cdFx0fSk7XG5cdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KG1vZHVsZSwgXCJleHBvcnRzXCIsIHtcblx0XHRcdGVudW1lcmFibGU6IHRydWVcblx0XHR9KTtcblx0XHRtb2R1bGUud2VicGFja1BvbHlmaWxsID0gMTtcblx0fVxuXHRyZXR1cm4gbW9kdWxlO1xufTtcblxuXG4vKioqLyB9KVxuXG4vKioqKioqLyBcdH0pO1xuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKioqKiovIFx0Ly8gVGhlIG1vZHVsZSBjYWNoZVxuLyoqKioqKi8gXHR2YXIgX193ZWJwYWNrX21vZHVsZV9jYWNoZV9fID0ge307XG4vKioqKioqLyBcdFxuLyoqKioqKi8gXHQvLyBUaGUgcmVxdWlyZSBmdW5jdGlvblxuLyoqKioqKi8gXHRmdW5jdGlvbiBfX25jY3dwY2tfcmVxdWlyZV9fKG1vZHVsZUlkKSB7XG4vKioqKioqLyBcdFx0Ly8gQ2hlY2sgaWYgbW9kdWxlIGlzIGluIGNhY2hlXG4vKioqKioqLyBcdFx0aWYoX193ZWJwYWNrX21vZHVsZV9jYWNoZV9fW21vZHVsZUlkXSkge1xuLyoqKioqKi8gXHRcdFx0cmV0dXJuIF9fd2VicGFja19tb2R1bGVfY2FjaGVfX1ttb2R1bGVJZF0uZXhwb3J0cztcbi8qKioqKiovIFx0XHR9XG4vKioqKioqLyBcdFx0Ly8gQ3JlYXRlIGEgbmV3IG1vZHVsZSAoYW5kIHB1dCBpdCBpbnRvIHRoZSBjYWNoZSlcbi8qKioqKiovIFx0XHR2YXIgbW9kdWxlID0gX193ZWJwYWNrX21vZHVsZV9jYWNoZV9fW21vZHVsZUlkXSA9IHtcbi8qKioqKiovIFx0XHRcdC8vIG5vIG1vZHVsZS5pZCBuZWVkZWRcbi8qKioqKiovIFx0XHRcdC8vIG5vIG1vZHVsZS5sb2FkZWQgbmVlZGVkXG4vKioqKioqLyBcdFx0XHRleHBvcnRzOiB7fVxuLyoqKioqKi8gXHRcdH07XG4vKioqKioqLyBcdFxuLyoqKioqKi8gXHRcdC8vIEV4ZWN1dGUgdGhlIG1vZHVsZSBmdW5jdGlvblxuLyoqKioqKi8gXHRcdHZhciB0aHJldyA9IHRydWU7XG4vKioqKioqLyBcdFx0dHJ5IHtcbi8qKioqKiovIFx0XHRcdF9fd2VicGFja19tb2R1bGVzX19bbW9kdWxlSWRdKG1vZHVsZSwgbW9kdWxlLmV4cG9ydHMsIF9fbmNjd3Bja19yZXF1aXJlX18pO1xuLyoqKioqKi8gXHRcdFx0dGhyZXcgPSBmYWxzZTtcbi8qKioqKiovIFx0XHR9IGZpbmFsbHkge1xuLyoqKioqKi8gXHRcdFx0aWYodGhyZXcpIGRlbGV0ZSBfX3dlYnBhY2tfbW9kdWxlX2NhY2hlX19bbW9kdWxlSWRdO1xuLyoqKioqKi8gXHRcdH1cbi8qKioqKiovIFx0XG4vKioqKioqLyBcdFx0Ly8gUmV0dXJuIHRoZSBleHBvcnRzIG9mIHRoZSBtb2R1bGVcbi8qKioqKiovIFx0XHRyZXR1cm4gbW9kdWxlLmV4cG9ydHM7XG4vKioqKioqLyBcdH1cbi8qKioqKiovIFx0XG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKioqKi8gXHQvKiB3ZWJwYWNrL3J1bnRpbWUvY29tcGF0ICovXG4vKioqKioqLyBcdFxuLyoqKioqKi8gXHRfX25jY3dwY2tfcmVxdWlyZV9fLmFiID0gX19kaXJuYW1lICsgXCIvXCI7LyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKioqKiovIFx0Ly8gbW9kdWxlIGV4cG9ydHMgbXVzdCBiZSByZXR1cm5lZCBmcm9tIHJ1bnRpbWUgc28gZW50cnkgaW5saW5pbmcgaXMgZGlzYWJsZWRcbi8qKioqKiovIFx0Ly8gc3RhcnR1cFxuLyoqKioqKi8gXHQvLyBMb2FkIGVudHJ5IG1vZHVsZSBhbmQgcmV0dXJuIGV4cG9ydHNcbi8qKioqKiovIFx0cmV0dXJuIF9fbmNjd3Bja19yZXF1aXJlX18oOTMxKTtcbi8qKioqKiovIH0pKClcbjsiLCJtb2R1bGUuZXhwb3J0cyA9XG4vKioqKioqLyAoZnVuY3Rpb24oKSB7IC8vIHdlYnBhY2tCb290c3RyYXBcbi8qKioqKiovIFx0dmFyIF9fd2VicGFja19tb2R1bGVzX18gPSAoe1xuXG4vKioqLyA4ODA6XG4vKioqLyAoZnVuY3Rpb24obW9kdWxlKSB7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24obW9kdWxlKSB7XG5cdGlmICghbW9kdWxlLndlYnBhY2tQb2x5ZmlsbCkge1xuXHRcdG1vZHVsZS5kZXByZWNhdGUgPSBmdW5jdGlvbigpIHt9O1xuXHRcdG1vZHVsZS5wYXRocyA9IFtdO1xuXHRcdC8vIG1vZHVsZS5wYXJlbnQgPSB1bmRlZmluZWQgYnkgZGVmYXVsdFxuXHRcdGlmICghbW9kdWxlLmNoaWxkcmVuKSBtb2R1bGUuY2hpbGRyZW4gPSBbXTtcblx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkobW9kdWxlLCBcImxvYWRlZFwiLCB7XG5cdFx0XHRlbnVtZXJhYmxlOiB0cnVlLFxuXHRcdFx0Z2V0OiBmdW5jdGlvbigpIHtcblx0XHRcdFx0cmV0dXJuIG1vZHVsZS5sO1xuXHRcdFx0fVxuXHRcdH0pO1xuXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShtb2R1bGUsIFwiaWRcIiwge1xuXHRcdFx0ZW51bWVyYWJsZTogdHJ1ZSxcblx0XHRcdGdldDogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHJldHVybiBtb2R1bGUuaTtcblx0XHRcdH1cblx0XHR9KTtcblx0XHRtb2R1bGUud2VicGFja1BvbHlmaWxsID0gMTtcblx0fVxuXHRyZXR1cm4gbW9kdWxlO1xufTtcblxuXG4vKioqLyB9KVxuXG4vKioqKioqLyBcdH0pO1xuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKioqKiovIFx0Ly8gVGhlIG1vZHVsZSBjYWNoZVxuLyoqKioqKi8gXHR2YXIgX193ZWJwYWNrX21vZHVsZV9jYWNoZV9fID0ge307XG4vKioqKioqLyBcdFxuLyoqKioqKi8gXHQvLyBUaGUgcmVxdWlyZSBmdW5jdGlvblxuLyoqKioqKi8gXHRmdW5jdGlvbiBfX25jY3dwY2tfcmVxdWlyZV9fKG1vZHVsZUlkKSB7XG4vKioqKioqLyBcdFx0Ly8gQ2hlY2sgaWYgbW9kdWxlIGlzIGluIGNhY2hlXG4vKioqKioqLyBcdFx0aWYoX193ZWJwYWNrX21vZHVsZV9jYWNoZV9fW21vZHVsZUlkXSkge1xuLyoqKioqKi8gXHRcdFx0cmV0dXJuIF9fd2VicGFja19tb2R1bGVfY2FjaGVfX1ttb2R1bGVJZF0uZXhwb3J0cztcbi8qKioqKiovIFx0XHR9XG4vKioqKioqLyBcdFx0Ly8gQ3JlYXRlIGEgbmV3IG1vZHVsZSAoYW5kIHB1dCBpdCBpbnRvIHRoZSBjYWNoZSlcbi8qKioqKiovIFx0XHR2YXIgbW9kdWxlID0gX193ZWJwYWNrX21vZHVsZV9jYWNoZV9fW21vZHVsZUlkXSA9IHtcbi8qKioqKiovIFx0XHRcdC8vIG5vIG1vZHVsZS5pZCBuZWVkZWRcbi8qKioqKiovIFx0XHRcdC8vIG5vIG1vZHVsZS5sb2FkZWQgbmVlZGVkXG4vKioqKioqLyBcdFx0XHRleHBvcnRzOiB7fVxuLyoqKioqKi8gXHRcdH07XG4vKioqKioqLyBcdFxuLyoqKioqKi8gXHRcdC8vIEV4ZWN1dGUgdGhlIG1vZHVsZSBmdW5jdGlvblxuLyoqKioqKi8gXHRcdHZhciB0aHJldyA9IHRydWU7XG4vKioqKioqLyBcdFx0dHJ5IHtcbi8qKioqKiovIFx0XHRcdF9fd2VicGFja19tb2R1bGVzX19bbW9kdWxlSWRdKG1vZHVsZSwgbW9kdWxlLmV4cG9ydHMsIF9fbmNjd3Bja19yZXF1aXJlX18pO1xuLyoqKioqKi8gXHRcdFx0dGhyZXcgPSBmYWxzZTtcbi8qKioqKiovIFx0XHR9IGZpbmFsbHkge1xuLyoqKioqKi8gXHRcdFx0aWYodGhyZXcpIGRlbGV0ZSBfX3dlYnBhY2tfbW9kdWxlX2NhY2hlX19bbW9kdWxlSWRdO1xuLyoqKioqKi8gXHRcdH1cbi8qKioqKiovIFx0XG4vKioqKioqLyBcdFx0Ly8gUmV0dXJuIHRoZSBleHBvcnRzIG9mIHRoZSBtb2R1bGVcbi8qKioqKiovIFx0XHRyZXR1cm4gbW9kdWxlLmV4cG9ydHM7XG4vKioqKioqLyBcdH1cbi8qKioqKiovIFx0XG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKioqKi8gXHQvKiB3ZWJwYWNrL3J1bnRpbWUvY29tcGF0ICovXG4vKioqKioqLyBcdFxuLyoqKioqKi8gXHRfX25jY3dwY2tfcmVxdWlyZV9fLmFiID0gX19kaXJuYW1lICsgXCIvXCI7LyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKioqKiovIFx0Ly8gbW9kdWxlIGV4cG9ydHMgbXVzdCBiZSByZXR1cm5lZCBmcm9tIHJ1bnRpbWUgc28gZW50cnkgaW5saW5pbmcgaXMgZGlzYWJsZWRcbi8qKioqKiovIFx0Ly8gc3RhcnR1cFxuLyoqKioqKi8gXHQvLyBMb2FkIGVudHJ5IG1vZHVsZSBhbmQgcmV0dXJuIGV4cG9ydHNcbi8qKioqKiovIFx0cmV0dXJuIF9fbmNjd3Bja19yZXF1aXJlX18oODgwKTtcbi8qKioqKiovIH0pKClcbjsiLCJpbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnXG5cbmV4cG9ydCBjb25zdCBBbXBTdGF0ZUNvbnRleHQ6IFJlYWN0LkNvbnRleHQ8YW55PiA9IFJlYWN0LmNyZWF0ZUNvbnRleHQoe30pXG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIEFtcFN0YXRlQ29udGV4dC5kaXNwbGF5TmFtZSA9ICdBbXBTdGF0ZUNvbnRleHQnXG59XG4iLCJpbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnXG5pbXBvcnQgeyBBbXBTdGF0ZUNvbnRleHQgfSBmcm9tICcuL2FtcC1jb250ZXh0J1xuXG5leHBvcnQgZnVuY3Rpb24gaXNJbkFtcE1vZGUoe1xuICBhbXBGaXJzdCA9IGZhbHNlLFxuICBoeWJyaWQgPSBmYWxzZSxcbiAgaGFzUXVlcnkgPSBmYWxzZSxcbn0gPSB7fSk6IGJvb2xlYW4ge1xuICByZXR1cm4gYW1wRmlyc3QgfHwgKGh5YnJpZCAmJiBoYXNRdWVyeSlcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHVzZUFtcCgpOiBib29sZWFuIHtcbiAgLy8gRG9uJ3QgYXNzaWduIHRoZSBjb250ZXh0IHZhbHVlIHRvIGEgdmFyaWFibGUgdG8gc2F2ZSBieXRlc1xuICByZXR1cm4gaXNJbkFtcE1vZGUoUmVhY3QudXNlQ29udGV4dChBbXBTdGF0ZUNvbnRleHQpKVxufVxuIiwiaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0J1xuXG5leHBvcnQgY29uc3QgSGVhZE1hbmFnZXJDb250ZXh0OiBSZWFjdC5Db250ZXh0PHtcbiAgdXBkYXRlSGVhZD86IChzdGF0ZTogYW55KSA9PiB2b2lkXG4gIG1vdW50ZWRJbnN0YW5jZXM/OiBhbnlcbiAgdXBkYXRlU2NyaXB0cz86IChzdGF0ZTogYW55KSA9PiB2b2lkXG4gIHNjcmlwdHM/OiBhbnlcbn0+ID0gUmVhY3QuY3JlYXRlQ29udGV4dCh7fSlcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgSGVhZE1hbmFnZXJDb250ZXh0LmRpc3BsYXlOYW1lID0gJ0hlYWRNYW5hZ2VyQ29udGV4dCdcbn1cbiIsImltcG9ydCBSZWFjdCwgeyB1c2VDb250ZXh0IH0gZnJvbSAncmVhY3QnXG5pbXBvcnQgRWZmZWN0IGZyb20gJy4vc2lkZS1lZmZlY3QnXG5pbXBvcnQgeyBBbXBTdGF0ZUNvbnRleHQgfSBmcm9tICcuL2FtcC1jb250ZXh0J1xuaW1wb3J0IHsgSGVhZE1hbmFnZXJDb250ZXh0IH0gZnJvbSAnLi9oZWFkLW1hbmFnZXItY29udGV4dCdcbmltcG9ydCB7IGlzSW5BbXBNb2RlIH0gZnJvbSAnLi9hbXAnXG5cbnR5cGUgV2l0aEluQW1wTW9kZSA9IHtcbiAgaW5BbXBNb2RlPzogYm9vbGVhblxufVxuXG5leHBvcnQgZnVuY3Rpb24gZGVmYXVsdEhlYWQoaW5BbXBNb2RlID0gZmFsc2UpOiBKU1guRWxlbWVudFtdIHtcbiAgY29uc3QgaGVhZCA9IFs8bWV0YSBjaGFyU2V0PVwidXRmLThcIiAvPl1cbiAgaWYgKCFpbkFtcE1vZGUpIHtcbiAgICBoZWFkLnB1c2goPG1ldGEgbmFtZT1cInZpZXdwb3J0XCIgY29udGVudD1cIndpZHRoPWRldmljZS13aWR0aFwiIC8+KVxuICB9XG4gIHJldHVybiBoZWFkXG59XG5cbmZ1bmN0aW9uIG9ubHlSZWFjdEVsZW1lbnQoXG4gIGxpc3Q6IEFycmF5PFJlYWN0LlJlYWN0RWxlbWVudDxhbnk+PixcbiAgY2hpbGQ6IFJlYWN0LlJlYWN0Q2hpbGRcbik6IEFycmF5PFJlYWN0LlJlYWN0RWxlbWVudDxhbnk+PiB7XG4gIC8vIFJlYWN0IGNoaWxkcmVuIGNhbiBiZSBcInN0cmluZ1wiIG9yIFwibnVtYmVyXCIgaW4gdGhpcyBjYXNlIHdlIGlnbm9yZSB0aGVtIGZvciBiYWNrd2FyZHMgY29tcGF0XG4gIGlmICh0eXBlb2YgY2hpbGQgPT09ICdzdHJpbmcnIHx8IHR5cGVvZiBjaGlsZCA9PT0gJ251bWJlcicpIHtcbiAgICByZXR1cm4gbGlzdFxuICB9XG4gIC8vIEFkZHMgc3VwcG9ydCBmb3IgUmVhY3QuRnJhZ21lbnRcbiAgaWYgKGNoaWxkLnR5cGUgPT09IFJlYWN0LkZyYWdtZW50KSB7XG4gICAgcmV0dXJuIGxpc3QuY29uY2F0KFxuICAgICAgUmVhY3QuQ2hpbGRyZW4udG9BcnJheShjaGlsZC5wcm9wcy5jaGlsZHJlbikucmVkdWNlKFxuICAgICAgICAoXG4gICAgICAgICAgZnJhZ21lbnRMaXN0OiBBcnJheTxSZWFjdC5SZWFjdEVsZW1lbnQ8YW55Pj4sXG4gICAgICAgICAgZnJhZ21lbnRDaGlsZDogUmVhY3QuUmVhY3RDaGlsZFxuICAgICAgICApOiBBcnJheTxSZWFjdC5SZWFjdEVsZW1lbnQ8YW55Pj4gPT4ge1xuICAgICAgICAgIGlmIChcbiAgICAgICAgICAgIHR5cGVvZiBmcmFnbWVudENoaWxkID09PSAnc3RyaW5nJyB8fFxuICAgICAgICAgICAgdHlwZW9mIGZyYWdtZW50Q2hpbGQgPT09ICdudW1iZXInXG4gICAgICAgICAgKSB7XG4gICAgICAgICAgICByZXR1cm4gZnJhZ21lbnRMaXN0XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBmcmFnbWVudExpc3QuY29uY2F0KGZyYWdtZW50Q2hpbGQpXG4gICAgICAgIH0sXG4gICAgICAgIFtdXG4gICAgICApXG4gICAgKVxuICB9XG4gIHJldHVybiBsaXN0LmNvbmNhdChjaGlsZClcbn1cblxuY29uc3QgTUVUQVRZUEVTID0gWyduYW1lJywgJ2h0dHBFcXVpdicsICdjaGFyU2V0JywgJ2l0ZW1Qcm9wJ11cblxuLypcbiByZXR1cm5zIGEgZnVuY3Rpb24gZm9yIGZpbHRlcmluZyBoZWFkIGNoaWxkIGVsZW1lbnRzXG4gd2hpY2ggc2hvdWxkbid0IGJlIGR1cGxpY2F0ZWQsIGxpa2UgPHRpdGxlLz5cbiBBbHNvIGFkZHMgc3VwcG9ydCBmb3IgZGVkdXBsaWNhdGVkIGBrZXlgIHByb3BlcnRpZXNcbiovXG5mdW5jdGlvbiB1bmlxdWUoKSB7XG4gIGNvbnN0IGtleXMgPSBuZXcgU2V0KClcbiAgY29uc3QgdGFncyA9IG5ldyBTZXQoKVxuICBjb25zdCBtZXRhVHlwZXMgPSBuZXcgU2V0KClcbiAgY29uc3QgbWV0YUNhdGVnb3JpZXM6IHsgW21ldGF0eXBlOiBzdHJpbmddOiBTZXQ8c3RyaW5nPiB9ID0ge31cblxuICByZXR1cm4gKGg6IFJlYWN0LlJlYWN0RWxlbWVudDxhbnk+KSA9PiB7XG4gICAgbGV0IGlzVW5pcXVlID0gdHJ1ZVxuICAgIGxldCBoYXNLZXkgPSBmYWxzZVxuXG4gICAgaWYgKGgua2V5ICYmIHR5cGVvZiBoLmtleSAhPT0gJ251bWJlcicgJiYgaC5rZXkuaW5kZXhPZignJCcpID4gMCkge1xuICAgICAgaGFzS2V5ID0gdHJ1ZVxuICAgICAgY29uc3Qga2V5ID0gaC5rZXkuc2xpY2UoaC5rZXkuaW5kZXhPZignJCcpICsgMSlcbiAgICAgIGlmIChrZXlzLmhhcyhrZXkpKSB7XG4gICAgICAgIGlzVW5pcXVlID0gZmFsc2VcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGtleXMuYWRkKGtleSlcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZGVmYXVsdC1jYXNlXG4gICAgc3dpdGNoIChoLnR5cGUpIHtcbiAgICAgIGNhc2UgJ3RpdGxlJzpcbiAgICAgIGNhc2UgJ2Jhc2UnOlxuICAgICAgICBpZiAodGFncy5oYXMoaC50eXBlKSkge1xuICAgICAgICAgIGlzVW5pcXVlID0gZmFsc2VcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0YWdzLmFkZChoLnR5cGUpXG4gICAgICAgIH1cbiAgICAgICAgYnJlYWtcbiAgICAgIGNhc2UgJ21ldGEnOlxuICAgICAgICBmb3IgKGxldCBpID0gMCwgbGVuID0gTUVUQVRZUEVTLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgY29uc3QgbWV0YXR5cGUgPSBNRVRBVFlQRVNbaV1cbiAgICAgICAgICBpZiAoIWgucHJvcHMuaGFzT3duUHJvcGVydHkobWV0YXR5cGUpKSBjb250aW51ZVxuXG4gICAgICAgICAgaWYgKG1ldGF0eXBlID09PSAnY2hhclNldCcpIHtcbiAgICAgICAgICAgIGlmIChtZXRhVHlwZXMuaGFzKG1ldGF0eXBlKSkge1xuICAgICAgICAgICAgICBpc1VuaXF1ZSA9IGZhbHNlXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBtZXRhVHlwZXMuYWRkKG1ldGF0eXBlKVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBjYXRlZ29yeSA9IGgucHJvcHNbbWV0YXR5cGVdXG4gICAgICAgICAgICBjb25zdCBjYXRlZ29yaWVzID0gbWV0YUNhdGVnb3JpZXNbbWV0YXR5cGVdIHx8IG5ldyBTZXQoKVxuICAgICAgICAgICAgaWYgKChtZXRhdHlwZSAhPT0gJ25hbWUnIHx8ICFoYXNLZXkpICYmIGNhdGVnb3JpZXMuaGFzKGNhdGVnb3J5KSkge1xuICAgICAgICAgICAgICBpc1VuaXF1ZSA9IGZhbHNlXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBjYXRlZ29yaWVzLmFkZChjYXRlZ29yeSlcbiAgICAgICAgICAgICAgbWV0YUNhdGVnb3JpZXNbbWV0YXR5cGVdID0gY2F0ZWdvcmllc1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBicmVha1xuICAgIH1cblxuICAgIHJldHVybiBpc1VuaXF1ZVxuICB9XG59XG5cbi8qKlxuICpcbiAqIEBwYXJhbSBoZWFkRWxlbWVudHMgTGlzdCBvZiBtdWx0aXBsZSA8SGVhZD4gaW5zdGFuY2VzXG4gKi9cbmZ1bmN0aW9uIHJlZHVjZUNvbXBvbmVudHMoXG4gIGhlYWRFbGVtZW50czogQXJyYXk8UmVhY3QuUmVhY3RFbGVtZW50PGFueT4+LFxuICBwcm9wczogV2l0aEluQW1wTW9kZVxuKSB7XG4gIHJldHVybiBoZWFkRWxlbWVudHNcbiAgICAucmVkdWNlKFxuICAgICAgKGxpc3Q6IFJlYWN0LlJlYWN0Q2hpbGRbXSwgaGVhZEVsZW1lbnQ6IFJlYWN0LlJlYWN0RWxlbWVudDxhbnk+KSA9PiB7XG4gICAgICAgIGNvbnN0IGhlYWRFbGVtZW50Q2hpbGRyZW4gPSBSZWFjdC5DaGlsZHJlbi50b0FycmF5KFxuICAgICAgICAgIGhlYWRFbGVtZW50LnByb3BzLmNoaWxkcmVuXG4gICAgICAgIClcbiAgICAgICAgcmV0dXJuIGxpc3QuY29uY2F0KGhlYWRFbGVtZW50Q2hpbGRyZW4pXG4gICAgICB9LFxuICAgICAgW11cbiAgICApXG4gICAgLnJlZHVjZShvbmx5UmVhY3RFbGVtZW50LCBbXSlcbiAgICAucmV2ZXJzZSgpXG4gICAgLmNvbmNhdChkZWZhdWx0SGVhZChwcm9wcy5pbkFtcE1vZGUpKVxuICAgIC5maWx0ZXIodW5pcXVlKCkpXG4gICAgLnJldmVyc2UoKVxuICAgIC5tYXAoKGM6IFJlYWN0LlJlYWN0RWxlbWVudDxhbnk+LCBpOiBudW1iZXIpID0+IHtcbiAgICAgIGNvbnN0IGtleSA9IGMua2V5IHx8IGlcbiAgICAgIGlmIChcbiAgICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdkZXZlbG9wbWVudCcgJiZcbiAgICAgICAgcHJvY2Vzcy5lbnYuX19ORVhUX09QVElNSVpFX0ZPTlRTICYmXG4gICAgICAgICFwcm9wcy5pbkFtcE1vZGVcbiAgICAgICkge1xuICAgICAgICBpZiAoXG4gICAgICAgICAgYy50eXBlID09PSAnbGluaycgJiZcbiAgICAgICAgICBjLnByb3BzWydocmVmJ10gJiZcbiAgICAgICAgICAvLyBUT0RPKHByYXRlZWtiaEApOiBSZXBsYWNlIHRoaXMgd2l0aCBjb25zdCBmcm9tIGBjb25zdGFudHNgIHdoZW4gdGhlIHRyZWUgc2hha2luZyB3b3Jrcy5cbiAgICAgICAgICBbXG4gICAgICAgICAgICAnaHR0cHM6Ly9mb250cy5nb29nbGVhcGlzLmNvbS9jc3MnLFxuICAgICAgICAgICAgJ2h0dHBzOi8vdXNlLnR5cGVraXQubmV0LycsXG4gICAgICAgICAgXS5zb21lKCh1cmwpID0+IGMucHJvcHNbJ2hyZWYnXS5zdGFydHNXaXRoKHVybCkpXG4gICAgICAgICkge1xuICAgICAgICAgIGNvbnN0IG5ld1Byb3BzID0geyAuLi4oYy5wcm9wcyB8fCB7fSkgfVxuICAgICAgICAgIG5ld1Byb3BzWydkYXRhLWhyZWYnXSA9IG5ld1Byb3BzWydocmVmJ11cbiAgICAgICAgICBuZXdQcm9wc1snaHJlZiddID0gdW5kZWZpbmVkXG5cbiAgICAgICAgICAvLyBBZGQgdGhpcyBhdHRyaWJ1dGUgdG8gbWFrZSBpdCBlYXN5IHRvIGlkZW50aWZ5IG9wdGltaXplZCB0YWdzXG4gICAgICAgICAgbmV3UHJvcHNbJ2RhdGEtb3B0aW1pemVkLWZvbnRzJ10gPSB0cnVlXG5cbiAgICAgICAgICByZXR1cm4gUmVhY3QuY2xvbmVFbGVtZW50KGMsIG5ld1Byb3BzKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gUmVhY3QuY2xvbmVFbGVtZW50KGMsIHsga2V5IH0pXG4gICAgfSlcbn1cblxuLyoqXG4gKiBUaGlzIGNvbXBvbmVudCBpbmplY3RzIGVsZW1lbnRzIHRvIGA8aGVhZD5gIG9mIHlvdXIgcGFnZS5cbiAqIFRvIGF2b2lkIGR1cGxpY2F0ZWQgYHRhZ3NgIGluIGA8aGVhZD5gIHlvdSBjYW4gdXNlIHRoZSBga2V5YCBwcm9wZXJ0eSwgd2hpY2ggd2lsbCBtYWtlIHN1cmUgZXZlcnkgdGFnIGlzIG9ubHkgcmVuZGVyZWQgb25jZS5cbiAqL1xuZnVuY3Rpb24gSGVhZCh7IGNoaWxkcmVuIH06IHsgY2hpbGRyZW46IFJlYWN0LlJlYWN0Tm9kZSB9KSB7XG4gIGNvbnN0IGFtcFN0YXRlID0gdXNlQ29udGV4dChBbXBTdGF0ZUNvbnRleHQpXG4gIGNvbnN0IGhlYWRNYW5hZ2VyID0gdXNlQ29udGV4dChIZWFkTWFuYWdlckNvbnRleHQpXG4gIHJldHVybiAoXG4gICAgPEVmZmVjdFxuICAgICAgcmVkdWNlQ29tcG9uZW50c1RvU3RhdGU9e3JlZHVjZUNvbXBvbmVudHN9XG4gICAgICBoZWFkTWFuYWdlcj17aGVhZE1hbmFnZXJ9XG4gICAgICBpbkFtcE1vZGU9e2lzSW5BbXBNb2RlKGFtcFN0YXRlKX1cbiAgICA+XG4gICAgICB7Y2hpbGRyZW59XG4gICAgPC9FZmZlY3Q+XG4gIClcbn1cblxuLy8gVE9ETzogUmVtb3ZlIGluIHRoZSBuZXh0IG1ham9yIHJlbGVhc2VcbkhlYWQucmV3aW5kID0gKCkgPT4ge31cblxuZXhwb3J0IGRlZmF1bHQgSGVhZFxuIiwiZXhwb3J0IGZ1bmN0aW9uIG5vcm1hbGl6ZUxvY2FsZVBhdGgoXG4gIHBhdGhuYW1lOiBzdHJpbmcsXG4gIGxvY2FsZXM/OiBzdHJpbmdbXVxuKToge1xuICBkZXRlY3RlZExvY2FsZT86IHN0cmluZ1xuICBwYXRobmFtZTogc3RyaW5nXG59IHtcbiAgbGV0IGRldGVjdGVkTG9jYWxlOiBzdHJpbmcgfCB1bmRlZmluZWRcbiAgLy8gZmlyc3QgaXRlbSB3aWxsIGJlIGVtcHR5IHN0cmluZyBmcm9tIHNwbGl0dGluZyBhdCBmaXJzdCBjaGFyXG4gIGNvbnN0IHBhdGhuYW1lUGFydHMgPSBwYXRobmFtZS5zcGxpdCgnLycpXG5cbiAgOyhsb2NhbGVzIHx8IFtdKS5zb21lKChsb2NhbGUpID0+IHtcbiAgICBpZiAocGF0aG5hbWVQYXJ0c1sxXS50b0xvd2VyQ2FzZSgpID09PSBsb2NhbGUudG9Mb3dlckNhc2UoKSkge1xuICAgICAgZGV0ZWN0ZWRMb2NhbGUgPSBsb2NhbGVcbiAgICAgIHBhdGhuYW1lUGFydHMuc3BsaWNlKDEsIDEpXG4gICAgICBwYXRobmFtZSA9IHBhdGhuYW1lUGFydHMuam9pbignLycpIHx8ICcvJ1xuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlXG4gIH0pXG5cbiAgcmV0dXJuIHtcbiAgICBwYXRobmFtZSxcbiAgICBkZXRlY3RlZExvY2FsZSxcbiAgfVxufVxuIiwiLypcbk1JVCBMaWNlbnNlXG5cbkNvcHlyaWdodCAoYykgSmFzb24gTWlsbGVyIChodHRwczovL2phc29uZm9ybWF0LmNvbS8pXG5cblBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG5cblRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuXG5USEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cbiovXG5cbi8vIFRoaXMgZmlsZSBpcyBiYXNlZCBvbiBodHRwczovL2dpdGh1Yi5jb20vZGV2ZWxvcGl0L21pdHQvYmxvYi92MS4xLjMvc3JjL2luZGV4LmpzXG4vLyBJdCdzIGJlZW4gZWRpdGVkIGZvciB0aGUgbmVlZHMgb2YgdGhpcyBzY3JpcHRcbi8vIFNlZSB0aGUgTElDRU5TRSBhdCB0aGUgdG9wIG9mIHRoZSBmaWxlXG5cbnR5cGUgSGFuZGxlciA9ICguLi5ldnRzOiBhbnlbXSkgPT4gdm9pZFxuXG5leHBvcnQgdHlwZSBNaXR0RW1pdHRlciA9IHtcbiAgb24odHlwZTogc3RyaW5nLCBoYW5kbGVyOiBIYW5kbGVyKTogdm9pZFxuICBvZmYodHlwZTogc3RyaW5nLCBoYW5kbGVyOiBIYW5kbGVyKTogdm9pZFxuICBlbWl0KHR5cGU6IHN0cmluZywgLi4uZXZ0czogYW55W10pOiB2b2lkXG59XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIG1pdHQoKTogTWl0dEVtaXR0ZXIge1xuICBjb25zdCBhbGw6IHsgW3M6IHN0cmluZ106IEhhbmRsZXJbXSB9ID0gT2JqZWN0LmNyZWF0ZShudWxsKVxuXG4gIHJldHVybiB7XG4gICAgb24odHlwZTogc3RyaW5nLCBoYW5kbGVyOiBIYW5kbGVyKSB7XG4gICAgICA7KGFsbFt0eXBlXSB8fCAoYWxsW3R5cGVdID0gW10pKS5wdXNoKGhhbmRsZXIpXG4gICAgfSxcblxuICAgIG9mZih0eXBlOiBzdHJpbmcsIGhhbmRsZXI6IEhhbmRsZXIpIHtcbiAgICAgIGlmIChhbGxbdHlwZV0pIHtcbiAgICAgICAgYWxsW3R5cGVdLnNwbGljZShhbGxbdHlwZV0uaW5kZXhPZihoYW5kbGVyKSA+Pj4gMCwgMSlcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgZW1pdCh0eXBlOiBzdHJpbmcsIC4uLmV2dHM6IGFueVtdKSB7XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgYXJyYXktY2FsbGJhY2stcmV0dXJuXG4gICAgICA7KGFsbFt0eXBlXSB8fCBbXSkuc2xpY2UoKS5tYXAoKGhhbmRsZXI6IEhhbmRsZXIpID0+IHtcbiAgICAgICAgaGFuZGxlciguLi5ldnRzKVxuICAgICAgfSlcbiAgICB9LFxuICB9XG59XG4iLCJpbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnXG5pbXBvcnQgeyBOZXh0Um91dGVyIH0gZnJvbSAnLi9yb3V0ZXIvcm91dGVyJ1xuXG5leHBvcnQgY29uc3QgUm91dGVyQ29udGV4dCA9IFJlYWN0LmNyZWF0ZUNvbnRleHQ8TmV4dFJvdXRlcj4obnVsbCBhcyBhbnkpXG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIFJvdXRlckNvbnRleHQuZGlzcGxheU5hbWUgPSAnUm91dGVyQ29udGV4dCdcbn1cbiIsIi8vIHRzbGludDpkaXNhYmxlOm5vLWNvbnNvbGVcbmltcG9ydCB7IFBhcnNlZFVybFF1ZXJ5IH0gZnJvbSAncXVlcnlzdHJpbmcnXG5pbXBvcnQgeyBDb21wb25lbnRUeXBlIH0gZnJvbSAncmVhY3QnXG5pbXBvcnQgeyBVcmxPYmplY3QgfSBmcm9tICd1cmwnXG5pbXBvcnQge1xuICBub3JtYWxpemVQYXRoVHJhaWxpbmdTbGFzaCxcbiAgcmVtb3ZlUGF0aFRyYWlsaW5nU2xhc2gsXG59IGZyb20gJy4uLy4uLy4uL2NsaWVudC9ub3JtYWxpemUtdHJhaWxpbmctc2xhc2gnXG5pbXBvcnQgeyBHb29kUGFnZUNhY2hlLCBTdHlsZVNoZWV0VHVwbGUgfSBmcm9tICcuLi8uLi8uLi9jbGllbnQvcGFnZS1sb2FkZXInXG5pbXBvcnQge1xuICBnZXRDbGllbnRCdWlsZE1hbmlmZXN0LFxuICBpc0Fzc2V0RXJyb3IsXG4gIG1hcmtBc3NldEVycm9yLFxufSBmcm9tICcuLi8uLi8uLi9jbGllbnQvcm91dGUtbG9hZGVyJ1xuaW1wb3J0IHsgRG9tYWluTG9jYWxlcyB9IGZyb20gJy4uLy4uL3NlcnZlci9jb25maWcnXG5pbXBvcnQgeyBkZW5vcm1hbGl6ZVBhZ2VQYXRoIH0gZnJvbSAnLi4vLi4vc2VydmVyL2Rlbm9ybWFsaXplLXBhZ2UtcGF0aCdcbmltcG9ydCB7IG5vcm1hbGl6ZUxvY2FsZVBhdGggfSBmcm9tICcuLi9pMThuL25vcm1hbGl6ZS1sb2NhbGUtcGF0aCdcbmltcG9ydCBtaXR0LCB7IE1pdHRFbWl0dGVyIH0gZnJvbSAnLi4vbWl0dCdcbmltcG9ydCB7XG4gIEFwcENvbnRleHRUeXBlLFxuICBmb3JtYXRXaXRoVmFsaWRhdGlvbixcbiAgZ2V0TG9jYXRpb25PcmlnaW4sXG4gIGdldFVSTCxcbiAgbG9hZEdldEluaXRpYWxQcm9wcyxcbiAgTmV4dFBhZ2VDb250ZXh0LFxuICBTVCxcbiAgTkVYVF9EQVRBLFxufSBmcm9tICcuLi91dGlscydcbmltcG9ydCB7IGlzRHluYW1pY1JvdXRlIH0gZnJvbSAnLi91dGlscy9pcy1keW5hbWljJ1xuaW1wb3J0IHsgcGFyc2VSZWxhdGl2ZVVybCB9IGZyb20gJy4vdXRpbHMvcGFyc2UtcmVsYXRpdmUtdXJsJ1xuaW1wb3J0IHsgc2VhcmNoUGFyYW1zVG9VcmxRdWVyeSB9IGZyb20gJy4vdXRpbHMvcXVlcnlzdHJpbmcnXG5pbXBvcnQgcmVzb2x2ZVJld3JpdGVzIGZyb20gJy4vdXRpbHMvcmVzb2x2ZS1yZXdyaXRlcydcbmltcG9ydCB7IGdldFJvdXRlTWF0Y2hlciB9IGZyb20gJy4vdXRpbHMvcm91dGUtbWF0Y2hlcidcbmltcG9ydCB7IGdldFJvdXRlUmVnZXggfSBmcm9tICcuL3V0aWxzL3JvdXRlLXJlZ2V4J1xuXG5kZWNsYXJlIGdsb2JhbCB7XG4gIGludGVyZmFjZSBXaW5kb3cge1xuICAgIC8qIHByb2QgKi9cbiAgICBfX05FWFRfREFUQV9fOiBORVhUX0RBVEFcbiAgfVxufVxuXG5pbnRlcmZhY2UgUm91dGVQcm9wZXJ0aWVzIHtcbiAgc2hhbGxvdzogYm9vbGVhblxufVxuXG5pbnRlcmZhY2UgVHJhbnNpdGlvbk9wdGlvbnMge1xuICBzaGFsbG93PzogYm9vbGVhblxuICBsb2NhbGU/OiBzdHJpbmcgfCBmYWxzZVxuICBzY3JvbGw/OiBib29sZWFuXG59XG5cbmludGVyZmFjZSBOZXh0SGlzdG9yeVN0YXRlIHtcbiAgdXJsOiBzdHJpbmdcbiAgYXM6IHN0cmluZ1xuICBvcHRpb25zOiBUcmFuc2l0aW9uT3B0aW9uc1xufVxuXG50eXBlIEhpc3RvcnlTdGF0ZSA9XG4gIHwgbnVsbFxuICB8IHsgX19OOiBmYWxzZSB9XG4gIHwgKHsgX19OOiB0cnVlOyBpZHg6IG51bWJlciB9ICYgTmV4dEhpc3RvcnlTdGF0ZSlcblxubGV0IGRldGVjdERvbWFpbkxvY2FsZTogdHlwZW9mIGltcG9ydCgnLi4vaTE4bi9kZXRlY3QtZG9tYWluLWxvY2FsZScpLmRldGVjdERvbWFpbkxvY2FsZVxuXG5pZiAocHJvY2Vzcy5lbnYuX19ORVhUX0kxOE5fU1VQUE9SVCkge1xuICBkZXRlY3REb21haW5Mb2NhbGUgPSByZXF1aXJlKCcuLi9pMThuL2RldGVjdC1kb21haW4tbG9jYWxlJylcbiAgICAuZGV0ZWN0RG9tYWluTG9jYWxlXG59XG5cbmNvbnN0IGJhc2VQYXRoID0gKHByb2Nlc3MuZW52Ll9fTkVYVF9ST1VURVJfQkFTRVBBVEggYXMgc3RyaW5nKSB8fCAnJ1xuXG5mdW5jdGlvbiBidWlsZENhbmNlbGxhdGlvbkVycm9yKCkge1xuICByZXR1cm4gT2JqZWN0LmFzc2lnbihuZXcgRXJyb3IoJ1JvdXRlIENhbmNlbGxlZCcpLCB7XG4gICAgY2FuY2VsbGVkOiB0cnVlLFxuICB9KVxufVxuXG5mdW5jdGlvbiBhZGRQYXRoUHJlZml4KHBhdGg6IHN0cmluZywgcHJlZml4Pzogc3RyaW5nKSB7XG4gIHJldHVybiBwcmVmaXggJiYgcGF0aC5zdGFydHNXaXRoKCcvJylcbiAgICA/IHBhdGggPT09ICcvJ1xuICAgICAgPyBub3JtYWxpemVQYXRoVHJhaWxpbmdTbGFzaChwcmVmaXgpXG4gICAgICA6IGAke3ByZWZpeH0ke3BhdGhOb1F1ZXJ5SGFzaChwYXRoKSA9PT0gJy8nID8gcGF0aC5zdWJzdHJpbmcoMSkgOiBwYXRofWBcbiAgICA6IHBhdGhcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldERvbWFpbkxvY2FsZShcbiAgcGF0aDogc3RyaW5nLFxuICBsb2NhbGU/OiBzdHJpbmcgfCBmYWxzZSxcbiAgbG9jYWxlcz86IHN0cmluZ1tdLFxuICBkb21haW5Mb2NhbGVzPzogRG9tYWluTG9jYWxlc1xuKSB7XG4gIGlmIChwcm9jZXNzLmVudi5fX05FWFRfSTE4Tl9TVVBQT1JUKSB7XG4gICAgbG9jYWxlID0gbG9jYWxlIHx8IG5vcm1hbGl6ZUxvY2FsZVBhdGgocGF0aCwgbG9jYWxlcykuZGV0ZWN0ZWRMb2NhbGVcblxuICAgIGNvbnN0IGRldGVjdGVkRG9tYWluID0gZGV0ZWN0RG9tYWluTG9jYWxlKGRvbWFpbkxvY2FsZXMsIHVuZGVmaW5lZCwgbG9jYWxlKVxuXG4gICAgaWYgKGRldGVjdGVkRG9tYWluKSB7XG4gICAgICByZXR1cm4gYGh0dHAke2RldGVjdGVkRG9tYWluLmh0dHAgPyAnJyA6ICdzJ306Ly8ke2RldGVjdGVkRG9tYWluLmRvbWFpbn0ke1xuICAgICAgICBiYXNlUGF0aCB8fCAnJ1xuICAgICAgfSR7bG9jYWxlID09PSBkZXRlY3RlZERvbWFpbi5kZWZhdWx0TG9jYWxlID8gJycgOiBgLyR7bG9jYWxlfWB9JHtwYXRofWBcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cblxuICByZXR1cm4gZmFsc2Vcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGFkZExvY2FsZShcbiAgcGF0aDogc3RyaW5nLFxuICBsb2NhbGU/OiBzdHJpbmcgfCBmYWxzZSxcbiAgZGVmYXVsdExvY2FsZT86IHN0cmluZ1xuKSB7XG4gIGlmIChwcm9jZXNzLmVudi5fX05FWFRfSTE4Tl9TVVBQT1JUKSB7XG4gICAgY29uc3QgcGF0aG5hbWUgPSBwYXRoTm9RdWVyeUhhc2gocGF0aClcbiAgICBjb25zdCBwYXRoTG93ZXIgPSBwYXRobmFtZS50b0xvd2VyQ2FzZSgpXG4gICAgY29uc3QgbG9jYWxlTG93ZXIgPSBsb2NhbGUgJiYgbG9jYWxlLnRvTG93ZXJDYXNlKClcblxuICAgIHJldHVybiBsb2NhbGUgJiZcbiAgICAgIGxvY2FsZSAhPT0gZGVmYXVsdExvY2FsZSAmJlxuICAgICAgIXBhdGhMb3dlci5zdGFydHNXaXRoKCcvJyArIGxvY2FsZUxvd2VyICsgJy8nKSAmJlxuICAgICAgcGF0aExvd2VyICE9PSAnLycgKyBsb2NhbGVMb3dlclxuICAgICAgPyBhZGRQYXRoUHJlZml4KHBhdGgsICcvJyArIGxvY2FsZSlcbiAgICAgIDogcGF0aFxuICB9XG4gIHJldHVybiBwYXRoXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBkZWxMb2NhbGUocGF0aDogc3RyaW5nLCBsb2NhbGU/OiBzdHJpbmcpIHtcbiAgaWYgKHByb2Nlc3MuZW52Ll9fTkVYVF9JMThOX1NVUFBPUlQpIHtcbiAgICBjb25zdCBwYXRobmFtZSA9IHBhdGhOb1F1ZXJ5SGFzaChwYXRoKVxuICAgIGNvbnN0IHBhdGhMb3dlciA9IHBhdGhuYW1lLnRvTG93ZXJDYXNlKClcbiAgICBjb25zdCBsb2NhbGVMb3dlciA9IGxvY2FsZSAmJiBsb2NhbGUudG9Mb3dlckNhc2UoKVxuXG4gICAgcmV0dXJuIGxvY2FsZSAmJlxuICAgICAgKHBhdGhMb3dlci5zdGFydHNXaXRoKCcvJyArIGxvY2FsZUxvd2VyICsgJy8nKSB8fFxuICAgICAgICBwYXRoTG93ZXIgPT09ICcvJyArIGxvY2FsZUxvd2VyKVxuICAgICAgPyAocGF0aG5hbWUubGVuZ3RoID09PSBsb2NhbGUubGVuZ3RoICsgMSA/ICcvJyA6ICcnKSArXG4gICAgICAgICAgcGF0aC5zdWJzdHIobG9jYWxlLmxlbmd0aCArIDEpXG4gICAgICA6IHBhdGhcbiAgfVxuICByZXR1cm4gcGF0aFxufVxuXG5mdW5jdGlvbiBwYXRoTm9RdWVyeUhhc2gocGF0aDogc3RyaW5nKSB7XG4gIGNvbnN0IHF1ZXJ5SW5kZXggPSBwYXRoLmluZGV4T2YoJz8nKVxuICBjb25zdCBoYXNoSW5kZXggPSBwYXRoLmluZGV4T2YoJyMnKVxuXG4gIGlmIChxdWVyeUluZGV4ID4gLTEgfHwgaGFzaEluZGV4ID4gLTEpIHtcbiAgICBwYXRoID0gcGF0aC5zdWJzdHJpbmcoMCwgcXVlcnlJbmRleCA+IC0xID8gcXVlcnlJbmRleCA6IGhhc2hJbmRleClcbiAgfVxuICByZXR1cm4gcGF0aFxufVxuXG5leHBvcnQgZnVuY3Rpb24gaGFzQmFzZVBhdGgocGF0aDogc3RyaW5nKTogYm9vbGVhbiB7XG4gIHBhdGggPSBwYXRoTm9RdWVyeUhhc2gocGF0aClcbiAgcmV0dXJuIHBhdGggPT09IGJhc2VQYXRoIHx8IHBhdGguc3RhcnRzV2l0aChiYXNlUGF0aCArICcvJylcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGFkZEJhc2VQYXRoKHBhdGg6IHN0cmluZyk6IHN0cmluZyB7XG4gIC8vIHdlIG9ubHkgYWRkIHRoZSBiYXNlcGF0aCBvbiByZWxhdGl2ZSB1cmxzXG4gIHJldHVybiBhZGRQYXRoUHJlZml4KHBhdGgsIGJhc2VQYXRoKVxufVxuXG5leHBvcnQgZnVuY3Rpb24gZGVsQmFzZVBhdGgocGF0aDogc3RyaW5nKTogc3RyaW5nIHtcbiAgcGF0aCA9IHBhdGguc2xpY2UoYmFzZVBhdGgubGVuZ3RoKVxuICBpZiAoIXBhdGguc3RhcnRzV2l0aCgnLycpKSBwYXRoID0gYC8ke3BhdGh9YFxuICByZXR1cm4gcGF0aFxufVxuXG4vKipcbiAqIERldGVjdHMgd2hldGhlciBhIGdpdmVuIHVybCBpcyByb3V0YWJsZSBieSB0aGUgTmV4dC5qcyByb3V0ZXIgKGJyb3dzZXIgb25seSkuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc0xvY2FsVVJMKHVybDogc3RyaW5nKTogYm9vbGVhbiB7XG4gIC8vIHByZXZlbnQgYSBoeWRyYXRpb24gbWlzbWF0Y2ggb24gaHJlZiBmb3IgdXJsIHdpdGggYW5jaG9yIHJlZnNcbiAgaWYgKHVybC5zdGFydHNXaXRoKCcvJykgfHwgdXJsLnN0YXJ0c1dpdGgoJyMnKSkgcmV0dXJuIHRydWVcbiAgdHJ5IHtcbiAgICAvLyBhYnNvbHV0ZSB1cmxzIGNhbiBiZSBsb2NhbCBpZiB0aGV5IGFyZSBvbiB0aGUgc2FtZSBvcmlnaW5cbiAgICBjb25zdCBsb2NhdGlvbk9yaWdpbiA9IGdldExvY2F0aW9uT3JpZ2luKClcbiAgICBjb25zdCByZXNvbHZlZCA9IG5ldyBVUkwodXJsLCBsb2NhdGlvbk9yaWdpbilcbiAgICByZXR1cm4gcmVzb2x2ZWQub3JpZ2luID09PSBsb2NhdGlvbk9yaWdpbiAmJiBoYXNCYXNlUGF0aChyZXNvbHZlZC5wYXRobmFtZSlcbiAgfSBjYXRjaCAoXykge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG59XG5cbnR5cGUgVXJsID0gVXJsT2JqZWN0IHwgc3RyaW5nXG5cbmV4cG9ydCBmdW5jdGlvbiBpbnRlcnBvbGF0ZUFzKFxuICByb3V0ZTogc3RyaW5nLFxuICBhc1BhdGhuYW1lOiBzdHJpbmcsXG4gIHF1ZXJ5OiBQYXJzZWRVcmxRdWVyeVxuKSB7XG4gIGxldCBpbnRlcnBvbGF0ZWRSb3V0ZSA9ICcnXG5cbiAgY29uc3QgZHluYW1pY1JlZ2V4ID0gZ2V0Um91dGVSZWdleChyb3V0ZSlcbiAgY29uc3QgZHluYW1pY0dyb3VwcyA9IGR5bmFtaWNSZWdleC5ncm91cHNcbiAgY29uc3QgZHluYW1pY01hdGNoZXMgPVxuICAgIC8vIFRyeSB0byBtYXRjaCB0aGUgZHluYW1pYyByb3V0ZSBhZ2FpbnN0IHRoZSBhc1BhdGhcbiAgICAoYXNQYXRobmFtZSAhPT0gcm91dGUgPyBnZXRSb3V0ZU1hdGNoZXIoZHluYW1pY1JlZ2V4KShhc1BhdGhuYW1lKSA6ICcnKSB8fFxuICAgIC8vIEZhbGwgYmFjayB0byByZWFkaW5nIHRoZSB2YWx1ZXMgZnJvbSB0aGUgaHJlZlxuICAgIC8vIFRPRE86IHNob3VsZCB0aGlzIHRha2UgcHJpb3JpdHk7IGFsc28gbmVlZCB0byBjaGFuZ2UgaW4gdGhlIHJvdXRlci5cbiAgICBxdWVyeVxuXG4gIGludGVycG9sYXRlZFJvdXRlID0gcm91dGVcbiAgY29uc3QgcGFyYW1zID0gT2JqZWN0LmtleXMoZHluYW1pY0dyb3VwcylcblxuICBpZiAoXG4gICAgIXBhcmFtcy5ldmVyeSgocGFyYW0pID0+IHtcbiAgICAgIGxldCB2YWx1ZSA9IGR5bmFtaWNNYXRjaGVzW3BhcmFtXSB8fCAnJ1xuICAgICAgY29uc3QgeyByZXBlYXQsIG9wdGlvbmFsIH0gPSBkeW5hbWljR3JvdXBzW3BhcmFtXVxuXG4gICAgICAvLyBzdXBwb3J0IHNpbmdsZS1sZXZlbCBjYXRjaC1hbGxcbiAgICAgIC8vIFRPRE86IG1vcmUgcm9idXN0IGhhbmRsaW5nIGZvciB1c2VyLWVycm9yIChwYXNzaW5nIGAvYClcbiAgICAgIGxldCByZXBsYWNlZCA9IGBbJHtyZXBlYXQgPyAnLi4uJyA6ICcnfSR7cGFyYW19XWBcbiAgICAgIGlmIChvcHRpb25hbCkge1xuICAgICAgICByZXBsYWNlZCA9IGAkeyF2YWx1ZSA/ICcvJyA6ICcnfVske3JlcGxhY2VkfV1gXG4gICAgICB9XG4gICAgICBpZiAocmVwZWF0ICYmICFBcnJheS5pc0FycmF5KHZhbHVlKSkgdmFsdWUgPSBbdmFsdWVdXG5cbiAgICAgIHJldHVybiAoXG4gICAgICAgIChvcHRpb25hbCB8fCBwYXJhbSBpbiBkeW5hbWljTWF0Y2hlcykgJiZcbiAgICAgICAgLy8gSW50ZXJwb2xhdGUgZ3JvdXAgaW50byBkYXRhIFVSTCBpZiBwcmVzZW50XG4gICAgICAgIChpbnRlcnBvbGF0ZWRSb3V0ZSA9XG4gICAgICAgICAgaW50ZXJwb2xhdGVkUm91dGUhLnJlcGxhY2UoXG4gICAgICAgICAgICByZXBsYWNlZCxcbiAgICAgICAgICAgIHJlcGVhdFxuICAgICAgICAgICAgICA/ICh2YWx1ZSBhcyBzdHJpbmdbXSlcbiAgICAgICAgICAgICAgICAgIC5tYXAoXG4gICAgICAgICAgICAgICAgICAgIC8vIHRoZXNlIHZhbHVlcyBzaG91bGQgYmUgZnVsbHkgZW5jb2RlZCBpbnN0ZWFkIG9mIGp1c3RcbiAgICAgICAgICAgICAgICAgICAgLy8gcGF0aCBkZWxpbWl0ZXIgZXNjYXBlZCBzaW5jZSB0aGV5IGFyZSBiZWluZyBpbnNlcnRlZFxuICAgICAgICAgICAgICAgICAgICAvLyBpbnRvIHRoZSBVUkwgYW5kIHdlIGV4cGVjdCBVUkwgZW5jb2RlZCBzZWdtZW50c1xuICAgICAgICAgICAgICAgICAgICAvLyB3aGVuIHBhcnNpbmcgZHluYW1pYyByb3V0ZSBwYXJhbXNcbiAgICAgICAgICAgICAgICAgICAgKHNlZ21lbnQpID0+IGVuY29kZVVSSUNvbXBvbmVudChzZWdtZW50KVxuICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgICAgLmpvaW4oJy8nKVxuICAgICAgICAgICAgICA6IGVuY29kZVVSSUNvbXBvbmVudCh2YWx1ZSBhcyBzdHJpbmcpXG4gICAgICAgICAgKSB8fCAnLycpXG4gICAgICApXG4gICAgfSlcbiAgKSB7XG4gICAgaW50ZXJwb2xhdGVkUm91dGUgPSAnJyAvLyBkaWQgbm90IHNhdGlzZnkgYWxsIHJlcXVpcmVtZW50c1xuXG4gICAgLy8gbi5iLiBXZSBpZ25vcmUgdGhpcyBlcnJvciBiZWNhdXNlIHdlIGhhbmRsZSB3YXJuaW5nIGZvciB0aGlzIGNhc2UgaW5cbiAgICAvLyBkZXZlbG9wbWVudCBpbiB0aGUgYDxMaW5rPmAgY29tcG9uZW50IGRpcmVjdGx5LlxuICB9XG4gIHJldHVybiB7XG4gICAgcGFyYW1zLFxuICAgIHJlc3VsdDogaW50ZXJwb2xhdGVkUm91dGUsXG4gIH1cbn1cblxuZnVuY3Rpb24gb21pdFBhcm1zRnJvbVF1ZXJ5KHF1ZXJ5OiBQYXJzZWRVcmxRdWVyeSwgcGFyYW1zOiBzdHJpbmdbXSkge1xuICBjb25zdCBmaWx0ZXJlZFF1ZXJ5OiBQYXJzZWRVcmxRdWVyeSA9IHt9XG5cbiAgT2JqZWN0LmtleXMocXVlcnkpLmZvckVhY2goKGtleSkgPT4ge1xuICAgIGlmICghcGFyYW1zLmluY2x1ZGVzKGtleSkpIHtcbiAgICAgIGZpbHRlcmVkUXVlcnlba2V5XSA9IHF1ZXJ5W2tleV1cbiAgICB9XG4gIH0pXG4gIHJldHVybiBmaWx0ZXJlZFF1ZXJ5XG59XG5cbi8qKlxuICogUmVzb2x2ZXMgYSBnaXZlbiBoeXBlcmxpbmsgd2l0aCBhIGNlcnRhaW4gcm91dGVyIHN0YXRlIChiYXNlUGF0aCBub3QgaW5jbHVkZWQpLlxuICogUHJlc2VydmVzIGFic29sdXRlIHVybHMuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiByZXNvbHZlSHJlZihcbiAgY3VycmVudFBhdGg6IHN0cmluZyxcbiAgaHJlZjogVXJsLFxuICByZXNvbHZlQXM/OiBib29sZWFuXG4pOiBzdHJpbmcge1xuICAvLyB3ZSB1c2UgYSBkdW1teSBiYXNlIHVybCBmb3IgcmVsYXRpdmUgdXJsc1xuICBsZXQgYmFzZTogVVJMXG5cbiAgdHJ5IHtcbiAgICBiYXNlID0gbmV3IFVSTChjdXJyZW50UGF0aCwgJ2h0dHA6Ly9uJylcbiAgfSBjYXRjaCAoXykge1xuICAgIC8vIGZhbGxiYWNrIHRvIC8gZm9yIGludmFsaWQgYXNQYXRoIHZhbHVlcyBlLmcuIC8vXG4gICAgYmFzZSA9IG5ldyBVUkwoJy8nLCAnaHR0cDovL24nKVxuICB9XG4gIGNvbnN0IHVybEFzU3RyaW5nID1cbiAgICB0eXBlb2YgaHJlZiA9PT0gJ3N0cmluZycgPyBocmVmIDogZm9ybWF0V2l0aFZhbGlkYXRpb24oaHJlZilcbiAgLy8gUmV0dXJuIGJlY2F1c2UgaXQgY2Fubm90IGJlIHJvdXRlZCBieSB0aGUgTmV4dC5qcyByb3V0ZXJcbiAgaWYgKCFpc0xvY2FsVVJMKHVybEFzU3RyaW5nKSkge1xuICAgIHJldHVybiAocmVzb2x2ZUFzID8gW3VybEFzU3RyaW5nXSA6IHVybEFzU3RyaW5nKSBhcyBzdHJpbmdcbiAgfVxuICB0cnkge1xuICAgIGNvbnN0IGZpbmFsVXJsID0gbmV3IFVSTCh1cmxBc1N0cmluZywgYmFzZSlcbiAgICBmaW5hbFVybC5wYXRobmFtZSA9IG5vcm1hbGl6ZVBhdGhUcmFpbGluZ1NsYXNoKGZpbmFsVXJsLnBhdGhuYW1lKVxuICAgIGxldCBpbnRlcnBvbGF0ZWRBcyA9ICcnXG5cbiAgICBpZiAoXG4gICAgICBpc0R5bmFtaWNSb3V0ZShmaW5hbFVybC5wYXRobmFtZSkgJiZcbiAgICAgIGZpbmFsVXJsLnNlYXJjaFBhcmFtcyAmJlxuICAgICAgcmVzb2x2ZUFzXG4gICAgKSB7XG4gICAgICBjb25zdCBxdWVyeSA9IHNlYXJjaFBhcmFtc1RvVXJsUXVlcnkoZmluYWxVcmwuc2VhcmNoUGFyYW1zKVxuXG4gICAgICBjb25zdCB7IHJlc3VsdCwgcGFyYW1zIH0gPSBpbnRlcnBvbGF0ZUFzKFxuICAgICAgICBmaW5hbFVybC5wYXRobmFtZSxcbiAgICAgICAgZmluYWxVcmwucGF0aG5hbWUsXG4gICAgICAgIHF1ZXJ5XG4gICAgICApXG5cbiAgICAgIGlmIChyZXN1bHQpIHtcbiAgICAgICAgaW50ZXJwb2xhdGVkQXMgPSBmb3JtYXRXaXRoVmFsaWRhdGlvbih7XG4gICAgICAgICAgcGF0aG5hbWU6IHJlc3VsdCxcbiAgICAgICAgICBoYXNoOiBmaW5hbFVybC5oYXNoLFxuICAgICAgICAgIHF1ZXJ5OiBvbWl0UGFybXNGcm9tUXVlcnkocXVlcnksIHBhcmFtcyksXG4gICAgICAgIH0pXG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gaWYgdGhlIG9yaWdpbiBkaWRuJ3QgY2hhbmdlLCBpdCBtZWFucyB3ZSByZWNlaXZlZCBhIHJlbGF0aXZlIGhyZWZcbiAgICBjb25zdCByZXNvbHZlZEhyZWYgPVxuICAgICAgZmluYWxVcmwub3JpZ2luID09PSBiYXNlLm9yaWdpblxuICAgICAgICA/IGZpbmFsVXJsLmhyZWYuc2xpY2UoZmluYWxVcmwub3JpZ2luLmxlbmd0aClcbiAgICAgICAgOiBmaW5hbFVybC5ocmVmXG5cbiAgICByZXR1cm4gKHJlc29sdmVBc1xuICAgICAgPyBbcmVzb2x2ZWRIcmVmLCBpbnRlcnBvbGF0ZWRBcyB8fCByZXNvbHZlZEhyZWZdXG4gICAgICA6IHJlc29sdmVkSHJlZikgYXMgc3RyaW5nXG4gIH0gY2F0Y2ggKF8pIHtcbiAgICByZXR1cm4gKHJlc29sdmVBcyA/IFt1cmxBc1N0cmluZ10gOiB1cmxBc1N0cmluZykgYXMgc3RyaW5nXG4gIH1cbn1cblxuZnVuY3Rpb24gc3RyaXBPcmlnaW4odXJsOiBzdHJpbmcpIHtcbiAgY29uc3Qgb3JpZ2luID0gZ2V0TG9jYXRpb25PcmlnaW4oKVxuXG4gIHJldHVybiB1cmwuc3RhcnRzV2l0aChvcmlnaW4pID8gdXJsLnN1YnN0cmluZyhvcmlnaW4ubGVuZ3RoKSA6IHVybFxufVxuXG5mdW5jdGlvbiBwcmVwYXJlVXJsQXMocm91dGVyOiBOZXh0Um91dGVyLCB1cmw6IFVybCwgYXM/OiBVcmwpIHtcbiAgLy8gSWYgdXJsIGFuZCBhcyBwcm92aWRlZCBhcyBhbiBvYmplY3QgcmVwcmVzZW50YXRpb24sXG4gIC8vIHdlJ2xsIGZvcm1hdCB0aGVtIGludG8gdGhlIHN0cmluZyB2ZXJzaW9uIGhlcmUuXG4gIGxldCBbcmVzb2x2ZWRIcmVmLCByZXNvbHZlZEFzXSA9IHJlc29sdmVIcmVmKHJvdXRlci5hc1BhdGgsIHVybCwgdHJ1ZSlcbiAgY29uc3Qgb3JpZ2luID0gZ2V0TG9jYXRpb25PcmlnaW4oKVxuICBjb25zdCBocmVmSGFkT3JpZ2luID0gcmVzb2x2ZWRIcmVmLnN0YXJ0c1dpdGgob3JpZ2luKVxuICBjb25zdCBhc0hhZE9yaWdpbiA9IHJlc29sdmVkQXMgJiYgcmVzb2x2ZWRBcy5zdGFydHNXaXRoKG9yaWdpbilcblxuICByZXNvbHZlZEhyZWYgPSBzdHJpcE9yaWdpbihyZXNvbHZlZEhyZWYpXG4gIHJlc29sdmVkQXMgPSByZXNvbHZlZEFzID8gc3RyaXBPcmlnaW4ocmVzb2x2ZWRBcykgOiByZXNvbHZlZEFzXG5cbiAgY29uc3QgcHJlcGFyZWRVcmwgPSBocmVmSGFkT3JpZ2luID8gcmVzb2x2ZWRIcmVmIDogYWRkQmFzZVBhdGgocmVzb2x2ZWRIcmVmKVxuICBjb25zdCBwcmVwYXJlZEFzID0gYXNcbiAgICA/IHN0cmlwT3JpZ2luKHJlc29sdmVIcmVmKHJvdXRlci5hc1BhdGgsIGFzKSlcbiAgICA6IHJlc29sdmVkQXMgfHwgcmVzb2x2ZWRIcmVmXG5cbiAgcmV0dXJuIHtcbiAgICB1cmw6IHByZXBhcmVkVXJsLFxuICAgIGFzOiBhc0hhZE9yaWdpbiA/IHByZXBhcmVkQXMgOiBhZGRCYXNlUGF0aChwcmVwYXJlZEFzKSxcbiAgfVxufVxuXG5mdW5jdGlvbiByZXNvbHZlRHluYW1pY1JvdXRlKHBhdGhuYW1lOiBzdHJpbmcsIHBhZ2VzOiBzdHJpbmdbXSkge1xuICBjb25zdCBjbGVhblBhdGhuYW1lID0gcmVtb3ZlUGF0aFRyYWlsaW5nU2xhc2goZGVub3JtYWxpemVQYWdlUGF0aChwYXRobmFtZSEpKVxuXG4gIGlmIChjbGVhblBhdGhuYW1lID09PSAnLzQwNCcgfHwgY2xlYW5QYXRobmFtZSA9PT0gJy9fZXJyb3InKSB7XG4gICAgcmV0dXJuIHBhdGhuYW1lXG4gIH1cblxuICAvLyBoYW5kbGUgcmVzb2x2aW5nIGhyZWYgZm9yIGR5bmFtaWMgcm91dGVzXG4gIGlmICghcGFnZXMuaW5jbHVkZXMoY2xlYW5QYXRobmFtZSEpKSB7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGFycmF5LWNhbGxiYWNrLXJldHVyblxuICAgIHBhZ2VzLnNvbWUoKHBhZ2UpID0+IHtcbiAgICAgIGlmIChpc0R5bmFtaWNSb3V0ZShwYWdlKSAmJiBnZXRSb3V0ZVJlZ2V4KHBhZ2UpLnJlLnRlc3QoY2xlYW5QYXRobmFtZSEpKSB7XG4gICAgICAgIHBhdGhuYW1lID0gcGFnZVxuICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgfVxuICAgIH0pXG4gIH1cbiAgcmV0dXJuIHJlbW92ZVBhdGhUcmFpbGluZ1NsYXNoKHBhdGhuYW1lKVxufVxuXG5leHBvcnQgdHlwZSBCYXNlUm91dGVyID0ge1xuICByb3V0ZTogc3RyaW5nXG4gIHBhdGhuYW1lOiBzdHJpbmdcbiAgcXVlcnk6IFBhcnNlZFVybFF1ZXJ5XG4gIGFzUGF0aDogc3RyaW5nXG4gIGJhc2VQYXRoOiBzdHJpbmdcbiAgbG9jYWxlPzogc3RyaW5nXG4gIGxvY2FsZXM/OiBzdHJpbmdbXVxuICBkZWZhdWx0TG9jYWxlPzogc3RyaW5nXG4gIGRvbWFpbkxvY2FsZXM/OiBEb21haW5Mb2NhbGVzXG4gIGlzTG9jYWxlRG9tYWluOiBib29sZWFuXG59XG5cbmV4cG9ydCB0eXBlIE5leHRSb3V0ZXIgPSBCYXNlUm91dGVyICZcbiAgUGljazxcbiAgICBSb3V0ZXIsXG4gICAgfCAncHVzaCdcbiAgICB8ICdyZXBsYWNlJ1xuICAgIHwgJ3JlbG9hZCdcbiAgICB8ICdiYWNrJ1xuICAgIHwgJ3ByZWZldGNoJ1xuICAgIHwgJ2JlZm9yZVBvcFN0YXRlJ1xuICAgIHwgJ2V2ZW50cydcbiAgICB8ICdpc0ZhbGxiYWNrJ1xuICAgIHwgJ2lzUmVhZHknXG4gICAgfCAnaXNQcmV2aWV3J1xuICA+XG5cbmV4cG9ydCB0eXBlIFByZWZldGNoT3B0aW9ucyA9IHtcbiAgcHJpb3JpdHk/OiBib29sZWFuXG4gIGxvY2FsZT86IHN0cmluZyB8IGZhbHNlXG59XG5cbmV4cG9ydCB0eXBlIFByaXZhdGVSb3V0ZUluZm8gPVxuICB8IChPbWl0PENvbXBsZXRlUHJpdmF0ZVJvdXRlSW5mbywgJ3N0eWxlU2hlZXRzJz4gJiB7IGluaXRpYWw6IHRydWUgfSlcbiAgfCBDb21wbGV0ZVByaXZhdGVSb3V0ZUluZm9cblxuZXhwb3J0IHR5cGUgQ29tcGxldGVQcml2YXRlUm91dGVJbmZvID0ge1xuICBDb21wb25lbnQ6IENvbXBvbmVudFR5cGVcbiAgc3R5bGVTaGVldHM6IFN0eWxlU2hlZXRUdXBsZVtdXG4gIF9fTl9TU0c/OiBib29sZWFuXG4gIF9fTl9TU1A/OiBib29sZWFuXG4gIHByb3BzPzogUmVjb3JkPHN0cmluZywgYW55PlxuICBlcnI/OiBFcnJvclxuICBlcnJvcj86IGFueVxufVxuXG5leHBvcnQgdHlwZSBBcHBQcm9wcyA9IFBpY2s8Q29tcGxldGVQcml2YXRlUm91dGVJbmZvLCAnQ29tcG9uZW50JyB8ICdlcnInPiAmIHtcbiAgcm91dGVyOiBSb3V0ZXJcbn0gJiBSZWNvcmQ8c3RyaW5nLCBhbnk+XG5leHBvcnQgdHlwZSBBcHBDb21wb25lbnQgPSBDb21wb25lbnRUeXBlPEFwcFByb3BzPlxuXG50eXBlIFN1YnNjcmlwdGlvbiA9IChcbiAgZGF0YTogUHJpdmF0ZVJvdXRlSW5mbyxcbiAgQXBwOiBBcHBDb21wb25lbnQsXG4gIHJlc2V0U2Nyb2xsOiB7IHg6IG51bWJlcjsgeTogbnVtYmVyIH0gfCBudWxsXG4pID0+IFByb21pc2U8dm9pZD5cblxudHlwZSBCZWZvcmVQb3BTdGF0ZUNhbGxiYWNrID0gKHN0YXRlOiBOZXh0SGlzdG9yeVN0YXRlKSA9PiBib29sZWFuXG5cbnR5cGUgQ29tcG9uZW50TG9hZENhbmNlbCA9ICgoKSA9PiB2b2lkKSB8IG51bGxcblxudHlwZSBIaXN0b3J5TWV0aG9kID0gJ3JlcGxhY2VTdGF0ZScgfCAncHVzaFN0YXRlJ1xuXG5jb25zdCBtYW51YWxTY3JvbGxSZXN0b3JhdGlvbiA9XG4gIHByb2Nlc3MuZW52Ll9fTkVYVF9TQ1JPTExfUkVTVE9SQVRJT04gJiZcbiAgdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgJ3Njcm9sbFJlc3RvcmF0aW9uJyBpbiB3aW5kb3cuaGlzdG9yeSAmJlxuICAhIShmdW5jdGlvbiAoKSB7XG4gICAgdHJ5IHtcbiAgICAgIGxldCB2ID0gJ19fbmV4dCdcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1zZXF1ZW5jZXNcbiAgICAgIHJldHVybiBzZXNzaW9uU3RvcmFnZS5zZXRJdGVtKHYsIHYpLCBzZXNzaW9uU3RvcmFnZS5yZW1vdmVJdGVtKHYpLCB0cnVlXG4gICAgfSBjYXRjaCAobikge31cbiAgfSkoKVxuXG5jb25zdCBTU0dfREFUQV9OT1RfRk9VTkQgPSBTeW1ib2woJ1NTR19EQVRBX05PVF9GT1VORCcpXG5cbmZ1bmN0aW9uIGZldGNoUmV0cnkodXJsOiBzdHJpbmcsIGF0dGVtcHRzOiBudW1iZXIpOiBQcm9taXNlPGFueT4ge1xuICByZXR1cm4gZmV0Y2godXJsLCB7XG4gICAgLy8gQ29va2llcyBhcmUgcmVxdWlyZWQgdG8gYmUgcHJlc2VudCBmb3IgTmV4dC5qcycgU1NHIFwiUHJldmlldyBNb2RlXCIuXG4gICAgLy8gQ29va2llcyBtYXkgYWxzbyBiZSByZXF1aXJlZCBmb3IgYGdldFNlcnZlclNpZGVQcm9wc2AuXG4gICAgLy9cbiAgICAvLyA+IGBmZXRjaGAgd29u4oCZdCBzZW5kIGNvb2tpZXMsIHVubGVzcyB5b3Ugc2V0IHRoZSBjcmVkZW50aWFscyBpbml0XG4gICAgLy8gPiBvcHRpb24uXG4gICAgLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0ZldGNoX0FQSS9Vc2luZ19GZXRjaFxuICAgIC8vXG4gICAgLy8gPiBGb3IgbWF4aW11bSBicm93c2VyIGNvbXBhdGliaWxpdHkgd2hlbiBpdCBjb21lcyB0byBzZW5kaW5nICZcbiAgICAvLyA+IHJlY2VpdmluZyBjb29raWVzLCBhbHdheXMgc3VwcGx5IHRoZSBgY3JlZGVudGlhbHM6ICdzYW1lLW9yaWdpbidgXG4gICAgLy8gPiBvcHRpb24gaW5zdGVhZCBvZiByZWx5aW5nIG9uIHRoZSBkZWZhdWx0LlxuICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9naXRodWIvZmV0Y2gjY2F2ZWF0c1xuICAgIGNyZWRlbnRpYWxzOiAnc2FtZS1vcmlnaW4nLFxuICB9KS50aGVuKChyZXMpID0+IHtcbiAgICBpZiAoIXJlcy5vaykge1xuICAgICAgaWYgKGF0dGVtcHRzID4gMSAmJiByZXMuc3RhdHVzID49IDUwMCkge1xuICAgICAgICByZXR1cm4gZmV0Y2hSZXRyeSh1cmwsIGF0dGVtcHRzIC0gMSlcbiAgICAgIH1cbiAgICAgIGlmIChyZXMuc3RhdHVzID09PSA0MDQpIHtcbiAgICAgICAgcmV0dXJuIHJlcy5qc29uKCkudGhlbigoZGF0YSkgPT4ge1xuICAgICAgICAgIGlmIChkYXRhLm5vdEZvdW5kKSB7XG4gICAgICAgICAgICByZXR1cm4geyBub3RGb3VuZDogU1NHX0RBVEFfTk9UX0ZPVU5EIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBGYWlsZWQgdG8gbG9hZCBzdGF0aWMgcHJvcHNgKVxuICAgICAgICB9KVxuICAgICAgfVxuICAgICAgdGhyb3cgbmV3IEVycm9yKGBGYWlsZWQgdG8gbG9hZCBzdGF0aWMgcHJvcHNgKVxuICAgIH1cbiAgICByZXR1cm4gcmVzLmpzb24oKVxuICB9KVxufVxuXG5mdW5jdGlvbiBmZXRjaE5leHREYXRhKGRhdGFIcmVmOiBzdHJpbmcsIGlzU2VydmVyUmVuZGVyOiBib29sZWFuKSB7XG4gIHJldHVybiBmZXRjaFJldHJ5KGRhdGFIcmVmLCBpc1NlcnZlclJlbmRlciA/IDMgOiAxKS5jYXRjaCgoZXJyOiBFcnJvcikgPT4ge1xuICAgIC8vIFdlIHNob3VsZCBvbmx5IHRyaWdnZXIgYSBzZXJ2ZXItc2lkZSB0cmFuc2l0aW9uIGlmIHRoaXMgd2FzIGNhdXNlZFxuICAgIC8vIG9uIGEgY2xpZW50LXNpZGUgdHJhbnNpdGlvbi4gT3RoZXJ3aXNlLCB3ZSdkIGdldCBpbnRvIGFuIGluZmluaXRlXG4gICAgLy8gbG9vcC5cblxuICAgIGlmICghaXNTZXJ2ZXJSZW5kZXIpIHtcbiAgICAgIG1hcmtBc3NldEVycm9yKGVycilcbiAgICB9XG4gICAgdGhyb3cgZXJyXG4gIH0pXG59XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFJvdXRlciBpbXBsZW1lbnRzIEJhc2VSb3V0ZXIge1xuICByb3V0ZTogc3RyaW5nXG4gIHBhdGhuYW1lOiBzdHJpbmdcbiAgcXVlcnk6IFBhcnNlZFVybFF1ZXJ5XG4gIGFzUGF0aDogc3RyaW5nXG4gIGJhc2VQYXRoOiBzdHJpbmdcblxuICAvKipcbiAgICogTWFwIG9mIGFsbCBjb21wb25lbnRzIGxvYWRlZCBpbiBgUm91dGVyYFxuICAgKi9cbiAgY29tcG9uZW50czogeyBbcGF0aG5hbWU6IHN0cmluZ106IFByaXZhdGVSb3V0ZUluZm8gfVxuICAvLyBTdGF0aWMgRGF0YSBDYWNoZVxuICBzZGM6IHsgW2FzUGF0aDogc3RyaW5nXTogb2JqZWN0IH0gPSB7fVxuICAvLyBJbi1mbGlnaHQgU2VydmVyIERhdGEgUmVxdWVzdHMsIGZvciBkZWR1cGluZ1xuICBzZHI6IHsgW2FzUGF0aDogc3RyaW5nXTogUHJvbWlzZTxvYmplY3Q+IH0gPSB7fVxuXG4gIHN1YjogU3Vic2NyaXB0aW9uXG4gIGNsYzogQ29tcG9uZW50TG9hZENhbmNlbFxuICBwYWdlTG9hZGVyOiBhbnlcbiAgX2JwczogQmVmb3JlUG9wU3RhdGVDYWxsYmFjayB8IHVuZGVmaW5lZFxuICBldmVudHM6IE1pdHRFbWl0dGVyXG4gIF93cmFwQXBwOiAoQXBwOiBBcHBDb21wb25lbnQpID0+IGFueVxuICBpc1NzcjogYm9vbGVhblxuICBpc0ZhbGxiYWNrOiBib29sZWFuXG4gIF9pbkZsaWdodFJvdXRlPzogc3RyaW5nXG4gIF9zaGFsbG93PzogYm9vbGVhblxuICBsb2NhbGU/OiBzdHJpbmdcbiAgbG9jYWxlcz86IHN0cmluZ1tdXG4gIGRlZmF1bHRMb2NhbGU/OiBzdHJpbmdcbiAgZG9tYWluTG9jYWxlcz86IERvbWFpbkxvY2FsZXNcbiAgaXNSZWFkeTogYm9vbGVhblxuICBpc1ByZXZpZXc6IGJvb2xlYW5cbiAgaXNMb2NhbGVEb21haW46IGJvb2xlYW5cblxuICBwcml2YXRlIF9pZHg6IG51bWJlciA9IDBcblxuICBzdGF0aWMgZXZlbnRzOiBNaXR0RW1pdHRlciA9IG1pdHQoKVxuXG4gIGNvbnN0cnVjdG9yKFxuICAgIHBhdGhuYW1lOiBzdHJpbmcsXG4gICAgcXVlcnk6IFBhcnNlZFVybFF1ZXJ5LFxuICAgIGFzOiBzdHJpbmcsXG4gICAge1xuICAgICAgaW5pdGlhbFByb3BzLFxuICAgICAgcGFnZUxvYWRlcixcbiAgICAgIEFwcCxcbiAgICAgIHdyYXBBcHAsXG4gICAgICBDb21wb25lbnQsXG4gICAgICBlcnIsXG4gICAgICBzdWJzY3JpcHRpb24sXG4gICAgICBpc0ZhbGxiYWNrLFxuICAgICAgbG9jYWxlLFxuICAgICAgbG9jYWxlcyxcbiAgICAgIGRlZmF1bHRMb2NhbGUsXG4gICAgICBkb21haW5Mb2NhbGVzLFxuICAgICAgaXNQcmV2aWV3LFxuICAgIH06IHtcbiAgICAgIHN1YnNjcmlwdGlvbjogU3Vic2NyaXB0aW9uXG4gICAgICBpbml0aWFsUHJvcHM6IGFueVxuICAgICAgcGFnZUxvYWRlcjogYW55XG4gICAgICBDb21wb25lbnQ6IENvbXBvbmVudFR5cGVcbiAgICAgIEFwcDogQXBwQ29tcG9uZW50XG4gICAgICB3cmFwQXBwOiAoV3JhcEFwcENvbXBvbmVudDogQXBwQ29tcG9uZW50KSA9PiBhbnlcbiAgICAgIGVycj86IEVycm9yXG4gICAgICBpc0ZhbGxiYWNrOiBib29sZWFuXG4gICAgICBsb2NhbGU/OiBzdHJpbmdcbiAgICAgIGxvY2FsZXM/OiBzdHJpbmdbXVxuICAgICAgZGVmYXVsdExvY2FsZT86IHN0cmluZ1xuICAgICAgZG9tYWluTG9jYWxlcz86IERvbWFpbkxvY2FsZXNcbiAgICAgIGlzUHJldmlldz86IGJvb2xlYW5cbiAgICB9XG4gICkge1xuICAgIC8vIHJlcHJlc2VudHMgdGhlIGN1cnJlbnQgY29tcG9uZW50IGtleVxuICAgIHRoaXMucm91dGUgPSByZW1vdmVQYXRoVHJhaWxpbmdTbGFzaChwYXRobmFtZSlcblxuICAgIC8vIHNldCB1cCB0aGUgY29tcG9uZW50IGNhY2hlIChieSByb3V0ZSBrZXlzKVxuICAgIHRoaXMuY29tcG9uZW50cyA9IHt9XG4gICAgLy8gV2Ugc2hvdWxkIG5vdCBrZWVwIHRoZSBjYWNoZSwgaWYgdGhlcmUncyBhbiBlcnJvclxuICAgIC8vIE90aGVyd2lzZSwgdGhpcyBjYXVzZSBpc3N1ZXMgd2hlbiB3aGVuIGdvaW5nIGJhY2sgYW5kXG4gICAgLy8gY29tZSBhZ2FpbiB0byB0aGUgZXJyb3JlZCBwYWdlLlxuICAgIGlmIChwYXRobmFtZSAhPT0gJy9fZXJyb3InKSB7XG4gICAgICB0aGlzLmNvbXBvbmVudHNbdGhpcy5yb3V0ZV0gPSB7XG4gICAgICAgIENvbXBvbmVudCxcbiAgICAgICAgaW5pdGlhbDogdHJ1ZSxcbiAgICAgICAgcHJvcHM6IGluaXRpYWxQcm9wcyxcbiAgICAgICAgZXJyLFxuICAgICAgICBfX05fU1NHOiBpbml0aWFsUHJvcHMgJiYgaW5pdGlhbFByb3BzLl9fTl9TU0csXG4gICAgICAgIF9fTl9TU1A6IGluaXRpYWxQcm9wcyAmJiBpbml0aWFsUHJvcHMuX19OX1NTUCxcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLmNvbXBvbmVudHNbJy9fYXBwJ10gPSB7XG4gICAgICBDb21wb25lbnQ6IEFwcCBhcyBDb21wb25lbnRUeXBlLFxuICAgICAgc3R5bGVTaGVldHM6IFtcbiAgICAgICAgLyogL19hcHAgZG9lcyBub3QgbmVlZCBpdHMgc3R5bGVzaGVldHMgbWFuYWdlZCAqL1xuICAgICAgXSxcbiAgICB9XG5cbiAgICAvLyBCYWNrd2FyZHMgY29tcGF0IGZvciBSb3V0ZXIucm91dGVyLmV2ZW50c1xuICAgIC8vIFRPRE86IFNob3VsZCBiZSByZW1vdmUgdGhlIGZvbGxvd2luZyBtYWpvciB2ZXJzaW9uIGFzIGl0IHdhcyBuZXZlciBkb2N1bWVudGVkXG4gICAgdGhpcy5ldmVudHMgPSBSb3V0ZXIuZXZlbnRzXG5cbiAgICB0aGlzLnBhZ2VMb2FkZXIgPSBwYWdlTG9hZGVyXG4gICAgdGhpcy5wYXRobmFtZSA9IHBhdGhuYW1lXG4gICAgdGhpcy5xdWVyeSA9IHF1ZXJ5XG4gICAgLy8gaWYgYXV0byBwcmVyZW5kZXJlZCBhbmQgZHluYW1pYyByb3V0ZSB3YWl0IHRvIHVwZGF0ZSBhc1BhdGhcbiAgICAvLyB1bnRpbCBhZnRlciBtb3VudCB0byBwcmV2ZW50IGh5ZHJhdGlvbiBtaXNtYXRjaFxuICAgIGNvbnN0IGF1dG9FeHBvcnREeW5hbWljID1cbiAgICAgIGlzRHluYW1pY1JvdXRlKHBhdGhuYW1lKSAmJiBzZWxmLl9fTkVYVF9EQVRBX18uYXV0b0V4cG9ydFxuXG4gICAgdGhpcy5hc1BhdGggPSBhdXRvRXhwb3J0RHluYW1pYyA/IHBhdGhuYW1lIDogYXNcbiAgICB0aGlzLmJhc2VQYXRoID0gYmFzZVBhdGhcbiAgICB0aGlzLnN1YiA9IHN1YnNjcmlwdGlvblxuICAgIHRoaXMuY2xjID0gbnVsbFxuICAgIHRoaXMuX3dyYXBBcHAgPSB3cmFwQXBwXG4gICAgLy8gbWFrZSBzdXJlIHRvIGlnbm9yZSBleHRyYSBwb3BTdGF0ZSBpbiBzYWZhcmkgb24gbmF2aWdhdGluZ1xuICAgIC8vIGJhY2sgZnJvbSBleHRlcm5hbCBzaXRlXG4gICAgdGhpcy5pc1NzciA9IHRydWVcblxuICAgIHRoaXMuaXNGYWxsYmFjayA9IGlzRmFsbGJhY2tcblxuICAgIHRoaXMuaXNSZWFkeSA9ICEhKFxuICAgICAgc2VsZi5fX05FWFRfREFUQV9fLmdzc3AgfHxcbiAgICAgIHNlbGYuX19ORVhUX0RBVEFfXy5naXAgfHxcbiAgICAgICghYXV0b0V4cG9ydER5bmFtaWMgJiZcbiAgICAgICAgIXNlbGYubG9jYXRpb24uc2VhcmNoICYmXG4gICAgICAgICFwcm9jZXNzLmVudi5fX05FWFRfSEFTX1JFV1JJVEVTKVxuICAgIClcbiAgICB0aGlzLmlzUHJldmlldyA9ICEhaXNQcmV2aWV3XG4gICAgdGhpcy5pc0xvY2FsZURvbWFpbiA9IGZhbHNlXG5cbiAgICBpZiAocHJvY2Vzcy5lbnYuX19ORVhUX0kxOE5fU1VQUE9SVCkge1xuICAgICAgdGhpcy5sb2NhbGUgPSBsb2NhbGVcbiAgICAgIHRoaXMubG9jYWxlcyA9IGxvY2FsZXNcbiAgICAgIHRoaXMuZGVmYXVsdExvY2FsZSA9IGRlZmF1bHRMb2NhbGVcbiAgICAgIHRoaXMuZG9tYWluTG9jYWxlcyA9IGRvbWFpbkxvY2FsZXNcbiAgICAgIHRoaXMuaXNMb2NhbGVEb21haW4gPSAhIWRldGVjdERvbWFpbkxvY2FsZShcbiAgICAgICAgZG9tYWluTG9jYWxlcyxcbiAgICAgICAgc2VsZi5sb2NhdGlvbi5ob3N0bmFtZVxuICAgICAgKVxuICAgIH1cblxuICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgLy8gbWFrZSBzdXJlIFwiYXNcIiBkb2Vzbid0IHN0YXJ0IHdpdGggZG91YmxlIHNsYXNoZXMgb3IgZWxzZSBpdCBjYW5cbiAgICAgIC8vIHRocm93IGFuIGVycm9yIGFzIGl0J3MgY29uc2lkZXJlZCBpbnZhbGlkXG4gICAgICBpZiAoYXMuc3Vic3RyKDAsIDIpICE9PSAnLy8nKSB7XG4gICAgICAgIC8vIGluIG9yZGVyIGZvciBgZS5zdGF0ZWAgdG8gd29yayBvbiB0aGUgYG9ucG9wc3RhdGVgIGV2ZW50XG4gICAgICAgIC8vIHdlIGhhdmUgdG8gcmVnaXN0ZXIgdGhlIGluaXRpYWwgcm91dGUgdXBvbiBpbml0aWFsaXphdGlvblxuICAgICAgICB0aGlzLmNoYW5nZVN0YXRlKFxuICAgICAgICAgICdyZXBsYWNlU3RhdGUnLFxuICAgICAgICAgIGZvcm1hdFdpdGhWYWxpZGF0aW9uKHsgcGF0aG5hbWU6IGFkZEJhc2VQYXRoKHBhdGhuYW1lKSwgcXVlcnkgfSksXG4gICAgICAgICAgZ2V0VVJMKCksXG4gICAgICAgICAgeyBsb2NhbGUgfVxuICAgICAgICApXG4gICAgICB9XG5cbiAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdwb3BzdGF0ZScsIHRoaXMub25Qb3BTdGF0ZSlcblxuICAgICAgLy8gZW5hYmxlIGN1c3RvbSBzY3JvbGwgcmVzdG9yYXRpb24gaGFuZGxpbmcgd2hlbiBhdmFpbGFibGVcbiAgICAgIC8vIG90aGVyd2lzZSBmYWxsYmFjayB0byBicm93c2VyJ3MgZGVmYXVsdCBoYW5kbGluZ1xuICAgICAgaWYgKHByb2Nlc3MuZW52Ll9fTkVYVF9TQ1JPTExfUkVTVE9SQVRJT04pIHtcbiAgICAgICAgaWYgKG1hbnVhbFNjcm9sbFJlc3RvcmF0aW9uKSB7XG4gICAgICAgICAgd2luZG93Lmhpc3Rvcnkuc2Nyb2xsUmVzdG9yYXRpb24gPSAnbWFudWFsJ1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgb25Qb3BTdGF0ZSA9IChlOiBQb3BTdGF0ZUV2ZW50KTogdm9pZCA9PiB7XG4gICAgY29uc3Qgc3RhdGUgPSBlLnN0YXRlIGFzIEhpc3RvcnlTdGF0ZVxuXG4gICAgaWYgKCFzdGF0ZSkge1xuICAgICAgLy8gV2UgZ2V0IHN0YXRlIGFzIHVuZGVmaW5lZCBmb3IgdHdvIHJlYXNvbnMuXG4gICAgICAvLyAgMS4gV2l0aCBvbGRlciBzYWZhcmkgKDwgOCkgYW5kIG9sZGVyIGNocm9tZSAoPCAzNClcbiAgICAgIC8vICAyLiBXaGVuIHRoZSBVUkwgY2hhbmdlZCB3aXRoICNcbiAgICAgIC8vXG4gICAgICAvLyBJbiB0aGUgYm90aCBjYXNlcywgd2UgZG9uJ3QgbmVlZCB0byBwcm9jZWVkIGFuZCBjaGFuZ2UgdGhlIHJvdXRlLlxuICAgICAgLy8gKGFzIGl0J3MgYWxyZWFkeSBjaGFuZ2VkKVxuICAgICAgLy8gQnV0IHdlIGNhbiBzaW1wbHkgcmVwbGFjZSB0aGUgc3RhdGUgd2l0aCB0aGUgbmV3IGNoYW5nZXMuXG4gICAgICAvLyBBY3R1YWxseSwgZm9yICgxKSB3ZSBkb24ndCBuZWVkIHRvIG5vdGhpbmcuIEJ1dCBpdCdzIGhhcmQgdG8gZGV0ZWN0IHRoYXQgZXZlbnQuXG4gICAgICAvLyBTbywgZG9pbmcgdGhlIGZvbGxvd2luZyBmb3IgKDEpIGRvZXMgbm8gaGFybS5cbiAgICAgIGNvbnN0IHsgcGF0aG5hbWUsIHF1ZXJ5IH0gPSB0aGlzXG4gICAgICB0aGlzLmNoYW5nZVN0YXRlKFxuICAgICAgICAncmVwbGFjZVN0YXRlJyxcbiAgICAgICAgZm9ybWF0V2l0aFZhbGlkYXRpb24oeyBwYXRobmFtZTogYWRkQmFzZVBhdGgocGF0aG5hbWUpLCBxdWVyeSB9KSxcbiAgICAgICAgZ2V0VVJMKClcbiAgICAgIClcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIGlmICghc3RhdGUuX19OKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICBsZXQgZm9yY2VkU2Nyb2xsOiB7IHg6IG51bWJlcjsgeTogbnVtYmVyIH0gfCB1bmRlZmluZWRcbiAgICBjb25zdCB7IHVybCwgYXMsIG9wdGlvbnMsIGlkeCB9ID0gc3RhdGVcbiAgICBpZiAocHJvY2Vzcy5lbnYuX19ORVhUX1NDUk9MTF9SRVNUT1JBVElPTikge1xuICAgICAgaWYgKG1hbnVhbFNjcm9sbFJlc3RvcmF0aW9uKSB7XG4gICAgICAgIGlmICh0aGlzLl9pZHggIT09IGlkeCkge1xuICAgICAgICAgIC8vIFNuYXBzaG90IGN1cnJlbnQgc2Nyb2xsIHBvc2l0aW9uOlxuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBzZXNzaW9uU3RvcmFnZS5zZXRJdGVtKFxuICAgICAgICAgICAgICAnX19uZXh0X3Njcm9sbF8nICsgdGhpcy5faWR4LFxuICAgICAgICAgICAgICBKU09OLnN0cmluZ2lmeSh7IHg6IHNlbGYucGFnZVhPZmZzZXQsIHk6IHNlbGYucGFnZVlPZmZzZXQgfSlcbiAgICAgICAgICAgIClcbiAgICAgICAgICB9IGNhdGNoIHt9XG5cbiAgICAgICAgICAvLyBSZXN0b3JlIG9sZCBzY3JvbGwgcG9zaXRpb246XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHYgPSBzZXNzaW9uU3RvcmFnZS5nZXRJdGVtKCdfX25leHRfc2Nyb2xsXycgKyBpZHgpXG4gICAgICAgICAgICBmb3JjZWRTY3JvbGwgPSBKU09OLnBhcnNlKHYhKVxuICAgICAgICAgIH0gY2F0Y2gge1xuICAgICAgICAgICAgZm9yY2VkU2Nyb2xsID0geyB4OiAwLCB5OiAwIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5faWR4ID0gaWR4XG5cbiAgICBjb25zdCB7IHBhdGhuYW1lIH0gPSBwYXJzZVJlbGF0aXZlVXJsKHVybClcblxuICAgIC8vIE1ha2Ugc3VyZSB3ZSBkb24ndCByZS1yZW5kZXIgb24gaW5pdGlhbCBsb2FkLFxuICAgIC8vIGNhbiBiZSBjYXVzZWQgYnkgbmF2aWdhdGluZyBiYWNrIGZyb20gYW4gZXh0ZXJuYWwgc2l0ZVxuICAgIGlmICh0aGlzLmlzU3NyICYmIGFzID09PSB0aGlzLmFzUGF0aCAmJiBwYXRobmFtZSA9PT0gdGhpcy5wYXRobmFtZSkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgLy8gSWYgdGhlIGRvd25zdHJlYW0gYXBwbGljYXRpb24gcmV0dXJucyBmYWxzeSwgcmV0dXJuLlxuICAgIC8vIFRoZXkgd2lsbCB0aGVuIGJlIHJlc3BvbnNpYmxlIGZvciBoYW5kbGluZyB0aGUgZXZlbnQuXG4gICAgaWYgKHRoaXMuX2JwcyAmJiAhdGhpcy5fYnBzKHN0YXRlKSkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgdGhpcy5jaGFuZ2UoXG4gICAgICAncmVwbGFjZVN0YXRlJyxcbiAgICAgIHVybCxcbiAgICAgIGFzLFxuICAgICAgT2JqZWN0LmFzc2lnbjx7fSwgVHJhbnNpdGlvbk9wdGlvbnMsIFRyYW5zaXRpb25PcHRpb25zPih7fSwgb3B0aW9ucywge1xuICAgICAgICBzaGFsbG93OiBvcHRpb25zLnNoYWxsb3cgJiYgdGhpcy5fc2hhbGxvdyxcbiAgICAgICAgbG9jYWxlOiBvcHRpb25zLmxvY2FsZSB8fCB0aGlzLmRlZmF1bHRMb2NhbGUsXG4gICAgICB9KSxcbiAgICAgIGZvcmNlZFNjcm9sbFxuICAgIClcbiAgfVxuXG4gIHJlbG9hZCgpOiB2b2lkIHtcbiAgICB3aW5kb3cubG9jYXRpb24ucmVsb2FkKClcbiAgfVxuXG4gIC8qKlxuICAgKiBHbyBiYWNrIGluIGhpc3RvcnlcbiAgICovXG4gIGJhY2soKSB7XG4gICAgd2luZG93Lmhpc3RvcnkuYmFjaygpXG4gIH1cblxuICAvKipcbiAgICogUGVyZm9ybXMgYSBgcHVzaFN0YXRlYCB3aXRoIGFyZ3VtZW50c1xuICAgKiBAcGFyYW0gdXJsIG9mIHRoZSByb3V0ZVxuICAgKiBAcGFyYW0gYXMgbWFza3MgYHVybGAgZm9yIHRoZSBicm93c2VyXG4gICAqIEBwYXJhbSBvcHRpb25zIG9iamVjdCB5b3UgY2FuIGRlZmluZSBgc2hhbGxvd2AgYW5kIG90aGVyIG9wdGlvbnNcbiAgICovXG4gIHB1c2godXJsOiBVcmwsIGFzPzogVXJsLCBvcHRpb25zOiBUcmFuc2l0aW9uT3B0aW9ucyA9IHt9KSB7XG4gICAgaWYgKHByb2Nlc3MuZW52Ll9fTkVYVF9TQ1JPTExfUkVTVE9SQVRJT04pIHtcbiAgICAgIC8vIFRPRE86IHJlbW92ZSBpbiB0aGUgZnV0dXJlIHdoZW4gd2UgdXBkYXRlIGhpc3RvcnkgYmVmb3JlIHJvdXRlIGNoYW5nZVxuICAgICAgLy8gaXMgY29tcGxldGUsIGFzIHRoZSBwb3BzdGF0ZSBldmVudCBzaG91bGQgaGFuZGxlIHRoaXMgY2FwdHVyZS5cbiAgICAgIGlmIChtYW51YWxTY3JvbGxSZXN0b3JhdGlvbikge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIC8vIFNuYXBzaG90IHNjcm9sbCBwb3NpdGlvbiByaWdodCBiZWZvcmUgbmF2aWdhdGluZyB0byBhIG5ldyBwYWdlOlxuICAgICAgICAgIHNlc3Npb25TdG9yYWdlLnNldEl0ZW0oXG4gICAgICAgICAgICAnX19uZXh0X3Njcm9sbF8nICsgdGhpcy5faWR4LFxuICAgICAgICAgICAgSlNPTi5zdHJpbmdpZnkoeyB4OiBzZWxmLnBhZ2VYT2Zmc2V0LCB5OiBzZWxmLnBhZ2VZT2Zmc2V0IH0pXG4gICAgICAgICAgKVxuICAgICAgICB9IGNhdGNoIHt9XG4gICAgICB9XG4gICAgfVxuICAgIDsoeyB1cmwsIGFzIH0gPSBwcmVwYXJlVXJsQXModGhpcywgdXJsLCBhcykpXG4gICAgcmV0dXJuIHRoaXMuY2hhbmdlKCdwdXNoU3RhdGUnLCB1cmwsIGFzLCBvcHRpb25zKVxuICB9XG5cbiAgLyoqXG4gICAqIFBlcmZvcm1zIGEgYHJlcGxhY2VTdGF0ZWAgd2l0aCBhcmd1bWVudHNcbiAgICogQHBhcmFtIHVybCBvZiB0aGUgcm91dGVcbiAgICogQHBhcmFtIGFzIG1hc2tzIGB1cmxgIGZvciB0aGUgYnJvd3NlclxuICAgKiBAcGFyYW0gb3B0aW9ucyBvYmplY3QgeW91IGNhbiBkZWZpbmUgYHNoYWxsb3dgIGFuZCBvdGhlciBvcHRpb25zXG4gICAqL1xuICByZXBsYWNlKHVybDogVXJsLCBhcz86IFVybCwgb3B0aW9uczogVHJhbnNpdGlvbk9wdGlvbnMgPSB7fSkge1xuICAgIDsoeyB1cmwsIGFzIH0gPSBwcmVwYXJlVXJsQXModGhpcywgdXJsLCBhcykpXG4gICAgcmV0dXJuIHRoaXMuY2hhbmdlKCdyZXBsYWNlU3RhdGUnLCB1cmwsIGFzLCBvcHRpb25zKVxuICB9XG5cbiAgcHJpdmF0ZSBhc3luYyBjaGFuZ2UoXG4gICAgbWV0aG9kOiBIaXN0b3J5TWV0aG9kLFxuICAgIHVybDogc3RyaW5nLFxuICAgIGFzOiBzdHJpbmcsXG4gICAgb3B0aW9uczogVHJhbnNpdGlvbk9wdGlvbnMsXG4gICAgZm9yY2VkU2Nyb2xsPzogeyB4OiBudW1iZXI7IHk6IG51bWJlciB9XG4gICk6IFByb21pc2U8Ym9vbGVhbj4ge1xuICAgIGlmICghaXNMb2NhbFVSTCh1cmwpKSB7XG4gICAgICB3aW5kb3cubG9jYXRpb24uaHJlZiA9IHVybFxuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuICAgIGNvbnN0IHNob3VsZFJlc29sdmVIcmVmID0gdXJsID09PSBhcyB8fCAob3B0aW9ucyBhcyBhbnkpLl9oXG5cbiAgICAvLyBmb3Igc3RhdGljIHBhZ2VzIHdpdGggcXVlcnkgcGFyYW1zIGluIHRoZSBVUkwgd2UgZGVsYXlcbiAgICAvLyBtYXJraW5nIHRoZSByb3V0ZXIgcmVhZHkgdW50aWwgYWZ0ZXIgdGhlIHF1ZXJ5IGlzIHVwZGF0ZWRcbiAgICBpZiAoKG9wdGlvbnMgYXMgYW55KS5faCkge1xuICAgICAgdGhpcy5pc1JlYWR5ID0gdHJ1ZVxuICAgIH1cblxuICAgIC8vIERlZmF1bHQgdG8gc2Nyb2xsIHJlc2V0IGJlaGF2aW9yIHVubGVzcyBleHBsaWNpdGx5IHNwZWNpZmllZCB0byBiZVxuICAgIC8vIGBmYWxzZWAhIFRoaXMgbWFrZXMgdGhlIGJlaGF2aW9yIGJldHdlZW4gdXNpbmcgYFJvdXRlciNwdXNoYCBhbmQgYVxuICAgIC8vIGA8TGluayAvPmAgY29uc2lzdGVudC5cbiAgICBvcHRpb25zLnNjcm9sbCA9ICEhKG9wdGlvbnMuc2Nyb2xsID8/IHRydWUpXG5cbiAgICBsZXQgbG9jYWxlQ2hhbmdlID0gb3B0aW9ucy5sb2NhbGUgIT09IHRoaXMubG9jYWxlXG5cbiAgICBpZiAocHJvY2Vzcy5lbnYuX19ORVhUX0kxOE5fU1VQUE9SVCkge1xuICAgICAgdGhpcy5sb2NhbGUgPVxuICAgICAgICBvcHRpb25zLmxvY2FsZSA9PT0gZmFsc2VcbiAgICAgICAgICA/IHRoaXMuZGVmYXVsdExvY2FsZVxuICAgICAgICAgIDogb3B0aW9ucy5sb2NhbGUgfHwgdGhpcy5sb2NhbGVcblxuICAgICAgaWYgKHR5cGVvZiBvcHRpb25zLmxvY2FsZSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgb3B0aW9ucy5sb2NhbGUgPSB0aGlzLmxvY2FsZVxuICAgICAgfVxuXG4gICAgICBjb25zdCBwYXJzZWRBcyA9IHBhcnNlUmVsYXRpdmVVcmwoaGFzQmFzZVBhdGgoYXMpID8gZGVsQmFzZVBhdGgoYXMpIDogYXMpXG4gICAgICBjb25zdCBsb2NhbGVQYXRoUmVzdWx0ID0gbm9ybWFsaXplTG9jYWxlUGF0aChcbiAgICAgICAgcGFyc2VkQXMucGF0aG5hbWUsXG4gICAgICAgIHRoaXMubG9jYWxlc1xuICAgICAgKVxuXG4gICAgICBpZiAobG9jYWxlUGF0aFJlc3VsdC5kZXRlY3RlZExvY2FsZSkge1xuICAgICAgICB0aGlzLmxvY2FsZSA9IGxvY2FsZVBhdGhSZXN1bHQuZGV0ZWN0ZWRMb2NhbGVcbiAgICAgICAgcGFyc2VkQXMucGF0aG5hbWUgPSBhZGRCYXNlUGF0aChwYXJzZWRBcy5wYXRobmFtZSlcbiAgICAgICAgYXMgPSBmb3JtYXRXaXRoVmFsaWRhdGlvbihwYXJzZWRBcylcbiAgICAgICAgdXJsID0gYWRkQmFzZVBhdGgoXG4gICAgICAgICAgbm9ybWFsaXplTG9jYWxlUGF0aChcbiAgICAgICAgICAgIGhhc0Jhc2VQYXRoKHVybCkgPyBkZWxCYXNlUGF0aCh1cmwpIDogdXJsLFxuICAgICAgICAgICAgdGhpcy5sb2NhbGVzXG4gICAgICAgICAgKS5wYXRobmFtZVxuICAgICAgICApXG4gICAgICB9XG4gICAgICBsZXQgZGlkTmF2aWdhdGUgPSBmYWxzZVxuXG4gICAgICAvLyB3ZSBuZWVkIHRvIHdyYXAgdGhpcyBpbiB0aGUgZW52IGNoZWNrIGFnYWluIHNpbmNlIHJlZ2VuZXJhdG9yIHJ1bnRpbWVcbiAgICAgIC8vIG1vdmVzIHRoaXMgb24gaXRzIG93biBkdWUgdG8gdGhlIHJldHVyblxuICAgICAgaWYgKHByb2Nlc3MuZW52Ll9fTkVYVF9JMThOX1NVUFBPUlQpIHtcbiAgICAgICAgLy8gaWYgdGhlIGxvY2FsZSBpc24ndCBjb25maWd1cmVkIGhhcmQgbmF2aWdhdGUgdG8gc2hvdyA0MDQgcGFnZVxuICAgICAgICBpZiAoIXRoaXMubG9jYWxlcz8uaW5jbHVkZXModGhpcy5sb2NhbGUhKSkge1xuICAgICAgICAgIHBhcnNlZEFzLnBhdGhuYW1lID0gYWRkTG9jYWxlKHBhcnNlZEFzLnBhdGhuYW1lLCB0aGlzLmxvY2FsZSlcbiAgICAgICAgICB3aW5kb3cubG9jYXRpb24uaHJlZiA9IGZvcm1hdFdpdGhWYWxpZGF0aW9uKHBhcnNlZEFzKVxuICAgICAgICAgIC8vIHRoaXMgd2FzIHByZXZpb3VzbHkgYSByZXR1cm4gYnV0IHdhcyByZW1vdmVkIGluIGZhdm9yXG4gICAgICAgICAgLy8gb2YgYmV0dGVyIGRlYWQgY29kZSBlbGltaW5hdGlvbiB3aXRoIHJlZ2VuZXJhdG9yIHJ1bnRpbWVcbiAgICAgICAgICBkaWROYXZpZ2F0ZSA9IHRydWVcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBjb25zdCBkZXRlY3RlZERvbWFpbiA9IGRldGVjdERvbWFpbkxvY2FsZShcbiAgICAgICAgdGhpcy5kb21haW5Mb2NhbGVzLFxuICAgICAgICB1bmRlZmluZWQsXG4gICAgICAgIHRoaXMubG9jYWxlXG4gICAgICApXG5cbiAgICAgIC8vIHdlIG5lZWQgdG8gd3JhcCB0aGlzIGluIHRoZSBlbnYgY2hlY2sgYWdhaW4gc2luY2UgcmVnZW5lcmF0b3IgcnVudGltZVxuICAgICAgLy8gbW92ZXMgdGhpcyBvbiBpdHMgb3duIGR1ZSB0byB0aGUgcmV0dXJuXG4gICAgICBpZiAocHJvY2Vzcy5lbnYuX19ORVhUX0kxOE5fU1VQUE9SVCkge1xuICAgICAgICAvLyBpZiB3ZSBhcmUgbmF2aWdhdGluZyB0byBhIGRvbWFpbiBsb2NhbGUgZW5zdXJlIHdlIHJlZGlyZWN0IHRvIHRoZVxuICAgICAgICAvLyBjb3JyZWN0IGRvbWFpblxuICAgICAgICBpZiAoXG4gICAgICAgICAgIWRpZE5hdmlnYXRlICYmXG4gICAgICAgICAgZGV0ZWN0ZWREb21haW4gJiZcbiAgICAgICAgICB0aGlzLmlzTG9jYWxlRG9tYWluICYmXG4gICAgICAgICAgc2VsZi5sb2NhdGlvbi5ob3N0bmFtZSAhPT0gZGV0ZWN0ZWREb21haW4uZG9tYWluXG4gICAgICAgICkge1xuICAgICAgICAgIGNvbnN0IGFzTm9CYXNlUGF0aCA9IGRlbEJhc2VQYXRoKGFzKVxuICAgICAgICAgIHdpbmRvdy5sb2NhdGlvbi5ocmVmID0gYGh0dHAke2RldGVjdGVkRG9tYWluLmh0dHAgPyAnJyA6ICdzJ306Ly8ke1xuICAgICAgICAgICAgZGV0ZWN0ZWREb21haW4uZG9tYWluXG4gICAgICAgICAgfSR7YWRkQmFzZVBhdGgoXG4gICAgICAgICAgICBgJHtcbiAgICAgICAgICAgICAgdGhpcy5sb2NhbGUgPT09IGRldGVjdGVkRG9tYWluLmRlZmF1bHRMb2NhbGVcbiAgICAgICAgICAgICAgICA/ICcnXG4gICAgICAgICAgICAgICAgOiBgLyR7dGhpcy5sb2NhbGV9YFxuICAgICAgICAgICAgfSR7YXNOb0Jhc2VQYXRoID09PSAnLycgPyAnJyA6IGFzTm9CYXNlUGF0aH1gIHx8ICcvJ1xuICAgICAgICAgICl9YFxuICAgICAgICAgIC8vIHRoaXMgd2FzIHByZXZpb3VzbHkgYSByZXR1cm4gYnV0IHdhcyByZW1vdmVkIGluIGZhdm9yXG4gICAgICAgICAgLy8gb2YgYmV0dGVyIGRlYWQgY29kZSBlbGltaW5hdGlvbiB3aXRoIHJlZ2VuZXJhdG9yIHJ1bnRpbWVcbiAgICAgICAgICBkaWROYXZpZ2F0ZSA9IHRydWVcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoZGlkTmF2aWdhdGUpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKCgpID0+IHt9KVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmICghKG9wdGlvbnMgYXMgYW55KS5faCkge1xuICAgICAgdGhpcy5pc1NzciA9IGZhbHNlXG4gICAgfVxuICAgIC8vIG1hcmtpbmcgcm91dGUgY2hhbmdlcyBhcyBhIG5hdmlnYXRpb24gc3RhcnQgZW50cnlcbiAgICBpZiAoU1QpIHtcbiAgICAgIHBlcmZvcm1hbmNlLm1hcmsoJ3JvdXRlQ2hhbmdlJylcbiAgICB9XG5cbiAgICBjb25zdCB7IHNoYWxsb3cgPSBmYWxzZSB9ID0gb3B0aW9uc1xuICAgIGNvbnN0IHJvdXRlUHJvcHMgPSB7IHNoYWxsb3cgfVxuXG4gICAgaWYgKHRoaXMuX2luRmxpZ2h0Um91dGUpIHtcbiAgICAgIHRoaXMuYWJvcnRDb21wb25lbnRMb2FkKHRoaXMuX2luRmxpZ2h0Um91dGUsIHJvdXRlUHJvcHMpXG4gICAgfVxuXG4gICAgYXMgPSBhZGRCYXNlUGF0aChcbiAgICAgIGFkZExvY2FsZShcbiAgICAgICAgaGFzQmFzZVBhdGgoYXMpID8gZGVsQmFzZVBhdGgoYXMpIDogYXMsXG4gICAgICAgIG9wdGlvbnMubG9jYWxlLFxuICAgICAgICB0aGlzLmRlZmF1bHRMb2NhbGVcbiAgICAgIClcbiAgICApXG4gICAgY29uc3QgY2xlYW5lZEFzID0gZGVsTG9jYWxlKFxuICAgICAgaGFzQmFzZVBhdGgoYXMpID8gZGVsQmFzZVBhdGgoYXMpIDogYXMsXG4gICAgICB0aGlzLmxvY2FsZVxuICAgIClcbiAgICB0aGlzLl9pbkZsaWdodFJvdXRlID0gYXNcblxuICAgIC8vIElmIHRoZSB1cmwgY2hhbmdlIGlzIG9ubHkgcmVsYXRlZCB0byBhIGhhc2ggY2hhbmdlXG4gICAgLy8gV2Ugc2hvdWxkIG5vdCBwcm9jZWVkLiBXZSBzaG91bGQgb25seSBjaGFuZ2UgdGhlIHN0YXRlLlxuXG4gICAgLy8gV0FSTklORzogYF9oYCBpcyBhbiBpbnRlcm5hbCBvcHRpb24gZm9yIGhhbmRpbmcgTmV4dC5qcyBjbGllbnQtc2lkZVxuICAgIC8vIGh5ZHJhdGlvbi4gWW91ciBhcHAgc2hvdWxkIF9uZXZlcl8gdXNlIHRoaXMgcHJvcGVydHkuIEl0IG1heSBjaGFuZ2UgYXRcbiAgICAvLyBhbnkgdGltZSB3aXRob3V0IG5vdGljZS5cbiAgICBpZiAoIShvcHRpb25zIGFzIGFueSkuX2ggJiYgdGhpcy5vbmx5QUhhc2hDaGFuZ2UoY2xlYW5lZEFzKSkge1xuICAgICAgdGhpcy5hc1BhdGggPSBjbGVhbmVkQXNcbiAgICAgIFJvdXRlci5ldmVudHMuZW1pdCgnaGFzaENoYW5nZVN0YXJ0JywgYXMsIHJvdXRlUHJvcHMpXG4gICAgICAvLyBUT0RPOiBkbyB3ZSBuZWVkIHRoZSByZXNvbHZlZCBocmVmIHdoZW4gb25seSBhIGhhc2ggY2hhbmdlP1xuICAgICAgdGhpcy5jaGFuZ2VTdGF0ZShtZXRob2QsIHVybCwgYXMsIG9wdGlvbnMpXG4gICAgICB0aGlzLnNjcm9sbFRvSGFzaChjbGVhbmVkQXMpXG4gICAgICB0aGlzLm5vdGlmeSh0aGlzLmNvbXBvbmVudHNbdGhpcy5yb3V0ZV0sIG51bGwpXG4gICAgICBSb3V0ZXIuZXZlbnRzLmVtaXQoJ2hhc2hDaGFuZ2VDb21wbGV0ZScsIGFzLCByb3V0ZVByb3BzKVxuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG5cbiAgICBsZXQgcGFyc2VkID0gcGFyc2VSZWxhdGl2ZVVybCh1cmwpXG4gICAgbGV0IHsgcGF0aG5hbWUsIHF1ZXJ5IH0gPSBwYXJzZWRcblxuICAgIC8vIFRoZSBidWlsZCBtYW5pZmVzdCBuZWVkcyB0byBiZSBsb2FkZWQgYmVmb3JlIGF1dG8tc3RhdGljIGR5bmFtaWMgcGFnZXNcbiAgICAvLyBnZXQgdGhlaXIgcXVlcnkgcGFyYW1ldGVycyB0byBhbGxvdyBlbnN1cmluZyB0aGV5IGNhbiBiZSBwYXJzZWQgcHJvcGVybHlcbiAgICAvLyB3aGVuIHJld3JpdHRlbiB0b1xuICAgIGxldCBwYWdlczogYW55LCByZXdyaXRlczogYW55XG4gICAgdHJ5IHtcbiAgICAgIHBhZ2VzID0gYXdhaXQgdGhpcy5wYWdlTG9hZGVyLmdldFBhZ2VMaXN0KClcbiAgICAgIDsoeyBfX3Jld3JpdGVzOiByZXdyaXRlcyB9ID0gYXdhaXQgZ2V0Q2xpZW50QnVpbGRNYW5pZmVzdCgpKVxuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgLy8gSWYgd2UgZmFpbCB0byByZXNvbHZlIHRoZSBwYWdlIGxpc3Qgb3IgY2xpZW50LWJ1aWxkIG1hbmlmZXN0LCB3ZSBtdXN0XG4gICAgICAvLyBkbyBhIHNlcnZlci1zaWRlIHRyYW5zaXRpb246XG4gICAgICB3aW5kb3cubG9jYXRpb24uaHJlZiA9IGFzXG4gICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG5cbiAgICAvLyBJZiBhc2tlZCB0byBjaGFuZ2UgdGhlIGN1cnJlbnQgVVJMIHdlIHNob3VsZCByZWxvYWQgdGhlIGN1cnJlbnQgcGFnZVxuICAgIC8vIChub3QgbG9jYXRpb24ucmVsb2FkKCkgYnV0IHJlbG9hZCBnZXRJbml0aWFsUHJvcHMgYW5kIG90aGVyIE5leHQuanMgc3R1ZmZzKVxuICAgIC8vIFdlIGFsc28gbmVlZCB0byBzZXQgdGhlIG1ldGhvZCA9IHJlcGxhY2VTdGF0ZSBhbHdheXNcbiAgICAvLyBhcyB0aGlzIHNob3VsZCBub3QgZ28gaW50byB0aGUgaGlzdG9yeSAoVGhhdCdzIGhvdyBicm93c2VycyB3b3JrKVxuICAgIC8vIFdlIHNob3VsZCBjb21wYXJlIHRoZSBuZXcgYXNQYXRoIHRvIHRoZSBjdXJyZW50IGFzUGF0aCwgbm90IHRoZSB1cmxcbiAgICBpZiAoIXRoaXMudXJsSXNOZXcoY2xlYW5lZEFzKSAmJiAhbG9jYWxlQ2hhbmdlKSB7XG4gICAgICBtZXRob2QgPSAncmVwbGFjZVN0YXRlJ1xuICAgIH1cblxuICAgIC8vIHdlIG5lZWQgdG8gcmVzb2x2ZSB0aGUgYXMgdmFsdWUgdXNpbmcgcmV3cml0ZXMgZm9yIGR5bmFtaWMgU1NHXG4gICAgLy8gcGFnZXMgdG8gYWxsb3cgYnVpbGRpbmcgdGhlIGRhdGEgVVJMIGNvcnJlY3RseVxuICAgIGxldCByZXNvbHZlZEFzID0gYXNcblxuICAgIC8vIHVybCBhbmQgYXMgc2hvdWxkIGFsd2F5cyBiZSBwcmVmaXhlZCB3aXRoIGJhc2VQYXRoIGJ5IHRoaXNcbiAgICAvLyBwb2ludCBieSBlaXRoZXIgbmV4dC9saW5rIG9yIHJvdXRlci5wdXNoL3JlcGxhY2Ugc28gc3RyaXAgdGhlXG4gICAgLy8gYmFzZVBhdGggZnJvbSB0aGUgcGF0aG5hbWUgdG8gbWF0Y2ggdGhlIHBhZ2VzIGRpciAxLXRvLTFcbiAgICBwYXRobmFtZSA9IHBhdGhuYW1lXG4gICAgICA/IHJlbW92ZVBhdGhUcmFpbGluZ1NsYXNoKGRlbEJhc2VQYXRoKHBhdGhuYW1lKSlcbiAgICAgIDogcGF0aG5hbWVcblxuICAgIGlmIChzaG91bGRSZXNvbHZlSHJlZiAmJiBwYXRobmFtZSAhPT0gJy9fZXJyb3InKSB7XG4gICAgICBpZiAocHJvY2Vzcy5lbnYuX19ORVhUX0hBU19SRVdSSVRFUyAmJiBhcy5zdGFydHNXaXRoKCcvJykpIHtcbiAgICAgICAgY29uc3QgcmV3cml0ZXNSZXN1bHQgPSByZXNvbHZlUmV3cml0ZXMoXG4gICAgICAgICAgYWRkQmFzZVBhdGgoYWRkTG9jYWxlKGNsZWFuZWRBcywgdGhpcy5sb2NhbGUpKSxcbiAgICAgICAgICBwYWdlcyxcbiAgICAgICAgICByZXdyaXRlcyxcbiAgICAgICAgICBxdWVyeSxcbiAgICAgICAgICAocDogc3RyaW5nKSA9PiByZXNvbHZlRHluYW1pY1JvdXRlKHAsIHBhZ2VzKSxcbiAgICAgICAgICB0aGlzLmxvY2FsZXNcbiAgICAgICAgKVxuICAgICAgICByZXNvbHZlZEFzID0gcmV3cml0ZXNSZXN1bHQuYXNQYXRoXG5cbiAgICAgICAgaWYgKHJld3JpdGVzUmVzdWx0Lm1hdGNoZWRQYWdlICYmIHJld3JpdGVzUmVzdWx0LnJlc29sdmVkSHJlZikge1xuICAgICAgICAgIC8vIGlmIHRoaXMgZGlyZWN0bHkgbWF0Y2hlcyBhIHBhZ2Ugd2UgbmVlZCB0byB1cGRhdGUgdGhlIGhyZWYgdG9cbiAgICAgICAgICAvLyBhbGxvdyB0aGUgY29ycmVjdCBwYWdlIGNodW5rIHRvIGJlIGxvYWRlZFxuICAgICAgICAgIHBhdGhuYW1lID0gcmV3cml0ZXNSZXN1bHQucmVzb2x2ZWRIcmVmXG4gICAgICAgICAgcGFyc2VkLnBhdGhuYW1lID0gcGF0aG5hbWVcbiAgICAgICAgICB1cmwgPSBmb3JtYXRXaXRoVmFsaWRhdGlvbihwYXJzZWQpXG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHBhcnNlZC5wYXRobmFtZSA9IHJlc29sdmVEeW5hbWljUm91dGUocGF0aG5hbWUsIHBhZ2VzKVxuXG4gICAgICAgIGlmIChwYXJzZWQucGF0aG5hbWUgIT09IHBhdGhuYW1lKSB7XG4gICAgICAgICAgcGF0aG5hbWUgPSBwYXJzZWQucGF0aG5hbWVcbiAgICAgICAgICB1cmwgPSBmb3JtYXRXaXRoVmFsaWRhdGlvbihwYXJzZWQpXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBjb25zdCByb3V0ZSA9IHJlbW92ZVBhdGhUcmFpbGluZ1NsYXNoKHBhdGhuYW1lKVxuXG4gICAgaWYgKCFpc0xvY2FsVVJMKGFzKSkge1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgIGBJbnZhbGlkIGhyZWY6IFwiJHt1cmx9XCIgYW5kIGFzOiBcIiR7YXN9XCIsIHJlY2VpdmVkIHJlbGF0aXZlIGhyZWYgYW5kIGV4dGVybmFsIGFzYCArXG4gICAgICAgICAgICBgXFxuU2VlIG1vcmUgaW5mbzogaHR0cHM6Ly9uZXh0anMub3JnL2RvY3MvbWVzc2FnZXMvaW52YWxpZC1yZWxhdGl2ZS11cmwtZXh0ZXJuYWwtYXNgXG4gICAgICAgIClcbiAgICAgIH1cblxuICAgICAgd2luZG93LmxvY2F0aW9uLmhyZWYgPSBhc1xuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuXG4gICAgcmVzb2x2ZWRBcyA9IGRlbExvY2FsZShkZWxCYXNlUGF0aChyZXNvbHZlZEFzKSwgdGhpcy5sb2NhbGUpXG5cbiAgICBpZiAoaXNEeW5hbWljUm91dGUocm91dGUpKSB7XG4gICAgICBjb25zdCBwYXJzZWRBcyA9IHBhcnNlUmVsYXRpdmVVcmwocmVzb2x2ZWRBcylcbiAgICAgIGNvbnN0IGFzUGF0aG5hbWUgPSBwYXJzZWRBcy5wYXRobmFtZVxuXG4gICAgICBjb25zdCByb3V0ZVJlZ2V4ID0gZ2V0Um91dGVSZWdleChyb3V0ZSlcbiAgICAgIGNvbnN0IHJvdXRlTWF0Y2ggPSBnZXRSb3V0ZU1hdGNoZXIocm91dGVSZWdleCkoYXNQYXRobmFtZSlcbiAgICAgIGNvbnN0IHNob3VsZEludGVycG9sYXRlID0gcm91dGUgPT09IGFzUGF0aG5hbWVcbiAgICAgIGNvbnN0IGludGVycG9sYXRlZEFzID0gc2hvdWxkSW50ZXJwb2xhdGVcbiAgICAgICAgPyBpbnRlcnBvbGF0ZUFzKHJvdXRlLCBhc1BhdGhuYW1lLCBxdWVyeSlcbiAgICAgICAgOiAoe30gYXMgeyByZXN1bHQ6IHVuZGVmaW5lZDsgcGFyYW1zOiB1bmRlZmluZWQgfSlcblxuICAgICAgaWYgKCFyb3V0ZU1hdGNoIHx8IChzaG91bGRJbnRlcnBvbGF0ZSAmJiAhaW50ZXJwb2xhdGVkQXMucmVzdWx0KSkge1xuICAgICAgICBjb25zdCBtaXNzaW5nUGFyYW1zID0gT2JqZWN0LmtleXMocm91dGVSZWdleC5ncm91cHMpLmZpbHRlcihcbiAgICAgICAgICAocGFyYW0pID0+ICFxdWVyeVtwYXJhbV1cbiAgICAgICAgKVxuXG4gICAgICAgIGlmIChtaXNzaW5nUGFyYW1zLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKFxuICAgICAgICAgICAgICBgJHtcbiAgICAgICAgICAgICAgICBzaG91bGRJbnRlcnBvbGF0ZVxuICAgICAgICAgICAgICAgICAgPyBgSW50ZXJwb2xhdGluZyBocmVmYFxuICAgICAgICAgICAgICAgICAgOiBgTWlzbWF0Y2hpbmcgXFxgYXNcXGAgYW5kIFxcYGhyZWZcXGBgXG4gICAgICAgICAgICAgIH0gZmFpbGVkIHRvIG1hbnVhbGx5IHByb3ZpZGUgYCArXG4gICAgICAgICAgICAgICAgYHRoZSBwYXJhbXM6ICR7bWlzc2luZ1BhcmFtcy5qb2luKFxuICAgICAgICAgICAgICAgICAgJywgJ1xuICAgICAgICAgICAgICAgICl9IGluIHRoZSBcXGBocmVmXFxgJ3MgXFxgcXVlcnlcXGBgXG4gICAgICAgICAgICApXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgKHNob3VsZEludGVycG9sYXRlXG4gICAgICAgICAgICAgID8gYFRoZSBwcm92aWRlZCBcXGBocmVmXFxgICgke3VybH0pIHZhbHVlIGlzIG1pc3NpbmcgcXVlcnkgdmFsdWVzICgke21pc3NpbmdQYXJhbXMuam9pbihcbiAgICAgICAgICAgICAgICAgICcsICdcbiAgICAgICAgICAgICAgICApfSkgdG8gYmUgaW50ZXJwb2xhdGVkIHByb3Blcmx5LiBgXG4gICAgICAgICAgICAgIDogYFRoZSBwcm92aWRlZCBcXGBhc1xcYCB2YWx1ZSAoJHthc1BhdGhuYW1lfSkgaXMgaW5jb21wYXRpYmxlIHdpdGggdGhlIFxcYGhyZWZcXGAgdmFsdWUgKCR7cm91dGV9KS4gYCkgK1xuICAgICAgICAgICAgICBgUmVhZCBtb3JlOiBodHRwczovL25leHRqcy5vcmcvZG9jcy9tZXNzYWdlcy8ke1xuICAgICAgICAgICAgICAgIHNob3VsZEludGVycG9sYXRlXG4gICAgICAgICAgICAgICAgICA/ICdocmVmLWludGVycG9sYXRpb24tZmFpbGVkJ1xuICAgICAgICAgICAgICAgICAgOiAnaW5jb21wYXRpYmxlLWhyZWYtYXMnXG4gICAgICAgICAgICAgIH1gXG4gICAgICAgICAgKVxuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHNob3VsZEludGVycG9sYXRlKSB7XG4gICAgICAgIGFzID0gZm9ybWF0V2l0aFZhbGlkYXRpb24oXG4gICAgICAgICAgT2JqZWN0LmFzc2lnbih7fSwgcGFyc2VkQXMsIHtcbiAgICAgICAgICAgIHBhdGhuYW1lOiBpbnRlcnBvbGF0ZWRBcy5yZXN1bHQsXG4gICAgICAgICAgICBxdWVyeTogb21pdFBhcm1zRnJvbVF1ZXJ5KHF1ZXJ5LCBpbnRlcnBvbGF0ZWRBcy5wYXJhbXMhKSxcbiAgICAgICAgICB9KVxuICAgICAgICApXG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBNZXJnZSBwYXJhbXMgaW50byBgcXVlcnlgLCBvdmVyd3JpdGluZyBhbnkgc3BlY2lmaWVkIGluIHNlYXJjaFxuICAgICAgICBPYmplY3QuYXNzaWduKHF1ZXJ5LCByb3V0ZU1hdGNoKVxuICAgICAgfVxuICAgIH1cblxuICAgIFJvdXRlci5ldmVudHMuZW1pdCgncm91dGVDaGFuZ2VTdGFydCcsIGFzLCByb3V0ZVByb3BzKVxuXG4gICAgdHJ5IHtcbiAgICAgIGxldCByb3V0ZUluZm8gPSBhd2FpdCB0aGlzLmdldFJvdXRlSW5mbyhcbiAgICAgICAgcm91dGUsXG4gICAgICAgIHBhdGhuYW1lLFxuICAgICAgICBxdWVyeSxcbiAgICAgICAgYXMsXG4gICAgICAgIHJlc29sdmVkQXMsXG4gICAgICAgIHJvdXRlUHJvcHNcbiAgICAgIClcbiAgICAgIGxldCB7IGVycm9yLCBwcm9wcywgX19OX1NTRywgX19OX1NTUCB9ID0gcm91dGVJbmZvXG5cbiAgICAgIC8vIGhhbmRsZSByZWRpcmVjdCBvbiBjbGllbnQtdHJhbnNpdGlvblxuICAgICAgaWYgKChfX05fU1NHIHx8IF9fTl9TU1ApICYmIHByb3BzKSB7XG4gICAgICAgIGlmICgocHJvcHMgYXMgYW55KS5wYWdlUHJvcHMgJiYgKHByb3BzIGFzIGFueSkucGFnZVByb3BzLl9fTl9SRURJUkVDVCkge1xuICAgICAgICAgIGNvbnN0IGRlc3RpbmF0aW9uID0gKHByb3BzIGFzIGFueSkucGFnZVByb3BzLl9fTl9SRURJUkVDVFxuXG4gICAgICAgICAgLy8gY2hlY2sgaWYgZGVzdGluYXRpb24gaXMgaW50ZXJuYWwgKHJlc29sdmVzIHRvIGEgcGFnZSkgYW5kIGF0dGVtcHRcbiAgICAgICAgICAvLyBjbGllbnQtbmF2aWdhdGlvbiBpZiBpdCBpcyBmYWxsaW5nIGJhY2sgdG8gaGFyZCBuYXZpZ2F0aW9uIGlmXG4gICAgICAgICAgLy8gaXQncyBub3RcbiAgICAgICAgICBpZiAoZGVzdGluYXRpb24uc3RhcnRzV2l0aCgnLycpKSB7XG4gICAgICAgICAgICBjb25zdCBwYXJzZWRIcmVmID0gcGFyc2VSZWxhdGl2ZVVybChkZXN0aW5hdGlvbilcbiAgICAgICAgICAgIHBhcnNlZEhyZWYucGF0aG5hbWUgPSByZXNvbHZlRHluYW1pY1JvdXRlKFxuICAgICAgICAgICAgICBwYXJzZWRIcmVmLnBhdGhuYW1lLFxuICAgICAgICAgICAgICBwYWdlc1xuICAgICAgICAgICAgKVxuXG4gICAgICAgICAgICBpZiAocGFnZXMuaW5jbHVkZXMocGFyc2VkSHJlZi5wYXRobmFtZSkpIHtcbiAgICAgICAgICAgICAgY29uc3QgeyB1cmw6IG5ld1VybCwgYXM6IG5ld0FzIH0gPSBwcmVwYXJlVXJsQXMoXG4gICAgICAgICAgICAgICAgdGhpcyxcbiAgICAgICAgICAgICAgICBkZXN0aW5hdGlvbixcbiAgICAgICAgICAgICAgICBkZXN0aW5hdGlvblxuICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgIHJldHVybiB0aGlzLmNoYW5nZShtZXRob2QsIG5ld1VybCwgbmV3QXMsIG9wdGlvbnMpXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgd2luZG93LmxvY2F0aW9uLmhyZWYgPSBkZXN0aW5hdGlvblxuICAgICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgoKSA9PiB7fSlcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuaXNQcmV2aWV3ID0gISFwcm9wcy5fX05fUFJFVklFV1xuXG4gICAgICAgIC8vIGhhbmRsZSBTU0cgZGF0YSA0MDRcbiAgICAgICAgaWYgKHByb3BzLm5vdEZvdW5kID09PSBTU0dfREFUQV9OT1RfRk9VTkQpIHtcbiAgICAgICAgICBsZXQgbm90Rm91bmRSb3V0ZVxuXG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuZmV0Y2hDb21wb25lbnQoJy80MDQnKVxuICAgICAgICAgICAgbm90Rm91bmRSb3V0ZSA9ICcvNDA0J1xuICAgICAgICAgIH0gY2F0Y2ggKF8pIHtcbiAgICAgICAgICAgIG5vdEZvdW5kUm91dGUgPSAnL19lcnJvcidcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByb3V0ZUluZm8gPSBhd2FpdCB0aGlzLmdldFJvdXRlSW5mbyhcbiAgICAgICAgICAgIG5vdEZvdW5kUm91dGUsXG4gICAgICAgICAgICBub3RGb3VuZFJvdXRlLFxuICAgICAgICAgICAgcXVlcnksXG4gICAgICAgICAgICBhcyxcbiAgICAgICAgICAgIHJlc29sdmVkQXMsXG4gICAgICAgICAgICB7IHNoYWxsb3c6IGZhbHNlIH1cbiAgICAgICAgICApXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgUm91dGVyLmV2ZW50cy5lbWl0KCdiZWZvcmVIaXN0b3J5Q2hhbmdlJywgYXMsIHJvdXRlUHJvcHMpXG4gICAgICB0aGlzLmNoYW5nZVN0YXRlKG1ldGhvZCwgdXJsLCBhcywgb3B0aW9ucylcblxuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgY29uc3QgYXBwQ29tcDogYW55ID0gdGhpcy5jb21wb25lbnRzWycvX2FwcCddLkNvbXBvbmVudFxuICAgICAgICA7KHdpbmRvdyBhcyBhbnkpLm5leHQuaXNQcmVyZW5kZXJlZCA9XG4gICAgICAgICAgYXBwQ29tcC5nZXRJbml0aWFsUHJvcHMgPT09IGFwcENvbXAub3JpZ0dldEluaXRpYWxQcm9wcyAmJlxuICAgICAgICAgICEocm91dGVJbmZvLkNvbXBvbmVudCBhcyBhbnkpLmdldEluaXRpYWxQcm9wc1xuICAgICAgfVxuXG4gICAgICAvLyBzaGFsbG93IHJvdXRpbmcgaXMgb25seSBhbGxvd2VkIGZvciBzYW1lIHBhZ2UgVVJMIGNoYW5nZXMuXG4gICAgICBjb25zdCBpc1ZhbGlkU2hhbGxvd1JvdXRlID0gb3B0aW9ucy5zaGFsbG93ICYmIHRoaXMucm91dGUgPT09IHJvdXRlXG5cbiAgICAgIGlmIChcbiAgICAgICAgKG9wdGlvbnMgYXMgYW55KS5faCAmJlxuICAgICAgICBwYXRobmFtZSA9PT0gJy9fZXJyb3InICYmXG4gICAgICAgIHNlbGYuX19ORVhUX0RBVEFfXy5wcm9wcz8ucGFnZVByb3BzPy5zdGF0dXNDb2RlID09PSA1MDAgJiZcbiAgICAgICAgcHJvcHM/LnBhZ2VQcm9wc1xuICAgICAgKSB7XG4gICAgICAgIC8vIGVuc3VyZSBzdGF0dXNDb2RlIGlzIHN0aWxsIGNvcnJlY3QgZm9yIHN0YXRpYyA1MDAgcGFnZVxuICAgICAgICAvLyB3aGVuIHVwZGF0aW5nIHF1ZXJ5IGluZm9ybWF0aW9uXG4gICAgICAgIHByb3BzLnBhZ2VQcm9wcy5zdGF0dXNDb2RlID0gNTAwXG4gICAgICB9XG5cbiAgICAgIGF3YWl0IHRoaXMuc2V0KFxuICAgICAgICByb3V0ZSxcbiAgICAgICAgcGF0aG5hbWUhLFxuICAgICAgICBxdWVyeSxcbiAgICAgICAgY2xlYW5lZEFzLFxuICAgICAgICByb3V0ZUluZm8sXG4gICAgICAgIGZvcmNlZFNjcm9sbCB8fFxuICAgICAgICAgIChpc1ZhbGlkU2hhbGxvd1JvdXRlIHx8ICFvcHRpb25zLnNjcm9sbCA/IG51bGwgOiB7IHg6IDAsIHk6IDAgfSlcbiAgICAgICkuY2F0Y2goKGUpID0+IHtcbiAgICAgICAgaWYgKGUuY2FuY2VsbGVkKSBlcnJvciA9IGVycm9yIHx8IGVcbiAgICAgICAgZWxzZSB0aHJvdyBlXG4gICAgICB9KVxuXG4gICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgUm91dGVyLmV2ZW50cy5lbWl0KCdyb3V0ZUNoYW5nZUVycm9yJywgZXJyb3IsIGNsZWFuZWRBcywgcm91dGVQcm9wcylcbiAgICAgICAgdGhyb3cgZXJyb3JcbiAgICAgIH1cblxuICAgICAgaWYgKHByb2Nlc3MuZW52Ll9fTkVYVF9JMThOX1NVUFBPUlQpIHtcbiAgICAgICAgaWYgKHRoaXMubG9jYWxlKSB7XG4gICAgICAgICAgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmxhbmcgPSB0aGlzLmxvY2FsZVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBSb3V0ZXIuZXZlbnRzLmVtaXQoJ3JvdXRlQ2hhbmdlQ29tcGxldGUnLCBhcywgcm91dGVQcm9wcylcblxuICAgICAgcmV0dXJuIHRydWVcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIGlmIChlcnIuY2FuY2VsbGVkKSB7XG4gICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgfVxuICAgICAgdGhyb3cgZXJyXG4gICAgfVxuICB9XG5cbiAgY2hhbmdlU3RhdGUoXG4gICAgbWV0aG9kOiBIaXN0b3J5TWV0aG9kLFxuICAgIHVybDogc3RyaW5nLFxuICAgIGFzOiBzdHJpbmcsXG4gICAgb3B0aW9uczogVHJhbnNpdGlvbk9wdGlvbnMgPSB7fVxuICApOiB2b2lkIHtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgaWYgKHR5cGVvZiB3aW5kb3cuaGlzdG9yeSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihgV2FybmluZzogd2luZG93Lmhpc3RvcnkgaXMgbm90IGF2YWlsYWJsZS5gKVxuICAgICAgICByZXR1cm5cbiAgICAgIH1cblxuICAgICAgaWYgKHR5cGVvZiB3aW5kb3cuaGlzdG9yeVttZXRob2RdID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICBjb25zb2xlLmVycm9yKGBXYXJuaW5nOiB3aW5kb3cuaGlzdG9yeS4ke21ldGhvZH0gaXMgbm90IGF2YWlsYWJsZWApXG4gICAgICAgIHJldHVyblxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChtZXRob2QgIT09ICdwdXNoU3RhdGUnIHx8IGdldFVSTCgpICE9PSBhcykge1xuICAgICAgdGhpcy5fc2hhbGxvdyA9IG9wdGlvbnMuc2hhbGxvd1xuICAgICAgd2luZG93Lmhpc3RvcnlbbWV0aG9kXShcbiAgICAgICAge1xuICAgICAgICAgIHVybCxcbiAgICAgICAgICBhcyxcbiAgICAgICAgICBvcHRpb25zLFxuICAgICAgICAgIF9fTjogdHJ1ZSxcbiAgICAgICAgICBpZHg6IHRoaXMuX2lkeCA9IG1ldGhvZCAhPT0gJ3B1c2hTdGF0ZScgPyB0aGlzLl9pZHggOiB0aGlzLl9pZHggKyAxLFxuICAgICAgICB9IGFzIEhpc3RvcnlTdGF0ZSxcbiAgICAgICAgLy8gTW9zdCBicm93c2VycyBjdXJyZW50bHkgaWdub3JlcyB0aGlzIHBhcmFtZXRlciwgYWx0aG91Z2ggdGhleSBtYXkgdXNlIGl0IGluIHRoZSBmdXR1cmUuXG4gICAgICAgIC8vIFBhc3NpbmcgdGhlIGVtcHR5IHN0cmluZyBoZXJlIHNob3VsZCBiZSBzYWZlIGFnYWluc3QgZnV0dXJlIGNoYW5nZXMgdG8gdGhlIG1ldGhvZC5cbiAgICAgICAgLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0hpc3RvcnkvcmVwbGFjZVN0YXRlXG4gICAgICAgICcnLFxuICAgICAgICBhc1xuICAgICAgKVxuICAgIH1cbiAgfVxuXG4gIGFzeW5jIGhhbmRsZVJvdXRlSW5mb0Vycm9yKFxuICAgIGVycjogRXJyb3IgJiB7IGNvZGU6IGFueTsgY2FuY2VsbGVkOiBib29sZWFuIH0sXG4gICAgcGF0aG5hbWU6IHN0cmluZyxcbiAgICBxdWVyeTogUGFyc2VkVXJsUXVlcnksXG4gICAgYXM6IHN0cmluZyxcbiAgICByb3V0ZVByb3BzOiBSb3V0ZVByb3BlcnRpZXMsXG4gICAgbG9hZEVycm9yRmFpbD86IGJvb2xlYW5cbiAgKTogUHJvbWlzZTxDb21wbGV0ZVByaXZhdGVSb3V0ZUluZm8+IHtcbiAgICBpZiAoZXJyLmNhbmNlbGxlZCkge1xuICAgICAgLy8gYnViYmxlIHVwIGNhbmNlbGxhdGlvbiBlcnJvcnNcbiAgICAgIHRocm93IGVyclxuICAgIH1cblxuICAgIGlmIChpc0Fzc2V0RXJyb3IoZXJyKSB8fCBsb2FkRXJyb3JGYWlsKSB7XG4gICAgICBSb3V0ZXIuZXZlbnRzLmVtaXQoJ3JvdXRlQ2hhbmdlRXJyb3InLCBlcnIsIGFzLCByb3V0ZVByb3BzKVxuXG4gICAgICAvLyBJZiB3ZSBjYW4ndCBsb2FkIHRoZSBwYWdlIGl0IGNvdWxkIGJlIG9uZSBvZiBmb2xsb3dpbmcgcmVhc29uc1xuICAgICAgLy8gIDEuIFBhZ2UgZG9lc24ndCBleGlzdHNcbiAgICAgIC8vICAyLiBQYWdlIGRvZXMgZXhpc3QgaW4gYSBkaWZmZXJlbnQgem9uZVxuICAgICAgLy8gIDMuIEludGVybmFsIGVycm9yIHdoaWxlIGxvYWRpbmcgdGhlIHBhZ2VcblxuICAgICAgLy8gU28sIGRvaW5nIGEgaGFyZCByZWxvYWQgaXMgdGhlIHByb3BlciB3YXkgdG8gZGVhbCB3aXRoIHRoaXMuXG4gICAgICB3aW5kb3cubG9jYXRpb24uaHJlZiA9IGFzXG5cbiAgICAgIC8vIENoYW5naW5nIHRoZSBVUkwgZG9lc24ndCBibG9jayBleGVjdXRpbmcgdGhlIGN1cnJlbnQgY29kZSBwYXRoLlxuICAgICAgLy8gU28gbGV0J3MgdGhyb3cgYSBjYW5jZWxsYXRpb24gZXJyb3Igc3RvcCB0aGUgcm91dGluZyBsb2dpYy5cbiAgICAgIHRocm93IGJ1aWxkQ2FuY2VsbGF0aW9uRXJyb3IoKVxuICAgIH1cblxuICAgIHRyeSB7XG4gICAgICBsZXQgQ29tcG9uZW50OiBDb21wb25lbnRUeXBlXG4gICAgICBsZXQgc3R5bGVTaGVldHM6IFN0eWxlU2hlZXRUdXBsZVtdXG4gICAgICBsZXQgcHJvcHM6IFJlY29yZDxzdHJpbmcsIGFueT4gfCB1bmRlZmluZWRcblxuICAgICAgaWYgKFxuICAgICAgICB0eXBlb2YgQ29tcG9uZW50ISA9PT0gJ3VuZGVmaW5lZCcgfHxcbiAgICAgICAgdHlwZW9mIHN0eWxlU2hlZXRzISA9PT0gJ3VuZGVmaW5lZCdcbiAgICAgICkge1xuICAgICAgICA7KHsgcGFnZTogQ29tcG9uZW50LCBzdHlsZVNoZWV0cyB9ID0gYXdhaXQgdGhpcy5mZXRjaENvbXBvbmVudChcbiAgICAgICAgICAnL19lcnJvcidcbiAgICAgICAgKSlcbiAgICAgIH1cblxuICAgICAgY29uc3Qgcm91dGVJbmZvOiBDb21wbGV0ZVByaXZhdGVSb3V0ZUluZm8gPSB7XG4gICAgICAgIHByb3BzLFxuICAgICAgICBDb21wb25lbnQsXG4gICAgICAgIHN0eWxlU2hlZXRzLFxuICAgICAgICBlcnIsXG4gICAgICAgIGVycm9yOiBlcnIsXG4gICAgICB9XG5cbiAgICAgIGlmICghcm91dGVJbmZvLnByb3BzKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgcm91dGVJbmZvLnByb3BzID0gYXdhaXQgdGhpcy5nZXRJbml0aWFsUHJvcHMoQ29tcG9uZW50LCB7XG4gICAgICAgICAgICBlcnIsXG4gICAgICAgICAgICBwYXRobmFtZSxcbiAgICAgICAgICAgIHF1ZXJ5LFxuICAgICAgICAgIH0gYXMgYW55KVxuICAgICAgICB9IGNhdGNoIChnaXBFcnIpIHtcbiAgICAgICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBpbiBlcnJvciBwYWdlIGBnZXRJbml0aWFsUHJvcHNgOiAnLCBnaXBFcnIpXG4gICAgICAgICAgcm91dGVJbmZvLnByb3BzID0ge31cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gcm91dGVJbmZvXG4gICAgfSBjYXRjaCAocm91dGVJbmZvRXJyKSB7XG4gICAgICByZXR1cm4gdGhpcy5oYW5kbGVSb3V0ZUluZm9FcnJvcihcbiAgICAgICAgcm91dGVJbmZvRXJyLFxuICAgICAgICBwYXRobmFtZSxcbiAgICAgICAgcXVlcnksXG4gICAgICAgIGFzLFxuICAgICAgICByb3V0ZVByb3BzLFxuICAgICAgICB0cnVlXG4gICAgICApXG4gICAgfVxuICB9XG5cbiAgYXN5bmMgZ2V0Um91dGVJbmZvKFxuICAgIHJvdXRlOiBzdHJpbmcsXG4gICAgcGF0aG5hbWU6IHN0cmluZyxcbiAgICBxdWVyeTogYW55LFxuICAgIGFzOiBzdHJpbmcsXG4gICAgcmVzb2x2ZWRBczogc3RyaW5nLFxuICAgIHJvdXRlUHJvcHM6IFJvdXRlUHJvcGVydGllc1xuICApOiBQcm9taXNlPFByaXZhdGVSb3V0ZUluZm8+IHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgZXhpc3RpbmdSb3V0ZUluZm86IFByaXZhdGVSb3V0ZUluZm8gfCB1bmRlZmluZWQgPSB0aGlzLmNvbXBvbmVudHNbXG4gICAgICAgIHJvdXRlXG4gICAgICBdXG4gICAgICBpZiAocm91dGVQcm9wcy5zaGFsbG93ICYmIGV4aXN0aW5nUm91dGVJbmZvICYmIHRoaXMucm91dGUgPT09IHJvdXRlKSB7XG4gICAgICAgIHJldHVybiBleGlzdGluZ1JvdXRlSW5mb1xuICAgICAgfVxuXG4gICAgICBjb25zdCBjYWNoZWRSb3V0ZUluZm86IENvbXBsZXRlUHJpdmF0ZVJvdXRlSW5mbyB8IHVuZGVmaW5lZCA9XG4gICAgICAgIGV4aXN0aW5nUm91dGVJbmZvICYmICdpbml0aWFsJyBpbiBleGlzdGluZ1JvdXRlSW5mb1xuICAgICAgICAgID8gdW5kZWZpbmVkXG4gICAgICAgICAgOiBleGlzdGluZ1JvdXRlSW5mb1xuICAgICAgY29uc3Qgcm91dGVJbmZvOiBDb21wbGV0ZVByaXZhdGVSb3V0ZUluZm8gPSBjYWNoZWRSb3V0ZUluZm9cbiAgICAgICAgPyBjYWNoZWRSb3V0ZUluZm9cbiAgICAgICAgOiBhd2FpdCB0aGlzLmZldGNoQ29tcG9uZW50KHJvdXRlKS50aGVuKChyZXMpID0+ICh7XG4gICAgICAgICAgICBDb21wb25lbnQ6IHJlcy5wYWdlLFxuICAgICAgICAgICAgc3R5bGVTaGVldHM6IHJlcy5zdHlsZVNoZWV0cyxcbiAgICAgICAgICAgIF9fTl9TU0c6IHJlcy5tb2QuX19OX1NTRyxcbiAgICAgICAgICAgIF9fTl9TU1A6IHJlcy5tb2QuX19OX1NTUCxcbiAgICAgICAgICB9KSlcblxuICAgICAgY29uc3QgeyBDb21wb25lbnQsIF9fTl9TU0csIF9fTl9TU1AgfSA9IHJvdXRlSW5mb1xuXG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICBjb25zdCB7IGlzVmFsaWRFbGVtZW50VHlwZSB9ID0gcmVxdWlyZSgncmVhY3QtaXMnKVxuICAgICAgICBpZiAoIWlzVmFsaWRFbGVtZW50VHlwZShDb21wb25lbnQpKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgYFRoZSBkZWZhdWx0IGV4cG9ydCBpcyBub3QgYSBSZWFjdCBDb21wb25lbnQgaW4gcGFnZTogXCIke3BhdGhuYW1lfVwiYFxuICAgICAgICAgIClcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBsZXQgZGF0YUhyZWY6IHN0cmluZyB8IHVuZGVmaW5lZFxuXG4gICAgICBpZiAoX19OX1NTRyB8fCBfX05fU1NQKSB7XG4gICAgICAgIGRhdGFIcmVmID0gdGhpcy5wYWdlTG9hZGVyLmdldERhdGFIcmVmKFxuICAgICAgICAgIGZvcm1hdFdpdGhWYWxpZGF0aW9uKHsgcGF0aG5hbWUsIHF1ZXJ5IH0pLFxuICAgICAgICAgIHJlc29sdmVkQXMsXG4gICAgICAgICAgX19OX1NTRyxcbiAgICAgICAgICB0aGlzLmxvY2FsZVxuICAgICAgICApXG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHByb3BzID0gYXdhaXQgdGhpcy5fZ2V0RGF0YTxDb21wbGV0ZVByaXZhdGVSb3V0ZUluZm8+KCgpID0+XG4gICAgICAgIF9fTl9TU0dcbiAgICAgICAgICA/IHRoaXMuX2dldFN0YXRpY0RhdGEoZGF0YUhyZWYhKVxuICAgICAgICAgIDogX19OX1NTUFxuICAgICAgICAgID8gdGhpcy5fZ2V0U2VydmVyRGF0YShkYXRhSHJlZiEpXG4gICAgICAgICAgOiB0aGlzLmdldEluaXRpYWxQcm9wcyhcbiAgICAgICAgICAgICAgQ29tcG9uZW50LFxuICAgICAgICAgICAgICAvLyB3ZSBwcm92aWRlIEFwcFRyZWUgbGF0ZXIgc28gdGhpcyBuZWVkcyB0byBiZSBgYW55YFxuICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgcGF0aG5hbWUsXG4gICAgICAgICAgICAgICAgcXVlcnksXG4gICAgICAgICAgICAgICAgYXNQYXRoOiBhcyxcbiAgICAgICAgICAgICAgICBsb2NhbGU6IHRoaXMubG9jYWxlLFxuICAgICAgICAgICAgICAgIGxvY2FsZXM6IHRoaXMubG9jYWxlcyxcbiAgICAgICAgICAgICAgICBkZWZhdWx0TG9jYWxlOiB0aGlzLmRlZmF1bHRMb2NhbGUsXG4gICAgICAgICAgICAgIH0gYXMgYW55XG4gICAgICAgICAgICApXG4gICAgICApXG5cbiAgICAgIHJvdXRlSW5mby5wcm9wcyA9IHByb3BzXG4gICAgICB0aGlzLmNvbXBvbmVudHNbcm91dGVdID0gcm91dGVJbmZvXG4gICAgICByZXR1cm4gcm91dGVJbmZvXG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICByZXR1cm4gdGhpcy5oYW5kbGVSb3V0ZUluZm9FcnJvcihlcnIsIHBhdGhuYW1lLCBxdWVyeSwgYXMsIHJvdXRlUHJvcHMpXG4gICAgfVxuICB9XG5cbiAgc2V0KFxuICAgIHJvdXRlOiBzdHJpbmcsXG4gICAgcGF0aG5hbWU6IHN0cmluZyxcbiAgICBxdWVyeTogUGFyc2VkVXJsUXVlcnksXG4gICAgYXM6IHN0cmluZyxcbiAgICBkYXRhOiBQcml2YXRlUm91dGVJbmZvLFxuICAgIHJlc2V0U2Nyb2xsOiB7IHg6IG51bWJlcjsgeTogbnVtYmVyIH0gfCBudWxsXG4gICk6IFByb21pc2U8dm9pZD4ge1xuICAgIHRoaXMuaXNGYWxsYmFjayA9IGZhbHNlXG5cbiAgICB0aGlzLnJvdXRlID0gcm91dGVcbiAgICB0aGlzLnBhdGhuYW1lID0gcGF0aG5hbWVcbiAgICB0aGlzLnF1ZXJ5ID0gcXVlcnlcbiAgICB0aGlzLmFzUGF0aCA9IGFzXG4gICAgcmV0dXJuIHRoaXMubm90aWZ5KGRhdGEsIHJlc2V0U2Nyb2xsKVxuICB9XG5cbiAgLyoqXG4gICAqIENhbGxiYWNrIHRvIGV4ZWN1dGUgYmVmb3JlIHJlcGxhY2luZyByb3V0ZXIgc3RhdGVcbiAgICogQHBhcmFtIGNiIGNhbGxiYWNrIHRvIGJlIGV4ZWN1dGVkXG4gICAqL1xuICBiZWZvcmVQb3BTdGF0ZShjYjogQmVmb3JlUG9wU3RhdGVDYWxsYmFjaykge1xuICAgIHRoaXMuX2JwcyA9IGNiXG4gIH1cblxuICBvbmx5QUhhc2hDaGFuZ2UoYXM6IHN0cmluZyk6IGJvb2xlYW4ge1xuICAgIGlmICghdGhpcy5hc1BhdGgpIHJldHVybiBmYWxzZVxuICAgIGNvbnN0IFtvbGRVcmxOb0hhc2gsIG9sZEhhc2hdID0gdGhpcy5hc1BhdGguc3BsaXQoJyMnKVxuICAgIGNvbnN0IFtuZXdVcmxOb0hhc2gsIG5ld0hhc2hdID0gYXMuc3BsaXQoJyMnKVxuXG4gICAgLy8gTWFrZXMgc3VyZSB3ZSBzY3JvbGwgdG8gdGhlIHByb3ZpZGVkIGhhc2ggaWYgdGhlIHVybC9oYXNoIGFyZSB0aGUgc2FtZVxuICAgIGlmIChuZXdIYXNoICYmIG9sZFVybE5vSGFzaCA9PT0gbmV3VXJsTm9IYXNoICYmIG9sZEhhc2ggPT09IG5ld0hhc2gpIHtcbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuXG4gICAgLy8gSWYgdGhlIHVybHMgYXJlIGNoYW5nZSwgdGhlcmUncyBtb3JlIHRoYW4gYSBoYXNoIGNoYW5nZVxuICAgIGlmIChvbGRVcmxOb0hhc2ggIT09IG5ld1VybE5vSGFzaCkge1xuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuXG4gICAgLy8gSWYgdGhlIGhhc2ggaGFzIGNoYW5nZWQsIHRoZW4gaXQncyBhIGhhc2ggb25seSBjaGFuZ2UuXG4gICAgLy8gVGhpcyBjaGVjayBpcyBuZWNlc3NhcnkgdG8gaGFuZGxlIGJvdGggdGhlIGVudGVyIGFuZFxuICAgIC8vIGxlYXZlIGhhc2ggPT09ICcnIGNhc2VzLiBUaGUgaWRlbnRpdHkgY2FzZSBmYWxscyB0aHJvdWdoXG4gICAgLy8gYW5kIGlzIHRyZWF0ZWQgYXMgYSBuZXh0IHJlbG9hZC5cbiAgICByZXR1cm4gb2xkSGFzaCAhPT0gbmV3SGFzaFxuICB9XG5cbiAgc2Nyb2xsVG9IYXNoKGFzOiBzdHJpbmcpOiB2b2lkIHtcbiAgICBjb25zdCBbLCBoYXNoXSA9IGFzLnNwbGl0KCcjJylcbiAgICAvLyBTY3JvbGwgdG8gdG9wIGlmIHRoZSBoYXNoIGlzIGp1c3QgYCNgIHdpdGggbm8gdmFsdWUgb3IgYCN0b3BgXG4gICAgLy8gVG8gbWlycm9yIGJyb3dzZXJzXG4gICAgaWYgKGhhc2ggPT09ICcnIHx8IGhhc2ggPT09ICd0b3AnKSB7XG4gICAgICB3aW5kb3cuc2Nyb2xsVG8oMCwgMClcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIC8vIEZpcnN0IHdlIGNoZWNrIGlmIHRoZSBlbGVtZW50IGJ5IGlkIGlzIGZvdW5kXG4gICAgY29uc3QgaWRFbCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGhhc2gpXG4gICAgaWYgKGlkRWwpIHtcbiAgICAgIGlkRWwuc2Nyb2xsSW50b1ZpZXcoKVxuICAgICAgcmV0dXJuXG4gICAgfVxuICAgIC8vIElmIHRoZXJlJ3Mgbm8gZWxlbWVudCB3aXRoIHRoZSBpZCwgd2UgY2hlY2sgdGhlIGBuYW1lYCBwcm9wZXJ0eVxuICAgIC8vIFRvIG1pcnJvciBicm93c2Vyc1xuICAgIGNvbnN0IG5hbWVFbCA9IGRvY3VtZW50LmdldEVsZW1lbnRzQnlOYW1lKGhhc2gpWzBdXG4gICAgaWYgKG5hbWVFbCkge1xuICAgICAgbmFtZUVsLnNjcm9sbEludG9WaWV3KClcbiAgICB9XG4gIH1cblxuICB1cmxJc05ldyhhc1BhdGg6IHN0cmluZyk6IGJvb2xlYW4ge1xuICAgIHJldHVybiB0aGlzLmFzUGF0aCAhPT0gYXNQYXRoXG4gIH1cblxuICAvKipcbiAgICogUHJlZmV0Y2ggcGFnZSBjb2RlLCB5b3UgbWF5IHdhaXQgZm9yIHRoZSBkYXRhIGR1cmluZyBwYWdlIHJlbmRlcmluZy5cbiAgICogVGhpcyBmZWF0dXJlIG9ubHkgd29ya3MgaW4gcHJvZHVjdGlvbiFcbiAgICogQHBhcmFtIHVybCB0aGUgaHJlZiBvZiBwcmVmZXRjaGVkIHBhZ2VcbiAgICogQHBhcmFtIGFzUGF0aCB0aGUgYXMgcGF0aCBvZiB0aGUgcHJlZmV0Y2hlZCBwYWdlXG4gICAqL1xuICBhc3luYyBwcmVmZXRjaChcbiAgICB1cmw6IHN0cmluZyxcbiAgICBhc1BhdGg6IHN0cmluZyA9IHVybCxcbiAgICBvcHRpb25zOiBQcmVmZXRjaE9wdGlvbnMgPSB7fVxuICApOiBQcm9taXNlPHZvaWQ+IHtcbiAgICBsZXQgcGFyc2VkID0gcGFyc2VSZWxhdGl2ZVVybCh1cmwpXG5cbiAgICBsZXQgeyBwYXRobmFtZSB9ID0gcGFyc2VkXG5cbiAgICBpZiAocHJvY2Vzcy5lbnYuX19ORVhUX0kxOE5fU1VQUE9SVCkge1xuICAgICAgaWYgKG9wdGlvbnMubG9jYWxlID09PSBmYWxzZSkge1xuICAgICAgICBwYXRobmFtZSA9IG5vcm1hbGl6ZUxvY2FsZVBhdGghKHBhdGhuYW1lLCB0aGlzLmxvY2FsZXMpLnBhdGhuYW1lXG4gICAgICAgIHBhcnNlZC5wYXRobmFtZSA9IHBhdGhuYW1lXG4gICAgICAgIHVybCA9IGZvcm1hdFdpdGhWYWxpZGF0aW9uKHBhcnNlZClcblxuICAgICAgICBsZXQgcGFyc2VkQXMgPSBwYXJzZVJlbGF0aXZlVXJsKGFzUGF0aClcbiAgICAgICAgY29uc3QgbG9jYWxlUGF0aFJlc3VsdCA9IG5vcm1hbGl6ZUxvY2FsZVBhdGghKFxuICAgICAgICAgIHBhcnNlZEFzLnBhdGhuYW1lLFxuICAgICAgICAgIHRoaXMubG9jYWxlc1xuICAgICAgICApXG4gICAgICAgIHBhcnNlZEFzLnBhdGhuYW1lID0gbG9jYWxlUGF0aFJlc3VsdC5wYXRobmFtZVxuICAgICAgICBvcHRpb25zLmxvY2FsZSA9IGxvY2FsZVBhdGhSZXN1bHQuZGV0ZWN0ZWRMb2NhbGUgfHwgdGhpcy5kZWZhdWx0TG9jYWxlXG4gICAgICAgIGFzUGF0aCA9IGZvcm1hdFdpdGhWYWxpZGF0aW9uKHBhcnNlZEFzKVxuICAgICAgfVxuICAgIH1cblxuICAgIGNvbnN0IHBhZ2VzID0gYXdhaXQgdGhpcy5wYWdlTG9hZGVyLmdldFBhZ2VMaXN0KClcbiAgICBsZXQgcmVzb2x2ZWRBcyA9IGFzUGF0aFxuXG4gICAgaWYgKHByb2Nlc3MuZW52Ll9fTkVYVF9IQVNfUkVXUklURVMgJiYgYXNQYXRoLnN0YXJ0c1dpdGgoJy8nKSkge1xuICAgICAgbGV0IHJld3JpdGVzOiBhbnlcbiAgICAgIDsoeyBfX3Jld3JpdGVzOiByZXdyaXRlcyB9ID0gYXdhaXQgZ2V0Q2xpZW50QnVpbGRNYW5pZmVzdCgpKVxuXG4gICAgICBjb25zdCByZXdyaXRlc1Jlc3VsdCA9IHJlc29sdmVSZXdyaXRlcyhcbiAgICAgICAgYWRkQmFzZVBhdGgoYWRkTG9jYWxlKGFzUGF0aCwgdGhpcy5sb2NhbGUpKSxcbiAgICAgICAgcGFnZXMsXG4gICAgICAgIHJld3JpdGVzLFxuICAgICAgICBwYXJzZWQucXVlcnksXG4gICAgICAgIChwOiBzdHJpbmcpID0+IHJlc29sdmVEeW5hbWljUm91dGUocCwgcGFnZXMpLFxuICAgICAgICB0aGlzLmxvY2FsZXNcbiAgICAgIClcbiAgICAgIHJlc29sdmVkQXMgPSBkZWxMb2NhbGUoZGVsQmFzZVBhdGgocmV3cml0ZXNSZXN1bHQuYXNQYXRoKSwgdGhpcy5sb2NhbGUpXG5cbiAgICAgIGlmIChyZXdyaXRlc1Jlc3VsdC5tYXRjaGVkUGFnZSAmJiByZXdyaXRlc1Jlc3VsdC5yZXNvbHZlZEhyZWYpIHtcbiAgICAgICAgLy8gaWYgdGhpcyBkaXJlY3RseSBtYXRjaGVzIGEgcGFnZSB3ZSBuZWVkIHRvIHVwZGF0ZSB0aGUgaHJlZiB0b1xuICAgICAgICAvLyBhbGxvdyB0aGUgY29ycmVjdCBwYWdlIGNodW5rIHRvIGJlIGxvYWRlZFxuICAgICAgICBwYXRobmFtZSA9IHJld3JpdGVzUmVzdWx0LnJlc29sdmVkSHJlZlxuICAgICAgICBwYXJzZWQucGF0aG5hbWUgPSBwYXRobmFtZVxuICAgICAgICB1cmwgPSBmb3JtYXRXaXRoVmFsaWRhdGlvbihwYXJzZWQpXG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHBhcnNlZC5wYXRobmFtZSA9IHJlc29sdmVEeW5hbWljUm91dGUocGFyc2VkLnBhdGhuYW1lLCBwYWdlcylcblxuICAgICAgaWYgKHBhcnNlZC5wYXRobmFtZSAhPT0gcGF0aG5hbWUpIHtcbiAgICAgICAgcGF0aG5hbWUgPSBwYXJzZWQucGF0aG5hbWVcbiAgICAgICAgdXJsID0gZm9ybWF0V2l0aFZhbGlkYXRpb24ocGFyc2VkKVxuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCByb3V0ZSA9IHJlbW92ZVBhdGhUcmFpbGluZ1NsYXNoKHBhdGhuYW1lKVxuXG4gICAgLy8gUHJlZmV0Y2ggaXMgbm90IHN1cHBvcnRlZCBpbiBkZXZlbG9wbWVudCBtb2RlIGJlY2F1c2UgaXQgd291bGQgdHJpZ2dlciBvbi1kZW1hbmQtZW50cmllc1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICBhd2FpdCBQcm9taXNlLmFsbChbXG4gICAgICB0aGlzLnBhZ2VMb2FkZXIuX2lzU3NnKHJvdXRlKS50aGVuKChpc1NzZzogYm9vbGVhbikgPT4ge1xuICAgICAgICByZXR1cm4gaXNTc2dcbiAgICAgICAgICA/IHRoaXMuX2dldFN0YXRpY0RhdGEoXG4gICAgICAgICAgICAgIHRoaXMucGFnZUxvYWRlci5nZXREYXRhSHJlZihcbiAgICAgICAgICAgICAgICB1cmwsXG4gICAgICAgICAgICAgICAgcmVzb2x2ZWRBcyxcbiAgICAgICAgICAgICAgICB0cnVlLFxuICAgICAgICAgICAgICAgIHR5cGVvZiBvcHRpb25zLmxvY2FsZSAhPT0gJ3VuZGVmaW5lZCdcbiAgICAgICAgICAgICAgICAgID8gb3B0aW9ucy5sb2NhbGVcbiAgICAgICAgICAgICAgICAgIDogdGhpcy5sb2NhbGVcbiAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgKVxuICAgICAgICAgIDogZmFsc2VcbiAgICAgIH0pLFxuICAgICAgdGhpcy5wYWdlTG9hZGVyW29wdGlvbnMucHJpb3JpdHkgPyAnbG9hZFBhZ2UnIDogJ3ByZWZldGNoJ10ocm91dGUpLFxuICAgIF0pXG4gIH1cblxuICBhc3luYyBmZXRjaENvbXBvbmVudChyb3V0ZTogc3RyaW5nKTogUHJvbWlzZTxHb29kUGFnZUNhY2hlPiB7XG4gICAgbGV0IGNhbmNlbGxlZCA9IGZhbHNlXG4gICAgY29uc3QgY2FuY2VsID0gKHRoaXMuY2xjID0gKCkgPT4ge1xuICAgICAgY2FuY2VsbGVkID0gdHJ1ZVxuICAgIH0pXG5cbiAgICBjb25zdCBjb21wb25lbnRSZXN1bHQgPSBhd2FpdCB0aGlzLnBhZ2VMb2FkZXIubG9hZFBhZ2Uocm91dGUpXG5cbiAgICBpZiAoY2FuY2VsbGVkKSB7XG4gICAgICBjb25zdCBlcnJvcjogYW55ID0gbmV3IEVycm9yKFxuICAgICAgICBgQWJvcnQgZmV0Y2hpbmcgY29tcG9uZW50IGZvciByb3V0ZTogXCIke3JvdXRlfVwiYFxuICAgICAgKVxuICAgICAgZXJyb3IuY2FuY2VsbGVkID0gdHJ1ZVxuICAgICAgdGhyb3cgZXJyb3JcbiAgICB9XG5cbiAgICBpZiAoY2FuY2VsID09PSB0aGlzLmNsYykge1xuICAgICAgdGhpcy5jbGMgPSBudWxsXG4gICAgfVxuXG4gICAgcmV0dXJuIGNvbXBvbmVudFJlc3VsdFxuICB9XG5cbiAgX2dldERhdGE8VD4oZm46ICgpID0+IFByb21pc2U8VD4pOiBQcm9taXNlPFQ+IHtcbiAgICBsZXQgY2FuY2VsbGVkID0gZmFsc2VcbiAgICBjb25zdCBjYW5jZWwgPSAoKSA9PiB7XG4gICAgICBjYW5jZWxsZWQgPSB0cnVlXG4gICAgfVxuICAgIHRoaXMuY2xjID0gY2FuY2VsXG4gICAgcmV0dXJuIGZuKCkudGhlbigoZGF0YSkgPT4ge1xuICAgICAgaWYgKGNhbmNlbCA9PT0gdGhpcy5jbGMpIHtcbiAgICAgICAgdGhpcy5jbGMgPSBudWxsXG4gICAgICB9XG5cbiAgICAgIGlmIChjYW5jZWxsZWQpIHtcbiAgICAgICAgY29uc3QgZXJyOiBhbnkgPSBuZXcgRXJyb3IoJ0xvYWRpbmcgaW5pdGlhbCBwcm9wcyBjYW5jZWxsZWQnKVxuICAgICAgICBlcnIuY2FuY2VsbGVkID0gdHJ1ZVxuICAgICAgICB0aHJvdyBlcnJcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGRhdGFcbiAgICB9KVxuICB9XG5cbiAgX2dldFN0YXRpY0RhdGEoZGF0YUhyZWY6IHN0cmluZyk6IFByb21pc2U8b2JqZWN0PiB7XG4gICAgY29uc3QgeyBocmVmOiBjYWNoZUtleSB9ID0gbmV3IFVSTChkYXRhSHJlZiwgd2luZG93LmxvY2F0aW9uLmhyZWYpXG4gICAgaWYgKFxuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdwcm9kdWN0aW9uJyAmJlxuICAgICAgIXRoaXMuaXNQcmV2aWV3ICYmXG4gICAgICB0aGlzLnNkY1tjYWNoZUtleV1cbiAgICApIHtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUodGhpcy5zZGNbY2FjaGVLZXldKVxuICAgIH1cbiAgICByZXR1cm4gZmV0Y2hOZXh0RGF0YShkYXRhSHJlZiwgdGhpcy5pc1NzcikudGhlbigoZGF0YSkgPT4ge1xuICAgICAgdGhpcy5zZGNbY2FjaGVLZXldID0gZGF0YVxuICAgICAgcmV0dXJuIGRhdGFcbiAgICB9KVxuICB9XG5cbiAgX2dldFNlcnZlckRhdGEoZGF0YUhyZWY6IHN0cmluZyk6IFByb21pc2U8b2JqZWN0PiB7XG4gICAgY29uc3QgeyBocmVmOiByZXNvdXJjZUtleSB9ID0gbmV3IFVSTChkYXRhSHJlZiwgd2luZG93LmxvY2F0aW9uLmhyZWYpXG4gICAgaWYgKHRoaXMuc2RyW3Jlc291cmNlS2V5XSkge1xuICAgICAgcmV0dXJuIHRoaXMuc2RyW3Jlc291cmNlS2V5XVxuICAgIH1cbiAgICByZXR1cm4gKHRoaXMuc2RyW3Jlc291cmNlS2V5XSA9IGZldGNoTmV4dERhdGEoZGF0YUhyZWYsIHRoaXMuaXNTc3IpXG4gICAgICAudGhlbigoZGF0YSkgPT4ge1xuICAgICAgICBkZWxldGUgdGhpcy5zZHJbcmVzb3VyY2VLZXldXG4gICAgICAgIHJldHVybiBkYXRhXG4gICAgICB9KVxuICAgICAgLmNhdGNoKChlcnIpID0+IHtcbiAgICAgICAgZGVsZXRlIHRoaXMuc2RyW3Jlc291cmNlS2V5XVxuICAgICAgICB0aHJvdyBlcnJcbiAgICAgIH0pKVxuICB9XG5cbiAgZ2V0SW5pdGlhbFByb3BzKFxuICAgIENvbXBvbmVudDogQ29tcG9uZW50VHlwZSxcbiAgICBjdHg6IE5leHRQYWdlQ29udGV4dFxuICApOiBQcm9taXNlPGFueT4ge1xuICAgIGNvbnN0IHsgQ29tcG9uZW50OiBBcHAgfSA9IHRoaXMuY29tcG9uZW50c1snL19hcHAnXVxuICAgIGNvbnN0IEFwcFRyZWUgPSB0aGlzLl93cmFwQXBwKEFwcCBhcyBBcHBDb21wb25lbnQpXG4gICAgY3R4LkFwcFRyZWUgPSBBcHBUcmVlXG4gICAgcmV0dXJuIGxvYWRHZXRJbml0aWFsUHJvcHM8QXBwQ29udGV4dFR5cGU8Um91dGVyPj4oQXBwLCB7XG4gICAgICBBcHBUcmVlLFxuICAgICAgQ29tcG9uZW50LFxuICAgICAgcm91dGVyOiB0aGlzLFxuICAgICAgY3R4LFxuICAgIH0pXG4gIH1cblxuICBhYm9ydENvbXBvbmVudExvYWQoYXM6IHN0cmluZywgcm91dGVQcm9wczogUm91dGVQcm9wZXJ0aWVzKTogdm9pZCB7XG4gICAgaWYgKHRoaXMuY2xjKSB7XG4gICAgICBSb3V0ZXIuZXZlbnRzLmVtaXQoXG4gICAgICAgICdyb3V0ZUNoYW5nZUVycm9yJyxcbiAgICAgICAgYnVpbGRDYW5jZWxsYXRpb25FcnJvcigpLFxuICAgICAgICBhcyxcbiAgICAgICAgcm91dGVQcm9wc1xuICAgICAgKVxuICAgICAgdGhpcy5jbGMoKVxuICAgICAgdGhpcy5jbGMgPSBudWxsXG4gICAgfVxuICB9XG5cbiAgbm90aWZ5KFxuICAgIGRhdGE6IFByaXZhdGVSb3V0ZUluZm8sXG4gICAgcmVzZXRTY3JvbGw6IHsgeDogbnVtYmVyOyB5OiBudW1iZXIgfSB8IG51bGxcbiAgKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgcmV0dXJuIHRoaXMuc3ViKFxuICAgICAgZGF0YSxcbiAgICAgIHRoaXMuY29tcG9uZW50c1snL19hcHAnXS5Db21wb25lbnQgYXMgQXBwQ29tcG9uZW50LFxuICAgICAgcmVzZXRTY3JvbGxcbiAgICApXG4gIH1cbn1cbiIsIi8vIEZvcm1hdCBmdW5jdGlvbiBtb2RpZmllZCBmcm9tIG5vZGVqc1xuLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbmltcG9ydCB7IFVybE9iamVjdCB9IGZyb20gJ3VybCdcbmltcG9ydCB7IFBhcnNlZFVybFF1ZXJ5IH0gZnJvbSAncXVlcnlzdHJpbmcnXG5pbXBvcnQgKiBhcyBxdWVyeXN0cmluZyBmcm9tICcuL3F1ZXJ5c3RyaW5nJ1xuXG5jb25zdCBzbGFzaGVkUHJvdG9jb2xzID0gL2h0dHBzP3xmdHB8Z29waGVyfGZpbGUvXG5cbmV4cG9ydCBmdW5jdGlvbiBmb3JtYXRVcmwodXJsT2JqOiBVcmxPYmplY3QpIHtcbiAgbGV0IHsgYXV0aCwgaG9zdG5hbWUgfSA9IHVybE9ialxuICBsZXQgcHJvdG9jb2wgPSB1cmxPYmoucHJvdG9jb2wgfHwgJydcbiAgbGV0IHBhdGhuYW1lID0gdXJsT2JqLnBhdGhuYW1lIHx8ICcnXG4gIGxldCBoYXNoID0gdXJsT2JqLmhhc2ggfHwgJydcbiAgbGV0IHF1ZXJ5ID0gdXJsT2JqLnF1ZXJ5IHx8ICcnXG4gIGxldCBob3N0OiBzdHJpbmcgfCBmYWxzZSA9IGZhbHNlXG5cbiAgYXV0aCA9IGF1dGggPyBlbmNvZGVVUklDb21wb25lbnQoYXV0aCkucmVwbGFjZSgvJTNBL2ksICc6JykgKyAnQCcgOiAnJ1xuXG4gIGlmICh1cmxPYmouaG9zdCkge1xuICAgIGhvc3QgPSBhdXRoICsgdXJsT2JqLmhvc3RcbiAgfSBlbHNlIGlmIChob3N0bmFtZSkge1xuICAgIGhvc3QgPSBhdXRoICsgKH5ob3N0bmFtZS5pbmRleE9mKCc6JykgPyBgWyR7aG9zdG5hbWV9XWAgOiBob3N0bmFtZSlcbiAgICBpZiAodXJsT2JqLnBvcnQpIHtcbiAgICAgIGhvc3QgKz0gJzonICsgdXJsT2JqLnBvcnRcbiAgICB9XG4gIH1cblxuICBpZiAocXVlcnkgJiYgdHlwZW9mIHF1ZXJ5ID09PSAnb2JqZWN0Jykge1xuICAgIHF1ZXJ5ID0gU3RyaW5nKHF1ZXJ5c3RyaW5nLnVybFF1ZXJ5VG9TZWFyY2hQYXJhbXMocXVlcnkgYXMgUGFyc2VkVXJsUXVlcnkpKVxuICB9XG5cbiAgbGV0IHNlYXJjaCA9IHVybE9iai5zZWFyY2ggfHwgKHF1ZXJ5ICYmIGA/JHtxdWVyeX1gKSB8fCAnJ1xuXG4gIGlmIChwcm90b2NvbCAmJiBwcm90b2NvbC5zdWJzdHIoLTEpICE9PSAnOicpIHByb3RvY29sICs9ICc6J1xuXG4gIGlmIChcbiAgICB1cmxPYmouc2xhc2hlcyB8fFxuICAgICgoIXByb3RvY29sIHx8IHNsYXNoZWRQcm90b2NvbHMudGVzdChwcm90b2NvbCkpICYmIGhvc3QgIT09IGZhbHNlKVxuICApIHtcbiAgICBob3N0ID0gJy8vJyArIChob3N0IHx8ICcnKVxuICAgIGlmIChwYXRobmFtZSAmJiBwYXRobmFtZVswXSAhPT0gJy8nKSBwYXRobmFtZSA9ICcvJyArIHBhdGhuYW1lXG4gIH0gZWxzZSBpZiAoIWhvc3QpIHtcbiAgICBob3N0ID0gJydcbiAgfVxuXG4gIGlmIChoYXNoICYmIGhhc2hbMF0gIT09ICcjJykgaGFzaCA9ICcjJyArIGhhc2hcbiAgaWYgKHNlYXJjaCAmJiBzZWFyY2hbMF0gIT09ICc/Jykgc2VhcmNoID0gJz8nICsgc2VhcmNoXG5cbiAgcGF0aG5hbWUgPSBwYXRobmFtZS5yZXBsYWNlKC9bPyNdL2csIGVuY29kZVVSSUNvbXBvbmVudClcbiAgc2VhcmNoID0gc2VhcmNoLnJlcGxhY2UoJyMnLCAnJTIzJylcblxuICByZXR1cm4gYCR7cHJvdG9jb2x9JHtob3N0fSR7cGF0aG5hbWV9JHtzZWFyY2h9JHtoYXNofWBcbn1cbiIsIi8vIFRyYW5zbGF0ZXMgYSBsb2dpY2FsIHJvdXRlIGludG8gaXRzIHBhZ2VzIGFzc2V0IHBhdGggKHJlbGF0aXZlIGZyb20gYSBjb21tb24gcHJlZml4KVxuLy8gXCJhc3NldCBwYXRoXCIgYmVpbmcgaXRzIGphdmFzY3JpcHQgZmlsZSwgZGF0YSBmaWxlLCBwcmVyZW5kZXJlZCBodG1sLC4uLlxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZ2V0QXNzZXRQYXRoRnJvbVJvdXRlKFxuICByb3V0ZTogc3RyaW5nLFxuICBleHQ6IHN0cmluZyA9ICcnXG4pOiBzdHJpbmcge1xuICBjb25zdCBwYXRoID1cbiAgICByb3V0ZSA9PT0gJy8nXG4gICAgICA/ICcvaW5kZXgnXG4gICAgICA6IC9eXFwvaW5kZXgoXFwvfCQpLy50ZXN0KHJvdXRlKVxuICAgICAgPyBgL2luZGV4JHtyb3V0ZX1gXG4gICAgICA6IGAke3JvdXRlfWBcbiAgcmV0dXJuIHBhdGggKyBleHRcbn1cbiIsIi8vIElkZW50aWZ5IC9bcGFyYW1dLyBpbiByb3V0ZSBzdHJpbmdcbmNvbnN0IFRFU1RfUk9VVEUgPSAvXFwvXFxbW14vXSs/XFxdKD89XFwvfCQpL1xuXG5leHBvcnQgZnVuY3Rpb24gaXNEeW5hbWljUm91dGUocm91dGU6IHN0cmluZyk6IGJvb2xlYW4ge1xuICByZXR1cm4gVEVTVF9ST1VURS50ZXN0KHJvdXRlKVxufVxuIiwiaW1wb3J0IHsgZ2V0TG9jYXRpb25PcmlnaW4gfSBmcm9tICcuLi8uLi91dGlscydcbmltcG9ydCB7IHNlYXJjaFBhcmFtc1RvVXJsUXVlcnkgfSBmcm9tICcuL3F1ZXJ5c3RyaW5nJ1xuXG4vKipcbiAqIFBhcnNlcyBwYXRoLXJlbGF0aXZlIHVybHMgKGUuZy4gYC9oZWxsby93b3JsZD9mb289YmFyYCkuIElmIHVybCBpc24ndCBwYXRoLXJlbGF0aXZlXG4gKiAoZS5nLiBgLi9oZWxsb2ApIHRoZW4gYXQgbGVhc3QgYmFzZSBtdXN0IGJlLlxuICogQWJzb2x1dGUgdXJscyBhcmUgcmVqZWN0ZWQgd2l0aCBvbmUgZXhjZXB0aW9uLCBpbiB0aGUgYnJvd3NlciwgYWJzb2x1dGUgdXJscyB0aGF0IGFyZSBvblxuICogdGhlIGN1cnJlbnQgb3JpZ2luIHdpbGwgYmUgcGFyc2VkIGFzIHJlbGF0aXZlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBwYXJzZVJlbGF0aXZlVXJsKHVybDogc3RyaW5nLCBiYXNlPzogc3RyaW5nKSB7XG4gIGNvbnN0IGdsb2JhbEJhc2UgPSBuZXcgVVJMKFxuICAgIHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnID8gJ2h0dHA6Ly9uJyA6IGdldExvY2F0aW9uT3JpZ2luKClcbiAgKVxuICBjb25zdCByZXNvbHZlZEJhc2UgPSBiYXNlID8gbmV3IFVSTChiYXNlLCBnbG9iYWxCYXNlKSA6IGdsb2JhbEJhc2VcbiAgY29uc3QgeyBwYXRobmFtZSwgc2VhcmNoUGFyYW1zLCBzZWFyY2gsIGhhc2gsIGhyZWYsIG9yaWdpbiB9ID0gbmV3IFVSTChcbiAgICB1cmwsXG4gICAgcmVzb2x2ZWRCYXNlXG4gIClcbiAgaWYgKG9yaWdpbiAhPT0gZ2xvYmFsQmFzZS5vcmlnaW4pIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYGludmFyaWFudDogaW52YWxpZCByZWxhdGl2ZSBVUkwsIHJvdXRlciByZWNlaXZlZCAke3VybH1gKVxuICB9XG4gIHJldHVybiB7XG4gICAgcGF0aG5hbWUsXG4gICAgcXVlcnk6IHNlYXJjaFBhcmFtc1RvVXJsUXVlcnkoc2VhcmNoUGFyYW1zKSxcbiAgICBzZWFyY2gsXG4gICAgaGFzaCxcbiAgICBocmVmOiBocmVmLnNsaWNlKGdsb2JhbEJhc2Uub3JpZ2luLmxlbmd0aCksXG4gIH1cbn1cbiIsImltcG9ydCB7IFBhcnNlZFVybFF1ZXJ5IH0gZnJvbSAncXVlcnlzdHJpbmcnXG5cbmV4cG9ydCBmdW5jdGlvbiBzZWFyY2hQYXJhbXNUb1VybFF1ZXJ5KFxuICBzZWFyY2hQYXJhbXM6IFVSTFNlYXJjaFBhcmFtc1xuKTogUGFyc2VkVXJsUXVlcnkge1xuICBjb25zdCBxdWVyeTogUGFyc2VkVXJsUXVlcnkgPSB7fVxuICBzZWFyY2hQYXJhbXMuZm9yRWFjaCgodmFsdWUsIGtleSkgPT4ge1xuICAgIGlmICh0eXBlb2YgcXVlcnlba2V5XSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHF1ZXJ5W2tleV0gPSB2YWx1ZVxuICAgIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheShxdWVyeVtrZXldKSkge1xuICAgICAgOyhxdWVyeVtrZXldIGFzIHN0cmluZ1tdKS5wdXNoKHZhbHVlKVxuICAgIH0gZWxzZSB7XG4gICAgICBxdWVyeVtrZXldID0gW3F1ZXJ5W2tleV0gYXMgc3RyaW5nLCB2YWx1ZV1cbiAgICB9XG4gIH0pXG4gIHJldHVybiBxdWVyeVxufVxuXG5mdW5jdGlvbiBzdHJpbmdpZnlVcmxRdWVyeVBhcmFtKHBhcmFtOiBzdHJpbmcpOiBzdHJpbmcge1xuICBpZiAoXG4gICAgdHlwZW9mIHBhcmFtID09PSAnc3RyaW5nJyB8fFxuICAgICh0eXBlb2YgcGFyYW0gPT09ICdudW1iZXInICYmICFpc05hTihwYXJhbSkpIHx8XG4gICAgdHlwZW9mIHBhcmFtID09PSAnYm9vbGVhbidcbiAgKSB7XG4gICAgcmV0dXJuIFN0cmluZyhwYXJhbSlcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gJydcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gdXJsUXVlcnlUb1NlYXJjaFBhcmFtcyhcbiAgdXJsUXVlcnk6IFBhcnNlZFVybFF1ZXJ5XG4pOiBVUkxTZWFyY2hQYXJhbXMge1xuICBjb25zdCByZXN1bHQgPSBuZXcgVVJMU2VhcmNoUGFyYW1zKClcbiAgT2JqZWN0LmVudHJpZXModXJsUXVlcnkpLmZvckVhY2goKFtrZXksIHZhbHVlXSkgPT4ge1xuICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgdmFsdWUuZm9yRWFjaCgoaXRlbSkgPT4gcmVzdWx0LmFwcGVuZChrZXksIHN0cmluZ2lmeVVybFF1ZXJ5UGFyYW0oaXRlbSkpKVxuICAgIH0gZWxzZSB7XG4gICAgICByZXN1bHQuc2V0KGtleSwgc3RyaW5naWZ5VXJsUXVlcnlQYXJhbSh2YWx1ZSkpXG4gICAgfVxuICB9KVxuICByZXR1cm4gcmVzdWx0XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBhc3NpZ24oXG4gIHRhcmdldDogVVJMU2VhcmNoUGFyYW1zLFxuICAuLi5zZWFyY2hQYXJhbXNMaXN0OiBVUkxTZWFyY2hQYXJhbXNbXVxuKTogVVJMU2VhcmNoUGFyYW1zIHtcbiAgc2VhcmNoUGFyYW1zTGlzdC5mb3JFYWNoKChzZWFyY2hQYXJhbXMpID0+IHtcbiAgICBBcnJheS5mcm9tKHNlYXJjaFBhcmFtcy5rZXlzKCkpLmZvckVhY2goKGtleSkgPT4gdGFyZ2V0LmRlbGV0ZShrZXkpKVxuICAgIHNlYXJjaFBhcmFtcy5mb3JFYWNoKCh2YWx1ZSwga2V5KSA9PiB0YXJnZXQuYXBwZW5kKGtleSwgdmFsdWUpKVxuICB9KVxuICByZXR1cm4gdGFyZ2V0XG59XG4iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbiByZXNvbHZlUmV3cml0ZXMoKSB7fVxuIiwiaW1wb3J0IHsgZ2V0Um91dGVSZWdleCB9IGZyb20gJy4vcm91dGUtcmVnZXgnXG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRSb3V0ZU1hdGNoZXIocm91dGVSZWdleDogUmV0dXJuVHlwZTx0eXBlb2YgZ2V0Um91dGVSZWdleD4pIHtcbiAgY29uc3QgeyByZSwgZ3JvdXBzIH0gPSByb3V0ZVJlZ2V4XG4gIHJldHVybiAocGF0aG5hbWU6IHN0cmluZyB8IG51bGwgfCB1bmRlZmluZWQpID0+IHtcbiAgICBjb25zdCByb3V0ZU1hdGNoID0gcmUuZXhlYyhwYXRobmFtZSEpXG4gICAgaWYgKCFyb3V0ZU1hdGNoKSB7XG4gICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG5cbiAgICBjb25zdCBkZWNvZGUgPSAocGFyYW06IHN0cmluZykgPT4ge1xuICAgICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIGRlY29kZVVSSUNvbXBvbmVudChwYXJhbSlcbiAgICAgIH0gY2F0Y2ggKF8pIHtcbiAgICAgICAgY29uc3QgZXJyOiBFcnJvciAmIHsgY29kZT86IHN0cmluZyB9ID0gbmV3IEVycm9yKFxuICAgICAgICAgICdmYWlsZWQgdG8gZGVjb2RlIHBhcmFtJ1xuICAgICAgICApXG4gICAgICAgIGVyci5jb2RlID0gJ0RFQ09ERV9GQUlMRUQnXG4gICAgICAgIHRocm93IGVyclxuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBwYXJhbXM6IHsgW3BhcmFtTmFtZTogc3RyaW5nXTogc3RyaW5nIHwgc3RyaW5nW10gfSA9IHt9XG5cbiAgICBPYmplY3Qua2V5cyhncm91cHMpLmZvckVhY2goKHNsdWdOYW1lOiBzdHJpbmcpID0+IHtcbiAgICAgIGNvbnN0IGcgPSBncm91cHNbc2x1Z05hbWVdXG4gICAgICBjb25zdCBtID0gcm91dGVNYXRjaFtnLnBvc11cbiAgICAgIGlmIChtICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcGFyYW1zW3NsdWdOYW1lXSA9IH5tLmluZGV4T2YoJy8nKVxuICAgICAgICAgID8gbS5zcGxpdCgnLycpLm1hcCgoZW50cnkpID0+IGRlY29kZShlbnRyeSkpXG4gICAgICAgICAgOiBnLnJlcGVhdFxuICAgICAgICAgID8gW2RlY29kZShtKV1cbiAgICAgICAgICA6IGRlY29kZShtKVxuICAgICAgfVxuICAgIH0pXG4gICAgcmV0dXJuIHBhcmFtc1xuICB9XG59XG4iLCJleHBvcnQgaW50ZXJmYWNlIEdyb3VwIHtcbiAgcG9zOiBudW1iZXJcbiAgcmVwZWF0OiBib29sZWFuXG4gIG9wdGlvbmFsOiBib29sZWFuXG59XG5cbi8vIHRoaXMgaXNuJ3QgaW1wb3J0aW5nIHRoZSBlc2NhcGUtc3RyaW5nLXJlZ2V4IG1vZHVsZVxuLy8gdG8gcmVkdWNlIGJ5dGVzXG5mdW5jdGlvbiBlc2NhcGVSZWdleChzdHI6IHN0cmluZykge1xuICByZXR1cm4gc3RyLnJlcGxhY2UoL1t8XFxcXHt9KClbXFxdXiQrKj8uLV0vZywgJ1xcXFwkJicpXG59XG5cbmZ1bmN0aW9uIHBhcnNlUGFyYW1ldGVyKHBhcmFtOiBzdHJpbmcpIHtcbiAgY29uc3Qgb3B0aW9uYWwgPSBwYXJhbS5zdGFydHNXaXRoKCdbJykgJiYgcGFyYW0uZW5kc1dpdGgoJ10nKVxuICBpZiAob3B0aW9uYWwpIHtcbiAgICBwYXJhbSA9IHBhcmFtLnNsaWNlKDEsIC0xKVxuICB9XG4gIGNvbnN0IHJlcGVhdCA9IHBhcmFtLnN0YXJ0c1dpdGgoJy4uLicpXG4gIGlmIChyZXBlYXQpIHtcbiAgICBwYXJhbSA9IHBhcmFtLnNsaWNlKDMpXG4gIH1cbiAgcmV0dXJuIHsga2V5OiBwYXJhbSwgcmVwZWF0LCBvcHRpb25hbCB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRSb3V0ZVJlZ2V4KFxuICBub3JtYWxpemVkUm91dGU6IHN0cmluZ1xuKToge1xuICByZTogUmVnRXhwXG4gIG5hbWVkUmVnZXg/OiBzdHJpbmdcbiAgcm91dGVLZXlzPzogeyBbbmFtZWQ6IHN0cmluZ106IHN0cmluZyB9XG4gIGdyb3VwczogeyBbZ3JvdXBOYW1lOiBzdHJpbmddOiBHcm91cCB9XG59IHtcbiAgY29uc3Qgc2VnbWVudHMgPSAobm9ybWFsaXplZFJvdXRlLnJlcGxhY2UoL1xcLyQvLCAnJykgfHwgJy8nKVxuICAgIC5zbGljZSgxKVxuICAgIC5zcGxpdCgnLycpXG5cbiAgY29uc3QgZ3JvdXBzOiB7IFtncm91cE5hbWU6IHN0cmluZ106IEdyb3VwIH0gPSB7fVxuICBsZXQgZ3JvdXBJbmRleCA9IDFcbiAgY29uc3QgcGFyYW1ldGVyaXplZFJvdXRlID0gc2VnbWVudHNcbiAgICAubWFwKChzZWdtZW50KSA9PiB7XG4gICAgICBpZiAoc2VnbWVudC5zdGFydHNXaXRoKCdbJykgJiYgc2VnbWVudC5lbmRzV2l0aCgnXScpKSB7XG4gICAgICAgIGNvbnN0IHsga2V5LCBvcHRpb25hbCwgcmVwZWF0IH0gPSBwYXJzZVBhcmFtZXRlcihzZWdtZW50LnNsaWNlKDEsIC0xKSlcbiAgICAgICAgZ3JvdXBzW2tleV0gPSB7IHBvczogZ3JvdXBJbmRleCsrLCByZXBlYXQsIG9wdGlvbmFsIH1cbiAgICAgICAgcmV0dXJuIHJlcGVhdCA/IChvcHRpb25hbCA/ICcoPzovKC4rPykpPycgOiAnLyguKz8pJykgOiAnLyhbXi9dKz8pJ1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGAvJHtlc2NhcGVSZWdleChzZWdtZW50KX1gXG4gICAgICB9XG4gICAgfSlcbiAgICAuam9pbignJylcblxuICAvLyBkZWFkIGNvZGUgZWxpbWluYXRlIGZvciBicm93c2VyIHNpbmNlIGl0J3Mgb25seSBuZWVkZWRcbiAgLy8gd2hpbGUgZ2VuZXJhdGluZyByb3V0ZXMtbWFuaWZlc3RcbiAgaWYgKHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgbGV0IHJvdXRlS2V5Q2hhckNvZGUgPSA5N1xuICAgIGxldCByb3V0ZUtleUNoYXJMZW5ndGggPSAxXG5cbiAgICAvLyBidWlsZHMgYSBtaW5pbWFsIHJvdXRlS2V5IHVzaW5nIG9ubHkgYS16IGFuZCBtaW5pbWFsIG51bWJlciBvZiBjaGFyYWN0ZXJzXG4gICAgY29uc3QgZ2V0U2FmZVJvdXRlS2V5ID0gKCkgPT4ge1xuICAgICAgbGV0IHJvdXRlS2V5ID0gJydcblxuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCByb3V0ZUtleUNoYXJMZW5ndGg7IGkrKykge1xuICAgICAgICByb3V0ZUtleSArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKHJvdXRlS2V5Q2hhckNvZGUpXG4gICAgICAgIHJvdXRlS2V5Q2hhckNvZGUrK1xuXG4gICAgICAgIGlmIChyb3V0ZUtleUNoYXJDb2RlID4gMTIyKSB7XG4gICAgICAgICAgcm91dGVLZXlDaGFyTGVuZ3RoKytcbiAgICAgICAgICByb3V0ZUtleUNoYXJDb2RlID0gOTdcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHJvdXRlS2V5XG4gICAgfVxuXG4gICAgY29uc3Qgcm91dGVLZXlzOiB7IFtuYW1lZDogc3RyaW5nXTogc3RyaW5nIH0gPSB7fVxuXG4gICAgbGV0IG5hbWVkUGFyYW1ldGVyaXplZFJvdXRlID0gc2VnbWVudHNcbiAgICAgIC5tYXAoKHNlZ21lbnQpID0+IHtcbiAgICAgICAgaWYgKHNlZ21lbnQuc3RhcnRzV2l0aCgnWycpICYmIHNlZ21lbnQuZW5kc1dpdGgoJ10nKSkge1xuICAgICAgICAgIGNvbnN0IHsga2V5LCBvcHRpb25hbCwgcmVwZWF0IH0gPSBwYXJzZVBhcmFtZXRlcihzZWdtZW50LnNsaWNlKDEsIC0xKSlcbiAgICAgICAgICAvLyByZXBsYWNlIGFueSBub24td29yZCBjaGFyYWN0ZXJzIHNpbmNlIHRoZXkgY2FuIGJyZWFrXG4gICAgICAgICAgLy8gdGhlIG5hbWVkIHJlZ2V4XG4gICAgICAgICAgbGV0IGNsZWFuZWRLZXkgPSBrZXkucmVwbGFjZSgvXFxXL2csICcnKVxuICAgICAgICAgIGxldCBpbnZhbGlkS2V5ID0gZmFsc2VcblxuICAgICAgICAgIC8vIGNoZWNrIGlmIHRoZSBrZXkgaXMgc3RpbGwgaW52YWxpZCBhbmQgZmFsbGJhY2sgdG8gdXNpbmcgYSBrbm93blxuICAgICAgICAgIC8vIHNhZmUga2V5XG4gICAgICAgICAgaWYgKGNsZWFuZWRLZXkubGVuZ3RoID09PSAwIHx8IGNsZWFuZWRLZXkubGVuZ3RoID4gMzApIHtcbiAgICAgICAgICAgIGludmFsaWRLZXkgPSB0cnVlXG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICghaXNOYU4ocGFyc2VJbnQoY2xlYW5lZEtleS5zdWJzdHIoMCwgMSkpKSkge1xuICAgICAgICAgICAgaW52YWxpZEtleSA9IHRydWVcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoaW52YWxpZEtleSkge1xuICAgICAgICAgICAgY2xlYW5lZEtleSA9IGdldFNhZmVSb3V0ZUtleSgpXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcm91dGVLZXlzW2NsZWFuZWRLZXldID0ga2V5XG4gICAgICAgICAgcmV0dXJuIHJlcGVhdFxuICAgICAgICAgICAgPyBvcHRpb25hbFxuICAgICAgICAgICAgICA/IGAoPzovKD88JHtjbGVhbmVkS2V5fT4uKz8pKT9gXG4gICAgICAgICAgICAgIDogYC8oPzwke2NsZWFuZWRLZXl9Pi4rPylgXG4gICAgICAgICAgICA6IGAvKD88JHtjbGVhbmVkS2V5fT5bXi9dKz8pYFxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiBgLyR7ZXNjYXBlUmVnZXgoc2VnbWVudCl9YFxuICAgICAgICB9XG4gICAgICB9KVxuICAgICAgLmpvaW4oJycpXG5cbiAgICByZXR1cm4ge1xuICAgICAgcmU6IG5ldyBSZWdFeHAoYF4ke3BhcmFtZXRlcml6ZWRSb3V0ZX0oPzovKT8kYCksXG4gICAgICBncm91cHMsXG4gICAgICByb3V0ZUtleXMsXG4gICAgICBuYW1lZFJlZ2V4OiBgXiR7bmFtZWRQYXJhbWV0ZXJpemVkUm91dGV9KD86Lyk/JGAsXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHtcbiAgICByZTogbmV3IFJlZ0V4cChgXiR7cGFyYW1ldGVyaXplZFJvdXRlfSg/Oi8pPyRgKSxcbiAgICBncm91cHMsXG4gIH1cbn1cbiIsImltcG9ydCBSZWFjdCwgeyBDb21wb25lbnQgfSBmcm9tICdyZWFjdCdcblxuY29uc3QgaXNTZXJ2ZXIgPSB0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJ1xuXG50eXBlIFN0YXRlID0gSlNYLkVsZW1lbnRbXSB8IHVuZGVmaW5lZFxuXG50eXBlIFNpZGVFZmZlY3RQcm9wcyA9IHtcbiAgcmVkdWNlQ29tcG9uZW50c1RvU3RhdGU6IDxUPihcbiAgICBjb21wb25lbnRzOiBBcnJheTxSZWFjdC5SZWFjdEVsZW1lbnQ8YW55Pj4sXG4gICAgcHJvcHM6IFRcbiAgKSA9PiBTdGF0ZVxuICBoYW5kbGVTdGF0ZUNoYW5nZT86IChzdGF0ZTogU3RhdGUpID0+IHZvaWRcbiAgaGVhZE1hbmFnZXI6IGFueVxuICBpbkFtcE1vZGU/OiBib29sZWFuXG59XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIGV4dGVuZHMgQ29tcG9uZW50PFNpZGVFZmZlY3RQcm9wcz4ge1xuICBwcml2YXRlIF9oYXNIZWFkTWFuYWdlcjogYm9vbGVhblxuXG4gIGVtaXRDaGFuZ2UgPSAoKTogdm9pZCA9PiB7XG4gICAgaWYgKHRoaXMuX2hhc0hlYWRNYW5hZ2VyKSB7XG4gICAgICB0aGlzLnByb3BzLmhlYWRNYW5hZ2VyLnVwZGF0ZUhlYWQoXG4gICAgICAgIHRoaXMucHJvcHMucmVkdWNlQ29tcG9uZW50c1RvU3RhdGUoXG4gICAgICAgICAgWy4uLnRoaXMucHJvcHMuaGVhZE1hbmFnZXIubW91bnRlZEluc3RhbmNlc10sXG4gICAgICAgICAgdGhpcy5wcm9wc1xuICAgICAgICApXG4gICAgICApXG4gICAgfVxuICB9XG5cbiAgY29uc3RydWN0b3IocHJvcHM6IGFueSkge1xuICAgIHN1cGVyKHByb3BzKVxuICAgIHRoaXMuX2hhc0hlYWRNYW5hZ2VyID1cbiAgICAgIHRoaXMucHJvcHMuaGVhZE1hbmFnZXIgJiYgdGhpcy5wcm9wcy5oZWFkTWFuYWdlci5tb3VudGVkSW5zdGFuY2VzXG5cbiAgICBpZiAoaXNTZXJ2ZXIgJiYgdGhpcy5faGFzSGVhZE1hbmFnZXIpIHtcbiAgICAgIHRoaXMucHJvcHMuaGVhZE1hbmFnZXIubW91bnRlZEluc3RhbmNlcy5hZGQodGhpcylcbiAgICAgIHRoaXMuZW1pdENoYW5nZSgpXG4gICAgfVxuICB9XG4gIGNvbXBvbmVudERpZE1vdW50KCkge1xuICAgIGlmICh0aGlzLl9oYXNIZWFkTWFuYWdlcikge1xuICAgICAgdGhpcy5wcm9wcy5oZWFkTWFuYWdlci5tb3VudGVkSW5zdGFuY2VzLmFkZCh0aGlzKVxuICAgIH1cbiAgICB0aGlzLmVtaXRDaGFuZ2UoKVxuICB9XG4gIGNvbXBvbmVudERpZFVwZGF0ZSgpIHtcbiAgICB0aGlzLmVtaXRDaGFuZ2UoKVxuICB9XG4gIGNvbXBvbmVudFdpbGxVbm1vdW50KCkge1xuICAgIGlmICh0aGlzLl9oYXNIZWFkTWFuYWdlcikge1xuICAgICAgdGhpcy5wcm9wcy5oZWFkTWFuYWdlci5tb3VudGVkSW5zdGFuY2VzLmRlbGV0ZSh0aGlzKVxuICAgIH1cbiAgICB0aGlzLmVtaXRDaGFuZ2UoKVxuICB9XG5cbiAgcmVuZGVyKCkge1xuICAgIHJldHVybiBudWxsXG4gIH1cbn1cbiIsImltcG9ydCB7IEluY29taW5nTWVzc2FnZSwgU2VydmVyUmVzcG9uc2UgfSBmcm9tICdodHRwJ1xuaW1wb3J0IHsgUGFyc2VkVXJsUXVlcnkgfSBmcm9tICdxdWVyeXN0cmluZydcbmltcG9ydCB7IENvbXBvbmVudFR5cGUgfSBmcm9tICdyZWFjdCdcbmltcG9ydCB7IFVybE9iamVjdCB9IGZyb20gJ3VybCdcbmltcG9ydCB7IGZvcm1hdFVybCB9IGZyb20gJy4vcm91dGVyL3V0aWxzL2Zvcm1hdC11cmwnXG5pbXBvcnQgeyBOZXh0Um91dGVyIH0gZnJvbSAnLi9yb3V0ZXIvcm91dGVyJ1xuaW1wb3J0IHsgRW52IH0gZnJvbSAnQG5leHQvZW52J1xuaW1wb3J0IHsgQnVpbGRNYW5pZmVzdCB9IGZyb20gJy4uL3NlcnZlci9nZXQtcGFnZS1maWxlcydcbmltcG9ydCB7IERvbWFpbkxvY2FsZXMgfSBmcm9tICcuLi9zZXJ2ZXIvY29uZmlnJ1xuaW1wb3J0IHsgUHJldmlld0RhdGEgfSBmcm9tICduZXh0L3R5cGVzJ1xuXG4vKipcbiAqIFR5cGVzIHVzZWQgYnkgYm90aCBuZXh0IGFuZCBuZXh0LXNlcnZlclxuICovXG5cbmV4cG9ydCB0eXBlIE5leHRDb21wb25lbnRUeXBlPFxuICBDIGV4dGVuZHMgQmFzZUNvbnRleHQgPSBOZXh0UGFnZUNvbnRleHQsXG4gIElQID0ge30sXG4gIFAgPSB7fVxuPiA9IENvbXBvbmVudFR5cGU8UD4gJiB7XG4gIC8qKlxuICAgKiBVc2VkIGZvciBpbml0aWFsIHBhZ2UgbG9hZCBkYXRhIHBvcHVsYXRpb24uIERhdGEgcmV0dXJuZWQgZnJvbSBgZ2V0SW5pdGlhbFByb3BzYCBpcyBzZXJpYWxpemVkIHdoZW4gc2VydmVyIHJlbmRlcmVkLlxuICAgKiBNYWtlIHN1cmUgdG8gcmV0dXJuIHBsYWluIGBPYmplY3RgIHdpdGhvdXQgdXNpbmcgYERhdGVgLCBgTWFwYCwgYFNldGAuXG4gICAqIEBwYXJhbSBjdHggQ29udGV4dCBvZiBgcGFnZWBcbiAgICovXG4gIGdldEluaXRpYWxQcm9wcz8oY29udGV4dDogQyk6IElQIHwgUHJvbWlzZTxJUD5cbn1cblxuZXhwb3J0IHR5cGUgRG9jdW1lbnRUeXBlID0gTmV4dENvbXBvbmVudFR5cGU8XG4gIERvY3VtZW50Q29udGV4dCxcbiAgRG9jdW1lbnRJbml0aWFsUHJvcHMsXG4gIERvY3VtZW50UHJvcHNcbj4gJiB7XG4gIHJlbmRlckRvY3VtZW50KFxuICAgIERvY3VtZW50OiBEb2N1bWVudFR5cGUsXG4gICAgcHJvcHM6IERvY3VtZW50UHJvcHNcbiAgKTogUmVhY3QuUmVhY3RFbGVtZW50XG59XG5cbmV4cG9ydCB0eXBlIEFwcFR5cGUgPSBOZXh0Q29tcG9uZW50VHlwZTxcbiAgQXBwQ29udGV4dFR5cGUsXG4gIEFwcEluaXRpYWxQcm9wcyxcbiAgQXBwUHJvcHNUeXBlXG4+XG5cbmV4cG9ydCB0eXBlIEFwcFRyZWVUeXBlID0gQ29tcG9uZW50VHlwZTxcbiAgQXBwSW5pdGlhbFByb3BzICYgeyBbbmFtZTogc3RyaW5nXTogYW55IH1cbj5cblxuLyoqXG4gKiBXZWIgdml0YWxzIHByb3ZpZGVkIHRvIF9hcHAucmVwb3J0V2ViVml0YWxzIGJ5IENvcmUgV2ViIFZpdGFscyBwbHVnaW4gZGV2ZWxvcGVkIGJ5IEdvb2dsZSBDaHJvbWUgdGVhbS5cbiAqIGh0dHBzOi8vbmV4dGpzLm9yZy9ibG9nL25leHQtOS00I2ludGVncmF0ZWQtd2ViLXZpdGFscy1yZXBvcnRpbmdcbiAqL1xuZXhwb3J0IHR5cGUgTmV4dFdlYlZpdGFsc01ldHJpYyA9IHtcbiAgaWQ6IHN0cmluZ1xuICBsYWJlbDogc3RyaW5nXG4gIG5hbWU6IHN0cmluZ1xuICBzdGFydFRpbWU6IG51bWJlclxuICB2YWx1ZTogbnVtYmVyXG59XG5cbmV4cG9ydCB0eXBlIEVuaGFuY2VyPEM+ID0gKENvbXBvbmVudDogQykgPT4gQ1xuXG5leHBvcnQgdHlwZSBDb21wb25lbnRzRW5oYW5jZXIgPVxuICB8IHtcbiAgICAgIGVuaGFuY2VBcHA/OiBFbmhhbmNlcjxBcHBUeXBlPlxuICAgICAgZW5oYW5jZUNvbXBvbmVudD86IEVuaGFuY2VyPE5leHRDb21wb25lbnRUeXBlPlxuICAgIH1cbiAgfCBFbmhhbmNlcjxOZXh0Q29tcG9uZW50VHlwZT5cblxuZXhwb3J0IHR5cGUgUmVuZGVyUGFnZVJlc3VsdCA9IHtcbiAgaHRtbDogc3RyaW5nXG4gIGhlYWQ/OiBBcnJheTxKU1guRWxlbWVudCB8IG51bGw+XG59XG5cbmV4cG9ydCB0eXBlIFJlbmRlclBhZ2UgPSAoXG4gIG9wdGlvbnM/OiBDb21wb25lbnRzRW5oYW5jZXJcbikgPT4gUmVuZGVyUGFnZVJlc3VsdCB8IFByb21pc2U8UmVuZGVyUGFnZVJlc3VsdD5cblxuZXhwb3J0IHR5cGUgQmFzZUNvbnRleHQgPSB7XG4gIHJlcz86IFNlcnZlclJlc3BvbnNlXG4gIFtrOiBzdHJpbmddOiBhbnlcbn1cblxuZXhwb3J0IHR5cGUgTkVYVF9EQVRBID0ge1xuICBwcm9wczogUmVjb3JkPHN0cmluZywgYW55PlxuICBwYWdlOiBzdHJpbmdcbiAgcXVlcnk6IFBhcnNlZFVybFF1ZXJ5XG4gIGJ1aWxkSWQ6IHN0cmluZ1xuICBhc3NldFByZWZpeD86IHN0cmluZ1xuICBydW50aW1lQ29uZmlnPzogeyBba2V5OiBzdHJpbmddOiBhbnkgfVxuICBuZXh0RXhwb3J0PzogYm9vbGVhblxuICBhdXRvRXhwb3J0PzogYm9vbGVhblxuICBpc0ZhbGxiYWNrPzogYm9vbGVhblxuICBkeW5hbWljSWRzPzogKHN0cmluZyB8IG51bWJlcilbXVxuICBlcnI/OiBFcnJvciAmIHsgc3RhdHVzQ29kZT86IG51bWJlciB9XG4gIGdzcD86IGJvb2xlYW5cbiAgZ3NzcD86IGJvb2xlYW5cbiAgY3VzdG9tU2VydmVyPzogYm9vbGVhblxuICBnaXA/OiBib29sZWFuXG4gIGFwcEdpcD86IGJvb2xlYW5cbiAgbG9jYWxlPzogc3RyaW5nXG4gIGxvY2FsZXM/OiBzdHJpbmdbXVxuICBkZWZhdWx0TG9jYWxlPzogc3RyaW5nXG4gIGRvbWFpbkxvY2FsZXM/OiBEb21haW5Mb2NhbGVzXG4gIHNjcmlwdExvYWRlcj86IGFueVtdXG4gIGlzUHJldmlldz86IGJvb2xlYW5cbn1cblxuLyoqXG4gKiBgTmV4dGAgY29udGV4dFxuICovXG5leHBvcnQgaW50ZXJmYWNlIE5leHRQYWdlQ29udGV4dCB7XG4gIC8qKlxuICAgKiBFcnJvciBvYmplY3QgaWYgZW5jb3VudGVyZWQgZHVyaW5nIHJlbmRlcmluZ1xuICAgKi9cbiAgZXJyPzogKEVycm9yICYgeyBzdGF0dXNDb2RlPzogbnVtYmVyIH0pIHwgbnVsbFxuICAvKipcbiAgICogYEhUVFBgIHJlcXVlc3Qgb2JqZWN0LlxuICAgKi9cbiAgcmVxPzogSW5jb21pbmdNZXNzYWdlXG4gIC8qKlxuICAgKiBgSFRUUGAgcmVzcG9uc2Ugb2JqZWN0LlxuICAgKi9cbiAgcmVzPzogU2VydmVyUmVzcG9uc2VcbiAgLyoqXG4gICAqIFBhdGggc2VjdGlvbiBvZiBgVVJMYC5cbiAgICovXG4gIHBhdGhuYW1lOiBzdHJpbmdcbiAgLyoqXG4gICAqIFF1ZXJ5IHN0cmluZyBzZWN0aW9uIG9mIGBVUkxgIHBhcnNlZCBhcyBhbiBvYmplY3QuXG4gICAqL1xuICBxdWVyeTogUGFyc2VkVXJsUXVlcnlcbiAgLyoqXG4gICAqIGBTdHJpbmdgIG9mIHRoZSBhY3R1YWwgcGF0aCBpbmNsdWRpbmcgcXVlcnkuXG4gICAqL1xuICBhc1BhdGg/OiBzdHJpbmdcbiAgLyoqXG4gICAqIFRoZSBjdXJyZW50bHkgYWN0aXZlIGxvY2FsZVxuICAgKi9cbiAgbG9jYWxlPzogc3RyaW5nXG4gIC8qKlxuICAgKiBBbGwgY29uZmlndXJlZCBsb2NhbGVzXG4gICAqL1xuICBsb2NhbGVzPzogc3RyaW5nW11cbiAgLyoqXG4gICAqIFRoZSBjb25maWd1cmVkIGRlZmF1bHQgbG9jYWxlXG4gICAqL1xuICBkZWZhdWx0TG9jYWxlPzogc3RyaW5nXG4gIC8qKlxuICAgKiBgQ29tcG9uZW50YCB0aGUgdHJlZSBvZiB0aGUgQXBwIHRvIHVzZSBpZiBuZWVkaW5nIHRvIHJlbmRlciBzZXBhcmF0ZWx5XG4gICAqL1xuICBBcHBUcmVlOiBBcHBUcmVlVHlwZVxufVxuXG5leHBvcnQgdHlwZSBBcHBDb250ZXh0VHlwZTxSIGV4dGVuZHMgTmV4dFJvdXRlciA9IE5leHRSb3V0ZXI+ID0ge1xuICBDb21wb25lbnQ6IE5leHRDb21wb25lbnRUeXBlPE5leHRQYWdlQ29udGV4dD5cbiAgQXBwVHJlZTogQXBwVHJlZVR5cGVcbiAgY3R4OiBOZXh0UGFnZUNvbnRleHRcbiAgcm91dGVyOiBSXG59XG5cbmV4cG9ydCB0eXBlIEFwcEluaXRpYWxQcm9wcyA9IHtcbiAgcGFnZVByb3BzOiBhbnlcbn1cblxuZXhwb3J0IHR5cGUgQXBwUHJvcHNUeXBlPFxuICBSIGV4dGVuZHMgTmV4dFJvdXRlciA9IE5leHRSb3V0ZXIsXG4gIFAgPSB7fVxuPiA9IEFwcEluaXRpYWxQcm9wcyAmIHtcbiAgQ29tcG9uZW50OiBOZXh0Q29tcG9uZW50VHlwZTxOZXh0UGFnZUNvbnRleHQsIGFueSwgUD5cbiAgcm91dGVyOiBSXG4gIF9fTl9TU0c/OiBib29sZWFuXG4gIF9fTl9TU1A/OiBib29sZWFuXG59XG5cbmV4cG9ydCB0eXBlIERvY3VtZW50Q29udGV4dCA9IE5leHRQYWdlQ29udGV4dCAmIHtcbiAgcmVuZGVyUGFnZTogUmVuZGVyUGFnZVxufVxuXG5leHBvcnQgdHlwZSBEb2N1bWVudEluaXRpYWxQcm9wcyA9IFJlbmRlclBhZ2VSZXN1bHQgJiB7XG4gIHN0eWxlcz86IFJlYWN0LlJlYWN0RWxlbWVudFtdIHwgUmVhY3QuUmVhY3RGcmFnbWVudFxufVxuXG5leHBvcnQgdHlwZSBEb2N1bWVudFByb3BzID0gRG9jdW1lbnRJbml0aWFsUHJvcHMgJiB7XG4gIF9fTkVYVF9EQVRBX186IE5FWFRfREFUQVxuICBkYW5nZXJvdXNBc1BhdGg6IHN0cmluZ1xuICBkb2NDb21wb25lbnRzUmVuZGVyZWQ6IHtcbiAgICBIdG1sPzogYm9vbGVhblxuICAgIE1haW4/OiBib29sZWFuXG4gICAgSGVhZD86IGJvb2xlYW5cbiAgICBOZXh0U2NyaXB0PzogYm9vbGVhblxuICB9XG4gIGJ1aWxkTWFuaWZlc3Q6IEJ1aWxkTWFuaWZlc3RcbiAgYW1wUGF0aDogc3RyaW5nXG4gIGluQW1wTW9kZTogYm9vbGVhblxuICBoeWJyaWRBbXA6IGJvb2xlYW5cbiAgaXNEZXZlbG9wbWVudDogYm9vbGVhblxuICBkeW5hbWljSW1wb3J0czogc3RyaW5nW11cbiAgYXNzZXRQcmVmaXg/OiBzdHJpbmdcbiAgY2Fub25pY2FsQmFzZTogc3RyaW5nXG4gIGhlYWRUYWdzOiBhbnlbXVxuICB1bnN0YWJsZV9ydW50aW1lSlM/OiBmYWxzZVxuICB1bnN0YWJsZV9Kc1ByZWxvYWQ/OiBmYWxzZVxuICBkZXZPbmx5Q2FjaGVCdXN0ZXJRdWVyeVN0cmluZzogc3RyaW5nXG4gIHNjcmlwdExvYWRlcjogeyBhZnRlckludGVyYWN0aXZlPzogc3RyaW5nW107IGJlZm9yZUludGVyYWN0aXZlPzogYW55W10gfVxuICBsb2NhbGU/OiBzdHJpbmdcbiAgZGlzYWJsZU9wdGltaXplZExvYWRpbmc/OiBib29sZWFuXG59XG5cbi8qKlxuICogTmV4dCBgQVBJYCByb3V0ZSByZXF1ZXN0XG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgTmV4dEFwaVJlcXVlc3QgZXh0ZW5kcyBJbmNvbWluZ01lc3NhZ2Uge1xuICAvKipcbiAgICogT2JqZWN0IG9mIGBxdWVyeWAgdmFsdWVzIGZyb20gdXJsXG4gICAqL1xuICBxdWVyeToge1xuICAgIFtrZXk6IHN0cmluZ106IHN0cmluZyB8IHN0cmluZ1tdXG4gIH1cbiAgLyoqXG4gICAqIE9iamVjdCBvZiBgY29va2llc2AgZnJvbSBoZWFkZXJcbiAgICovXG4gIGNvb2tpZXM6IHtcbiAgICBba2V5OiBzdHJpbmddOiBzdHJpbmdcbiAgfVxuXG4gIGJvZHk6IGFueVxuXG4gIGVudjogRW52XG5cbiAgcHJldmlldz86IGJvb2xlYW5cbiAgLyoqXG4gICAqIFByZXZpZXcgZGF0YSBzZXQgb24gdGhlIHJlcXVlc3QsIGlmIGFueVxuICAgKiAqL1xuICBwcmV2aWV3RGF0YT86IFByZXZpZXdEYXRhXG59XG5cbi8qKlxuICogU2VuZCBib2R5IG9mIHJlc3BvbnNlXG4gKi9cbnR5cGUgU2VuZDxUPiA9IChib2R5OiBUKSA9PiB2b2lkXG5cbi8qKlxuICogTmV4dCBgQVBJYCByb3V0ZSByZXNwb25zZVxuICovXG5leHBvcnQgdHlwZSBOZXh0QXBpUmVzcG9uc2U8VCA9IGFueT4gPSBTZXJ2ZXJSZXNwb25zZSAmIHtcbiAgLyoqXG4gICAqIFNlbmQgZGF0YSBgYW55YCBkYXRhIGluIHJlc3BvbnNlXG4gICAqL1xuICBzZW5kOiBTZW5kPFQ+XG4gIC8qKlxuICAgKiBTZW5kIGRhdGEgYGpzb25gIGRhdGEgaW4gcmVzcG9uc2VcbiAgICovXG4gIGpzb246IFNlbmQ8VD5cbiAgc3RhdHVzOiAoc3RhdHVzQ29kZTogbnVtYmVyKSA9PiBOZXh0QXBpUmVzcG9uc2U8VD5cbiAgcmVkaXJlY3QodXJsOiBzdHJpbmcpOiBOZXh0QXBpUmVzcG9uc2U8VD5cbiAgcmVkaXJlY3Qoc3RhdHVzOiBudW1iZXIsIHVybDogc3RyaW5nKTogTmV4dEFwaVJlc3BvbnNlPFQ+XG5cbiAgLyoqXG4gICAqIFNldCBwcmV2aWV3IGRhdGEgZm9yIE5leHQuanMnIHByZXJlbmRlciBtb2RlXG4gICAqL1xuICBzZXRQcmV2aWV3RGF0YTogKFxuICAgIGRhdGE6IG9iamVjdCB8IHN0cmluZyxcbiAgICBvcHRpb25zPzoge1xuICAgICAgLyoqXG4gICAgICAgKiBTcGVjaWZpZXMgdGhlIG51bWJlciAoaW4gc2Vjb25kcykgZm9yIHRoZSBwcmV2aWV3IHNlc3Npb24gdG8gbGFzdCBmb3IuXG4gICAgICAgKiBUaGUgZ2l2ZW4gbnVtYmVyIHdpbGwgYmUgY29udmVydGVkIHRvIGFuIGludGVnZXIgYnkgcm91bmRpbmcgZG93bi5cbiAgICAgICAqIEJ5IGRlZmF1bHQsIG5vIG1heGltdW0gYWdlIGlzIHNldCBhbmQgdGhlIHByZXZpZXcgc2Vzc2lvbiBmaW5pc2hlc1xuICAgICAgICogd2hlbiB0aGUgY2xpZW50IHNodXRzIGRvd24gKGJyb3dzZXIgaXMgY2xvc2VkKS5cbiAgICAgICAqL1xuICAgICAgbWF4QWdlPzogbnVtYmVyXG4gICAgfVxuICApID0+IE5leHRBcGlSZXNwb25zZTxUPlxuICBjbGVhclByZXZpZXdEYXRhOiAoKSA9PiBOZXh0QXBpUmVzcG9uc2U8VD5cbn1cblxuLyoqXG4gKiBOZXh0IGBBUElgIHJvdXRlIGhhbmRsZXJcbiAqL1xuZXhwb3J0IHR5cGUgTmV4dEFwaUhhbmRsZXI8VCA9IGFueT4gPSAoXG4gIHJlcTogTmV4dEFwaVJlcXVlc3QsXG4gIHJlczogTmV4dEFwaVJlc3BvbnNlPFQ+XG4pID0+IHZvaWQgfCBQcm9taXNlPHZvaWQ+XG5cbi8qKlxuICogVXRpbHNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGV4ZWNPbmNlPFQgZXh0ZW5kcyAoLi4uYXJnczogYW55W10pID0+IFJldHVyblR5cGU8VD4+KFxuICBmbjogVFxuKTogVCB7XG4gIGxldCB1c2VkID0gZmFsc2VcbiAgbGV0IHJlc3VsdDogUmV0dXJuVHlwZTxUPlxuXG4gIHJldHVybiAoKC4uLmFyZ3M6IGFueVtdKSA9PiB7XG4gICAgaWYgKCF1c2VkKSB7XG4gICAgICB1c2VkID0gdHJ1ZVxuICAgICAgcmVzdWx0ID0gZm4oLi4uYXJncylcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdFxuICB9KSBhcyBUXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRMb2NhdGlvbk9yaWdpbigpIHtcbiAgY29uc3QgeyBwcm90b2NvbCwgaG9zdG5hbWUsIHBvcnQgfSA9IHdpbmRvdy5sb2NhdGlvblxuICByZXR1cm4gYCR7cHJvdG9jb2x9Ly8ke2hvc3RuYW1lfSR7cG9ydCA/ICc6JyArIHBvcnQgOiAnJ31gXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRVUkwoKSB7XG4gIGNvbnN0IHsgaHJlZiB9ID0gd2luZG93LmxvY2F0aW9uXG4gIGNvbnN0IG9yaWdpbiA9IGdldExvY2F0aW9uT3JpZ2luKClcbiAgcmV0dXJuIGhyZWYuc3Vic3RyaW5nKG9yaWdpbi5sZW5ndGgpXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXREaXNwbGF5TmFtZTxQPihDb21wb25lbnQ6IENvbXBvbmVudFR5cGU8UD4pIHtcbiAgcmV0dXJuIHR5cGVvZiBDb21wb25lbnQgPT09ICdzdHJpbmcnXG4gICAgPyBDb21wb25lbnRcbiAgICA6IENvbXBvbmVudC5kaXNwbGF5TmFtZSB8fCBDb21wb25lbnQubmFtZSB8fCAnVW5rbm93bidcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGlzUmVzU2VudChyZXM6IFNlcnZlclJlc3BvbnNlKSB7XG4gIHJldHVybiByZXMuZmluaXNoZWQgfHwgcmVzLmhlYWRlcnNTZW50XG59XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBsb2FkR2V0SW5pdGlhbFByb3BzPFxuICBDIGV4dGVuZHMgQmFzZUNvbnRleHQsXG4gIElQID0ge30sXG4gIFAgPSB7fVxuPihBcHA6IE5leHRDb21wb25lbnRUeXBlPEMsIElQLCBQPiwgY3R4OiBDKTogUHJvbWlzZTxJUD4ge1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIGlmIChBcHAucHJvdG90eXBlPy5nZXRJbml0aWFsUHJvcHMpIHtcbiAgICAgIGNvbnN0IG1lc3NhZ2UgPSBgXCIke2dldERpc3BsYXlOYW1lKFxuICAgICAgICBBcHBcbiAgICAgICl9LmdldEluaXRpYWxQcm9wcygpXCIgaXMgZGVmaW5lZCBhcyBhbiBpbnN0YW5jZSBtZXRob2QgLSB2aXNpdCBodHRwczovL25leHRqcy5vcmcvZG9jcy9tZXNzYWdlcy9nZXQtaW5pdGlhbC1wcm9wcy1hcy1hbi1pbnN0YW5jZS1tZXRob2QgZm9yIG1vcmUgaW5mb3JtYXRpb24uYFxuICAgICAgdGhyb3cgbmV3IEVycm9yKG1lc3NhZ2UpXG4gICAgfVxuICB9XG4gIC8vIHdoZW4gY2FsbGVkIGZyb20gX2FwcCBgY3R4YCBpcyBuZXN0ZWQgaW4gYGN0eGBcbiAgY29uc3QgcmVzID0gY3R4LnJlcyB8fCAoY3R4LmN0eCAmJiBjdHguY3R4LnJlcylcblxuICBpZiAoIUFwcC5nZXRJbml0aWFsUHJvcHMpIHtcbiAgICBpZiAoY3R4LmN0eCAmJiBjdHguQ29tcG9uZW50KSB7XG4gICAgICAvLyBAdHMtaWdub3JlIHBhZ2VQcm9wcyBkZWZhdWx0XG4gICAgICByZXR1cm4ge1xuICAgICAgICBwYWdlUHJvcHM6IGF3YWl0IGxvYWRHZXRJbml0aWFsUHJvcHMoY3R4LkNvbXBvbmVudCwgY3R4LmN0eCksXG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB7fSBhcyBJUFxuICB9XG5cbiAgY29uc3QgcHJvcHMgPSBhd2FpdCBBcHAuZ2V0SW5pdGlhbFByb3BzKGN0eClcblxuICBpZiAocmVzICYmIGlzUmVzU2VudChyZXMpKSB7XG4gICAgcmV0dXJuIHByb3BzXG4gIH1cblxuICBpZiAoIXByb3BzKSB7XG4gICAgY29uc3QgbWVzc2FnZSA9IGBcIiR7Z2V0RGlzcGxheU5hbWUoXG4gICAgICBBcHBcbiAgICApfS5nZXRJbml0aWFsUHJvcHMoKVwiIHNob3VsZCByZXNvbHZlIHRvIGFuIG9iamVjdC4gQnV0IGZvdW5kIFwiJHtwcm9wc31cIiBpbnN0ZWFkLmBcbiAgICB0aHJvdyBuZXcgRXJyb3IobWVzc2FnZSlcbiAgfVxuXG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgaWYgKE9iamVjdC5rZXlzKHByb3BzKS5sZW5ndGggPT09IDAgJiYgIWN0eC5jdHgpIHtcbiAgICAgIGNvbnNvbGUud2FybihcbiAgICAgICAgYCR7Z2V0RGlzcGxheU5hbWUoXG4gICAgICAgICAgQXBwXG4gICAgICAgICl9IHJldHVybmVkIGFuIGVtcHR5IG9iamVjdCBmcm9tIFxcYGdldEluaXRpYWxQcm9wc1xcYC4gVGhpcyBkZS1vcHRpbWl6ZXMgYW5kIHByZXZlbnRzIGF1dG9tYXRpYyBzdGF0aWMgb3B0aW1pemF0aW9uLiBodHRwczovL25leHRqcy5vcmcvZG9jcy9tZXNzYWdlcy9lbXB0eS1vYmplY3QtZ2V0SW5pdGlhbFByb3BzYFxuICAgICAgKVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBwcm9wc1xufVxuXG5leHBvcnQgY29uc3QgdXJsT2JqZWN0S2V5cyA9IFtcbiAgJ2F1dGgnLFxuICAnaGFzaCcsXG4gICdob3N0JyxcbiAgJ2hvc3RuYW1lJyxcbiAgJ2hyZWYnLFxuICAncGF0aCcsXG4gICdwYXRobmFtZScsXG4gICdwb3J0JyxcbiAgJ3Byb3RvY29sJyxcbiAgJ3F1ZXJ5JyxcbiAgJ3NlYXJjaCcsXG4gICdzbGFzaGVzJyxcbl1cblxuZXhwb3J0IGZ1bmN0aW9uIGZvcm1hdFdpdGhWYWxpZGF0aW9uKHVybDogVXJsT2JqZWN0KTogc3RyaW5nIHtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAnZGV2ZWxvcG1lbnQnKSB7XG4gICAgaWYgKHVybCAhPT0gbnVsbCAmJiB0eXBlb2YgdXJsID09PSAnb2JqZWN0Jykge1xuICAgICAgT2JqZWN0LmtleXModXJsKS5mb3JFYWNoKChrZXkpID0+IHtcbiAgICAgICAgaWYgKHVybE9iamVjdEtleXMuaW5kZXhPZihrZXkpID09PSAtMSkge1xuICAgICAgICAgIGNvbnNvbGUud2FybihcbiAgICAgICAgICAgIGBVbmtub3duIGtleSBwYXNzZWQgdmlhIHVybE9iamVjdCBpbnRvIHVybC5mb3JtYXQ6ICR7a2V5fWBcbiAgICAgICAgICApXG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZvcm1hdFVybCh1cmwpXG59XG5cbmV4cG9ydCBjb25zdCBTUCA9IHR5cGVvZiBwZXJmb3JtYW5jZSAhPT0gJ3VuZGVmaW5lZCdcbmV4cG9ydCBjb25zdCBTVCA9XG4gIFNQICYmXG4gIHR5cGVvZiBwZXJmb3JtYW5jZS5tYXJrID09PSAnZnVuY3Rpb24nICYmXG4gIHR5cGVvZiBwZXJmb3JtYW5jZS5tZWFzdXJlID09PSAnZnVuY3Rpb24nXG4iLCJcInVzZSBzdHJpY3RcIjtleHBvcnRzLl9fZXNNb2R1bGU9dHJ1ZTtleHBvcnRzLm5vcm1hbGl6ZVBhdGhTZXA9bm9ybWFsaXplUGF0aFNlcDtleHBvcnRzLmRlbm9ybWFsaXplUGFnZVBhdGg9ZGVub3JtYWxpemVQYWdlUGF0aDtmdW5jdGlvbiBub3JtYWxpemVQYXRoU2VwKHBhdGgpe3JldHVybiBwYXRoLnJlcGxhY2UoL1xcXFwvZywnLycpO31mdW5jdGlvbiBkZW5vcm1hbGl6ZVBhZ2VQYXRoKHBhZ2Upe3BhZ2U9bm9ybWFsaXplUGF0aFNlcChwYWdlKTtpZihwYWdlLnN0YXJ0c1dpdGgoJy9pbmRleC8nKSl7cGFnZT1wYWdlLnNsaWNlKDYpO31lbHNlIGlmKHBhZ2U9PT0nL2luZGV4Jyl7cGFnZT0nLyc7fXJldHVybiBwYWdlO31cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRlbm9ybWFsaXplLXBhZ2UtcGF0aC5qcy5tYXAiLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vZGlzdC9uZXh0LXNlcnZlci9saWIvaGVhZCcpXG4iLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vZGlzdC9jbGllbnQvbGluaycpXG4iLCJpbXBvcnR7dXNlU3RhdGUgYXMgbix1c2VSZWR1Y2VyIGFzIHQsdXNlRWZmZWN0IGFzIGUsdXNlTGF5b3V0RWZmZWN0IGFzIHIsdXNlUmVmIGFzIHUsdXNlSW1wZXJhdGl2ZUhhbmRsZSBhcyBvLHVzZU1lbW8gYXMgaSx1c2VDYWxsYmFjayBhcyBsLHVzZUNvbnRleHQgYXMgZix1c2VEZWJ1Z1ZhbHVlIGFzIGN9ZnJvbVwicHJlYWN0L2hvb2tzXCI7ZXhwb3J0KmZyb21cInByZWFjdC9ob29rc1wiO2ltcG9ydHtDb21wb25lbnQgYXMgYSxjcmVhdGVFbGVtZW50IGFzIHMsb3B0aW9ucyBhcyBoLHRvQ2hpbGRBcnJheSBhcyBwLEZyYWdtZW50IGFzIHYscmVuZGVyIGFzIGQsaHlkcmF0ZSBhcyBtLGNsb25lRWxlbWVudCBhcyB5LGNyZWF0ZVJlZiBhcyBiLGNyZWF0ZUNvbnRleHQgYXMgX31mcm9tXCJwcmVhY3RcIjtleHBvcnR7Y3JlYXRlRWxlbWVudCxjcmVhdGVDb250ZXh0LGNyZWF0ZVJlZixGcmFnbWVudCxDb21wb25lbnR9ZnJvbVwicHJlYWN0XCI7ZnVuY3Rpb24gQyhuLHQpe2Zvcih2YXIgZSBpbiB0KW5bZV09dFtlXTtyZXR1cm4gbn1mdW5jdGlvbiBTKG4sdCl7Zm9yKHZhciBlIGluIG4paWYoXCJfX3NvdXJjZVwiIT09ZSYmIShlIGluIHQpKXJldHVybiEwO2Zvcih2YXIgciBpbiB0KWlmKFwiX19zb3VyY2VcIiE9PXImJm5bcl0hPT10W3JdKXJldHVybiEwO3JldHVybiExfWZ1bmN0aW9uIEUobil7dGhpcy5wcm9wcz1ufWZ1bmN0aW9uIGcobix0KXtmdW5jdGlvbiBlKG4pe3ZhciBlPXRoaXMucHJvcHMucmVmLHI9ZT09bi5yZWY7cmV0dXJuIXImJmUmJihlLmNhbGw/ZShudWxsKTplLmN1cnJlbnQ9bnVsbCksdD8hdCh0aGlzLnByb3BzLG4pfHwhcjpTKHRoaXMucHJvcHMsbil9ZnVuY3Rpb24gcih0KXtyZXR1cm4gdGhpcy5zaG91bGRDb21wb25lbnRVcGRhdGU9ZSxzKG4sdCl9cmV0dXJuIHIuZGlzcGxheU5hbWU9XCJNZW1vKFwiKyhuLmRpc3BsYXlOYW1lfHxuLm5hbWUpK1wiKVwiLHIucHJvdG90eXBlLmlzUmVhY3RDb21wb25lbnQ9ITAsci5fX2Y9ITAscn0oRS5wcm90b3R5cGU9bmV3IGEpLmlzUHVyZVJlYWN0Q29tcG9uZW50PSEwLEUucHJvdG90eXBlLnNob3VsZENvbXBvbmVudFVwZGF0ZT1mdW5jdGlvbihuLHQpe3JldHVybiBTKHRoaXMucHJvcHMsbil8fFModGhpcy5zdGF0ZSx0KX07dmFyIHc9aC5fX2I7aC5fX2I9ZnVuY3Rpb24obil7bi50eXBlJiZuLnR5cGUuX19mJiZuLnJlZiYmKG4ucHJvcHMucmVmPW4ucmVmLG4ucmVmPW51bGwpLHcmJncobil9O3ZhciBSPVwidW5kZWZpbmVkXCIhPXR5cGVvZiBTeW1ib2wmJlN5bWJvbC5mb3ImJlN5bWJvbC5mb3IoXCJyZWFjdC5mb3J3YXJkX3JlZlwiKXx8MzkxMTtmdW5jdGlvbiB4KG4pe2Z1bmN0aW9uIHQodCxlKXt2YXIgcj1DKHt9LHQpO3JldHVybiBkZWxldGUgci5yZWYsbihyLChlPXQucmVmfHxlKSYmKFwib2JqZWN0XCIhPXR5cGVvZiBlfHxcImN1cnJlbnRcImluIGUpP2U6bnVsbCl9cmV0dXJuIHQuJCR0eXBlb2Y9Uix0LnJlbmRlcj10LHQucHJvdG90eXBlLmlzUmVhY3RDb21wb25lbnQ9dC5fX2Y9ITAsdC5kaXNwbGF5TmFtZT1cIkZvcndhcmRSZWYoXCIrKG4uZGlzcGxheU5hbWV8fG4ubmFtZSkrXCIpXCIsdH12YXIgTj1mdW5jdGlvbihuLHQpe3JldHVybiBudWxsPT1uP251bGw6cChwKG4pLm1hcCh0KSl9LGs9e21hcDpOLGZvckVhY2g6Tixjb3VudDpmdW5jdGlvbihuKXtyZXR1cm4gbj9wKG4pLmxlbmd0aDowfSxvbmx5OmZ1bmN0aW9uKG4pe3ZhciB0PXAobik7aWYoMSE9PXQubGVuZ3RoKXRocm93XCJDaGlsZHJlbi5vbmx5XCI7cmV0dXJuIHRbMF19LHRvQXJyYXk6cH0sQT1oLl9fZTtoLl9fZT1mdW5jdGlvbihuLHQsZSl7aWYobi50aGVuKWZvcih2YXIgcix1PXQ7dT11Ll9fOylpZigocj11Ll9fYykmJnIuX19jKXJldHVybiBudWxsPT10Ll9fZSYmKHQuX19lPWUuX19lLHQuX19rPWUuX19rKSxyLl9fYyhuLHQpO0Eobix0LGUpfTt2YXIgTz1oLnVubW91bnQ7ZnVuY3Rpb24gTCgpe3RoaXMuX191PTAsdGhpcy50PW51bGwsdGhpcy5fX2I9bnVsbH1mdW5jdGlvbiBVKG4pe3ZhciB0PW4uX18uX19jO3JldHVybiB0JiZ0Ll9fZSYmdC5fX2Uobil9ZnVuY3Rpb24gRChuKXt2YXIgdCxlLHI7ZnVuY3Rpb24gdSh1KXtpZih0fHwodD1uKCkpLnRoZW4oZnVuY3Rpb24obil7ZT1uLmRlZmF1bHR8fG59LGZ1bmN0aW9uKG4pe3I9bn0pLHIpdGhyb3cgcjtpZighZSl0aHJvdyB0O3JldHVybiBzKGUsdSl9cmV0dXJuIHUuZGlzcGxheU5hbWU9XCJMYXp5XCIsdS5fX2Y9ITAsdX1mdW5jdGlvbiBGKCl7dGhpcy51PW51bGwsdGhpcy5vPW51bGx9aC51bm1vdW50PWZ1bmN0aW9uKG4pe3ZhciB0PW4uX19jO3QmJnQuX19SJiZ0Ll9fUigpLHQmJiEwPT09bi5fX2gmJihuLnR5cGU9bnVsbCksTyYmTyhuKX0sKEwucHJvdG90eXBlPW5ldyBhKS5fX2M9ZnVuY3Rpb24obix0KXt2YXIgZT10Ll9fYyxyPXRoaXM7bnVsbD09ci50JiYoci50PVtdKSxyLnQucHVzaChlKTt2YXIgdT1VKHIuX192KSxvPSExLGk9ZnVuY3Rpb24oKXtvfHwobz0hMCxlLl9fUj1udWxsLHU/dShsKTpsKCkpfTtlLl9fUj1pO3ZhciBsPWZ1bmN0aW9uKCl7aWYoIS0tci5fX3Upe2lmKHIuc3RhdGUuX19lKXt2YXIgbj1yLnN0YXRlLl9fZTtyLl9fdi5fX2tbMF09ZnVuY3Rpb24gbih0LGUscil7cmV0dXJuIHQmJih0Ll9fdj1udWxsLHQuX19rPXQuX19rJiZ0Ll9fay5tYXAoZnVuY3Rpb24odCl7cmV0dXJuIG4odCxlLHIpfSksdC5fX2MmJnQuX19jLl9fUD09PWUmJih0Ll9fZSYmci5pbnNlcnRCZWZvcmUodC5fX2UsdC5fX2QpLHQuX19jLl9fZT0hMCx0Ll9fYy5fX1A9cikpLHR9KG4sbi5fX2MuX19QLG4uX19jLl9fTyl9dmFyIHQ7Zm9yKHIuc2V0U3RhdGUoe19fZTpyLl9fYj1udWxsfSk7dD1yLnQucG9wKCk7KXQuZm9yY2VVcGRhdGUoKX19LGY9ITA9PT10Ll9faDtyLl9fdSsrfHxmfHxyLnNldFN0YXRlKHtfX2U6ci5fX2I9ci5fX3YuX19rWzBdfSksbi50aGVuKGksaSl9LEwucHJvdG90eXBlLmNvbXBvbmVudFdpbGxVbm1vdW50PWZ1bmN0aW9uKCl7dGhpcy50PVtdfSxMLnByb3RvdHlwZS5yZW5kZXI9ZnVuY3Rpb24obix0KXtpZih0aGlzLl9fYil7aWYodGhpcy5fX3YuX19rKXt2YXIgZT1kb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpLHI9dGhpcy5fX3YuX19rWzBdLl9fYzt0aGlzLl9fdi5fX2tbMF09ZnVuY3Rpb24gbih0LGUscil7cmV0dXJuIHQmJih0Ll9fYyYmdC5fX2MuX19IJiYodC5fX2MuX19ILl9fLmZvckVhY2goZnVuY3Rpb24obil7XCJmdW5jdGlvblwiPT10eXBlb2Ygbi5fX2MmJm4uX19jKCl9KSx0Ll9fYy5fX0g9bnVsbCksbnVsbCE9KHQ9Qyh7fSx0KSkuX19jJiYodC5fX2MuX19QPT09ciYmKHQuX19jLl9fUD1lKSx0Ll9fYz1udWxsKSx0Ll9faz10Ll9fayYmdC5fX2subWFwKGZ1bmN0aW9uKHQpe3JldHVybiBuKHQsZSxyKX0pKSx0fSh0aGlzLl9fYixlLHIuX19PPXIuX19QKX10aGlzLl9fYj1udWxsfXZhciB1PXQuX19lJiZzKHYsbnVsbCxuLmZhbGxiYWNrKTtyZXR1cm4gdSYmKHUuX19oPW51bGwpLFtzKHYsbnVsbCx0Ll9fZT9udWxsOm4uY2hpbGRyZW4pLHVdfTt2YXIgTT1mdW5jdGlvbihuLHQsZSl7aWYoKytlWzFdPT09ZVswXSYmbi5vLmRlbGV0ZSh0KSxuLnByb3BzLnJldmVhbE9yZGVyJiYoXCJ0XCIhPT1uLnByb3BzLnJldmVhbE9yZGVyWzBdfHwhbi5vLnNpemUpKWZvcihlPW4udTtlOyl7Zm9yKDtlLmxlbmd0aD4zOyllLnBvcCgpKCk7aWYoZVsxXTxlWzBdKWJyZWFrO24udT1lPWVbMl19fTtmdW5jdGlvbiBUKG4pe3JldHVybiB0aGlzLmdldENoaWxkQ29udGV4dD1mdW5jdGlvbigpe3JldHVybiBuLmNvbnRleHR9LG4uY2hpbGRyZW59ZnVuY3Rpb24gaihuKXt2YXIgdD10aGlzLGU9bi5pO3QuY29tcG9uZW50V2lsbFVubW91bnQ9ZnVuY3Rpb24oKXtkKG51bGwsdC5sKSx0Lmw9bnVsbCx0Lmk9bnVsbH0sdC5pJiZ0LmkhPT1lJiZ0LmNvbXBvbmVudFdpbGxVbm1vdW50KCksbi5fX3Y/KHQubHx8KHQuaT1lLHQubD17bm9kZVR5cGU6MSxwYXJlbnROb2RlOmUsY2hpbGROb2RlczpbXSxhcHBlbmRDaGlsZDpmdW5jdGlvbihuKXt0aGlzLmNoaWxkTm9kZXMucHVzaChuKSx0LmkuYXBwZW5kQ2hpbGQobil9LGluc2VydEJlZm9yZTpmdW5jdGlvbihuLGUpe3RoaXMuY2hpbGROb2Rlcy5wdXNoKG4pLHQuaS5hcHBlbmRDaGlsZChuKX0scmVtb3ZlQ2hpbGQ6ZnVuY3Rpb24obil7dGhpcy5jaGlsZE5vZGVzLnNwbGljZSh0aGlzLmNoaWxkTm9kZXMuaW5kZXhPZihuKT4+PjEsMSksdC5pLnJlbW92ZUNoaWxkKG4pfX0pLGQocyhULHtjb250ZXh0OnQuY29udGV4dH0sbi5fX3YpLHQubCkpOnQubCYmdC5jb21wb25lbnRXaWxsVW5tb3VudCgpfWZ1bmN0aW9uIEkobix0KXtyZXR1cm4gcyhqLHtfX3Y6bixpOnR9KX0oRi5wcm90b3R5cGU9bmV3IGEpLl9fZT1mdW5jdGlvbihuKXt2YXIgdD10aGlzLGU9VSh0Ll9fdikscj10Lm8uZ2V0KG4pO3JldHVybiByWzBdKyssZnVuY3Rpb24odSl7dmFyIG89ZnVuY3Rpb24oKXt0LnByb3BzLnJldmVhbE9yZGVyPyhyLnB1c2godSksTSh0LG4scikpOnUoKX07ZT9lKG8pOm8oKX19LEYucHJvdG90eXBlLnJlbmRlcj1mdW5jdGlvbihuKXt0aGlzLnU9bnVsbCx0aGlzLm89bmV3IE1hcDt2YXIgdD1wKG4uY2hpbGRyZW4pO24ucmV2ZWFsT3JkZXImJlwiYlwiPT09bi5yZXZlYWxPcmRlclswXSYmdC5yZXZlcnNlKCk7Zm9yKHZhciBlPXQubGVuZ3RoO2UtLTspdGhpcy5vLnNldCh0W2VdLHRoaXMudT1bMSwwLHRoaXMudV0pO3JldHVybiBuLmNoaWxkcmVufSxGLnByb3RvdHlwZS5jb21wb25lbnREaWRVcGRhdGU9Ri5wcm90b3R5cGUuY29tcG9uZW50RGlkTW91bnQ9ZnVuY3Rpb24oKXt2YXIgbj10aGlzO3RoaXMuby5mb3JFYWNoKGZ1bmN0aW9uKHQsZSl7TShuLGUsdCl9KX07dmFyIFc9XCJ1bmRlZmluZWRcIiE9dHlwZW9mIFN5bWJvbCYmU3ltYm9sLmZvciYmU3ltYm9sLmZvcihcInJlYWN0LmVsZW1lbnRcIil8fDYwMTAzLFA9L14oPzphY2NlbnR8YWxpZ25tZW50fGFyYWJpY3xiYXNlbGluZXxjYXB8Y2xpcCg/IVBhdGhVKXxjb2xvcnxmaWxsfGZsb29kfGZvbnR8Z2x5cGgoPyFSKXxob3JpenxtYXJrZXIoPyFIfFd8VSl8b3ZlcmxpbmV8cGFpbnR8c3RvcHxzdHJpa2V0aHJvdWdofHN0cm9rZXx0ZXh0KD8hTCl8dW5kZXJsaW5lfHVuaWNvZGV8dW5pdHN8dnx2ZWN0b3J8dmVydHx3b3JkfHdyaXRpbmd8eCg/IUMpKVtBLVpdLyxWPWZ1bmN0aW9uKG4pe3JldHVybihcInVuZGVmaW5lZFwiIT10eXBlb2YgU3ltYm9sJiZcInN5bWJvbFwiPT10eXBlb2YgU3ltYm9sKCk/L2ZpbHxjaGV8cmFkL2k6L2ZpbHxjaGV8cmEvaSkudGVzdChuKX07ZnVuY3Rpb24geihuLHQsZSl7cmV0dXJuIG51bGw9PXQuX19rJiYodC50ZXh0Q29udGVudD1cIlwiKSxkKG4sdCksXCJmdW5jdGlvblwiPT10eXBlb2YgZSYmZSgpLG4/bi5fX2M6bnVsbH1mdW5jdGlvbiBCKG4sdCxlKXtyZXR1cm4gbShuLHQpLFwiZnVuY3Rpb25cIj09dHlwZW9mIGUmJmUoKSxuP24uX19jOm51bGx9YS5wcm90b3R5cGUuaXNSZWFjdENvbXBvbmVudD17fSxbXCJjb21wb25lbnRXaWxsTW91bnRcIixcImNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHNcIixcImNvbXBvbmVudFdpbGxVcGRhdGVcIl0uZm9yRWFjaChmdW5jdGlvbihuKXtPYmplY3QuZGVmaW5lUHJvcGVydHkoYS5wcm90b3R5cGUsbix7Y29uZmlndXJhYmxlOiEwLGdldDpmdW5jdGlvbigpe3JldHVybiB0aGlzW1wiVU5TQUZFX1wiK25dfSxzZXQ6ZnVuY3Rpb24odCl7T2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsbix7Y29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwLHZhbHVlOnR9KX19KX0pO3ZhciBIPWguZXZlbnQ7ZnVuY3Rpb24gWigpe31mdW5jdGlvbiBZKCl7cmV0dXJuIHRoaXMuY2FuY2VsQnViYmxlfWZ1bmN0aW9uICQoKXtyZXR1cm4gdGhpcy5kZWZhdWx0UHJldmVudGVkfWguZXZlbnQ9ZnVuY3Rpb24obil7cmV0dXJuIEgmJihuPUgobikpLG4ucGVyc2lzdD1aLG4uaXNQcm9wYWdhdGlvblN0b3BwZWQ9WSxuLmlzRGVmYXVsdFByZXZlbnRlZD0kLG4ubmF0aXZlRXZlbnQ9bn07dmFyIHEsRz17Y29uZmlndXJhYmxlOiEwLGdldDpmdW5jdGlvbigpe3JldHVybiB0aGlzLmNsYXNzfX0sSj1oLnZub2RlO2gudm5vZGU9ZnVuY3Rpb24obil7dmFyIHQ9bi50eXBlLGU9bi5wcm9wcyxyPWU7aWYoXCJzdHJpbmdcIj09dHlwZW9mIHQpe2Zvcih2YXIgdSBpbiByPXt9LGUpe3ZhciBvPWVbdV07XCJ2YWx1ZVwiPT09dSYmXCJkZWZhdWx0VmFsdWVcImluIGUmJm51bGw9PW98fChcImRlZmF1bHRWYWx1ZVwiPT09dSYmXCJ2YWx1ZVwiaW4gZSYmbnVsbD09ZS52YWx1ZT91PVwidmFsdWVcIjpcImRvd25sb2FkXCI9PT11JiYhMD09PW8/bz1cIlwiOi9vbmRvdWJsZWNsaWNrL2kudGVzdCh1KT91PVwib25kYmxjbGlja1wiOi9eb25jaGFuZ2UodGV4dGFyZWF8aW5wdXQpL2kudGVzdCh1K3QpJiYhVihlLnR5cGUpP3U9XCJvbmlucHV0XCI6L15vbihBbml8VHJhfFRvdXxCZWZvcmVJbnApLy50ZXN0KHUpP3U9dS50b0xvd2VyQ2FzZSgpOlAudGVzdCh1KT91PXUucmVwbGFjZSgvW0EtWjAtOV0vLFwiLSQmXCIpLnRvTG93ZXJDYXNlKCk6bnVsbD09PW8mJihvPXZvaWQgMCksclt1XT1vKX1cInNlbGVjdFwiPT10JiZyLm11bHRpcGxlJiZBcnJheS5pc0FycmF5KHIudmFsdWUpJiYoci52YWx1ZT1wKGUuY2hpbGRyZW4pLmZvckVhY2goZnVuY3Rpb24obil7bi5wcm9wcy5zZWxlY3RlZD0tMSE9ci52YWx1ZS5pbmRleE9mKG4ucHJvcHMudmFsdWUpfSkpLFwic2VsZWN0XCI9PXQmJm51bGwhPXIuZGVmYXVsdFZhbHVlJiYoci52YWx1ZT1wKGUuY2hpbGRyZW4pLmZvckVhY2goZnVuY3Rpb24obil7bi5wcm9wcy5zZWxlY3RlZD1yLm11bHRpcGxlPy0xIT1yLmRlZmF1bHRWYWx1ZS5pbmRleE9mKG4ucHJvcHMudmFsdWUpOnIuZGVmYXVsdFZhbHVlPT1uLnByb3BzLnZhbHVlfSkpLG4ucHJvcHM9cn10JiZlLmNsYXNzIT1lLmNsYXNzTmFtZSYmKEcuZW51bWVyYWJsZT1cImNsYXNzTmFtZVwiaW4gZSxudWxsIT1lLmNsYXNzTmFtZSYmKHIuY2xhc3M9ZS5jbGFzc05hbWUpLE9iamVjdC5kZWZpbmVQcm9wZXJ0eShyLFwiY2xhc3NOYW1lXCIsRykpLG4uJCR0eXBlb2Y9VyxKJiZKKG4pfTt2YXIgSz1oLl9fcjtoLl9fcj1mdW5jdGlvbihuKXtLJiZLKG4pLHE9bi5fX2N9O3ZhciBRPXtSZWFjdEN1cnJlbnREaXNwYXRjaGVyOntjdXJyZW50OntyZWFkQ29udGV4dDpmdW5jdGlvbihuKXtyZXR1cm4gcS5fX25bbi5fX2NdLnByb3BzLnZhbHVlfX19fSxYPTEsbm49Mix0bj0zLGVuPTQscm49NTtmdW5jdGlvbiB1bihuLHQpe3JldHVybiB0KCl9dmFyIG9uPVwib2JqZWN0XCI9PXR5cGVvZiBwZXJmb3JtYW5jZSYmXCJmdW5jdGlvblwiPT10eXBlb2YgcGVyZm9ybWFuY2Uubm93P3BlcmZvcm1hbmNlLm5vdy5iaW5kKHBlcmZvcm1hbmNlKTpmdW5jdGlvbigpe3JldHVybiBEYXRlLm5vdygpfSxsbj1cIjE2LjguMFwiO2Z1bmN0aW9uIGZuKG4pe3JldHVybiBzLmJpbmQobnVsbCxuKX1mdW5jdGlvbiBjbihuKXtyZXR1cm4hIW4mJm4uJCR0eXBlb2Y9PT1XfWZ1bmN0aW9uIGFuKG4pe3JldHVybiBjbihuKT95LmFwcGx5KG51bGwsYXJndW1lbnRzKTpufWZ1bmN0aW9uIHNuKG4pe3JldHVybiEhbi5fX2smJihkKG51bGwsbiksITApfWZ1bmN0aW9uIGhuKG4pe3JldHVybiBuJiYobi5iYXNlfHwxPT09bi5ub2RlVHlwZSYmbil8fG51bGx9dmFyIHBuPWZ1bmN0aW9uKG4sdCl7cmV0dXJuIG4odCl9LHZuPXY7ZXhwb3J0IGRlZmF1bHR7dXNlU3RhdGU6bix1c2VSZWR1Y2VyOnQsdXNlRWZmZWN0OmUsdXNlTGF5b3V0RWZmZWN0OnIsdXNlUmVmOnUsdXNlSW1wZXJhdGl2ZUhhbmRsZTpvLHVzZU1lbW86aSx1c2VDYWxsYmFjazpsLHVzZUNvbnRleHQ6Zix1c2VEZWJ1Z1ZhbHVlOmMsdmVyc2lvbjpcIjE2LjguMFwiLENoaWxkcmVuOmsscmVuZGVyOnosaHlkcmF0ZTpCLHVubW91bnRDb21wb25lbnRBdE5vZGU6c24sY3JlYXRlUG9ydGFsOkksY3JlYXRlRWxlbWVudDpzLGNyZWF0ZUNvbnRleHQ6XyxjcmVhdGVGYWN0b3J5OmZuLGNsb25lRWxlbWVudDphbixjcmVhdGVSZWY6YixGcmFnbWVudDp2LGlzVmFsaWRFbGVtZW50OmNuLGZpbmRET01Ob2RlOmhuLENvbXBvbmVudDphLFB1cmVDb21wb25lbnQ6RSxtZW1vOmcsZm9yd2FyZFJlZjp4LHVuc3RhYmxlX2JhdGNoZWRVcGRhdGVzOnBuLFN0cmljdE1vZGU6dixTdXNwZW5zZTpMLFN1c3BlbnNlTGlzdDpGLGxhenk6RCxfX1NFQ1JFVF9JTlRFUk5BTFNfRE9fTk9UX1VTRV9PUl9ZT1VfV0lMTF9CRV9GSVJFRDpRfTtleHBvcnR7bG4gYXMgdmVyc2lvbixrIGFzIENoaWxkcmVuLHogYXMgcmVuZGVyLEIgYXMgaHlkcmF0ZSxzbiBhcyB1bm1vdW50Q29tcG9uZW50QXROb2RlLEkgYXMgY3JlYXRlUG9ydGFsLGZuIGFzIGNyZWF0ZUZhY3RvcnksYW4gYXMgY2xvbmVFbGVtZW50LGNuIGFzIGlzVmFsaWRFbGVtZW50LGhuIGFzIGZpbmRET01Ob2RlLEUgYXMgUHVyZUNvbXBvbmVudCxnIGFzIG1lbW8seCBhcyBmb3J3YXJkUmVmLHBuIGFzIHVuc3RhYmxlX2JhdGNoZWRVcGRhdGVzLHZuIGFzIFN0cmljdE1vZGUsTCBhcyBTdXNwZW5zZSxGIGFzIFN1c3BlbnNlTGlzdCxEIGFzIGxhenksUSBhcyBfX1NFQ1JFVF9JTlRFUk5BTFNfRE9fTk9UX1VTRV9PUl9ZT1VfV0lMTF9CRV9GSVJFRCxYIGFzIHVuc3RhYmxlX0ltbWVkaWF0ZVByaW9yaXR5LG5uIGFzIHVuc3RhYmxlX1VzZXJCbG9ja2luZ1ByaW9yaXR5LHRuIGFzIHVuc3RhYmxlX05vcm1hbFByaW9yaXR5LGVuIGFzIHVuc3RhYmxlX0xvd1ByaW9yaXR5LHJuIGFzIHVuc3RhYmxlX0lkbGVQcmlvcml0eSx1biBhcyB1bnN0YWJsZV9ydW5XaXRoUHJpb3JpdHksb24gYXMgdW5zdGFibGVfbm93fTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNvbXBhdC5tb2R1bGUuanMubWFwXG4iLCJ2YXIgbixsLHUsaSx0LG8scj17fSxmPVtdLGU9L2FjaXR8ZXgoPzpzfGd8bnxwfCQpfHJwaHxncmlkfG93c3xtbmN8bnR3fGluZVtjaF18em9vfF5vcmR8aXRlcmEvaTtmdW5jdGlvbiBjKG4sbCl7Zm9yKHZhciB1IGluIGwpblt1XT1sW3VdO3JldHVybiBufWZ1bmN0aW9uIHMobil7dmFyIGw9bi5wYXJlbnROb2RlO2wmJmwucmVtb3ZlQ2hpbGQobil9ZnVuY3Rpb24gYShuLGwsdSl7dmFyIGksdCxvLHI9YXJndW1lbnRzLGY9e307Zm9yKG8gaW4gbClcImtleVwiPT1vP2k9bFtvXTpcInJlZlwiPT1vP3Q9bFtvXTpmW29dPWxbb107aWYoYXJndW1lbnRzLmxlbmd0aD4zKWZvcih1PVt1XSxvPTM7bzxhcmd1bWVudHMubGVuZ3RoO28rKyl1LnB1c2gocltvXSk7aWYobnVsbCE9dSYmKGYuY2hpbGRyZW49dSksXCJmdW5jdGlvblwiPT10eXBlb2YgbiYmbnVsbCE9bi5kZWZhdWx0UHJvcHMpZm9yKG8gaW4gbi5kZWZhdWx0UHJvcHMpdm9pZCAwPT09ZltvXSYmKGZbb109bi5kZWZhdWx0UHJvcHNbb10pO3JldHVybiB2KG4sZixpLHQsbnVsbCl9ZnVuY3Rpb24gdihsLHUsaSx0LG8pe3ZhciByPXt0eXBlOmwscHJvcHM6dSxrZXk6aSxyZWY6dCxfX2s6bnVsbCxfXzpudWxsLF9fYjowLF9fZTpudWxsLF9fZDp2b2lkIDAsX19jOm51bGwsX19oOm51bGwsY29uc3RydWN0b3I6dm9pZCAwLF9fdjpudWxsPT1vPysrbi5fX3Y6b307cmV0dXJuIG51bGwhPW4udm5vZGUmJm4udm5vZGUocikscn1mdW5jdGlvbiBoKCl7cmV0dXJue2N1cnJlbnQ6bnVsbH19ZnVuY3Rpb24geShuKXtyZXR1cm4gbi5jaGlsZHJlbn1mdW5jdGlvbiBwKG4sbCl7dGhpcy5wcm9wcz1uLHRoaXMuY29udGV4dD1sfWZ1bmN0aW9uIGQobixsKXtpZihudWxsPT1sKXJldHVybiBuLl9fP2Qobi5fXyxuLl9fLl9fay5pbmRleE9mKG4pKzEpOm51bGw7Zm9yKHZhciB1O2w8bi5fX2subGVuZ3RoO2wrKylpZihudWxsIT0odT1uLl9fa1tsXSkmJm51bGwhPXUuX19lKXJldHVybiB1Ll9fZTtyZXR1cm5cImZ1bmN0aW9uXCI9PXR5cGVvZiBuLnR5cGU/ZChuKTpudWxsfWZ1bmN0aW9uIF8obil7dmFyIGwsdTtpZihudWxsIT0obj1uLl9fKSYmbnVsbCE9bi5fX2Mpe2ZvcihuLl9fZT1uLl9fYy5iYXNlPW51bGwsbD0wO2w8bi5fX2subGVuZ3RoO2wrKylpZihudWxsIT0odT1uLl9fa1tsXSkmJm51bGwhPXUuX19lKXtuLl9fZT1uLl9fYy5iYXNlPXUuX19lO2JyZWFrfXJldHVybiBfKG4pfX1mdW5jdGlvbiBrKGwpeyghbC5fX2QmJihsLl9fZD0hMCkmJnUucHVzaChsKSYmIWIuX19yKyt8fHQhPT1uLmRlYm91bmNlUmVuZGVyaW5nKSYmKCh0PW4uZGVib3VuY2VSZW5kZXJpbmcpfHxpKShiKX1mdW5jdGlvbiBiKCl7Zm9yKHZhciBuO2IuX19yPXUubGVuZ3RoOyluPXUuc29ydChmdW5jdGlvbihuLGwpe3JldHVybiBuLl9fdi5fX2ItbC5fX3YuX19ifSksdT1bXSxuLnNvbWUoZnVuY3Rpb24obil7dmFyIGwsdSxpLHQsbyxyO24uX19kJiYobz0odD0obD1uKS5fX3YpLl9fZSwocj1sLl9fUCkmJih1PVtdLChpPWMoe30sdCkpLl9fdj10Ll9fdisxLEkocix0LGksbC5fX24sdm9pZCAwIT09ci5vd25lclNWR0VsZW1lbnQsbnVsbCE9dC5fX2g/W29dOm51bGwsdSxudWxsPT1vP2QodCk6byx0Ll9faCksVCh1LHQpLHQuX19lIT1vJiZfKHQpKSl9KX1mdW5jdGlvbiBtKG4sbCx1LGksdCxvLGUsYyxzLGEpe3ZhciBoLHAsXyxrLGIsbSx3LEE9aSYmaS5fX2t8fGYsUD1BLmxlbmd0aDtmb3IodS5fX2s9W10saD0wO2g8bC5sZW5ndGg7aCsrKWlmKG51bGwhPShrPXUuX19rW2hdPW51bGw9PShrPWxbaF0pfHxcImJvb2xlYW5cIj09dHlwZW9mIGs/bnVsbDpcInN0cmluZ1wiPT10eXBlb2Yga3x8XCJudW1iZXJcIj09dHlwZW9mIGt8fFwiYmlnaW50XCI9PXR5cGVvZiBrP3YobnVsbCxrLG51bGwsbnVsbCxrKTpBcnJheS5pc0FycmF5KGspP3YoeSx7Y2hpbGRyZW46a30sbnVsbCxudWxsLG51bGwpOmsuX19iPjA/dihrLnR5cGUsay5wcm9wcyxrLmtleSxudWxsLGsuX192KTprKSl7aWYoay5fXz11LGsuX19iPXUuX19iKzEsbnVsbD09PShfPUFbaF0pfHxfJiZrLmtleT09Xy5rZXkmJmsudHlwZT09PV8udHlwZSlBW2hdPXZvaWQgMDtlbHNlIGZvcihwPTA7cDxQO3ArKyl7aWYoKF89QVtwXSkmJmsua2V5PT1fLmtleSYmay50eXBlPT09Xy50eXBlKXtBW3BdPXZvaWQgMDticmVha31fPW51bGx9SShuLGssXz1ffHxyLHQsbyxlLGMscyxhKSxiPWsuX19lLChwPWsucmVmKSYmXy5yZWYhPXAmJih3fHwodz1bXSksXy5yZWYmJncucHVzaChfLnJlZixudWxsLGspLHcucHVzaChwLGsuX19jfHxiLGspKSxudWxsIT1iPyhudWxsPT1tJiYobT1iKSxcImZ1bmN0aW9uXCI9PXR5cGVvZiBrLnR5cGUmJm51bGwhPWsuX19rJiZrLl9faz09PV8uX19rP2suX19kPXM9ZyhrLHMsbik6cz14KG4sayxfLEEsYixzKSxhfHxcIm9wdGlvblwiIT09dS50eXBlP1wiZnVuY3Rpb25cIj09dHlwZW9mIHUudHlwZSYmKHUuX19kPXMpOm4udmFsdWU9XCJcIik6cyYmXy5fX2U9PXMmJnMucGFyZW50Tm9kZSE9biYmKHM9ZChfKSl9Zm9yKHUuX19lPW0saD1QO2gtLTspbnVsbCE9QVtoXSYmKFwiZnVuY3Rpb25cIj09dHlwZW9mIHUudHlwZSYmbnVsbCE9QVtoXS5fX2UmJkFbaF0uX19lPT11Ll9fZCYmKHUuX19kPWQoaSxoKzEpKSxMKEFbaF0sQVtoXSkpO2lmKHcpZm9yKGg9MDtoPHcubGVuZ3RoO2grKyl6KHdbaF0sd1srK2hdLHdbKytoXSl9ZnVuY3Rpb24gZyhuLGwsdSl7dmFyIGksdDtmb3IoaT0wO2k8bi5fX2subGVuZ3RoO2krKykodD1uLl9fa1tpXSkmJih0Ll9fPW4sbD1cImZ1bmN0aW9uXCI9PXR5cGVvZiB0LnR5cGU/Zyh0LGwsdSk6eCh1LHQsdCxuLl9fayx0Ll9fZSxsKSk7cmV0dXJuIGx9ZnVuY3Rpb24gdyhuLGwpe3JldHVybiBsPWx8fFtdLG51bGw9PW58fFwiYm9vbGVhblwiPT10eXBlb2Ygbnx8KEFycmF5LmlzQXJyYXkobik/bi5zb21lKGZ1bmN0aW9uKG4pe3cobixsKX0pOmwucHVzaChuKSksbH1mdW5jdGlvbiB4KG4sbCx1LGksdCxvKXt2YXIgcixmLGU7aWYodm9pZCAwIT09bC5fX2Qpcj1sLl9fZCxsLl9fZD12b2lkIDA7ZWxzZSBpZihudWxsPT11fHx0IT1vfHxudWxsPT10LnBhcmVudE5vZGUpbjppZihudWxsPT1vfHxvLnBhcmVudE5vZGUhPT1uKW4uYXBwZW5kQ2hpbGQodCkscj1udWxsO2Vsc2V7Zm9yKGY9byxlPTA7KGY9Zi5uZXh0U2libGluZykmJmU8aS5sZW5ndGg7ZSs9MilpZihmPT10KWJyZWFrIG47bi5pbnNlcnRCZWZvcmUodCxvKSxyPW99cmV0dXJuIHZvaWQgMCE9PXI/cjp0Lm5leHRTaWJsaW5nfWZ1bmN0aW9uIEEobixsLHUsaSx0KXt2YXIgbztmb3IobyBpbiB1KVwiY2hpbGRyZW5cIj09PW98fFwia2V5XCI9PT1vfHxvIGluIGx8fEMobixvLG51bGwsdVtvXSxpKTtmb3IobyBpbiBsKXQmJlwiZnVuY3Rpb25cIiE9dHlwZW9mIGxbb118fFwiY2hpbGRyZW5cIj09PW98fFwia2V5XCI9PT1vfHxcInZhbHVlXCI9PT1vfHxcImNoZWNrZWRcIj09PW98fHVbb109PT1sW29dfHxDKG4sbyxsW29dLHVbb10saSl9ZnVuY3Rpb24gUChuLGwsdSl7XCItXCI9PT1sWzBdP24uc2V0UHJvcGVydHkobCx1KTpuW2xdPW51bGw9PXU/XCJcIjpcIm51bWJlclwiIT10eXBlb2YgdXx8ZS50ZXN0KGwpP3U6dStcInB4XCJ9ZnVuY3Rpb24gQyhuLGwsdSxpLHQpe3ZhciBvO246aWYoXCJzdHlsZVwiPT09bClpZihcInN0cmluZ1wiPT10eXBlb2YgdSluLnN0eWxlLmNzc1RleHQ9dTtlbHNle2lmKFwic3RyaW5nXCI9PXR5cGVvZiBpJiYobi5zdHlsZS5jc3NUZXh0PWk9XCJcIiksaSlmb3IobCBpbiBpKXUmJmwgaW4gdXx8UChuLnN0eWxlLGwsXCJcIik7aWYodSlmb3IobCBpbiB1KWkmJnVbbF09PT1pW2xdfHxQKG4uc3R5bGUsbCx1W2xdKX1lbHNlIGlmKFwib1wiPT09bFswXSYmXCJuXCI9PT1sWzFdKW89bCE9PShsPWwucmVwbGFjZSgvQ2FwdHVyZSQvLFwiXCIpKSxsPWwudG9Mb3dlckNhc2UoKWluIG4/bC50b0xvd2VyQ2FzZSgpLnNsaWNlKDIpOmwuc2xpY2UoMiksbi5sfHwobi5sPXt9KSxuLmxbbCtvXT11LHU/aXx8bi5hZGRFdmVudExpc3RlbmVyKGwsbz9IOiQsbyk6bi5yZW1vdmVFdmVudExpc3RlbmVyKGwsbz9IOiQsbyk7ZWxzZSBpZihcImRhbmdlcm91c2x5U2V0SW5uZXJIVE1MXCIhPT1sKXtpZih0KWw9bC5yZXBsYWNlKC94bGlua1tIOmhdLyxcImhcIikucmVwbGFjZSgvc05hbWUkLyxcInNcIik7ZWxzZSBpZihcImhyZWZcIiE9PWwmJlwibGlzdFwiIT09bCYmXCJmb3JtXCIhPT1sJiZcInRhYkluZGV4XCIhPT1sJiZcImRvd25sb2FkXCIhPT1sJiZsIGluIG4pdHJ5e25bbF09bnVsbD09dT9cIlwiOnU7YnJlYWsgbn1jYXRjaChuKXt9XCJmdW5jdGlvblwiPT10eXBlb2YgdXx8KG51bGwhPXUmJighMSE9PXV8fFwiYVwiPT09bFswXSYmXCJyXCI9PT1sWzFdKT9uLnNldEF0dHJpYnV0ZShsLHUpOm4ucmVtb3ZlQXR0cmlidXRlKGwpKX19ZnVuY3Rpb24gJChsKXt0aGlzLmxbbC50eXBlKyExXShuLmV2ZW50P24uZXZlbnQobCk6bCl9ZnVuY3Rpb24gSChsKXt0aGlzLmxbbC50eXBlKyEwXShuLmV2ZW50P24uZXZlbnQobCk6bCl9ZnVuY3Rpb24gSShsLHUsaSx0LG8scixmLGUscyl7dmFyIGEsdixoLGQsXyxrLGIsZyx3LHgsQSxQPXUudHlwZTtpZih2b2lkIDAhPT11LmNvbnN0cnVjdG9yKXJldHVybiBudWxsO251bGwhPWkuX19oJiYocz1pLl9faCxlPXUuX19lPWkuX19lLHUuX19oPW51bGwscj1bZV0pLChhPW4uX19iKSYmYSh1KTt0cnl7bjppZihcImZ1bmN0aW9uXCI9PXR5cGVvZiBQKXtpZihnPXUucHJvcHMsdz0oYT1QLmNvbnRleHRUeXBlKSYmdFthLl9fY10seD1hP3c/dy5wcm9wcy52YWx1ZTphLl9fOnQsaS5fX2M/Yj0odj11Ll9fYz1pLl9fYykuX189di5fX0U6KFwicHJvdG90eXBlXCJpbiBQJiZQLnByb3RvdHlwZS5yZW5kZXI/dS5fX2M9dj1uZXcgUChnLHgpOih1Ll9fYz12PW5ldyBwKGcseCksdi5jb25zdHJ1Y3Rvcj1QLHYucmVuZGVyPU0pLHcmJncuc3ViKHYpLHYucHJvcHM9Zyx2LnN0YXRlfHwodi5zdGF0ZT17fSksdi5jb250ZXh0PXgsdi5fX249dCxoPXYuX19kPSEwLHYuX19oPVtdKSxudWxsPT12Ll9fcyYmKHYuX19zPXYuc3RhdGUpLG51bGwhPVAuZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzJiYodi5fX3M9PXYuc3RhdGUmJih2Ll9fcz1jKHt9LHYuX19zKSksYyh2Ll9fcyxQLmdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcyhnLHYuX19zKSkpLGQ9di5wcm9wcyxfPXYuc3RhdGUsaCludWxsPT1QLmdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcyYmbnVsbCE9di5jb21wb25lbnRXaWxsTW91bnQmJnYuY29tcG9uZW50V2lsbE1vdW50KCksbnVsbCE9di5jb21wb25lbnREaWRNb3VudCYmdi5fX2gucHVzaCh2LmNvbXBvbmVudERpZE1vdW50KTtlbHNle2lmKG51bGw9PVAuZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzJiZnIT09ZCYmbnVsbCE9di5jb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzJiZ2LmNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMoZyx4KSwhdi5fX2UmJm51bGwhPXYuc2hvdWxkQ29tcG9uZW50VXBkYXRlJiYhMT09PXYuc2hvdWxkQ29tcG9uZW50VXBkYXRlKGcsdi5fX3MseCl8fHUuX192PT09aS5fX3Ype3YucHJvcHM9Zyx2LnN0YXRlPXYuX19zLHUuX192IT09aS5fX3YmJih2Ll9fZD0hMSksdi5fX3Y9dSx1Ll9fZT1pLl9fZSx1Ll9faz1pLl9fayx1Ll9fay5mb3JFYWNoKGZ1bmN0aW9uKG4pe24mJihuLl9fPXUpfSksdi5fX2gubGVuZ3RoJiZmLnB1c2godik7YnJlYWsgbn1udWxsIT12LmNvbXBvbmVudFdpbGxVcGRhdGUmJnYuY29tcG9uZW50V2lsbFVwZGF0ZShnLHYuX19zLHgpLG51bGwhPXYuY29tcG9uZW50RGlkVXBkYXRlJiZ2Ll9faC5wdXNoKGZ1bmN0aW9uKCl7di5jb21wb25lbnREaWRVcGRhdGUoZCxfLGspfSl9di5jb250ZXh0PXgsdi5wcm9wcz1nLHYuc3RhdGU9di5fX3MsKGE9bi5fX3IpJiZhKHUpLHYuX19kPSExLHYuX192PXUsdi5fX1A9bCxhPXYucmVuZGVyKHYucHJvcHMsdi5zdGF0ZSx2LmNvbnRleHQpLHYuc3RhdGU9di5fX3MsbnVsbCE9di5nZXRDaGlsZENvbnRleHQmJih0PWMoYyh7fSx0KSx2LmdldENoaWxkQ29udGV4dCgpKSksaHx8bnVsbD09di5nZXRTbmFwc2hvdEJlZm9yZVVwZGF0ZXx8KGs9di5nZXRTbmFwc2hvdEJlZm9yZVVwZGF0ZShkLF8pKSxBPW51bGwhPWEmJmEudHlwZT09PXkmJm51bGw9PWEua2V5P2EucHJvcHMuY2hpbGRyZW46YSxtKGwsQXJyYXkuaXNBcnJheShBKT9BOltBXSx1LGksdCxvLHIsZixlLHMpLHYuYmFzZT11Ll9fZSx1Ll9faD1udWxsLHYuX19oLmxlbmd0aCYmZi5wdXNoKHYpLGImJih2Ll9fRT12Ll9fPW51bGwpLHYuX19lPSExfWVsc2UgbnVsbD09ciYmdS5fX3Y9PT1pLl9fdj8odS5fX2s9aS5fX2ssdS5fX2U9aS5fX2UpOnUuX19lPWooaS5fX2UsdSxpLHQsbyxyLGYscyk7KGE9bi5kaWZmZWQpJiZhKHUpfWNhdGNoKGwpe3UuX192PW51bGwsKHN8fG51bGwhPXIpJiYodS5fX2U9ZSx1Ll9faD0hIXMscltyLmluZGV4T2YoZSldPW51bGwpLG4uX19lKGwsdSxpKX19ZnVuY3Rpb24gVChsLHUpe24uX19jJiZuLl9fYyh1LGwpLGwuc29tZShmdW5jdGlvbih1KXt0cnl7bD11Ll9faCx1Ll9faD1bXSxsLnNvbWUoZnVuY3Rpb24obil7bi5jYWxsKHUpfSl9Y2F0Y2gobCl7bi5fX2UobCx1Ll9fdil9fSl9ZnVuY3Rpb24gaihuLGwsdSxpLHQsbyxlLGMpe3ZhciBhLHYsaCx5LHA9dS5wcm9wcyxkPWwucHJvcHMsXz1sLnR5cGUsaz0wO2lmKFwic3ZnXCI9PT1fJiYodD0hMCksbnVsbCE9bylmb3IoO2s8by5sZW5ndGg7aysrKWlmKChhPW9ba10pJiYoYT09PW58fChfP2EubG9jYWxOYW1lPT1fOjM9PWEubm9kZVR5cGUpKSl7bj1hLG9ba109bnVsbDticmVha31pZihudWxsPT1uKXtpZihudWxsPT09XylyZXR1cm4gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoZCk7bj10P2RvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyhcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIsXyk6ZG9jdW1lbnQuY3JlYXRlRWxlbWVudChfLGQuaXMmJmQpLG89bnVsbCxjPSExfWlmKG51bGw9PT1fKXA9PT1kfHxjJiZuLmRhdGE9PT1kfHwobi5kYXRhPWQpO2Vsc2V7aWYobz1vJiZmLnNsaWNlLmNhbGwobi5jaGlsZE5vZGVzKSx2PShwPXUucHJvcHN8fHIpLmRhbmdlcm91c2x5U2V0SW5uZXJIVE1MLGg9ZC5kYW5nZXJvdXNseVNldElubmVySFRNTCwhYyl7aWYobnVsbCE9bylmb3IocD17fSx5PTA7eTxuLmF0dHJpYnV0ZXMubGVuZ3RoO3krKylwW24uYXR0cmlidXRlc1t5XS5uYW1lXT1uLmF0dHJpYnV0ZXNbeV0udmFsdWU7KGh8fHYpJiYoaCYmKHYmJmguX19odG1sPT12Ll9faHRtbHx8aC5fX2h0bWw9PT1uLmlubmVySFRNTCl8fChuLmlubmVySFRNTD1oJiZoLl9faHRtbHx8XCJcIikpfWlmKEEobixkLHAsdCxjKSxoKWwuX19rPVtdO2Vsc2UgaWYoaz1sLnByb3BzLmNoaWxkcmVuLG0obixBcnJheS5pc0FycmF5KGspP2s6W2tdLGwsdSxpLHQmJlwiZm9yZWlnbk9iamVjdFwiIT09XyxvLGUsbi5maXJzdENoaWxkLGMpLG51bGwhPW8pZm9yKGs9by5sZW5ndGg7ay0tOyludWxsIT1vW2tdJiZzKG9ba10pO2N8fChcInZhbHVlXCJpbiBkJiZ2b2lkIDAhPT0oaz1kLnZhbHVlKSYmKGshPT1uLnZhbHVlfHxcInByb2dyZXNzXCI9PT1fJiYhaykmJkMobixcInZhbHVlXCIsayxwLnZhbHVlLCExKSxcImNoZWNrZWRcImluIGQmJnZvaWQgMCE9PShrPWQuY2hlY2tlZCkmJmshPT1uLmNoZWNrZWQmJkMobixcImNoZWNrZWRcIixrLHAuY2hlY2tlZCwhMSkpfXJldHVybiBufWZ1bmN0aW9uIHoobCx1LGkpe3RyeXtcImZ1bmN0aW9uXCI9PXR5cGVvZiBsP2wodSk6bC5jdXJyZW50PXV9Y2F0Y2gobCl7bi5fX2UobCxpKX19ZnVuY3Rpb24gTChsLHUsaSl7dmFyIHQsbyxyO2lmKG4udW5tb3VudCYmbi51bm1vdW50KGwpLCh0PWwucmVmKSYmKHQuY3VycmVudCYmdC5jdXJyZW50IT09bC5fX2V8fHoodCxudWxsLHUpKSxpfHxcImZ1bmN0aW9uXCI9PXR5cGVvZiBsLnR5cGV8fChpPW51bGwhPShvPWwuX19lKSksbC5fX2U9bC5fX2Q9dm9pZCAwLG51bGwhPSh0PWwuX19jKSl7aWYodC5jb21wb25lbnRXaWxsVW5tb3VudCl0cnl7dC5jb21wb25lbnRXaWxsVW5tb3VudCgpfWNhdGNoKGwpe24uX19lKGwsdSl9dC5iYXNlPXQuX19QPW51bGx9aWYodD1sLl9faylmb3Iocj0wO3I8dC5sZW5ndGg7cisrKXRbcl0mJkwodFtyXSx1LGkpO251bGwhPW8mJnMobyl9ZnVuY3Rpb24gTShuLGwsdSl7cmV0dXJuIHRoaXMuY29uc3RydWN0b3Iobix1KX1mdW5jdGlvbiBOKGwsdSxpKXt2YXIgdCxvLGU7bi5fXyYmbi5fXyhsLHUpLG89KHQ9XCJmdW5jdGlvblwiPT10eXBlb2YgaSk/bnVsbDppJiZpLl9fa3x8dS5fX2ssZT1bXSxJKHUsbD0oIXQmJml8fHUpLl9faz1hKHksbnVsbCxbbF0pLG98fHIscix2b2lkIDAhPT11Lm93bmVyU1ZHRWxlbWVudCwhdCYmaT9baV06bz9udWxsOnUuZmlyc3RDaGlsZD9mLnNsaWNlLmNhbGwodS5jaGlsZE5vZGVzKTpudWxsLGUsIXQmJmk/aTpvP28uX19lOnUuZmlyc3RDaGlsZCx0KSxUKGUsbCl9ZnVuY3Rpb24gTyhuLGwpe04obixsLE8pfWZ1bmN0aW9uIFMobixsLHUpe3ZhciBpLHQsbyxyPWFyZ3VtZW50cyxmPWMoe30sbi5wcm9wcyk7Zm9yKG8gaW4gbClcImtleVwiPT1vP2k9bFtvXTpcInJlZlwiPT1vP3Q9bFtvXTpmW29dPWxbb107aWYoYXJndW1lbnRzLmxlbmd0aD4zKWZvcih1PVt1XSxvPTM7bzxhcmd1bWVudHMubGVuZ3RoO28rKyl1LnB1c2gocltvXSk7cmV0dXJuIG51bGwhPXUmJihmLmNoaWxkcmVuPXUpLHYobi50eXBlLGYsaXx8bi5rZXksdHx8bi5yZWYsbnVsbCl9ZnVuY3Rpb24gcShuLGwpe3ZhciB1PXtfX2M6bD1cIl9fY0NcIitvKyssX186bixDb25zdW1lcjpmdW5jdGlvbihuLGwpe3JldHVybiBuLmNoaWxkcmVuKGwpfSxQcm92aWRlcjpmdW5jdGlvbihuKXt2YXIgdSxpO3JldHVybiB0aGlzLmdldENoaWxkQ29udGV4dHx8KHU9W10sKGk9e30pW2xdPXRoaXMsdGhpcy5nZXRDaGlsZENvbnRleHQ9ZnVuY3Rpb24oKXtyZXR1cm4gaX0sdGhpcy5zaG91bGRDb21wb25lbnRVcGRhdGU9ZnVuY3Rpb24obil7dGhpcy5wcm9wcy52YWx1ZSE9PW4udmFsdWUmJnUuc29tZShrKX0sdGhpcy5zdWI9ZnVuY3Rpb24obil7dS5wdXNoKG4pO3ZhciBsPW4uY29tcG9uZW50V2lsbFVubW91bnQ7bi5jb21wb25lbnRXaWxsVW5tb3VudD1mdW5jdGlvbigpe3Uuc3BsaWNlKHUuaW5kZXhPZihuKSwxKSxsJiZsLmNhbGwobil9fSksbi5jaGlsZHJlbn19O3JldHVybiB1LlByb3ZpZGVyLl9fPXUuQ29uc3VtZXIuY29udGV4dFR5cGU9dX1uPXtfX2U6ZnVuY3Rpb24obixsKXtmb3IodmFyIHUsaSx0O2w9bC5fXzspaWYoKHU9bC5fX2MpJiYhdS5fXyl0cnl7aWYoKGk9dS5jb25zdHJ1Y3RvcikmJm51bGwhPWkuZ2V0RGVyaXZlZFN0YXRlRnJvbUVycm9yJiYodS5zZXRTdGF0ZShpLmdldERlcml2ZWRTdGF0ZUZyb21FcnJvcihuKSksdD11Ll9fZCksbnVsbCE9dS5jb21wb25lbnREaWRDYXRjaCYmKHUuY29tcG9uZW50RGlkQ2F0Y2gobiksdD11Ll9fZCksdClyZXR1cm4gdS5fX0U9dX1jYXRjaChsKXtuPWx9dGhyb3cgbn0sX192OjB9LGw9ZnVuY3Rpb24obil7cmV0dXJuIG51bGwhPW4mJnZvaWQgMD09PW4uY29uc3RydWN0b3J9LHAucHJvdG90eXBlLnNldFN0YXRlPWZ1bmN0aW9uKG4sbCl7dmFyIHU7dT1udWxsIT10aGlzLl9fcyYmdGhpcy5fX3MhPT10aGlzLnN0YXRlP3RoaXMuX19zOnRoaXMuX19zPWMoe30sdGhpcy5zdGF0ZSksXCJmdW5jdGlvblwiPT10eXBlb2YgbiYmKG49bihjKHt9LHUpLHRoaXMucHJvcHMpKSxuJiZjKHUsbiksbnVsbCE9biYmdGhpcy5fX3YmJihsJiZ0aGlzLl9faC5wdXNoKGwpLGsodGhpcykpfSxwLnByb3RvdHlwZS5mb3JjZVVwZGF0ZT1mdW5jdGlvbihuKXt0aGlzLl9fdiYmKHRoaXMuX19lPSEwLG4mJnRoaXMuX19oLnB1c2gobiksayh0aGlzKSl9LHAucHJvdG90eXBlLnJlbmRlcj15LHU9W10saT1cImZ1bmN0aW9uXCI9PXR5cGVvZiBQcm9taXNlP1Byb21pc2UucHJvdG90eXBlLnRoZW4uYmluZChQcm9taXNlLnJlc29sdmUoKSk6c2V0VGltZW91dCxiLl9fcj0wLG89MDtleHBvcnR7TiBhcyByZW5kZXIsTyBhcyBoeWRyYXRlLGEgYXMgY3JlYXRlRWxlbWVudCxhIGFzIGgseSBhcyBGcmFnbWVudCxoIGFzIGNyZWF0ZVJlZixsIGFzIGlzVmFsaWRFbGVtZW50LHAgYXMgQ29tcG9uZW50LFMgYXMgY2xvbmVFbGVtZW50LHEgYXMgY3JlYXRlQ29udGV4dCx3IGFzIHRvQ2hpbGRBcnJheSxuIGFzIG9wdGlvbnN9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cHJlYWN0Lm1vZHVsZS5qcy5tYXBcbiIsImltcG9ydHtvcHRpb25zIGFzIG59ZnJvbVwicHJlYWN0XCI7dmFyIHQsdSxyLG89MCxpPVtdLGM9bi5fX2IsZj1uLl9fcixlPW4uZGlmZmVkLGE9bi5fX2Msdj1uLnVubW91bnQ7ZnVuY3Rpb24gbSh0LHIpe24uX19oJiZuLl9faCh1LHQsb3x8ciksbz0wO3ZhciBpPXUuX19IfHwodS5fX0g9e19fOltdLF9faDpbXX0pO3JldHVybiB0Pj1pLl9fLmxlbmd0aCYmaS5fXy5wdXNoKHt9KSxpLl9fW3RdfWZ1bmN0aW9uIGwobil7cmV0dXJuIG89MSxwKHcsbil9ZnVuY3Rpb24gcChuLHIsbyl7dmFyIGk9bSh0KyssMik7cmV0dXJuIGkudD1uLGkuX19jfHwoaS5fXz1bbz9vKHIpOncodm9pZCAwLHIpLGZ1bmN0aW9uKG4pe3ZhciB0PWkudChpLl9fWzBdLG4pO2kuX19bMF0hPT10JiYoaS5fXz1bdCxpLl9fWzFdXSxpLl9fYy5zZXRTdGF0ZSh7fSkpfV0saS5fX2M9dSksaS5fX31mdW5jdGlvbiB5KHIsbyl7dmFyIGk9bSh0KyssMyk7IW4uX19zJiZrKGkuX19ILG8pJiYoaS5fXz1yLGkuX19IPW8sdS5fX0guX19oLnB1c2goaSkpfWZ1bmN0aW9uIGgocixvKXt2YXIgaT1tKHQrKyw0KTshbi5fX3MmJmsoaS5fX0gsbykmJihpLl9fPXIsaS5fX0g9byx1Ll9faC5wdXNoKGkpKX1mdW5jdGlvbiBzKG4pe3JldHVybiBvPTUsZChmdW5jdGlvbigpe3JldHVybntjdXJyZW50Om59fSxbXSl9ZnVuY3Rpb24gXyhuLHQsdSl7bz02LGgoZnVuY3Rpb24oKXtcImZ1bmN0aW9uXCI9PXR5cGVvZiBuP24odCgpKTpuJiYobi5jdXJyZW50PXQoKSl9LG51bGw9PXU/dTp1LmNvbmNhdChuKSl9ZnVuY3Rpb24gZChuLHUpe3ZhciByPW0odCsrLDcpO3JldHVybiBrKHIuX19ILHUpJiYoci5fXz1uKCksci5fX0g9dSxyLl9faD1uKSxyLl9ffWZ1bmN0aW9uIEEobix0KXtyZXR1cm4gbz04LGQoZnVuY3Rpb24oKXtyZXR1cm4gbn0sdCl9ZnVuY3Rpb24gRihuKXt2YXIgcj11LmNvbnRleHRbbi5fX2NdLG89bSh0KyssOSk7cmV0dXJuIG8uX19jPW4scj8obnVsbD09by5fXyYmKG8uX189ITAsci5zdWIodSkpLHIucHJvcHMudmFsdWUpOm4uX199ZnVuY3Rpb24gVCh0LHUpe24udXNlRGVidWdWYWx1ZSYmbi51c2VEZWJ1Z1ZhbHVlKHU/dSh0KTp0KX1mdW5jdGlvbiBxKG4pe3ZhciByPW0odCsrLDEwKSxvPWwoKTtyZXR1cm4gci5fXz1uLHUuY29tcG9uZW50RGlkQ2F0Y2h8fCh1LmNvbXBvbmVudERpZENhdGNoPWZ1bmN0aW9uKG4pe3IuX18mJnIuX18obiksb1sxXShuKX0pLFtvWzBdLGZ1bmN0aW9uKCl7b1sxXSh2b2lkIDApfV19ZnVuY3Rpb24geCgpe2kuZm9yRWFjaChmdW5jdGlvbih0KXtpZih0Ll9fUCl0cnl7dC5fX0guX19oLmZvckVhY2goZyksdC5fX0guX19oLmZvckVhY2goaiksdC5fX0guX19oPVtdfWNhdGNoKHUpe3QuX19ILl9faD1bXSxuLl9fZSh1LHQuX192KX19KSxpPVtdfW4uX19iPWZ1bmN0aW9uKG4pe3U9bnVsbCxjJiZjKG4pfSxuLl9fcj1mdW5jdGlvbihuKXtmJiZmKG4pLHQ9MDt2YXIgcj0odT1uLl9fYykuX19IO3ImJihyLl9faC5mb3JFYWNoKGcpLHIuX19oLmZvckVhY2goaiksci5fX2g9W10pfSxuLmRpZmZlZD1mdW5jdGlvbih0KXtlJiZlKHQpO3ZhciBvPXQuX19jO28mJm8uX19IJiZvLl9fSC5fX2gubGVuZ3RoJiYoMSE9PWkucHVzaChvKSYmcj09PW4ucmVxdWVzdEFuaW1hdGlvbkZyYW1lfHwoKHI9bi5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUpfHxmdW5jdGlvbihuKXt2YXIgdCx1PWZ1bmN0aW9uKCl7Y2xlYXJUaW1lb3V0KHIpLGImJmNhbmNlbEFuaW1hdGlvbkZyYW1lKHQpLHNldFRpbWVvdXQobil9LHI9c2V0VGltZW91dCh1LDEwMCk7YiYmKHQ9cmVxdWVzdEFuaW1hdGlvbkZyYW1lKHUpKX0pKHgpKSx1PXZvaWQgMH0sbi5fX2M9ZnVuY3Rpb24odCx1KXt1LnNvbWUoZnVuY3Rpb24odCl7dHJ5e3QuX19oLmZvckVhY2goZyksdC5fX2g9dC5fX2guZmlsdGVyKGZ1bmN0aW9uKG4pe3JldHVybiFuLl9ffHxqKG4pfSl9Y2F0Y2gocil7dS5zb21lKGZ1bmN0aW9uKG4pe24uX19oJiYobi5fX2g9W10pfSksdT1bXSxuLl9fZShyLHQuX192KX19KSxhJiZhKHQsdSl9LG4udW5tb3VudD1mdW5jdGlvbih0KXt2JiZ2KHQpO3ZhciB1PXQuX19jO2lmKHUmJnUuX19IKXRyeXt1Ll9fSC5fXy5mb3JFYWNoKGcpfWNhdGNoKHQpe24uX19lKHQsdS5fX3YpfX07dmFyIGI9XCJmdW5jdGlvblwiPT10eXBlb2YgcmVxdWVzdEFuaW1hdGlvbkZyYW1lO2Z1bmN0aW9uIGcobil7dmFyIHQ9dTtcImZ1bmN0aW9uXCI9PXR5cGVvZiBuLl9fYyYmbi5fX2MoKSx1PXR9ZnVuY3Rpb24gaihuKXt2YXIgdD11O24uX19jPW4uX18oKSx1PXR9ZnVuY3Rpb24gayhuLHQpe3JldHVybiFufHxuLmxlbmd0aCE9PXQubGVuZ3RofHx0LnNvbWUoZnVuY3Rpb24odCx1KXtyZXR1cm4gdCE9PW5bdV19KX1mdW5jdGlvbiB3KG4sdCl7cmV0dXJuXCJmdW5jdGlvblwiPT10eXBlb2YgdD90KG4pOnR9ZXhwb3J0e2wgYXMgdXNlU3RhdGUscCBhcyB1c2VSZWR1Y2VyLHkgYXMgdXNlRWZmZWN0LGggYXMgdXNlTGF5b3V0RWZmZWN0LHMgYXMgdXNlUmVmLF8gYXMgdXNlSW1wZXJhdGl2ZUhhbmRsZSxkIGFzIHVzZU1lbW8sQSBhcyB1c2VDYWxsYmFjayxGIGFzIHVzZUNvbnRleHQsVCBhcyB1c2VEZWJ1Z1ZhbHVlLHEgYXMgdXNlRXJyb3JCb3VuZGFyeX07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1ob29rcy5tb2R1bGUuanMubWFwXG4iLCIvLyBzaGltIGZvciB1c2luZyBwcm9jZXNzIGluIGJyb3dzZXJcbnZhciBwcm9jZXNzID0gbW9kdWxlLmV4cG9ydHMgPSB7fTtcblxuLy8gY2FjaGVkIGZyb20gd2hhdGV2ZXIgZ2xvYmFsIGlzIHByZXNlbnQgc28gdGhhdCB0ZXN0IHJ1bm5lcnMgdGhhdCBzdHViIGl0XG4vLyBkb24ndCBicmVhayB0aGluZ3MuICBCdXQgd2UgbmVlZCB0byB3cmFwIGl0IGluIGEgdHJ5IGNhdGNoIGluIGNhc2UgaXQgaXNcbi8vIHdyYXBwZWQgaW4gc3RyaWN0IG1vZGUgY29kZSB3aGljaCBkb2Vzbid0IGRlZmluZSBhbnkgZ2xvYmFscy4gIEl0J3MgaW5zaWRlIGFcbi8vIGZ1bmN0aW9uIGJlY2F1c2UgdHJ5L2NhdGNoZXMgZGVvcHRpbWl6ZSBpbiBjZXJ0YWluIGVuZ2luZXMuXG5cbnZhciBjYWNoZWRTZXRUaW1lb3V0O1xudmFyIGNhY2hlZENsZWFyVGltZW91dDtcblxuZnVuY3Rpb24gZGVmYXVsdFNldFRpbW91dCgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3NldFRpbWVvdXQgaGFzIG5vdCBiZWVuIGRlZmluZWQnKTtcbn1cbmZ1bmN0aW9uIGRlZmF1bHRDbGVhclRpbWVvdXQgKCkge1xuICAgIHRocm93IG5ldyBFcnJvcignY2xlYXJUaW1lb3V0IGhhcyBub3QgYmVlbiBkZWZpbmVkJyk7XG59XG4oZnVuY3Rpb24gKCkge1xuICAgIHRyeSB7XG4gICAgICAgIGlmICh0eXBlb2Ygc2V0VGltZW91dCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IHNldFRpbWVvdXQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gZGVmYXVsdFNldFRpbW91dDtcbiAgICAgICAgfVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IGRlZmF1bHRTZXRUaW1vdXQ7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIGlmICh0eXBlb2YgY2xlYXJUaW1lb3V0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBjbGVhclRpbWVvdXQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBkZWZhdWx0Q2xlYXJUaW1lb3V0O1xuICAgICAgICB9XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBkZWZhdWx0Q2xlYXJUaW1lb3V0O1xuICAgIH1cbn0gKCkpXG5mdW5jdGlvbiBydW5UaW1lb3V0KGZ1bikge1xuICAgIGlmIChjYWNoZWRTZXRUaW1lb3V0ID09PSBzZXRUaW1lb3V0KSB7XG4gICAgICAgIC8vbm9ybWFsIGVudmlyb21lbnRzIGluIHNhbmUgc2l0dWF0aW9uc1xuICAgICAgICByZXR1cm4gc2V0VGltZW91dChmdW4sIDApO1xuICAgIH1cbiAgICAvLyBpZiBzZXRUaW1lb3V0IHdhc24ndCBhdmFpbGFibGUgYnV0IHdhcyBsYXR0ZXIgZGVmaW5lZFxuICAgIGlmICgoY2FjaGVkU2V0VGltZW91dCA9PT0gZGVmYXVsdFNldFRpbW91dCB8fCAhY2FjaGVkU2V0VGltZW91dCkgJiYgc2V0VGltZW91dCkge1xuICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gc2V0VGltZW91dDtcbiAgICAgICAgcmV0dXJuIHNldFRpbWVvdXQoZnVuLCAwKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgLy8gd2hlbiB3aGVuIHNvbWVib2R5IGhhcyBzY3Jld2VkIHdpdGggc2V0VGltZW91dCBidXQgbm8gSS5FLiBtYWRkbmVzc1xuICAgICAgICByZXR1cm4gY2FjaGVkU2V0VGltZW91dChmdW4sIDApO1xuICAgIH0gY2F0Y2goZSl7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBXaGVuIHdlIGFyZSBpbiBJLkUuIGJ1dCB0aGUgc2NyaXB0IGhhcyBiZWVuIGV2YWxlZCBzbyBJLkUuIGRvZXNuJ3QgdHJ1c3QgdGhlIGdsb2JhbCBvYmplY3Qgd2hlbiBjYWxsZWQgbm9ybWFsbHlcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRTZXRUaW1lb3V0LmNhbGwobnVsbCwgZnVuLCAwKTtcbiAgICAgICAgfSBjYXRjaChlKXtcbiAgICAgICAgICAgIC8vIHNhbWUgYXMgYWJvdmUgYnV0IHdoZW4gaXQncyBhIHZlcnNpb24gb2YgSS5FLiB0aGF0IG11c3QgaGF2ZSB0aGUgZ2xvYmFsIG9iamVjdCBmb3IgJ3RoaXMnLCBob3BmdWxseSBvdXIgY29udGV4dCBjb3JyZWN0IG90aGVyd2lzZSBpdCB3aWxsIHRocm93IGEgZ2xvYmFsIGVycm9yXG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkU2V0VGltZW91dC5jYWxsKHRoaXMsIGZ1biwgMCk7XG4gICAgICAgIH1cbiAgICB9XG5cblxufVxuZnVuY3Rpb24gcnVuQ2xlYXJUaW1lb3V0KG1hcmtlcikge1xuICAgIGlmIChjYWNoZWRDbGVhclRpbWVvdXQgPT09IGNsZWFyVGltZW91dCkge1xuICAgICAgICAvL25vcm1hbCBlbnZpcm9tZW50cyBpbiBzYW5lIHNpdHVhdGlvbnNcbiAgICAgICAgcmV0dXJuIGNsZWFyVGltZW91dChtYXJrZXIpO1xuICAgIH1cbiAgICAvLyBpZiBjbGVhclRpbWVvdXQgd2Fzbid0IGF2YWlsYWJsZSBidXQgd2FzIGxhdHRlciBkZWZpbmVkXG4gICAgaWYgKChjYWNoZWRDbGVhclRpbWVvdXQgPT09IGRlZmF1bHRDbGVhclRpbWVvdXQgfHwgIWNhY2hlZENsZWFyVGltZW91dCkgJiYgY2xlYXJUaW1lb3V0KSB7XG4gICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGNsZWFyVGltZW91dDtcbiAgICAgICAgcmV0dXJuIGNsZWFyVGltZW91dChtYXJrZXIpO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICAvLyB3aGVuIHdoZW4gc29tZWJvZHkgaGFzIHNjcmV3ZWQgd2l0aCBzZXRUaW1lb3V0IGJ1dCBubyBJLkUuIG1hZGRuZXNzXG4gICAgICAgIHJldHVybiBjYWNoZWRDbGVhclRpbWVvdXQobWFya2VyKTtcbiAgICB9IGNhdGNoIChlKXtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIFdoZW4gd2UgYXJlIGluIEkuRS4gYnV0IHRoZSBzY3JpcHQgaGFzIGJlZW4gZXZhbGVkIHNvIEkuRS4gZG9lc24ndCAgdHJ1c3QgdGhlIGdsb2JhbCBvYmplY3Qgd2hlbiBjYWxsZWQgbm9ybWFsbHlcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRDbGVhclRpbWVvdXQuY2FsbChudWxsLCBtYXJrZXIpO1xuICAgICAgICB9IGNhdGNoIChlKXtcbiAgICAgICAgICAgIC8vIHNhbWUgYXMgYWJvdmUgYnV0IHdoZW4gaXQncyBhIHZlcnNpb24gb2YgSS5FLiB0aGF0IG11c3QgaGF2ZSB0aGUgZ2xvYmFsIG9iamVjdCBmb3IgJ3RoaXMnLCBob3BmdWxseSBvdXIgY29udGV4dCBjb3JyZWN0IG90aGVyd2lzZSBpdCB3aWxsIHRocm93IGEgZ2xvYmFsIGVycm9yLlxuICAgICAgICAgICAgLy8gU29tZSB2ZXJzaW9ucyBvZiBJLkUuIGhhdmUgZGlmZmVyZW50IHJ1bGVzIGZvciBjbGVhclRpbWVvdXQgdnMgc2V0VGltZW91dFxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZENsZWFyVGltZW91dC5jYWxsKHRoaXMsIG1hcmtlcik7XG4gICAgICAgIH1cbiAgICB9XG5cblxuXG59XG52YXIgcXVldWUgPSBbXTtcbnZhciBkcmFpbmluZyA9IGZhbHNlO1xudmFyIGN1cnJlbnRRdWV1ZTtcbnZhciBxdWV1ZUluZGV4ID0gLTE7XG5cbmZ1bmN0aW9uIGNsZWFuVXBOZXh0VGljaygpIHtcbiAgICBpZiAoIWRyYWluaW5nIHx8ICFjdXJyZW50UXVldWUpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBkcmFpbmluZyA9IGZhbHNlO1xuICAgIGlmIChjdXJyZW50UXVldWUubGVuZ3RoKSB7XG4gICAgICAgIHF1ZXVlID0gY3VycmVudFF1ZXVlLmNvbmNhdChxdWV1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcXVldWVJbmRleCA9IC0xO1xuICAgIH1cbiAgICBpZiAocXVldWUubGVuZ3RoKSB7XG4gICAgICAgIGRyYWluUXVldWUoKTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGRyYWluUXVldWUoKSB7XG4gICAgaWYgKGRyYWluaW5nKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIHRpbWVvdXQgPSBydW5UaW1lb3V0KGNsZWFuVXBOZXh0VGljayk7XG4gICAgZHJhaW5pbmcgPSB0cnVlO1xuXG4gICAgdmFyIGxlbiA9IHF1ZXVlLmxlbmd0aDtcbiAgICB3aGlsZShsZW4pIHtcbiAgICAgICAgY3VycmVudFF1ZXVlID0gcXVldWU7XG4gICAgICAgIHF1ZXVlID0gW107XG4gICAgICAgIHdoaWxlICgrK3F1ZXVlSW5kZXggPCBsZW4pIHtcbiAgICAgICAgICAgIGlmIChjdXJyZW50UXVldWUpIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50UXVldWVbcXVldWVJbmRleF0ucnVuKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcXVldWVJbmRleCA9IC0xO1xuICAgICAgICBsZW4gPSBxdWV1ZS5sZW5ndGg7XG4gICAgfVxuICAgIGN1cnJlbnRRdWV1ZSA9IG51bGw7XG4gICAgZHJhaW5pbmcgPSBmYWxzZTtcbiAgICBydW5DbGVhclRpbWVvdXQodGltZW91dCk7XG59XG5cbnByb2Nlc3MubmV4dFRpY2sgPSBmdW5jdGlvbiAoZnVuKSB7XG4gICAgdmFyIGFyZ3MgPSBuZXcgQXJyYXkoYXJndW1lbnRzLmxlbmd0aCAtIDEpO1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSkge1xuICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgYXJnc1tpIC0gMV0gPSBhcmd1bWVudHNbaV07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcXVldWUucHVzaChuZXcgSXRlbShmdW4sIGFyZ3MpKTtcbiAgICBpZiAocXVldWUubGVuZ3RoID09PSAxICYmICFkcmFpbmluZykge1xuICAgICAgICBydW5UaW1lb3V0KGRyYWluUXVldWUpO1xuICAgIH1cbn07XG5cbi8vIHY4IGxpa2VzIHByZWRpY3RpYmxlIG9iamVjdHNcbmZ1bmN0aW9uIEl0ZW0oZnVuLCBhcnJheSkge1xuICAgIHRoaXMuZnVuID0gZnVuO1xuICAgIHRoaXMuYXJyYXkgPSBhcnJheTtcbn1cbkl0ZW0ucHJvdG90eXBlLnJ1biA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmZ1bi5hcHBseShudWxsLCB0aGlzLmFycmF5KTtcbn07XG5wcm9jZXNzLnRpdGxlID0gJ2Jyb3dzZXInO1xucHJvY2Vzcy5icm93c2VyID0gdHJ1ZTtcbnByb2Nlc3MuZW52ID0ge307XG5wcm9jZXNzLmFyZ3YgPSBbXTtcbnByb2Nlc3MudmVyc2lvbiA9ICcnOyAvLyBlbXB0eSBzdHJpbmcgdG8gYXZvaWQgcmVnZXhwIGlzc3Vlc1xucHJvY2Vzcy52ZXJzaW9ucyA9IHt9O1xuXG5mdW5jdGlvbiBub29wKCkge31cblxucHJvY2Vzcy5vbiA9IG5vb3A7XG5wcm9jZXNzLmFkZExpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3Mub25jZSA9IG5vb3A7XG5wcm9jZXNzLm9mZiA9IG5vb3A7XG5wcm9jZXNzLnJlbW92ZUxpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3MucmVtb3ZlQWxsTGlzdGVuZXJzID0gbm9vcDtcbnByb2Nlc3MuZW1pdCA9IG5vb3A7XG5wcm9jZXNzLnByZXBlbmRMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLnByZXBlbmRPbmNlTGlzdGVuZXIgPSBub29wO1xuXG5wcm9jZXNzLmxpc3RlbmVycyA9IGZ1bmN0aW9uIChuYW1lKSB7IHJldHVybiBbXSB9XG5cbnByb2Nlc3MuYmluZGluZyA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdwcm9jZXNzLmJpbmRpbmcgaXMgbm90IHN1cHBvcnRlZCcpO1xufTtcblxucHJvY2Vzcy5jd2QgPSBmdW5jdGlvbiAoKSB7IHJldHVybiAnLycgfTtcbnByb2Nlc3MuY2hkaXIgPSBmdW5jdGlvbiAoZGlyKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdwcm9jZXNzLmNoZGlyIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbn07XG5wcm9jZXNzLnVtYXNrID0gZnVuY3Rpb24oKSB7IHJldHVybiAwOyB9O1xuIiwiaW1wb3J0IHsgaXNWYWxpZEVsZW1lbnQsIHVzZVJlZiwgdXNlU3RhdGUsIHVzZUNhbGxiYWNrLCB1c2VFZmZlY3QsIGNyZWF0ZUNvbnRleHQsIHVzZUNvbnRleHQsIGNyZWF0ZUVsZW1lbnQsIGNsb25lRWxlbWVudCwgRnJhZ21lbnQgfSBmcm9tICdyZWFjdCc7XG5cbnZhciBpc051bGxPclVuZGVmaW5lZCA9ICh2YWx1ZSkgPT4gdmFsdWUgPT0gbnVsbDtcblxudmFyIGlzQXJyYXkgPSAodmFsdWUpID0+IEFycmF5LmlzQXJyYXkodmFsdWUpO1xuXG5jb25zdCBpc09iamVjdFR5cGUgPSAodmFsdWUpID0+IHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCc7XHJcbnZhciBpc09iamVjdCA9ICh2YWx1ZSkgPT4gIWlzTnVsbE9yVW5kZWZpbmVkKHZhbHVlKSAmJiAhaXNBcnJheSh2YWx1ZSkgJiYgaXNPYmplY3RUeXBlKHZhbHVlKTtcblxudmFyIGlzSFRNTEVsZW1lbnQgPSAodmFsdWUpID0+IGlzT2JqZWN0KHZhbHVlKSAmJiB2YWx1ZS5ub2RlVHlwZSA9PT0gTm9kZS5FTEVNRU5UX05PREU7XG5cbmNvbnN0IFZBTElEQVRJT05fTU9ERSA9IHtcclxuICAgIG9uQmx1cjogJ29uQmx1cicsXHJcbiAgICBvbkNoYW5nZTogJ29uQ2hhbmdlJyxcclxuICAgIG9uU3VibWl0OiAnb25TdWJtaXQnLFxyXG59O1xyXG5jb25zdCBWQUxVRSA9ICd2YWx1ZSc7XHJcbmNvbnN0IFVOREVGSU5FRCA9ICd1bmRlZmluZWQnO1xyXG5jb25zdCBFVkVOVFMgPSB7XHJcbiAgICBCTFVSOiAnYmx1cicsXHJcbiAgICBDSEFOR0U6ICdjaGFuZ2UnLFxyXG4gICAgSU5QVVQ6ICdpbnB1dCcsXHJcbn07XHJcbmNvbnN0IFNFTEVDVCA9ICdzZWxlY3QnO1xyXG5jb25zdCBJTlBVVF9WQUxJREFUSU9OX1JVTEVTID0ge1xyXG4gICAgbWF4OiAnbWF4JyxcclxuICAgIG1pbjogJ21pbicsXHJcbiAgICBtYXhMZW5ndGg6ICdtYXhMZW5ndGgnLFxyXG4gICAgbWluTGVuZ3RoOiAnbWluTGVuZ3RoJyxcclxuICAgIHBhdHRlcm46ICdwYXR0ZXJuJyxcclxuICAgIHJlcXVpcmVkOiAncmVxdWlyZWQnLFxyXG4gICAgdmFsaWRhdGU6ICd2YWxpZGF0ZScsXHJcbn07XHJcbmNvbnN0IFJFR0VYX0lTX0RFRVBfUFJPUCA9IC9cXC58XFxbKD86W15bXFxdXSp8KFtcIiddKSg/Oig/IVxcMSlbXlxcXFxdfFxcXFwuKSo/XFwxKVxcXS87XHJcbmNvbnN0IFJFR0VYX0lTX1BMQUlOX1BST1AgPSAvXlxcdyokLztcclxuY29uc3QgUkVHRVhfUFJPUF9OQU1FID0gL1teLltcXF1dK3xcXFsoPzooLT9cXGQrKD86XFwuXFxkKyk/KXwoW1wiJ10pKCg/Oig/IVxcMilbXlxcXFxdfFxcXFwuKSo/KVxcMilcXF18KD89KD86XFwufFxcW1xcXSkoPzpcXC58XFxbXFxdfCQpKS9nO1xyXG5jb25zdCBSRUdFWF9FU0NBUEVfQ0hBUiA9IC9cXFxcKFxcXFwpPy9nO1xyXG5jb25zdCBSRUdFWF9BUlJBWV9GSUVMRF9JTkRFWCA9IC9bXFxkK10vZztcblxuZnVuY3Rpb24gYXR0YWNoRXZlbnRMaXN0ZW5lcnMoeyBmaWVsZDogeyByZWYgfSwgaGFuZGxlQ2hhbmdlLCBpc1JhZGlvT3JDaGVja2JveCwgfSkge1xyXG4gICAgaWYgKGlzSFRNTEVsZW1lbnQocmVmKSAmJiBoYW5kbGVDaGFuZ2UpIHtcclxuICAgICAgICByZWYuYWRkRXZlbnRMaXN0ZW5lcihpc1JhZGlvT3JDaGVja2JveCA/IEVWRU5UUy5DSEFOR0UgOiBFVkVOVFMuSU5QVVQsIGhhbmRsZUNoYW5nZSk7XHJcbiAgICAgICAgcmVmLmFkZEV2ZW50TGlzdGVuZXIoRVZFTlRTLkJMVVIsIGhhbmRsZUNoYW5nZSk7XHJcbiAgICB9XHJcbn1cblxudmFyIGlzS2V5ID0gKHZhbHVlKSA9PiAhaXNBcnJheSh2YWx1ZSkgJiZcclxuICAgIChSRUdFWF9JU19QTEFJTl9QUk9QLnRlc3QodmFsdWUpIHx8ICFSRUdFWF9JU19ERUVQX1BST1AudGVzdCh2YWx1ZSkpO1xuXG52YXIgc3RyaW5nVG9QYXRoID0gKHN0cmluZykgPT4ge1xyXG4gICAgY29uc3QgcmVzdWx0ID0gW107XHJcbiAgICBzdHJpbmcucmVwbGFjZShSRUdFWF9QUk9QX05BTUUsIChtYXRjaCwgbnVtYmVyLCBxdW90ZSwgc3RyaW5nKSA9PiB7XHJcbiAgICAgICAgcmVzdWx0LnB1c2gocXVvdGUgPyBzdHJpbmcucmVwbGFjZShSRUdFWF9FU0NBUEVfQ0hBUiwgJyQxJykgOiBudW1iZXIgfHwgbWF0Y2gpO1xyXG4gICAgfSk7XHJcbiAgICByZXR1cm4gcmVzdWx0O1xyXG59O1xuXG5mdW5jdGlvbiBzZXQob2JqZWN0LCBwYXRoLCB2YWx1ZSkge1xyXG4gICAgbGV0IGluZGV4ID0gLTE7XHJcbiAgICBjb25zdCB0ZW1wUGF0aCA9IGlzS2V5KHBhdGgpID8gW3BhdGhdIDogc3RyaW5nVG9QYXRoKHBhdGgpO1xyXG4gICAgY29uc3QgbGVuZ3RoID0gdGVtcFBhdGgubGVuZ3RoO1xyXG4gICAgY29uc3QgbGFzdEluZGV4ID0gbGVuZ3RoIC0gMTtcclxuICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XHJcbiAgICAgICAgY29uc3Qga2V5ID0gdGVtcFBhdGhbaW5kZXhdO1xyXG4gICAgICAgIGxldCBuZXdWYWx1ZSA9IHZhbHVlO1xyXG4gICAgICAgIGlmIChpbmRleCAhPT0gbGFzdEluZGV4KSB7XHJcbiAgICAgICAgICAgIGNvbnN0IG9ialZhbHVlID0gb2JqZWN0W2tleV07XHJcbiAgICAgICAgICAgIG5ld1ZhbHVlID1cclxuICAgICAgICAgICAgICAgIGlzT2JqZWN0KG9ialZhbHVlKSB8fCBpc0FycmF5KG9ialZhbHVlKVxyXG4gICAgICAgICAgICAgICAgICAgID8gb2JqVmFsdWVcclxuICAgICAgICAgICAgICAgICAgICA6ICFpc05hTigrdGVtcFBhdGhbaW5kZXggKyAxXSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgPyBbXVxyXG4gICAgICAgICAgICAgICAgICAgICAgICA6IHt9O1xyXG4gICAgICAgIH1cclxuICAgICAgICBvYmplY3Rba2V5XSA9IG5ld1ZhbHVlO1xyXG4gICAgICAgIG9iamVjdCA9IG9iamVjdFtrZXldO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIG9iamVjdDtcclxufVxuXG52YXIgdHJhbnNmb3JtVG9OZXN0T2JqZWN0ID0gKGRhdGEpID0+IE9iamVjdC5lbnRyaWVzKGRhdGEpLnJlZHVjZSgocHJldmlvdXMsIFtrZXksIHZhbHVlXSkgPT4ge1xyXG4gICAgaWYgKCFpc0tleShrZXkpKSB7XHJcbiAgICAgICAgc2V0KHByZXZpb3VzLCBrZXksIHZhbHVlKTtcclxuICAgICAgICByZXR1cm4gcHJldmlvdXM7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBwcmV2aW91cyksIHsgW2tleV06IHZhbHVlIH0pO1xyXG59LCB7fSk7XG5cbnZhciBpc1VuZGVmaW5lZCA9ICh2YWwpID0+IHZhbCA9PT0gdW5kZWZpbmVkO1xuXG52YXIgZ2V0ID0gKG9iaiwgcGF0aCwgZGVmYXVsdFZhbHVlKSA9PiB7XHJcbiAgICBjb25zdCByZXN1bHQgPSBwYXRoXHJcbiAgICAgICAgLnNwbGl0KC9bLFtcXF0uXSs/LylcclxuICAgICAgICAuZmlsdGVyKEJvb2xlYW4pXHJcbiAgICAgICAgLnJlZHVjZSgocmVzdWx0LCBrZXkpID0+IChpc051bGxPclVuZGVmaW5lZChyZXN1bHQpID8gcmVzdWx0IDogcmVzdWx0W2tleV0pLCBvYmopO1xyXG4gICAgcmV0dXJuIGlzVW5kZWZpbmVkKHJlc3VsdCkgfHwgcmVzdWx0ID09PSBvYmpcclxuICAgICAgICA/IGlzVW5kZWZpbmVkKG9ialtwYXRoXSlcclxuICAgICAgICAgICAgPyBkZWZhdWx0VmFsdWVcclxuICAgICAgICAgICAgOiBvYmpbcGF0aF1cclxuICAgICAgICA6IHJlc3VsdDtcclxufTtcblxudmFyIGZvY3VzT25FcnJvckZpZWxkID0gKGZpZWxkcywgZmllbGRFcnJvcnMpID0+IHtcclxuICAgIGZvciAoY29uc3Qga2V5IGluIGZpZWxkcykge1xyXG4gICAgICAgIGlmIChnZXQoZmllbGRFcnJvcnMsIGtleSkpIHtcclxuICAgICAgICAgICAgY29uc3QgZmllbGQgPSBmaWVsZHNba2V5XTtcclxuICAgICAgICAgICAgaWYgKGZpZWxkKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoZmllbGQucmVmLmZvY3VzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZmllbGQucmVmLmZvY3VzKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChmaWVsZC5vcHRpb25zKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZmllbGQub3B0aW9uc1swXS5yZWYuZm9jdXMoKTtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxufTtcblxudmFyIHJlbW92ZUFsbEV2ZW50TGlzdGVuZXJzID0gKHJlZiwgdmFsaWRhdGVXaXRoU3RhdGVVcGRhdGUpID0+IHtcclxuICAgIGlmIChpc0hUTUxFbGVtZW50KHJlZikgJiYgcmVmLnJlbW92ZUV2ZW50TGlzdGVuZXIpIHtcclxuICAgICAgICByZWYucmVtb3ZlRXZlbnRMaXN0ZW5lcihFVkVOVFMuSU5QVVQsIHZhbGlkYXRlV2l0aFN0YXRlVXBkYXRlKTtcclxuICAgICAgICByZWYucmVtb3ZlRXZlbnRMaXN0ZW5lcihFVkVOVFMuQ0hBTkdFLCB2YWxpZGF0ZVdpdGhTdGF0ZVVwZGF0ZSk7XHJcbiAgICAgICAgcmVmLnJlbW92ZUV2ZW50TGlzdGVuZXIoRVZFTlRTLkJMVVIsIHZhbGlkYXRlV2l0aFN0YXRlVXBkYXRlKTtcclxuICAgIH1cclxufTtcblxudmFyIGlzUmFkaW9JbnB1dCA9IChlbGVtZW50KSA9PiBlbGVtZW50LnR5cGUgPT09ICdyYWRpbyc7XG5cbnZhciBpc0NoZWNrQm94SW5wdXQgPSAoZWxlbWVudCkgPT4gZWxlbWVudC50eXBlID09PSAnY2hlY2tib3gnO1xuXG5mdW5jdGlvbiBpc0RldGFjaGVkKGVsZW1lbnQpIHtcclxuICAgIGlmICghZWxlbWVudCkge1xyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfVxyXG4gICAgaWYgKCEoZWxlbWVudCBpbnN0YW5jZW9mIEhUTUxFbGVtZW50KSB8fFxyXG4gICAgICAgIGVsZW1lbnQubm9kZVR5cGUgPT09IE5vZGUuRE9DVU1FTlRfTk9ERSkge1xyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuICAgIHJldHVybiBpc0RldGFjaGVkKGVsZW1lbnQucGFyZW50Tm9kZSk7XHJcbn1cblxudmFyIGlzRW1wdHlPYmplY3QgPSAodmFsdWUpID0+IGlzT2JqZWN0KHZhbHVlKSAmJiAhT2JqZWN0LmtleXModmFsdWUpLmxlbmd0aDtcblxuZnVuY3Rpb24gY2FzdFBhdGgodmFsdWUpIHtcclxuICAgIHJldHVybiBpc0FycmF5KHZhbHVlKSA/IHZhbHVlIDogc3RyaW5nVG9QYXRoKHZhbHVlKTtcclxufVxyXG5mdW5jdGlvbiBiYXNlR2V0KG9iamVjdCwgcGF0aCkge1xyXG4gICAgY29uc3QgdXBkYXRlUGF0aCA9IGlzS2V5KHBhdGgpID8gW3BhdGhdIDogY2FzdFBhdGgocGF0aCk7XHJcbiAgICBjb25zdCBsZW5ndGggPSBwYXRoLmxlbmd0aDtcclxuICAgIGxldCBpbmRleCA9IDA7XHJcbiAgICB3aGlsZSAoaW5kZXggPCBsZW5ndGgpIHtcclxuICAgICAgICBvYmplY3QgPSBpc1VuZGVmaW5lZChvYmplY3QpID8gaW5kZXgrKyA6IG9iamVjdFt1cGRhdGVQYXRoW2luZGV4KytdXTtcclxuICAgIH1cclxuICAgIHJldHVybiBpbmRleCA9PSBsZW5ndGggPyBvYmplY3QgOiB1bmRlZmluZWQ7XHJcbn1cclxuZnVuY3Rpb24gYmFzZVNsaWNlKGFycmF5LCBzdGFydCwgZW5kKSB7XHJcbiAgICBsZXQgaW5kZXggPSAtMTtcclxuICAgIGxldCBsZW5ndGggPSBhcnJheS5sZW5ndGg7XHJcbiAgICBpZiAoc3RhcnQgPCAwKSB7XHJcbiAgICAgICAgc3RhcnQgPSAtc3RhcnQgPiBsZW5ndGggPyAwIDogbGVuZ3RoICsgc3RhcnQ7XHJcbiAgICB9XHJcbiAgICBlbmQgPSBlbmQgPiBsZW5ndGggPyBsZW5ndGggOiBlbmQ7XHJcbiAgICBpZiAoZW5kIDwgMCkge1xyXG4gICAgICAgIGVuZCArPSBsZW5ndGg7XHJcbiAgICB9XHJcbiAgICBsZW5ndGggPSBzdGFydCA+IGVuZCA/IDAgOiBlbmQgLSBzdGFydDtcclxuICAgIGNvbnN0IHJlc3VsdCA9IEFycmF5KGxlbmd0aCk7XHJcbiAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xyXG4gICAgICAgIHJlc3VsdFtpbmRleF0gPSBhcnJheVtpbmRleCArIHN0YXJ0XTtcclxuICAgIH1cclxuICAgIHJldHVybiByZXN1bHQ7XHJcbn1cclxuZnVuY3Rpb24gcGFyZW50KG9iamVjdCwgcGF0aCkge1xyXG4gICAgcmV0dXJuIHBhdGgubGVuZ3RoID09IDEgPyBvYmplY3QgOiBiYXNlR2V0KG9iamVjdCwgYmFzZVNsaWNlKHBhdGgsIDAsIC0xKSk7XHJcbn1cclxuZnVuY3Rpb24gYmFzZVVuc2V0KG9iamVjdCwgcGF0aCkge1xyXG4gICAgY29uc3QgdXBkYXRlUGF0aCA9IGlzS2V5KHBhdGgpID8gW3BhdGhdIDogY2FzdFBhdGgocGF0aCk7XHJcbiAgICBjb25zdCBjaGlsZE9iamVjdCA9IHBhcmVudChvYmplY3QsIHVwZGF0ZVBhdGgpO1xyXG4gICAgY29uc3Qga2V5ID0gdXBkYXRlUGF0aFt1cGRhdGVQYXRoLmxlbmd0aCAtIDFdO1xyXG4gICAgY29uc3QgcmVzdWx0ID0gIShjaGlsZE9iamVjdCAhPSBudWxsKSB8fCBkZWxldGUgY2hpbGRPYmplY3Rba2V5XTtcclxuICAgIGxldCBwcmV2aW91c09ialJlZiA9IHVuZGVmaW5lZDtcclxuICAgIGZvciAobGV0IGsgPSAwOyBrIDwgdXBkYXRlUGF0aC5zbGljZSgwLCAtMSkubGVuZ3RoOyBrKyspIHtcclxuICAgICAgICBsZXQgaW5kZXggPSAtMTtcclxuICAgICAgICBsZXQgb2JqZWN0UmVmID0gdW5kZWZpbmVkO1xyXG4gICAgICAgIGNvbnN0IGN1cnJlbnRQYXRocyA9IHVwZGF0ZVBhdGguc2xpY2UoMCwgLShrICsgMSkpO1xyXG4gICAgICAgIGNvbnN0IGN1cnJlbnRQYXRoc0xlbmd0aCA9IGN1cnJlbnRQYXRocy5sZW5ndGggLSAxO1xyXG4gICAgICAgIGlmIChrID4gMCkge1xyXG4gICAgICAgICAgICBwcmV2aW91c09ialJlZiA9IG9iamVjdDtcclxuICAgICAgICB9XHJcbiAgICAgICAgd2hpbGUgKCsraW5kZXggPCBjdXJyZW50UGF0aHMubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGl0ZW0gPSBjdXJyZW50UGF0aHNbaW5kZXhdO1xyXG4gICAgICAgICAgICBvYmplY3RSZWYgPSBvYmplY3RSZWYgPyBvYmplY3RSZWZbaXRlbV0gOiBvYmplY3RbaXRlbV07XHJcbiAgICAgICAgICAgIGlmIChjdXJyZW50UGF0aHNMZW5ndGggPT09IGluZGV4KSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoKGlzT2JqZWN0KG9iamVjdFJlZikgJiYgaXNFbXB0eU9iamVjdChvYmplY3RSZWYpKSB8fFxyXG4gICAgICAgICAgICAgICAgICAgIChpc0FycmF5KG9iamVjdFJlZikgJiZcclxuICAgICAgICAgICAgICAgICAgICAgICAgIW9iamVjdFJlZi5maWx0ZXIoKGRhdGEpID0+IGlzT2JqZWN0KGRhdGEpICYmICFpc0VtcHR5T2JqZWN0KGRhdGEpKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLmxlbmd0aCkpIHtcclxuICAgICAgICAgICAgICAgICAgICBwcmV2aW91c09ialJlZiA/IGRlbGV0ZSBwcmV2aW91c09ialJlZltpdGVtXSA6IGRlbGV0ZSBvYmplY3RbaXRlbV07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcHJldmlvdXNPYmpSZWYgPSBvYmplY3RSZWY7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIHJlc3VsdDtcclxufVxyXG5mdW5jdGlvbiB1bnNldChvYmplY3QsIHBhdGhzKSB7XHJcbiAgICBwYXRocy5mb3JFYWNoKChwYXRoKSA9PiB7XHJcbiAgICAgICAgYmFzZVVuc2V0KG9iamVjdCwgcGF0aCk7XHJcbiAgICB9KTtcclxuICAgIHJldHVybiBvYmplY3Q7XHJcbn1cblxuY29uc3QgaXNTYW1lUmVmID0gKGZpZWxkVmFsdWUsIHJlZikgPT4gZmllbGRWYWx1ZSAmJiBmaWVsZFZhbHVlLnJlZiA9PT0gcmVmO1xyXG5mdW5jdGlvbiBmaW5kUmVtb3ZlZEZpZWxkQW5kUmVtb3ZlTGlzdGVuZXIoZmllbGRzLCBoYW5kbGVDaGFuZ2UsIGZpZWxkLCBmb3JjZURlbGV0ZSkge1xyXG4gICAgY29uc3QgeyByZWYsIHJlZjogeyBuYW1lLCB0eXBlIH0sIG11dGF0aW9uV2F0Y2hlciwgfSA9IGZpZWxkO1xyXG4gICAgY29uc3QgZmllbGRWYWx1ZSA9IGZpZWxkc1tuYW1lXTtcclxuICAgIGlmICghdHlwZSkge1xyXG4gICAgICAgIGRlbGV0ZSBmaWVsZHNbbmFtZV07XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gICAgaWYgKChpc1JhZGlvSW5wdXQocmVmKSB8fCBpc0NoZWNrQm94SW5wdXQocmVmKSkgJiYgZmllbGRWYWx1ZSkge1xyXG4gICAgICAgIGNvbnN0IHsgb3B0aW9ucyB9ID0gZmllbGRWYWx1ZTtcclxuICAgICAgICBpZiAoaXNBcnJheShvcHRpb25zKSAmJiBvcHRpb25zLmxlbmd0aCkge1xyXG4gICAgICAgICAgICBvcHRpb25zLmZpbHRlcihCb29sZWFuKS5mb3JFYWNoKChvcHRpb24sIGluZGV4KSA9PiB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCB7IHJlZiwgbXV0YXRpb25XYXRjaGVyIH0gPSBvcHRpb247XHJcbiAgICAgICAgICAgICAgICBpZiAoKHJlZiAmJiBpc0RldGFjaGVkKHJlZikgJiYgaXNTYW1lUmVmKG9wdGlvbiwgcmVmKSkgfHwgZm9yY2VEZWxldGUpIHtcclxuICAgICAgICAgICAgICAgICAgICByZW1vdmVBbGxFdmVudExpc3RlbmVycyhyZWYsIGhhbmRsZUNoYW5nZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKG11dGF0aW9uV2F0Y2hlcikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBtdXRhdGlvbldhdGNoZXIuZGlzY29ubmVjdCgpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB1bnNldChvcHRpb25zLCBbYFske2luZGV4fV1gXSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICBpZiAob3B0aW9ucyAmJiAhb3B0aW9ucy5maWx0ZXIoQm9vbGVhbikubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgICBkZWxldGUgZmllbGRzW25hbWVdO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBkZWxldGUgZmllbGRzW25hbWVdO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGVsc2UgaWYgKChpc0RldGFjaGVkKHJlZikgJiYgaXNTYW1lUmVmKGZpZWxkVmFsdWUsIHJlZikpIHx8IGZvcmNlRGVsZXRlKSB7XHJcbiAgICAgICAgcmVtb3ZlQWxsRXZlbnRMaXN0ZW5lcnMocmVmLCBoYW5kbGVDaGFuZ2UpO1xyXG4gICAgICAgIGlmIChtdXRhdGlvbldhdGNoZXIpIHtcclxuICAgICAgICAgICAgbXV0YXRpb25XYXRjaGVyLmRpc2Nvbm5lY3QoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZGVsZXRlIGZpZWxkc1tuYW1lXTtcclxuICAgIH1cclxufVxuXG5jb25zdCBkZWZhdWx0UmV0dXJuID0ge1xyXG4gICAgaXNWYWxpZDogZmFsc2UsXHJcbiAgICB2YWx1ZTogJycsXHJcbn07XHJcbnZhciBnZXRSYWRpb1ZhbHVlID0gKG9wdGlvbnMpID0+IGlzQXJyYXkob3B0aW9ucylcclxuICAgID8gb3B0aW9ucy5yZWR1Y2UoKHByZXZpb3VzLCBvcHRpb24pID0+IG9wdGlvbiAmJiBvcHRpb24ucmVmLmNoZWNrZWRcclxuICAgICAgICA/IHtcclxuICAgICAgICAgICAgaXNWYWxpZDogdHJ1ZSxcclxuICAgICAgICAgICAgdmFsdWU6IG9wdGlvbi5yZWYudmFsdWUsXHJcbiAgICAgICAgfVxyXG4gICAgICAgIDogcHJldmlvdXMsIGRlZmF1bHRSZXR1cm4pXHJcbiAgICA6IGRlZmF1bHRSZXR1cm47XG5cbnZhciBnZXRNdWx0aXBsZVNlbGVjdFZhbHVlID0gKG9wdGlvbnMpID0+IFsuLi5vcHRpb25zXVxyXG4gICAgLmZpbHRlcigoeyBzZWxlY3RlZCB9KSA9PiBzZWxlY3RlZClcclxuICAgIC5tYXAoKHsgdmFsdWUgfSkgPT4gdmFsdWUpO1xuXG52YXIgaXNGaWxlSW5wdXQgPSAoZWxlbWVudCkgPT4gZWxlbWVudC50eXBlID09PSAnZmlsZSc7XG5cbnZhciBpc011bHRpcGxlU2VsZWN0ID0gKGVsZW1lbnQpID0+IGVsZW1lbnQudHlwZSA9PT0gYCR7U0VMRUNUfS1tdWx0aXBsZWA7XG5cbnZhciBpc0VtcHR5U3RyaW5nID0gKHZhbHVlKSA9PiB2YWx1ZSA9PT0gJyc7XG5cbmNvbnN0IGRlZmF1bHRSZXN1bHQgPSB7XHJcbiAgICB2YWx1ZTogZmFsc2UsXHJcbiAgICBpc1ZhbGlkOiBmYWxzZSxcclxufTtcclxuY29uc3QgdmFsaWRSZXN1bHQgPSB7IHZhbHVlOiB0cnVlLCBpc1ZhbGlkOiB0cnVlIH07XHJcbnZhciBnZXRDaGVja2JveFZhbHVlID0gKG9wdGlvbnMpID0+IHtcclxuICAgIGlmIChpc0FycmF5KG9wdGlvbnMpKSB7XHJcbiAgICAgICAgaWYgKG9wdGlvbnMubGVuZ3RoID4gMSkge1xyXG4gICAgICAgICAgICBjb25zdCB2YWx1ZXMgPSBvcHRpb25zXHJcbiAgICAgICAgICAgICAgICAuZmlsdGVyKChvcHRpb24pID0+IG9wdGlvbiAmJiBvcHRpb24ucmVmLmNoZWNrZWQpXHJcbiAgICAgICAgICAgICAgICAubWFwKCh7IHJlZjogeyB2YWx1ZSB9IH0pID0+IHZhbHVlKTtcclxuICAgICAgICAgICAgcmV0dXJuIHsgdmFsdWU6IHZhbHVlcywgaXNWYWxpZDogISF2YWx1ZXMubGVuZ3RoIH07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IHsgY2hlY2tlZCwgdmFsdWUsIGF0dHJpYnV0ZXMgfSA9IG9wdGlvbnNbMF0ucmVmO1xyXG4gICAgICAgIHJldHVybiBjaGVja2VkXHJcbiAgICAgICAgICAgID8gYXR0cmlidXRlcyAmJiAhaXNVbmRlZmluZWQoYXR0cmlidXRlcy52YWx1ZSlcclxuICAgICAgICAgICAgICAgID8gaXNVbmRlZmluZWQodmFsdWUpIHx8IGlzRW1wdHlTdHJpbmcodmFsdWUpXHJcbiAgICAgICAgICAgICAgICAgICAgPyB2YWxpZFJlc3VsdFxyXG4gICAgICAgICAgICAgICAgICAgIDogeyB2YWx1ZTogdmFsdWUsIGlzVmFsaWQ6IHRydWUgfVxyXG4gICAgICAgICAgICAgICAgOiB2YWxpZFJlc3VsdFxyXG4gICAgICAgICAgICA6IGRlZmF1bHRSZXN1bHQ7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gZGVmYXVsdFJlc3VsdDtcclxufTtcblxuZnVuY3Rpb24gZ2V0RmllbGRWYWx1ZShmaWVsZHMsIHJlZikge1xyXG4gICAgY29uc3QgeyBuYW1lLCB2YWx1ZSB9ID0gcmVmO1xyXG4gICAgY29uc3QgZmllbGQgPSBmaWVsZHNbbmFtZV07XHJcbiAgICBpZiAoaXNGaWxlSW5wdXQocmVmKSkge1xyXG4gICAgICAgIHJldHVybiByZWYuZmlsZXM7XHJcbiAgICB9XHJcbiAgICBpZiAoaXNSYWRpb0lucHV0KHJlZikpIHtcclxuICAgICAgICByZXR1cm4gZmllbGQgPyBnZXRSYWRpb1ZhbHVlKGZpZWxkLm9wdGlvbnMpLnZhbHVlIDogJyc7XHJcbiAgICB9XHJcbiAgICBpZiAoaXNNdWx0aXBsZVNlbGVjdChyZWYpKSB7XHJcbiAgICAgICAgcmV0dXJuIGdldE11bHRpcGxlU2VsZWN0VmFsdWUocmVmLm9wdGlvbnMpO1xyXG4gICAgfVxyXG4gICAgaWYgKGlzQ2hlY2tCb3hJbnB1dChyZWYpKSB7XHJcbiAgICAgICAgcmV0dXJuIGZpZWxkID8gZ2V0Q2hlY2tib3hWYWx1ZShmaWVsZC5vcHRpb25zKS52YWx1ZSA6IGZhbHNlO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHZhbHVlO1xyXG59XG5cbnZhciBpc1N0cmluZyA9ICh2YWx1ZSkgPT4gdHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJztcblxudmFyIGdldEZpZWxkc1ZhbHVlcyA9IChmaWVsZHMsIHNlYXJjaCkgPT4ge1xyXG4gICAgY29uc3Qgb3V0cHV0ID0ge307XHJcbiAgICBmb3IgKGNvbnN0IG5hbWUgaW4gZmllbGRzKSB7XHJcbiAgICAgICAgaWYgKGlzVW5kZWZpbmVkKHNlYXJjaCkgfHxcclxuICAgICAgICAgICAgKGlzU3RyaW5nKHNlYXJjaClcclxuICAgICAgICAgICAgICAgID8gbmFtZS5zdGFydHNXaXRoKHNlYXJjaClcclxuICAgICAgICAgICAgICAgIDogaXNBcnJheShzZWFyY2gpXHJcbiAgICAgICAgICAgICAgICAgICAgPyBzZWFyY2guZmluZCgoZGF0YSkgPT4gbmFtZS5zdGFydHNXaXRoKGRhdGEpKVxyXG4gICAgICAgICAgICAgICAgICAgIDogc2VhcmNoICYmIHNlYXJjaC5uZXN0KSkge1xyXG4gICAgICAgICAgICBvdXRwdXRbbmFtZV0gPSBnZXRGaWVsZFZhbHVlKGZpZWxkcywgZmllbGRzW25hbWVdLnJlZik7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIG91dHB1dDtcclxufTtcblxudmFyIGNvbXBhcmVPYmplY3QgPSAob2JqZWN0QSA9IHt9LCBvYmplY3RCID0ge30pID0+IHtcclxuICAgIGNvbnN0IG9iamVjdEFLZXlzID0gT2JqZWN0LmtleXMob2JqZWN0QSk7XHJcbiAgICBjb25zdCBvYmplY3RCS2V5cyA9IE9iamVjdC5rZXlzKG9iamVjdEIpO1xyXG4gICAgcmV0dXJuIChvYmplY3RBS2V5cy5sZW5ndGggPT09IG9iamVjdEJLZXlzLmxlbmd0aCAmJlxyXG4gICAgICAgIG9iamVjdEFLZXlzLmV2ZXJ5KChrZXkpID0+IG9iamVjdEJba2V5XSAmJiBvYmplY3RCW2tleV0gPT09IG9iamVjdEFba2V5XSkpO1xyXG59O1xuXG52YXIgaXNTYW1lRXJyb3IgPSAoZXJyb3IsIHsgdHlwZSwgdHlwZXMsIG1lc3NhZ2UgfSkgPT4gaXNPYmplY3QoZXJyb3IpICYmXHJcbiAgICBlcnJvci50eXBlID09PSB0eXBlICYmXHJcbiAgICBlcnJvci5tZXNzYWdlID09PSBtZXNzYWdlICYmXHJcbiAgICBjb21wYXJlT2JqZWN0KGVycm9yLnR5cGVzLCB0eXBlcyk7XG5cbmZ1bmN0aW9uIHNob3VsZFJlbmRlckJhc2VkT25FcnJvcih7IGVycm9ycywgbmFtZSwgZXJyb3IsIHZhbGlkRmllbGRzLCBmaWVsZHNXaXRoVmFsaWRhdGlvbiwgfSkge1xyXG4gICAgY29uc3QgaXNGaWVsZFZhbGlkID0gaXNFbXB0eU9iamVjdChlcnJvcik7XHJcbiAgICBjb25zdCBpc0Zvcm1WYWxpZCA9IGlzRW1wdHlPYmplY3QoZXJyb3JzKTtcclxuICAgIGNvbnN0IGN1cnJlbnRGaWVsZEVycm9yID0gZ2V0KGVycm9yLCBuYW1lKTtcclxuICAgIGNvbnN0IGV4aXN0RmllbGRFcnJvciA9IGdldChlcnJvcnMsIG5hbWUpO1xyXG4gICAgaWYgKChpc0ZpZWxkVmFsaWQgJiYgdmFsaWRGaWVsZHMuaGFzKG5hbWUpKSB8fFxyXG4gICAgICAgIChleGlzdEZpZWxkRXJyb3IgJiYgZXhpc3RGaWVsZEVycm9yLmlzTWFudWFsKSkge1xyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuICAgIGlmIChpc0Zvcm1WYWxpZCAhPT0gaXNGaWVsZFZhbGlkIHx8XHJcbiAgICAgICAgKCFpc0Zvcm1WYWxpZCAmJiAhZXhpc3RGaWVsZEVycm9yKSB8fFxyXG4gICAgICAgIChpc0ZpZWxkVmFsaWQgJiYgZmllbGRzV2l0aFZhbGlkYXRpb24uaGFzKG5hbWUpICYmICF2YWxpZEZpZWxkcy5oYXMobmFtZSkpKSB7XHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gY3VycmVudEZpZWxkRXJyb3IgJiYgIWlzU2FtZUVycm9yKGV4aXN0RmllbGRFcnJvciwgY3VycmVudEZpZWxkRXJyb3IpO1xyXG59XG5cbnZhciBpc1JlZ2V4ID0gKHZhbHVlKSA9PiB2YWx1ZSBpbnN0YW5jZW9mIFJlZ0V4cDtcblxudmFyIGdldFZhbHVlQW5kTWVzc2FnZSA9ICh2YWxpZGF0aW9uRGF0YSkgPT4ge1xyXG4gICAgY29uc3QgaXNWYWx1ZU1lc3NhZ2UgPSAodmFsdWUpID0+IGlzT2JqZWN0KHZhbHVlKSAmJiAhaXNSZWdleCh2YWx1ZSk7XHJcbiAgICByZXR1cm4gaXNWYWx1ZU1lc3NhZ2UodmFsaWRhdGlvbkRhdGEpXHJcbiAgICAgICAgPyB2YWxpZGF0aW9uRGF0YVxyXG4gICAgICAgIDoge1xyXG4gICAgICAgICAgICB2YWx1ZTogdmFsaWRhdGlvbkRhdGEsXHJcbiAgICAgICAgICAgIG1lc3NhZ2U6ICcnLFxyXG4gICAgICAgIH07XHJcbn07XG5cbnZhciBpc0Z1bmN0aW9uID0gKHZhbHVlKSA9PiB0eXBlb2YgdmFsdWUgPT09ICdmdW5jdGlvbic7XG5cbnZhciBpc0Jvb2xlYW4gPSAodmFsdWUpID0+IHR5cGVvZiB2YWx1ZSA9PT0gJ2Jvb2xlYW4nO1xuXG52YXIgaXNNZXNzYWdlID0gKHZhbHVlKSA9PiBpc1N0cmluZyh2YWx1ZSkgfHwgKGlzT2JqZWN0KHZhbHVlKSAmJiBpc1ZhbGlkRWxlbWVudCh2YWx1ZSkpO1xuXG5mdW5jdGlvbiBnZXRWYWxpZGF0ZUVycm9yKHJlc3VsdCwgcmVmLCB0eXBlID0gJ3ZhbGlkYXRlJykge1xyXG4gICAgaWYgKGlzTWVzc2FnZShyZXN1bHQpIHx8IChpc0Jvb2xlYW4ocmVzdWx0KSAmJiAhcmVzdWx0KSkge1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIHR5cGUsXHJcbiAgICAgICAgICAgIG1lc3NhZ2U6IGlzTWVzc2FnZShyZXN1bHQpID8gcmVzdWx0IDogJycsXHJcbiAgICAgICAgICAgIHJlZixcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG59XG5cbnZhciBhcHBlbmRFcnJvcnMgPSAobmFtZSwgdmFsaWRhdGVBbGxGaWVsZENyaXRlcmlhLCBlcnJvcnMsIHR5cGUsIG1lc3NhZ2UpID0+IHtcclxuICAgIGlmICh2YWxpZGF0ZUFsbEZpZWxkQ3JpdGVyaWEpIHtcclxuICAgICAgICBjb25zdCBlcnJvciA9IGVycm9yc1tuYW1lXTtcclxuICAgICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBlcnJvciksIHsgdHlwZXM6IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgKGVycm9yICYmIGVycm9yLnR5cGVzID8gZXJyb3IudHlwZXMgOiB7fSkpLCB7IFt0eXBlXTogbWVzc2FnZSB8fCB0cnVlIH0pIH0pO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHt9O1xyXG59O1xuXG52YXIgdmFsaWRhdGVGaWVsZCA9IGFzeW5jIChmaWVsZHNSZWYsIHZhbGlkYXRlQWxsRmllbGRDcml0ZXJpYSwgeyByZWYsIHJlZjogeyB0eXBlLCB2YWx1ZSwgbmFtZSB9LCBvcHRpb25zLCByZXF1aXJlZCwgbWF4TGVuZ3RoLCBtaW5MZW5ndGgsIG1pbiwgbWF4LCBwYXR0ZXJuLCB2YWxpZGF0ZSwgfSkgPT4ge1xyXG4gICAgdmFyIF9hO1xyXG4gICAgY29uc3QgZmllbGRzID0gZmllbGRzUmVmLmN1cnJlbnQ7XHJcbiAgICBjb25zdCBlcnJvciA9IHt9O1xyXG4gICAgY29uc3QgaXNSYWRpbyA9IGlzUmFkaW9JbnB1dChyZWYpO1xyXG4gICAgY29uc3QgaXNDaGVja0JveCA9IGlzQ2hlY2tCb3hJbnB1dChyZWYpO1xyXG4gICAgY29uc3QgaXNSYWRpb09yQ2hlY2tib3ggPSBpc1JhZGlvIHx8IGlzQ2hlY2tCb3g7XHJcbiAgICBjb25zdCBpc0VtcHR5ID0gaXNFbXB0eVN0cmluZyh2YWx1ZSk7XHJcbiAgICBjb25zdCBhcHBlbmRFcnJvcnNDdXJyeSA9IGFwcGVuZEVycm9ycy5iaW5kKG51bGwsIG5hbWUsIHZhbGlkYXRlQWxsRmllbGRDcml0ZXJpYSwgZXJyb3IpO1xyXG4gICAgY29uc3QgZ2V0TWluTWF4TWVzc2FnZSA9IChleGNlZWRNYXgsIG1heExlbmd0aE1lc3NhZ2UsIG1pbkxlbmd0aE1lc3NhZ2UsIG1heFR5cGUgPSBJTlBVVF9WQUxJREFUSU9OX1JVTEVTLm1heExlbmd0aCwgbWluVHlwZSA9IElOUFVUX1ZBTElEQVRJT05fUlVMRVMubWluTGVuZ3RoKSA9PiB7XHJcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGV4Y2VlZE1heCA/IG1heExlbmd0aE1lc3NhZ2UgOiBtaW5MZW5ndGhNZXNzYWdlO1xyXG4gICAgICAgIGVycm9yW25hbWVdID0gT2JqZWN0LmFzc2lnbih7IHR5cGU6IGV4Y2VlZE1heCA/IG1heFR5cGUgOiBtaW5UeXBlLCBtZXNzYWdlLFxyXG4gICAgICAgICAgICByZWYgfSwgKGV4Y2VlZE1heFxyXG4gICAgICAgICAgICA/IGFwcGVuZEVycm9yc0N1cnJ5KG1heFR5cGUsIG1lc3NhZ2UpXHJcbiAgICAgICAgICAgIDogYXBwZW5kRXJyb3JzQ3VycnkobWluVHlwZSwgbWVzc2FnZSkpKTtcclxuICAgICAgICBpZiAoIXZhbGlkYXRlQWxsRmllbGRDcml0ZXJpYSkge1xyXG4gICAgICAgICAgICByZXR1cm4gZXJyb3I7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIGlmIChyZXF1aXJlZCAmJlxyXG4gICAgICAgICgoIWlzUmFkaW8gJiYgIWlzQ2hlY2tCb3ggJiYgKGlzRW1wdHkgfHwgaXNOdWxsT3JVbmRlZmluZWQodmFsdWUpKSkgfHxcclxuICAgICAgICAgICAgKGlzQm9vbGVhbih2YWx1ZSkgJiYgIXZhbHVlKSB8fFxyXG4gICAgICAgICAgICAoaXNDaGVja0JveCAmJiAhZ2V0Q2hlY2tib3hWYWx1ZShvcHRpb25zKS5pc1ZhbGlkKSB8fFxyXG4gICAgICAgICAgICAoaXNSYWRpbyAmJiAhZ2V0UmFkaW9WYWx1ZShvcHRpb25zKS5pc1ZhbGlkKSkpIHtcclxuICAgICAgICBjb25zdCB7IHZhbHVlOiByZXF1aXJlZFZhbHVlLCBtZXNzYWdlOiByZXF1aXJlZE1lc3NhZ2UgfSA9IGlzTWVzc2FnZShyZXF1aXJlZClcclxuICAgICAgICAgICAgPyB7IHZhbHVlOiAhIXJlcXVpcmVkLCBtZXNzYWdlOiByZXF1aXJlZCB9XHJcbiAgICAgICAgICAgIDogZ2V0VmFsdWVBbmRNZXNzYWdlKHJlcXVpcmVkKTtcclxuICAgICAgICBpZiAocmVxdWlyZWRWYWx1ZSkge1xyXG4gICAgICAgICAgICBlcnJvcltuYW1lXSA9IE9iamVjdC5hc3NpZ24oeyB0eXBlOiBJTlBVVF9WQUxJREFUSU9OX1JVTEVTLnJlcXVpcmVkLCBtZXNzYWdlOiByZXF1aXJlZE1lc3NhZ2UsIHJlZjogaXNSYWRpb09yQ2hlY2tib3ggPyAoX2EgPSBmaWVsZHNbbmFtZV0ub3B0aW9ucykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hWzBdLnJlZiA6IHJlZiB9LCBhcHBlbmRFcnJvcnNDdXJyeShJTlBVVF9WQUxJREFUSU9OX1JVTEVTLnJlcXVpcmVkLCByZXF1aXJlZE1lc3NhZ2UpKTtcclxuICAgICAgICAgICAgaWYgKCF2YWxpZGF0ZUFsbEZpZWxkQ3JpdGVyaWEpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBlcnJvcjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGlmICghaXNOdWxsT3JVbmRlZmluZWQobWluKSB8fCAhaXNOdWxsT3JVbmRlZmluZWQobWF4KSkge1xyXG4gICAgICAgIGxldCBleGNlZWRNYXg7XHJcbiAgICAgICAgbGV0IGV4Y2VlZE1pbjtcclxuICAgICAgICBjb25zdCB7IHZhbHVlOiBtYXhWYWx1ZSwgbWVzc2FnZTogbWF4TWVzc2FnZSB9ID0gZ2V0VmFsdWVBbmRNZXNzYWdlKG1heCk7XHJcbiAgICAgICAgY29uc3QgeyB2YWx1ZTogbWluVmFsdWUsIG1lc3NhZ2U6IG1pbk1lc3NhZ2UgfSA9IGdldFZhbHVlQW5kTWVzc2FnZShtaW4pO1xyXG4gICAgICAgIGlmICh0eXBlID09PSAnbnVtYmVyJyB8fCAoIXR5cGUgJiYgIWlzTmFOKHZhbHVlKSkpIHtcclxuICAgICAgICAgICAgY29uc3QgdmFsdWVOdW1iZXIgPSByZWYudmFsdWVBc051bWJlciB8fCBwYXJzZUZsb2F0KHZhbHVlKTtcclxuICAgICAgICAgICAgaWYgKCFpc051bGxPclVuZGVmaW5lZChtYXhWYWx1ZSkpIHtcclxuICAgICAgICAgICAgICAgIGV4Y2VlZE1heCA9IHZhbHVlTnVtYmVyID4gbWF4VmFsdWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKCFpc051bGxPclVuZGVmaW5lZChtaW5WYWx1ZSkpIHtcclxuICAgICAgICAgICAgICAgIGV4Y2VlZE1pbiA9IHZhbHVlTnVtYmVyIDwgbWluVmFsdWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHZhbHVlRGF0ZSA9IHJlZi52YWx1ZUFzRGF0ZSB8fCBuZXcgRGF0ZSh2YWx1ZSk7XHJcbiAgICAgICAgICAgIGlmIChpc1N0cmluZyhtYXhWYWx1ZSkpIHtcclxuICAgICAgICAgICAgICAgIGV4Y2VlZE1heCA9IHZhbHVlRGF0ZSA+IG5ldyBEYXRlKG1heFZhbHVlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoaXNTdHJpbmcobWluVmFsdWUpKSB7XHJcbiAgICAgICAgICAgICAgICBleGNlZWRNaW4gPSB2YWx1ZURhdGUgPCBuZXcgRGF0ZShtaW5WYWx1ZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGV4Y2VlZE1heCB8fCBleGNlZWRNaW4pIHtcclxuICAgICAgICAgICAgZ2V0TWluTWF4TWVzc2FnZSghIWV4Y2VlZE1heCwgbWF4TWVzc2FnZSwgbWluTWVzc2FnZSwgSU5QVVRfVkFMSURBVElPTl9SVUxFUy5tYXgsIElOUFVUX1ZBTElEQVRJT05fUlVMRVMubWluKTtcclxuICAgICAgICAgICAgaWYgKCF2YWxpZGF0ZUFsbEZpZWxkQ3JpdGVyaWEpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBlcnJvcjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGlmIChpc1N0cmluZyh2YWx1ZSkgJiYgIWlzRW1wdHkgJiYgKG1heExlbmd0aCB8fCBtaW5MZW5ndGgpKSB7XHJcbiAgICAgICAgY29uc3QgeyB2YWx1ZTogbWF4TGVuZ3RoVmFsdWUsIG1lc3NhZ2U6IG1heExlbmd0aE1lc3NhZ2UsIH0gPSBnZXRWYWx1ZUFuZE1lc3NhZ2UobWF4TGVuZ3RoKTtcclxuICAgICAgICBjb25zdCB7IHZhbHVlOiBtaW5MZW5ndGhWYWx1ZSwgbWVzc2FnZTogbWluTGVuZ3RoTWVzc2FnZSwgfSA9IGdldFZhbHVlQW5kTWVzc2FnZShtaW5MZW5ndGgpO1xyXG4gICAgICAgIGNvbnN0IGlucHV0TGVuZ3RoID0gdmFsdWUudG9TdHJpbmcoKS5sZW5ndGg7XHJcbiAgICAgICAgY29uc3QgZXhjZWVkTWF4ID0gIWlzTnVsbE9yVW5kZWZpbmVkKG1heExlbmd0aFZhbHVlKSAmJiBpbnB1dExlbmd0aCA+IG1heExlbmd0aFZhbHVlO1xyXG4gICAgICAgIGNvbnN0IGV4Y2VlZE1pbiA9ICFpc051bGxPclVuZGVmaW5lZChtaW5MZW5ndGhWYWx1ZSkgJiYgaW5wdXRMZW5ndGggPCBtaW5MZW5ndGhWYWx1ZTtcclxuICAgICAgICBpZiAoZXhjZWVkTWF4IHx8IGV4Y2VlZE1pbikge1xyXG4gICAgICAgICAgICBnZXRNaW5NYXhNZXNzYWdlKCEhZXhjZWVkTWF4LCBtYXhMZW5ndGhNZXNzYWdlLCBtaW5MZW5ndGhNZXNzYWdlKTtcclxuICAgICAgICAgICAgaWYgKCF2YWxpZGF0ZUFsbEZpZWxkQ3JpdGVyaWEpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBlcnJvcjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGlmIChwYXR0ZXJuICYmICFpc0VtcHR5KSB7XHJcbiAgICAgICAgY29uc3QgeyB2YWx1ZTogcGF0dGVyblZhbHVlLCBtZXNzYWdlOiBwYXR0ZXJuTWVzc2FnZSB9ID0gZ2V0VmFsdWVBbmRNZXNzYWdlKHBhdHRlcm4pO1xyXG4gICAgICAgIGlmIChpc1JlZ2V4KHBhdHRlcm5WYWx1ZSkgJiYgIXBhdHRlcm5WYWx1ZS50ZXN0KHZhbHVlKSkge1xyXG4gICAgICAgICAgICBlcnJvcltuYW1lXSA9IE9iamVjdC5hc3NpZ24oeyB0eXBlOiBJTlBVVF9WQUxJREFUSU9OX1JVTEVTLnBhdHRlcm4sIG1lc3NhZ2U6IHBhdHRlcm5NZXNzYWdlLCByZWYgfSwgYXBwZW5kRXJyb3JzQ3VycnkoSU5QVVRfVkFMSURBVElPTl9SVUxFUy5wYXR0ZXJuLCBwYXR0ZXJuTWVzc2FnZSkpO1xyXG4gICAgICAgICAgICBpZiAoIXZhbGlkYXRlQWxsRmllbGRDcml0ZXJpYSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGVycm9yO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgaWYgKHZhbGlkYXRlKSB7XHJcbiAgICAgICAgY29uc3QgZmllbGRWYWx1ZSA9IGdldEZpZWxkVmFsdWUoZmllbGRzLCByZWYpO1xyXG4gICAgICAgIGNvbnN0IHZhbGlkYXRlUmVmID0gaXNSYWRpb09yQ2hlY2tib3ggJiYgb3B0aW9ucyA/IG9wdGlvbnNbMF0ucmVmIDogcmVmO1xyXG4gICAgICAgIGlmIChpc0Z1bmN0aW9uKHZhbGlkYXRlKSkge1xyXG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCB2YWxpZGF0ZShmaWVsZFZhbHVlKTtcclxuICAgICAgICAgICAgY29uc3QgdmFsaWRhdGVFcnJvciA9IGdldFZhbGlkYXRlRXJyb3IocmVzdWx0LCB2YWxpZGF0ZVJlZik7XHJcbiAgICAgICAgICAgIGlmICh2YWxpZGF0ZUVycm9yKSB7XHJcbiAgICAgICAgICAgICAgICBlcnJvcltuYW1lXSA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgdmFsaWRhdGVFcnJvciksIGFwcGVuZEVycm9yc0N1cnJ5KElOUFVUX1ZBTElEQVRJT05fUlVMRVMudmFsaWRhdGUsIHZhbGlkYXRlRXJyb3IubWVzc2FnZSkpO1xyXG4gICAgICAgICAgICAgICAgaWYgKCF2YWxpZGF0ZUFsbEZpZWxkQ3JpdGVyaWEpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZXJyb3I7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoaXNPYmplY3QodmFsaWRhdGUpKSB7XHJcbiAgICAgICAgICAgIGxldCB2YWxpZGF0aW9uUmVzdWx0ID0ge307XHJcbiAgICAgICAgICAgIGZvciAoY29uc3QgW2tleSwgdmFsaWRhdGVGdW5jdGlvbl0gb2YgT2JqZWN0LmVudHJpZXModmFsaWRhdGUpKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoIWlzRW1wdHlPYmplY3QodmFsaWRhdGlvblJlc3VsdCkgJiYgIXZhbGlkYXRlQWxsRmllbGRDcml0ZXJpYSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgY29uc3QgdmFsaWRhdGVSZXN1bHQgPSBhd2FpdCB2YWxpZGF0ZUZ1bmN0aW9uKGZpZWxkVmFsdWUpO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgdmFsaWRhdGVFcnJvciA9IGdldFZhbGlkYXRlRXJyb3IodmFsaWRhdGVSZXN1bHQsIHZhbGlkYXRlUmVmLCBrZXkpO1xyXG4gICAgICAgICAgICAgICAgaWYgKHZhbGlkYXRlRXJyb3IpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YWxpZGF0aW9uUmVzdWx0ID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCB2YWxpZGF0ZUVycm9yKSwgYXBwZW5kRXJyb3JzQ3Vycnkoa2V5LCB2YWxpZGF0ZUVycm9yLm1lc3NhZ2UpKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAodmFsaWRhdGVBbGxGaWVsZENyaXRlcmlhKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yW25hbWVdID0gdmFsaWRhdGlvblJlc3VsdDtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKCFpc0VtcHR5T2JqZWN0KHZhbGlkYXRpb25SZXN1bHQpKSB7XHJcbiAgICAgICAgICAgICAgICBlcnJvcltuYW1lXSA9IE9iamVjdC5hc3NpZ24oeyByZWY6IHZhbGlkYXRlUmVmIH0sIHZhbGlkYXRpb25SZXN1bHQpO1xyXG4gICAgICAgICAgICAgICAgaWYgKCF2YWxpZGF0ZUFsbEZpZWxkQ3JpdGVyaWEpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZXJyb3I7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gZXJyb3I7XHJcbn07XG5cbmNvbnN0IHBhcnNlRXJyb3JTY2hlbWEgPSAoZXJyb3IsIHZhbGlkYXRlQWxsRmllbGRDcml0ZXJpYSkgPT4gaXNBcnJheShlcnJvci5pbm5lcilcclxuICAgID8gZXJyb3IuaW5uZXIucmVkdWNlKChwcmV2aW91cywgeyBwYXRoLCBtZXNzYWdlLCB0eXBlIH0pID0+IChPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHByZXZpb3VzKSwgKHBhdGhcclxuICAgICAgICA/IHByZXZpb3VzW3BhdGhdICYmIHZhbGlkYXRlQWxsRmllbGRDcml0ZXJpYVxyXG4gICAgICAgICAgICA/IHtcclxuICAgICAgICAgICAgICAgIFtwYXRoXTogYXBwZW5kRXJyb3JzKHBhdGgsIHZhbGlkYXRlQWxsRmllbGRDcml0ZXJpYSwgcHJldmlvdXMsIHR5cGUsIG1lc3NhZ2UpLFxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIDoge1xyXG4gICAgICAgICAgICAgICAgW3BhdGhdOiBwcmV2aW91c1twYXRoXSB8fCBPYmplY3QuYXNzaWduKHsgbWVzc2FnZSxcclxuICAgICAgICAgICAgICAgICAgICB0eXBlIH0sICh2YWxpZGF0ZUFsbEZpZWxkQ3JpdGVyaWFcclxuICAgICAgICAgICAgICAgICAgICA/IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZXM6IHsgW3R5cGVdOiBtZXNzYWdlIHx8IHRydWUgfSxcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgOiB7fSkpLFxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgOiB7fSkpKSwge30pXHJcbiAgICA6IHtcclxuICAgICAgICBbZXJyb3IucGF0aF06IHsgbWVzc2FnZTogZXJyb3IubWVzc2FnZSwgdHlwZTogZXJyb3IudHlwZSB9LFxyXG4gICAgfTtcclxuYXN5bmMgZnVuY3Rpb24gdmFsaWRhdGVXaXRoU2NoZW1hKHZhbGlkYXRpb25TY2hlbWEsIHZhbGlkYXRlQWxsRmllbGRDcml0ZXJpYSwgZGF0YSwgdmFsaWRhdGlvblJlc29sdmVyLCBjb250ZXh0KSB7XHJcbiAgICBpZiAodmFsaWRhdGlvblJlc29sdmVyKSB7XHJcbiAgICAgICAgcmV0dXJuIHZhbGlkYXRpb25SZXNvbHZlcihkYXRhLCBjb250ZXh0KTtcclxuICAgIH1cclxuICAgIHRyeSB7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgdmFsdWVzOiBhd2FpdCB2YWxpZGF0aW9uU2NoZW1hLnZhbGlkYXRlKGRhdGEsIHtcclxuICAgICAgICAgICAgICAgIGFib3J0RWFybHk6IGZhbHNlLFxyXG4gICAgICAgICAgICAgICAgY29udGV4dCxcclxuICAgICAgICAgICAgfSksXHJcbiAgICAgICAgICAgIGVycm9yczoge30sXHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuICAgIGNhdGNoIChlKSB7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgdmFsdWVzOiB7fSxcclxuICAgICAgICAgICAgZXJyb3JzOiB0cmFuc2Zvcm1Ub05lc3RPYmplY3QocGFyc2VFcnJvclNjaGVtYShlLCB2YWxpZGF0ZUFsbEZpZWxkQ3JpdGVyaWEpKSxcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG59XG5cbnZhciBpc1ByaW1pdGl2ZSA9ICh2YWx1ZSkgPT4gaXNOdWxsT3JVbmRlZmluZWQodmFsdWUpIHx8ICFpc09iamVjdFR5cGUodmFsdWUpO1xuXG5jb25zdCBnZXRQYXRoID0gKHBhdGgsIHZhbHVlcykgPT4ge1xyXG4gICAgY29uc3QgZ2V0SW5uZXJQYXRoID0gKHZhbHVlLCBrZXksIGlzT2JqZWN0KSA9PiB7XHJcbiAgICAgICAgY29uc3QgcGF0aFdpdGhJbmRleCA9IGlzT2JqZWN0ID8gYCR7cGF0aH0uJHtrZXl9YCA6IGAke3BhdGh9WyR7a2V5fV1gO1xyXG4gICAgICAgIHJldHVybiBpc1ByaW1pdGl2ZSh2YWx1ZSkgPyBwYXRoV2l0aEluZGV4IDogZ2V0UGF0aChwYXRoV2l0aEluZGV4LCB2YWx1ZSk7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIGlzQXJyYXkodmFsdWVzKVxyXG4gICAgICAgID8gdmFsdWVzLm1hcCgodmFsdWUsIGtleSkgPT4gZ2V0SW5uZXJQYXRoKHZhbHVlLCBrZXkpKVxyXG4gICAgICAgIDogT2JqZWN0LmVudHJpZXModmFsdWVzKS5tYXAoKFtrZXksIHZhbHVlXSkgPT4gZ2V0SW5uZXJQYXRoKHZhbHVlLCBrZXksIHRydWUpKTtcclxufTtcclxudmFyIGdldFBhdGgkMSA9IChwYXJlbnRQYXRoLCB2YWx1ZSkgPT4gZ2V0UGF0aChwYXJlbnRQYXRoLCB2YWx1ZSkuZmxhdChJbmZpbml0eSk7XG5cbnZhciBhc3NpZ25XYXRjaEZpZWxkcyA9IChmaWVsZFZhbHVlcywgZmllbGROYW1lLCB3YXRjaEZpZWxkcywgaW5wdXRWYWx1ZSwgaXNTaW5nbGVGaWVsZCkgPT4ge1xyXG4gICAgbGV0IHZhbHVlO1xyXG4gICAgd2F0Y2hGaWVsZHMuYWRkKGZpZWxkTmFtZSk7XHJcbiAgICBpZiAoaXNFbXB0eU9iamVjdChmaWVsZFZhbHVlcykpIHtcclxuICAgICAgICB2YWx1ZSA9IHVuZGVmaW5lZDtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKCFpc1VuZGVmaW5lZChmaWVsZFZhbHVlc1tmaWVsZE5hbWVdKSkge1xyXG4gICAgICAgIHZhbHVlID0gZmllbGRWYWx1ZXNbZmllbGROYW1lXTtcclxuICAgICAgICB3YXRjaEZpZWxkcy5hZGQoZmllbGROYW1lKTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIHZhbHVlID0gZ2V0KHRyYW5zZm9ybVRvTmVzdE9iamVjdChmaWVsZFZhbHVlcyksIGZpZWxkTmFtZSk7XHJcbiAgICAgICAgaWYgKCFpc1VuZGVmaW5lZCh2YWx1ZSkpIHtcclxuICAgICAgICAgICAgZ2V0UGF0aCQxKGZpZWxkTmFtZSwgdmFsdWUpLmZvckVhY2goKG5hbWUpID0+IHdhdGNoRmllbGRzLmFkZChuYW1lKSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIGlzVW5kZWZpbmVkKHZhbHVlKVxyXG4gICAgICAgID8gaXNTaW5nbGVGaWVsZFxyXG4gICAgICAgICAgICA/IGlucHV0VmFsdWVcclxuICAgICAgICAgICAgOiBnZXQoaW5wdXRWYWx1ZSwgZmllbGROYW1lKVxyXG4gICAgICAgIDogdmFsdWU7XHJcbn07XG5cbnZhciBza2lwVmFsaWRhdGlvbiA9ICh7IGlzT25DaGFuZ2UsIGhhc0Vycm9yLCBpc0JsdXJFdmVudCwgaXNPblN1Ym1pdCwgaXNSZVZhbGlkYXRlT25TdWJtaXQsIGlzT25CbHVyLCBpc1JlVmFsaWRhdGVPbkJsdXIsIGlzU3VibWl0dGVkLCB9KSA9PiAoaXNPbkNoYW5nZSAmJiBpc0JsdXJFdmVudCkgfHxcclxuICAgIChpc09uU3VibWl0ICYmIGlzUmVWYWxpZGF0ZU9uU3VibWl0KSB8fFxyXG4gICAgKGlzT25TdWJtaXQgJiYgIWlzU3VibWl0dGVkKSB8fFxyXG4gICAgKGlzT25CbHVyICYmICFpc0JsdXJFdmVudCAmJiAhaGFzRXJyb3IpIHx8XHJcbiAgICAoaXNSZVZhbGlkYXRlT25CbHVyICYmICFpc0JsdXJFdmVudCAmJiBoYXNFcnJvcikgfHxcclxuICAgIChpc1JlVmFsaWRhdGVPblN1Ym1pdCAmJiBpc1N1Ym1pdHRlZCk7XG5cbnZhciBnZXRGaWVsZEFycmF5UGFyZW50TmFtZSA9IChuYW1lKSA9PiBuYW1lLnN1YnN0cmluZygwLCBuYW1lLmluZGV4T2YoJ1snKSk7XG5cbnZhciBnZXRGaWVsZFZhbHVlQnlOYW1lID0gKGZpZWxkcywgbmFtZSkgPT4ge1xyXG4gICAgY29uc3QgcmVzdWx0cyA9IHRyYW5zZm9ybVRvTmVzdE9iamVjdChnZXRGaWVsZHNWYWx1ZXMoZmllbGRzKSk7XHJcbiAgICByZXR1cm4gbmFtZSA/IGdldChyZXN1bHRzLCBuYW1lLCByZXN1bHRzKSA6IHJlc3VsdHM7XHJcbn07XG5cbmZ1bmN0aW9uIGdldElzRmllbGRzRGlmZmVyZW50KHJlZmVyZW5jZUFycmF5LCBkaWZmZXJlbmNlQXJyYXkpIHtcclxuICAgIGxldCBpc01hdGNoID0gZmFsc2U7XHJcbiAgICBpZiAoIWlzQXJyYXkocmVmZXJlbmNlQXJyYXkpIHx8XHJcbiAgICAgICAgIWlzQXJyYXkoZGlmZmVyZW5jZUFycmF5KSB8fFxyXG4gICAgICAgIHJlZmVyZW5jZUFycmF5Lmxlbmd0aCAhPT0gZGlmZmVyZW5jZUFycmF5Lmxlbmd0aCkge1xyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfVxyXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCByZWZlcmVuY2VBcnJheS5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIGlmIChpc01hdGNoKSB7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBkYXRhQSA9IHJlZmVyZW5jZUFycmF5W2ldO1xyXG4gICAgICAgIGNvbnN0IGRhdGFCID0gZGlmZmVyZW5jZUFycmF5W2ldO1xyXG4gICAgICAgIGlmIChpc1VuZGVmaW5lZChkYXRhQikgfHxcclxuICAgICAgICAgICAgT2JqZWN0LmtleXMoZGF0YUEpLmxlbmd0aCAhPT0gT2JqZWN0LmtleXMoZGF0YUIpLmxlbmd0aCkge1xyXG4gICAgICAgICAgICBpc01hdGNoID0gdHJ1ZTtcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZvciAoY29uc3Qga2V5IGluIGRhdGFBKSB7XHJcbiAgICAgICAgICAgIGlmIChkYXRhQVtrZXldICE9PSBkYXRhQltrZXldKSB7XHJcbiAgICAgICAgICAgICAgICBpc01hdGNoID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIGlzTWF0Y2g7XHJcbn1cblxuY29uc3QgaXNNYXRjaEZpZWxkQXJyYXlOYW1lID0gKG5hbWUsIHNlYXJjaE5hbWUpID0+IFJlZ0V4cChgXiR7c2VhcmNoTmFtZX1bXFxcXGQrXWAucmVwbGFjZSgvXFxbL2csICdcXFxcWycpLnJlcGxhY2UoL1xcXS9nLCAnXFxcXF0nKSkudGVzdChuYW1lKTtcclxudmFyIGlzTmFtZUluRmllbGRBcnJheSA9IChuYW1lcywgbmFtZSkgPT4gWy4uLm5hbWVzXS5zb21lKChjdXJyZW50KSA9PiBpc01hdGNoRmllbGRBcnJheU5hbWUobmFtZSwgY3VycmVudCkpO1xuXG52YXIgaXNTZWxlY3RJbnB1dCA9IChlbGVtZW50KSA9PiBlbGVtZW50LnR5cGUgPT09IGAke1NFTEVDVH0tb25lYDtcblxuZnVuY3Rpb24gb25Eb21SZW1vdmUoZWxlbWVudCwgb25EZXRhY2hDYWxsYmFjaykge1xyXG4gICAgY29uc3Qgb2JzZXJ2ZXIgPSBuZXcgTXV0YXRpb25PYnNlcnZlcigoKSA9PiB7XHJcbiAgICAgICAgaWYgKGlzRGV0YWNoZWQoZWxlbWVudCkpIHtcclxuICAgICAgICAgICAgb2JzZXJ2ZXIuZGlzY29ubmVjdCgpO1xyXG4gICAgICAgICAgICBvbkRldGFjaENhbGxiYWNrKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfSk7XHJcbiAgICBvYnNlcnZlci5vYnNlcnZlKHdpbmRvdy5kb2N1bWVudCwge1xyXG4gICAgICAgIGNoaWxkTGlzdDogdHJ1ZSxcclxuICAgICAgICBzdWJ0cmVlOiB0cnVlLFxyXG4gICAgfSk7XHJcbiAgICByZXR1cm4gb2JzZXJ2ZXI7XHJcbn1cblxudmFyIG1vZGVDaGVja2VyID0gKG1vZGUpID0+ICh7XHJcbiAgICBpc09uU3VibWl0OiAhbW9kZSB8fCBtb2RlID09PSBWQUxJREFUSU9OX01PREUub25TdWJtaXQsXHJcbiAgICBpc09uQmx1cjogbW9kZSA9PT0gVkFMSURBVElPTl9NT0RFLm9uQmx1cixcclxuICAgIGlzT25DaGFuZ2U6IG1vZGUgPT09IFZBTElEQVRJT05fTU9ERS5vbkNoYW5nZSxcclxufSk7XG5cbnZhciBpc1JhZGlvT3JDaGVja2JveEZ1bmN0aW9uID0gKHJlZikgPT4gaXNSYWRpb0lucHV0KHJlZikgfHwgaXNDaGVja0JveElucHV0KHJlZik7XG5cbmZ1bmN0aW9uIHVzZUZvcm0oeyBtb2RlID0gVkFMSURBVElPTl9NT0RFLm9uU3VibWl0LCByZVZhbGlkYXRlTW9kZSA9IFZBTElEQVRJT05fTU9ERS5vbkNoYW5nZSwgdmFsaWRhdGlvblNjaGVtYSwgdmFsaWRhdGlvblJlc29sdmVyLCB2YWxpZGF0aW9uQ29udGV4dCwgZGVmYXVsdFZhbHVlcyA9IHt9LCBzdWJtaXRGb2N1c0Vycm9yID0gdHJ1ZSwgdmFsaWRhdGVDcml0ZXJpYU1vZGUsIH0gPSB7fSkge1xyXG4gICAgY29uc3QgZmllbGRzUmVmID0gdXNlUmVmKHt9KTtcclxuICAgIGNvbnN0IGVycm9yc1JlZiA9IHVzZVJlZih7fSk7XHJcbiAgICBjb25zdCB0b3VjaGVkRmllbGRzUmVmID0gdXNlUmVmKHt9KTtcclxuICAgIGNvbnN0IGZpZWxkQXJyYXlEZWZhdWx0VmFsdWVzID0gdXNlUmVmKHt9KTtcclxuICAgIGNvbnN0IHdhdGNoRmllbGRzUmVmID0gdXNlUmVmKG5ldyBTZXQoKSk7XHJcbiAgICBjb25zdCBkaXJ0eUZpZWxkc1JlZiA9IHVzZVJlZihuZXcgU2V0KCkpO1xyXG4gICAgY29uc3QgZmllbGRzV2l0aFZhbGlkYXRpb25SZWYgPSB1c2VSZWYobmV3IFNldCgpKTtcclxuICAgIGNvbnN0IHZhbGlkRmllbGRzUmVmID0gdXNlUmVmKG5ldyBTZXQoKSk7XHJcbiAgICBjb25zdCBpc1ZhbGlkUmVmID0gdXNlUmVmKHRydWUpO1xyXG4gICAgY29uc3QgZGVmYXVsdFZhbHVlc1JlZiA9IHVzZVJlZihkZWZhdWx0VmFsdWVzKTtcclxuICAgIGNvbnN0IGRlZmF1bHRWYWx1ZXNBdFJlbmRlclJlZiA9IHVzZVJlZih7fSk7XHJcbiAgICBjb25zdCBpc1VuTW91bnQgPSB1c2VSZWYoZmFsc2UpO1xyXG4gICAgY29uc3QgaXNXYXRjaEFsbFJlZiA9IHVzZVJlZihmYWxzZSk7XHJcbiAgICBjb25zdCBpc1N1Ym1pdHRlZFJlZiA9IHVzZVJlZihmYWxzZSk7XHJcbiAgICBjb25zdCBpc0RpcnR5UmVmID0gdXNlUmVmKGZhbHNlKTtcclxuICAgIGNvbnN0IHN1Ym1pdENvdW50UmVmID0gdXNlUmVmKDApO1xyXG4gICAgY29uc3QgaXNTdWJtaXR0aW5nUmVmID0gdXNlUmVmKGZhbHNlKTtcclxuICAgIGNvbnN0IGhhbmRsZUNoYW5nZVJlZiA9IHVzZVJlZigpO1xyXG4gICAgY29uc3QgcmVzZXRGaWVsZEFycmF5RnVuY3Rpb25SZWYgPSB1c2VSZWYoe30pO1xyXG4gICAgY29uc3QgdmFsaWRhdGlvbkNvbnRleHRSZWYgPSB1c2VSZWYodmFsaWRhdGlvbkNvbnRleHQpO1xyXG4gICAgY29uc3QgZmllbGRBcnJheU5hbWVzUmVmID0gdXNlUmVmKG5ldyBTZXQoKSk7XHJcbiAgICBjb25zdCBbLCByZW5kZXJdID0gdXNlU3RhdGUoKTtcclxuICAgIGNvbnN0IHsgaXNPbkJsdXIsIGlzT25TdWJtaXQsIGlzT25DaGFuZ2UgfSA9IHVzZVJlZihtb2RlQ2hlY2tlcihtb2RlKSkuY3VycmVudDtcclxuICAgIGNvbnN0IHZhbGlkYXRlQWxsRmllbGRDcml0ZXJpYSA9IHZhbGlkYXRlQ3JpdGVyaWFNb2RlID09PSAnYWxsJztcclxuICAgIGNvbnN0IGlzV2luZG93VW5kZWZpbmVkID0gdHlwZW9mIHdpbmRvdyA9PT0gVU5ERUZJTkVEO1xyXG4gICAgY29uc3Qgc2hvdWxkVmFsaWRhdGVTY2hlbWFPclJlc29sdmVyID0gISEodmFsaWRhdGlvblNjaGVtYSB8fCB2YWxpZGF0aW9uUmVzb2x2ZXIpO1xyXG4gICAgY29uc3QgaXNXZWIgPSB0eXBlb2YgZG9jdW1lbnQgIT09IFVOREVGSU5FRCAmJlxyXG4gICAgICAgICFpc1dpbmRvd1VuZGVmaW5lZCAmJlxyXG4gICAgICAgICFpc1VuZGVmaW5lZCh3aW5kb3cuSFRNTEVsZW1lbnQpO1xyXG4gICAgY29uc3QgaXNQcm94eUVuYWJsZWQgPSBpc1dlYiA/ICdQcm94eScgaW4gd2luZG93IDogdHlwZW9mIFByb3h5ICE9PSBVTkRFRklORUQ7XHJcbiAgICBjb25zdCByZWFkRm9ybVN0YXRlUmVmID0gdXNlUmVmKHtcclxuICAgICAgICBkaXJ0eTogIWlzUHJveHlFbmFibGVkLFxyXG4gICAgICAgIGRpcnR5RmllbGRzOiAhaXNQcm94eUVuYWJsZWQsXHJcbiAgICAgICAgaXNTdWJtaXR0ZWQ6IGlzT25TdWJtaXQsXHJcbiAgICAgICAgc3VibWl0Q291bnQ6ICFpc1Byb3h5RW5hYmxlZCxcclxuICAgICAgICB0b3VjaGVkOiAhaXNQcm94eUVuYWJsZWQsXHJcbiAgICAgICAgaXNTdWJtaXR0aW5nOiAhaXNQcm94eUVuYWJsZWQsXHJcbiAgICAgICAgaXNWYWxpZDogIWlzUHJveHlFbmFibGVkLFxyXG4gICAgfSk7XHJcbiAgICBjb25zdCB7IGlzT25CbHVyOiBpc1JlVmFsaWRhdGVPbkJsdXIsIGlzT25TdWJtaXQ6IGlzUmVWYWxpZGF0ZU9uU3VibWl0LCB9ID0gdXNlUmVmKG1vZGVDaGVja2VyKHJlVmFsaWRhdGVNb2RlKSkuY3VycmVudDtcclxuICAgIHZhbGlkYXRpb25Db250ZXh0UmVmLmN1cnJlbnQgPSB2YWxpZGF0aW9uQ29udGV4dDtcclxuICAgIGNvbnN0IHJlUmVuZGVyID0gdXNlQ2FsbGJhY2soKCkgPT4ge1xyXG4gICAgICAgIGlmICghaXNVbk1vdW50LmN1cnJlbnQpIHtcclxuICAgICAgICAgICAgcmVuZGVyKHt9KTtcclxuICAgICAgICB9XHJcbiAgICB9LCBbXSk7XHJcbiAgICBjb25zdCBzaG91bGRSZW5kZXJCYXNlT25FcnJvciA9IHVzZUNhbGxiYWNrKChuYW1lLCBlcnJvciwgc2hvdWxkUmVuZGVyID0gZmFsc2UpID0+IHtcclxuICAgICAgICBsZXQgc2hvdWxkUmVSZW5kZXIgPSBzaG91bGRSZW5kZXIgfHxcclxuICAgICAgICAgICAgc2hvdWxkUmVuZGVyQmFzZWRPbkVycm9yKHtcclxuICAgICAgICAgICAgICAgIGVycm9yczogZXJyb3JzUmVmLmN1cnJlbnQsXHJcbiAgICAgICAgICAgICAgICBlcnJvcixcclxuICAgICAgICAgICAgICAgIG5hbWUsXHJcbiAgICAgICAgICAgICAgICB2YWxpZEZpZWxkczogdmFsaWRGaWVsZHNSZWYuY3VycmVudCxcclxuICAgICAgICAgICAgICAgIGZpZWxkc1dpdGhWYWxpZGF0aW9uOiBmaWVsZHNXaXRoVmFsaWRhdGlvblJlZi5jdXJyZW50LFxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICBpZiAoaXNFbXB0eU9iamVjdChlcnJvcikpIHtcclxuICAgICAgICAgICAgaWYgKGZpZWxkc1dpdGhWYWxpZGF0aW9uUmVmLmN1cnJlbnQuaGFzKG5hbWUpIHx8XHJcbiAgICAgICAgICAgICAgICBzaG91bGRWYWxpZGF0ZVNjaGVtYU9yUmVzb2x2ZXIpIHtcclxuICAgICAgICAgICAgICAgIHZhbGlkRmllbGRzUmVmLmN1cnJlbnQuYWRkKG5hbWUpO1xyXG4gICAgICAgICAgICAgICAgc2hvdWxkUmVSZW5kZXIgPSBzaG91bGRSZVJlbmRlciB8fCBnZXQoZXJyb3JzUmVmLmN1cnJlbnQsIG5hbWUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVycm9yc1JlZi5jdXJyZW50ID0gdW5zZXQoZXJyb3JzUmVmLmN1cnJlbnQsIFtuYW1lXSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBjb25zdCBwcmV2aW91c0Vycm9yID0gZ2V0KGVycm9yc1JlZi5jdXJyZW50LCBuYW1lKTtcclxuICAgICAgICAgICAgdmFsaWRGaWVsZHNSZWYuY3VycmVudC5kZWxldGUobmFtZSk7XHJcbiAgICAgICAgICAgIHNob3VsZFJlUmVuZGVyID1cclxuICAgICAgICAgICAgICAgIHNob3VsZFJlUmVuZGVyIHx8XHJcbiAgICAgICAgICAgICAgICAgICAgKHByZXZpb3VzRXJyb3JcclxuICAgICAgICAgICAgICAgICAgICAgICAgPyAhaXNTYW1lRXJyb3IocHJldmlvdXNFcnJvciwgZXJyb3JbbmFtZV0pXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDogdHJ1ZSk7XHJcbiAgICAgICAgICAgIHNldChlcnJvcnNSZWYuY3VycmVudCwgbmFtZSwgZXJyb3JbbmFtZV0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoc2hvdWxkUmVSZW5kZXIgJiYgIWlzTnVsbE9yVW5kZWZpbmVkKHNob3VsZFJlbmRlcikpIHtcclxuICAgICAgICAgICAgcmVSZW5kZXIoKTtcclxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgfSwgW3JlUmVuZGVyLCBzaG91bGRWYWxpZGF0ZVNjaGVtYU9yUmVzb2x2ZXJdKTtcclxuICAgIGNvbnN0IHNldEZpZWxkVmFsdWUgPSB1c2VDYWxsYmFjaygoZmllbGQsIHJhd1ZhbHVlKSA9PiB7XHJcbiAgICAgICAgY29uc3QgeyByZWYsIG9wdGlvbnMgfSA9IGZpZWxkO1xyXG4gICAgICAgIGNvbnN0IHZhbHVlID0gaXNXZWIgJiYgaXNIVE1MRWxlbWVudChyZWYpICYmIGlzTnVsbE9yVW5kZWZpbmVkKHJhd1ZhbHVlKVxyXG4gICAgICAgICAgICA/ICcnXHJcbiAgICAgICAgICAgIDogcmF3VmFsdWU7XHJcbiAgICAgICAgaWYgKGlzUmFkaW9JbnB1dChyZWYpICYmIG9wdGlvbnMpIHtcclxuICAgICAgICAgICAgb3B0aW9ucy5mb3JFYWNoKCh7IHJlZjogcmFkaW9SZWYgfSkgPT4gKHJhZGlvUmVmLmNoZWNrZWQgPSByYWRpb1JlZi52YWx1ZSA9PT0gdmFsdWUpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoaXNGaWxlSW5wdXQocmVmKSkge1xyXG4gICAgICAgICAgICBpZiAoaXNTdHJpbmcodmFsdWUpKSB7XHJcbiAgICAgICAgICAgICAgICByZWYudmFsdWUgPSB2YWx1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHJlZi5maWxlcyA9IHZhbHVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKGlzTXVsdGlwbGVTZWxlY3QocmVmKSkge1xyXG4gICAgICAgICAgICBbLi4ucmVmLm9wdGlvbnNdLmZvckVhY2goKHNlbGVjdFJlZikgPT4gKHNlbGVjdFJlZi5zZWxlY3RlZCA9IHZhbHVlLmluY2x1ZGVzKHNlbGVjdFJlZi52YWx1ZSkpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoaXNDaGVja0JveElucHV0KHJlZikgJiYgb3B0aW9ucykge1xyXG4gICAgICAgICAgICBvcHRpb25zLmxlbmd0aCA+IDFcclxuICAgICAgICAgICAgICAgID8gb3B0aW9ucy5mb3JFYWNoKCh7IHJlZjogY2hlY2tib3hSZWYgfSkgPT4gKGNoZWNrYm94UmVmLmNoZWNrZWQgPSB2YWx1ZS5pbmNsdWRlcyhjaGVja2JveFJlZi52YWx1ZSkpKVxyXG4gICAgICAgICAgICAgICAgOiAob3B0aW9uc1swXS5yZWYuY2hlY2tlZCA9ICEhdmFsdWUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcmVmLnZhbHVlID0gdmFsdWU7XHJcbiAgICAgICAgfVxyXG4gICAgfSwgW2lzV2ViXSk7XHJcbiAgICBjb25zdCBzZXREaXJ0eSA9IHVzZUNhbGxiYWNrKChuYW1lKSA9PiB7XHJcbiAgICAgICAgaWYgKCFmaWVsZHNSZWYuY3VycmVudFtuYW1lXSB8fFxyXG4gICAgICAgICAgICAoIXJlYWRGb3JtU3RhdGVSZWYuY3VycmVudC5kaXJ0eSAmJiAhcmVhZEZvcm1TdGF0ZVJlZi5jdXJyZW50LmRpcnR5RmllbGRzKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGxldCBpc0ZpZWxkRGlydHkgPSBkZWZhdWx0VmFsdWVzQXRSZW5kZXJSZWYuY3VycmVudFtuYW1lXSAhPT1cclxuICAgICAgICAgICAgZ2V0RmllbGRWYWx1ZShmaWVsZHNSZWYuY3VycmVudCwgZmllbGRzUmVmLmN1cnJlbnRbbmFtZV0ucmVmKTtcclxuICAgICAgICBjb25zdCBpc0ZpZWxkQXJyYXkgPSBpc05hbWVJbkZpZWxkQXJyYXkoZmllbGRBcnJheU5hbWVzUmVmLmN1cnJlbnQsIG5hbWUpO1xyXG4gICAgICAgIGNvbnN0IHByZXZpb3VzRGlydHlGaWVsZHNMZW5ndGggPSBkaXJ0eUZpZWxkc1JlZi5jdXJyZW50LnNpemU7XHJcbiAgICAgICAgaWYgKGlzRmllbGRBcnJheSkge1xyXG4gICAgICAgICAgICBjb25zdCBmaWVsZEFycmF5TmFtZSA9IGdldEZpZWxkQXJyYXlQYXJlbnROYW1lKG5hbWUpO1xyXG4gICAgICAgICAgICBpc0ZpZWxkRGlydHkgPSBnZXRJc0ZpZWxkc0RpZmZlcmVudChnZXRGaWVsZFZhbHVlQnlOYW1lKGZpZWxkc1JlZi5jdXJyZW50LCBmaWVsZEFycmF5TmFtZSksIGdldChkZWZhdWx0VmFsdWVzUmVmLmN1cnJlbnQsIGZpZWxkQXJyYXlOYW1lKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IGlzRGlydHlDaGFuZ2VkID0gKGlzRmllbGRBcnJheSA/IGlzRGlydHlSZWYuY3VycmVudCA6IGRpcnR5RmllbGRzUmVmLmN1cnJlbnQuaGFzKG5hbWUpKSAhPT1cclxuICAgICAgICAgICAgaXNGaWVsZERpcnR5O1xyXG4gICAgICAgIGlmIChpc0ZpZWxkRGlydHkpIHtcclxuICAgICAgICAgICAgZGlydHlGaWVsZHNSZWYuY3VycmVudC5hZGQobmFtZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBkaXJ0eUZpZWxkc1JlZi5jdXJyZW50LmRlbGV0ZShuYW1lKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaXNEaXJ0eVJlZi5jdXJyZW50ID0gaXNGaWVsZEFycmF5XHJcbiAgICAgICAgICAgID8gaXNGaWVsZERpcnR5XHJcbiAgICAgICAgICAgIDogISFkaXJ0eUZpZWxkc1JlZi5jdXJyZW50LnNpemU7XHJcbiAgICAgICAgcmV0dXJuIHJlYWRGb3JtU3RhdGVSZWYuY3VycmVudC5kaXJ0eVxyXG4gICAgICAgICAgICA/IGlzRGlydHlDaGFuZ2VkXHJcbiAgICAgICAgICAgIDogcHJldmlvdXNEaXJ0eUZpZWxkc0xlbmd0aCAhPT0gZGlydHlGaWVsZHNSZWYuY3VycmVudC5zaXplO1xyXG4gICAgfSwgW10pO1xyXG4gICAgY29uc3Qgc2V0SW50ZXJuYWxWYWx1ZXMgPSB1c2VDYWxsYmFjaygobmFtZSwgdmFsdWUsIHBhcmVudEZpZWxkTmFtZSkgPT4ge1xyXG4gICAgICAgIGNvbnN0IGlzVmFsdWVBcnJheSA9IGlzQXJyYXkodmFsdWUpO1xyXG4gICAgICAgIGZvciAoY29uc3Qga2V5IGluIHZhbHVlKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGZpZWxkTmFtZSA9IGAke3BhcmVudEZpZWxkTmFtZSB8fCBuYW1lfSR7aXNWYWx1ZUFycmF5ID8gYFske2tleX1dYCA6IGAuJHtrZXl9YH1gO1xyXG4gICAgICAgICAgICBjb25zdCBmaWVsZCA9IGZpZWxkc1JlZi5jdXJyZW50W2ZpZWxkTmFtZV07XHJcbiAgICAgICAgICAgIGlmIChpc09iamVjdCh2YWx1ZVtrZXldKSkge1xyXG4gICAgICAgICAgICAgICAgc2V0SW50ZXJuYWxWYWx1ZXMobmFtZSwgdmFsdWVba2V5XSwgZmllbGROYW1lKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoZmllbGQpIHtcclxuICAgICAgICAgICAgICAgIHNldEZpZWxkVmFsdWUoZmllbGQsIHZhbHVlW2tleV0pO1xyXG4gICAgICAgICAgICAgICAgc2V0RGlydHkoZmllbGROYW1lKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH0sIFtzZXRGaWVsZFZhbHVlLCBzZXREaXJ0eV0pO1xyXG4gICAgY29uc3Qgc2V0SW50ZXJuYWxWYWx1ZSA9IHVzZUNhbGxiYWNrKChuYW1lLCB2YWx1ZSkgPT4ge1xyXG4gICAgICAgIGNvbnN0IGZpZWxkID0gZmllbGRzUmVmLmN1cnJlbnRbbmFtZV07XHJcbiAgICAgICAgaWYgKGZpZWxkKSB7XHJcbiAgICAgICAgICAgIHNldEZpZWxkVmFsdWUoZmllbGQsIHZhbHVlKTtcclxuICAgICAgICAgICAgY29uc3Qgb3V0cHV0ID0gc2V0RGlydHkobmFtZSk7XHJcbiAgICAgICAgICAgIGlmIChpc0Jvb2xlYW4ob3V0cHV0KSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG91dHB1dDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmICghaXNQcmltaXRpdmUodmFsdWUpKSB7XHJcbiAgICAgICAgICAgIHNldEludGVybmFsVmFsdWVzKG5hbWUsIHZhbHVlKTtcclxuICAgICAgICB9XHJcbiAgICB9LCBbc2V0RGlydHksIHNldEZpZWxkVmFsdWUsIHNldEludGVybmFsVmFsdWVzXSk7XHJcbiAgICBjb25zdCBleGVjdXRlVmFsaWRhdGlvbiA9IHVzZUNhbGxiYWNrKGFzeW5jIChuYW1lLCBza2lwUmVSZW5kZXIpID0+IHtcclxuICAgICAgICBjb25zdCBmaWVsZCA9IGZpZWxkc1JlZi5jdXJyZW50W25hbWVdO1xyXG4gICAgICAgIGlmIChmaWVsZCkge1xyXG4gICAgICAgICAgICBjb25zdCBlcnJvciA9IGF3YWl0IHZhbGlkYXRlRmllbGQoZmllbGRzUmVmLCB2YWxpZGF0ZUFsbEZpZWxkQ3JpdGVyaWEsIGZpZWxkKTtcclxuICAgICAgICAgICAgc2hvdWxkUmVuZGVyQmFzZU9uRXJyb3IobmFtZSwgZXJyb3IsIHNraXBSZVJlbmRlciA/IG51bGwgOiBmYWxzZSk7XHJcbiAgICAgICAgICAgIHJldHVybiBpc0VtcHR5T2JqZWN0KGVycm9yKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfSwgW3Nob3VsZFJlbmRlckJhc2VPbkVycm9yLCB2YWxpZGF0ZUFsbEZpZWxkQ3JpdGVyaWFdKTtcclxuICAgIGNvbnN0IGV4ZWN1dGVTY2hlbWFPclJlc29sdmVyVmFsaWRhdGlvbiA9IHVzZUNhbGxiYWNrKGFzeW5jIChwYXlsb2FkKSA9PiB7XHJcbiAgICAgICAgY29uc3QgeyBlcnJvcnMgfSA9IGF3YWl0IHZhbGlkYXRlV2l0aFNjaGVtYSh2YWxpZGF0aW9uU2NoZW1hLCB2YWxpZGF0ZUFsbEZpZWxkQ3JpdGVyaWEsIGdldEZpZWxkVmFsdWVCeU5hbWUoZmllbGRzUmVmLmN1cnJlbnQpLCB2YWxpZGF0aW9uUmVzb2x2ZXIsIHZhbGlkYXRpb25Db250ZXh0UmVmLmN1cnJlbnQpO1xyXG4gICAgICAgIGNvbnN0IHByZXZpb3VzRm9ybUlzVmFsaWQgPSBpc1ZhbGlkUmVmLmN1cnJlbnQ7XHJcbiAgICAgICAgaXNWYWxpZFJlZi5jdXJyZW50ID0gaXNFbXB0eU9iamVjdChlcnJvcnMpO1xyXG4gICAgICAgIGlmIChpc0FycmF5KHBheWxvYWQpKSB7XHJcbiAgICAgICAgICAgIHBheWxvYWQuZm9yRWFjaCgobmFtZSkgPT4ge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgZXJyb3IgPSBnZXQoZXJyb3JzLCBuYW1lKTtcclxuICAgICAgICAgICAgICAgIGlmIChlcnJvcikge1xyXG4gICAgICAgICAgICAgICAgICAgIHNldChlcnJvcnNSZWYuY3VycmVudCwgbmFtZSwgZXJyb3IpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdW5zZXQoZXJyb3JzUmVmLmN1cnJlbnQsIFtuYW1lXSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICByZVJlbmRlcigpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgY29uc3QgZXJyb3IgPSBnZXQoZXJyb3JzLCBwYXlsb2FkKTtcclxuICAgICAgICAgICAgc2hvdWxkUmVuZGVyQmFzZU9uRXJyb3IocGF5bG9hZCwgKGVycm9yID8geyBbcGF5bG9hZF06IGVycm9yIH0gOiB7fSksIHByZXZpb3VzRm9ybUlzVmFsaWQgIT09IGlzVmFsaWRSZWYuY3VycmVudCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBpc0VtcHR5T2JqZWN0KGVycm9yc1JlZi5jdXJyZW50KTtcclxuICAgIH0sIFtcclxuICAgICAgICByZVJlbmRlcixcclxuICAgICAgICBzaG91bGRSZW5kZXJCYXNlT25FcnJvcixcclxuICAgICAgICB2YWxpZGF0ZUFsbEZpZWxkQ3JpdGVyaWEsXHJcbiAgICAgICAgdmFsaWRhdGlvblJlc29sdmVyLFxyXG4gICAgICAgIHZhbGlkYXRpb25TY2hlbWEsXHJcbiAgICBdKTtcclxuICAgIGNvbnN0IHRyaWdnZXJWYWxpZGF0aW9uID0gdXNlQ2FsbGJhY2soYXN5bmMgKHBheWxvYWQpID0+IHtcclxuICAgICAgICBjb25zdCBmaWVsZHMgPSBwYXlsb2FkIHx8IE9iamVjdC5rZXlzKGZpZWxkc1JlZi5jdXJyZW50KTtcclxuICAgICAgICBpZiAoc2hvdWxkVmFsaWRhdGVTY2hlbWFPclJlc29sdmVyKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBleGVjdXRlU2NoZW1hT3JSZXNvbHZlclZhbGlkYXRpb24oZmllbGRzKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGlzQXJyYXkoZmllbGRzKSkge1xyXG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBQcm9taXNlLmFsbChmaWVsZHMubWFwKGFzeW5jIChkYXRhKSA9PiBhd2FpdCBleGVjdXRlVmFsaWRhdGlvbihkYXRhLCB0cnVlKSkpO1xyXG4gICAgICAgICAgICByZVJlbmRlcigpO1xyXG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0LmV2ZXJ5KEJvb2xlYW4pO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gYXdhaXQgZXhlY3V0ZVZhbGlkYXRpb24oZmllbGRzKTtcclxuICAgIH0sIFtcclxuICAgICAgICBleGVjdXRlU2NoZW1hT3JSZXNvbHZlclZhbGlkYXRpb24sXHJcbiAgICAgICAgZXhlY3V0ZVZhbGlkYXRpb24sXHJcbiAgICAgICAgcmVSZW5kZXIsXHJcbiAgICAgICAgc2hvdWxkVmFsaWRhdGVTY2hlbWFPclJlc29sdmVyLFxyXG4gICAgXSk7XHJcbiAgICBjb25zdCBpc0ZpZWxkV2F0Y2hlZCA9IChuYW1lKSA9PiBpc1dhdGNoQWxsUmVmLmN1cnJlbnQgfHxcclxuICAgICAgICB3YXRjaEZpZWxkc1JlZi5jdXJyZW50LmhhcyhuYW1lKSB8fFxyXG4gICAgICAgIHdhdGNoRmllbGRzUmVmLmN1cnJlbnQuaGFzKChuYW1lLm1hdGNoKC9cXHcrLykgfHwgW10pWzBdKTtcclxuICAgIGZ1bmN0aW9uIHNldFZhbHVlKG5hbWVzLCB2YWx1ZU9yU2hvdWxkVmFsaWRhdGUsIHNob3VsZFZhbGlkYXRlKSB7XHJcbiAgICAgICAgbGV0IHNob3VsZFJlbmRlciA9IGZhbHNlO1xyXG4gICAgICAgIGNvbnN0IGlzQXJyYXlWYWx1ZSA9IGlzQXJyYXkobmFtZXMpO1xyXG4gICAgICAgIChpc0FycmF5VmFsdWVcclxuICAgICAgICAgICAgPyBuYW1lc1xyXG4gICAgICAgICAgICA6IFtuYW1lc10pLmZvckVhY2goKG5hbWUpID0+IHtcclxuICAgICAgICAgICAgY29uc3QgaXNTdHJpbmdGaWVsZE5hbWUgPSBpc1N0cmluZyhuYW1lKTtcclxuICAgICAgICAgICAgc2hvdWxkUmVuZGVyID1cclxuICAgICAgICAgICAgICAgIHNldEludGVybmFsVmFsdWUoaXNTdHJpbmdGaWVsZE5hbWUgPyBuYW1lIDogT2JqZWN0LmtleXMobmFtZSlbMF0sIGlzU3RyaW5nRmllbGROYW1lXHJcbiAgICAgICAgICAgICAgICAgICAgPyB2YWx1ZU9yU2hvdWxkVmFsaWRhdGVcclxuICAgICAgICAgICAgICAgICAgICA6IE9iamVjdC52YWx1ZXMobmFtZSlbMF0pIHx8IGlzQXJyYXlWYWx1ZVxyXG4gICAgICAgICAgICAgICAgICAgID8gdHJ1ZVxyXG4gICAgICAgICAgICAgICAgICAgIDogaXNGaWVsZFdhdGNoZWQobmFtZSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgaWYgKHNob3VsZFJlbmRlciB8fCBpc0FycmF5VmFsdWUpIHtcclxuICAgICAgICAgICAgcmVSZW5kZXIoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHNob3VsZFZhbGlkYXRlIHx8IChpc0FycmF5VmFsdWUgJiYgdmFsdWVPclNob3VsZFZhbGlkYXRlKSkge1xyXG4gICAgICAgICAgICB0cmlnZ2VyVmFsaWRhdGlvbihpc0FycmF5VmFsdWUgPyB1bmRlZmluZWQgOiBuYW1lcyk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgaGFuZGxlQ2hhbmdlUmVmLmN1cnJlbnQgPSBoYW5kbGVDaGFuZ2VSZWYuY3VycmVudFxyXG4gICAgICAgID8gaGFuZGxlQ2hhbmdlUmVmLmN1cnJlbnRcclxuICAgICAgICA6IGFzeW5jICh7IHR5cGUsIHRhcmdldCB9KSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IG5hbWUgPSB0YXJnZXQgPyB0YXJnZXQubmFtZSA6ICcnO1xyXG4gICAgICAgICAgICBjb25zdCBmaWVsZHMgPSBmaWVsZHNSZWYuY3VycmVudDtcclxuICAgICAgICAgICAgY29uc3QgZXJyb3JzID0gZXJyb3JzUmVmLmN1cnJlbnQ7XHJcbiAgICAgICAgICAgIGNvbnN0IGZpZWxkID0gZmllbGRzW25hbWVdO1xyXG4gICAgICAgICAgICBjb25zdCBjdXJyZW50RXJyb3IgPSBnZXQoZXJyb3JzLCBuYW1lKTtcclxuICAgICAgICAgICAgbGV0IGVycm9yO1xyXG4gICAgICAgICAgICBpZiAoIWZpZWxkKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY29uc3QgaXNCbHVyRXZlbnQgPSB0eXBlID09PSBFVkVOVFMuQkxVUjtcclxuICAgICAgICAgICAgY29uc3Qgc2hvdWxkU2tpcFZhbGlkYXRpb24gPSBza2lwVmFsaWRhdGlvbih7XHJcbiAgICAgICAgICAgICAgICBoYXNFcnJvcjogISFjdXJyZW50RXJyb3IsXHJcbiAgICAgICAgICAgICAgICBpc09uQ2hhbmdlLFxyXG4gICAgICAgICAgICAgICAgaXNCbHVyRXZlbnQsXHJcbiAgICAgICAgICAgICAgICBpc09uU3VibWl0LFxyXG4gICAgICAgICAgICAgICAgaXNSZVZhbGlkYXRlT25TdWJtaXQsXHJcbiAgICAgICAgICAgICAgICBpc09uQmx1cixcclxuICAgICAgICAgICAgICAgIGlzUmVWYWxpZGF0ZU9uQmx1cixcclxuICAgICAgICAgICAgICAgIGlzU3VibWl0dGVkOiBpc1N1Ym1pdHRlZFJlZi5jdXJyZW50LFxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgY29uc3Qgc2hvdWxkVXBkYXRlRGlydHkgPSBzZXREaXJ0eShuYW1lKTtcclxuICAgICAgICAgICAgbGV0IHNob3VsZFJlbmRlciA9IGlzRmllbGRXYXRjaGVkKG5hbWUpIHx8IHNob3VsZFVwZGF0ZURpcnR5O1xyXG4gICAgICAgICAgICBpZiAoaXNCbHVyRXZlbnQgJiZcclxuICAgICAgICAgICAgICAgICFnZXQodG91Y2hlZEZpZWxkc1JlZi5jdXJyZW50LCBuYW1lKSAmJlxyXG4gICAgICAgICAgICAgICAgcmVhZEZvcm1TdGF0ZVJlZi5jdXJyZW50LnRvdWNoZWQpIHtcclxuICAgICAgICAgICAgICAgIHNldCh0b3VjaGVkRmllbGRzUmVmLmN1cnJlbnQsIG5hbWUsIHRydWUpO1xyXG4gICAgICAgICAgICAgICAgc2hvdWxkUmVuZGVyID0gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoc2hvdWxkU2tpcFZhbGlkYXRpb24pIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBzaG91bGRSZW5kZXIgJiYgcmVSZW5kZXIoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoc2hvdWxkVmFsaWRhdGVTY2hlbWFPclJlc29sdmVyKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCB7IGVycm9ycyB9ID0gYXdhaXQgdmFsaWRhdGVXaXRoU2NoZW1hKHZhbGlkYXRpb25TY2hlbWEsIHZhbGlkYXRlQWxsRmllbGRDcml0ZXJpYSwgZ2V0RmllbGRWYWx1ZUJ5TmFtZShmaWVsZHMpLCB2YWxpZGF0aW9uUmVzb2x2ZXIsIHZhbGlkYXRpb25Db250ZXh0UmVmLmN1cnJlbnQpO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgcHJldmlvdXNGb3JtSXNWYWxpZCA9IGlzVmFsaWRSZWYuY3VycmVudDtcclxuICAgICAgICAgICAgICAgIGlzVmFsaWRSZWYuY3VycmVudCA9IGlzRW1wdHlPYmplY3QoZXJyb3JzKTtcclxuICAgICAgICAgICAgICAgIGVycm9yID0gKGdldChlcnJvcnMsIG5hbWUpXHJcbiAgICAgICAgICAgICAgICAgICAgPyB7IFtuYW1lXTogZ2V0KGVycm9ycywgbmFtZSkgfVxyXG4gICAgICAgICAgICAgICAgICAgIDoge30pO1xyXG4gICAgICAgICAgICAgICAgaWYgKHByZXZpb3VzRm9ybUlzVmFsaWQgIT09IGlzVmFsaWRSZWYuY3VycmVudCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHNob3VsZFJlbmRlciA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBlcnJvciA9IGF3YWl0IHZhbGlkYXRlRmllbGQoZmllbGRzUmVmLCB2YWxpZGF0ZUFsbEZpZWxkQ3JpdGVyaWEsIGZpZWxkKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoIXNob3VsZFJlbmRlckJhc2VPbkVycm9yKG5hbWUsIGVycm9yKSAmJiBzaG91bGRSZW5kZXIpIHtcclxuICAgICAgICAgICAgICAgIHJlUmVuZGVyKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgY29uc3QgdmFsaWRhdGVTY2hlbWFPclJlc29sdmVyID0gdXNlQ2FsbGJhY2soKHZhbHVlcyA9IHt9KSA9PiB7XHJcbiAgICAgICAgY29uc3QgZmllbGRWYWx1ZXMgPSBpc0VtcHR5T2JqZWN0KGRlZmF1bHRWYWx1ZXNSZWYuY3VycmVudClcclxuICAgICAgICAgICAgPyBnZXRGaWVsZHNWYWx1ZXMoZmllbGRzUmVmLmN1cnJlbnQpXHJcbiAgICAgICAgICAgIDogZGVmYXVsdFZhbHVlc1JlZi5jdXJyZW50O1xyXG4gICAgICAgIHZhbGlkYXRlV2l0aFNjaGVtYSh2YWxpZGF0aW9uU2NoZW1hLCB2YWxpZGF0ZUFsbEZpZWxkQ3JpdGVyaWEsIHRyYW5zZm9ybVRvTmVzdE9iamVjdChPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGZpZWxkVmFsdWVzKSwgdmFsdWVzKSksIHZhbGlkYXRpb25SZXNvbHZlciwgdmFsaWRhdGlvbkNvbnRleHRSZWYuY3VycmVudCkudGhlbigoeyBlcnJvcnMgfSkgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCBwcmV2aW91c0Zvcm1Jc1ZhbGlkID0gaXNWYWxpZFJlZi5jdXJyZW50O1xyXG4gICAgICAgICAgICBpc1ZhbGlkUmVmLmN1cnJlbnQgPSBpc0VtcHR5T2JqZWN0KGVycm9ycyk7XHJcbiAgICAgICAgICAgIGlmIChwcmV2aW91c0Zvcm1Jc1ZhbGlkICE9PSBpc1ZhbGlkUmVmLmN1cnJlbnQpIHtcclxuICAgICAgICAgICAgICAgIHJlUmVuZGVyKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgIH0sIFxyXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWhvb2tzL2V4aGF1c3RpdmUtZGVwc1xyXG4gICAgW3JlUmVuZGVyLCB2YWxpZGF0ZUFsbEZpZWxkQ3JpdGVyaWEsIHZhbGlkYXRpb25SZXNvbHZlcl0pO1xyXG4gICAgY29uc3QgcmVtb3ZlRmllbGRFdmVudExpc3RlbmVyID0gdXNlQ2FsbGJhY2soKGZpZWxkLCBmb3JjZURlbGV0ZSkgPT4ge1xyXG4gICAgICAgIGlmIChoYW5kbGVDaGFuZ2VSZWYuY3VycmVudCAmJiBmaWVsZCkge1xyXG4gICAgICAgICAgICBmaW5kUmVtb3ZlZEZpZWxkQW5kUmVtb3ZlTGlzdGVuZXIoZmllbGRzUmVmLmN1cnJlbnQsIGhhbmRsZUNoYW5nZVJlZi5jdXJyZW50LCBmaWVsZCwgZm9yY2VEZWxldGUpO1xyXG4gICAgICAgIH1cclxuICAgIH0sIFtdKTtcclxuICAgIGNvbnN0IHJlbW92ZUZpZWxkRXZlbnRMaXN0ZW5lckFuZFJlZiA9IHVzZUNhbGxiYWNrKChmaWVsZCwgZm9yY2VEZWxldGUpID0+IHtcclxuICAgICAgICBpZiAoIWZpZWxkIHx8XHJcbiAgICAgICAgICAgIChmaWVsZCAmJlxyXG4gICAgICAgICAgICAgICAgaXNOYW1lSW5GaWVsZEFycmF5KGZpZWxkQXJyYXlOYW1lc1JlZi5jdXJyZW50LCBmaWVsZC5yZWYubmFtZSkgJiZcclxuICAgICAgICAgICAgICAgICFmb3JjZURlbGV0ZSkpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZW1vdmVGaWVsZEV2ZW50TGlzdGVuZXIoZmllbGQsIGZvcmNlRGVsZXRlKTtcclxuICAgICAgICBjb25zdCB7IG5hbWUgfSA9IGZpZWxkLnJlZjtcclxuICAgICAgICBlcnJvcnNSZWYuY3VycmVudCA9IHVuc2V0KGVycm9yc1JlZi5jdXJyZW50LCBbbmFtZV0pO1xyXG4gICAgICAgIHRvdWNoZWRGaWVsZHNSZWYuY3VycmVudCA9IHVuc2V0KHRvdWNoZWRGaWVsZHNSZWYuY3VycmVudCwgW25hbWVdKTtcclxuICAgICAgICBkZWZhdWx0VmFsdWVzQXRSZW5kZXJSZWYuY3VycmVudCA9IHVuc2V0KGRlZmF1bHRWYWx1ZXNBdFJlbmRlclJlZi5jdXJyZW50LCBbbmFtZV0pO1xyXG4gICAgICAgIFtcclxuICAgICAgICAgICAgZGlydHlGaWVsZHNSZWYsXHJcbiAgICAgICAgICAgIGZpZWxkc1dpdGhWYWxpZGF0aW9uUmVmLFxyXG4gICAgICAgICAgICB2YWxpZEZpZWxkc1JlZixcclxuICAgICAgICAgICAgd2F0Y2hGaWVsZHNSZWYsXHJcbiAgICAgICAgXS5mb3JFYWNoKChkYXRhKSA9PiBkYXRhLmN1cnJlbnQuZGVsZXRlKG5hbWUpKTtcclxuICAgICAgICBpZiAocmVhZEZvcm1TdGF0ZVJlZi5jdXJyZW50LmlzVmFsaWQgfHxcclxuICAgICAgICAgICAgcmVhZEZvcm1TdGF0ZVJlZi5jdXJyZW50LnRvdWNoZWQpIHtcclxuICAgICAgICAgICAgcmVSZW5kZXIoKTtcclxuICAgICAgICAgICAgaWYgKHNob3VsZFZhbGlkYXRlU2NoZW1hT3JSZXNvbHZlcikge1xyXG4gICAgICAgICAgICAgICAgdmFsaWRhdGVTY2hlbWFPclJlc29sdmVyKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9LCBbXHJcbiAgICAgICAgcmVSZW5kZXIsXHJcbiAgICAgICAgc2hvdWxkVmFsaWRhdGVTY2hlbWFPclJlc29sdmVyLFxyXG4gICAgICAgIHZhbGlkYXRlU2NoZW1hT3JSZXNvbHZlcixcclxuICAgICAgICByZW1vdmVGaWVsZEV2ZW50TGlzdGVuZXIsXHJcbiAgICBdKTtcclxuICAgIGZ1bmN0aW9uIGNsZWFyRXJyb3IobmFtZSkge1xyXG4gICAgICAgIGlmIChuYW1lKSB7XHJcbiAgICAgICAgICAgIHVuc2V0KGVycm9yc1JlZi5jdXJyZW50LCBpc0FycmF5KG5hbWUpID8gbmFtZSA6IFtuYW1lXSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBlcnJvcnNSZWYuY3VycmVudCA9IHt9O1xyXG4gICAgICAgIH1cclxuICAgICAgICByZVJlbmRlcigpO1xyXG4gICAgfVxyXG4gICAgY29uc3Qgc2V0SW50ZXJuYWxFcnJvciA9ICh7IG5hbWUsIHR5cGUsIHR5cGVzLCBtZXNzYWdlLCBzaG91bGRSZW5kZXIsIH0pID0+IHtcclxuICAgICAgICBjb25zdCBmaWVsZCA9IGZpZWxkc1JlZi5jdXJyZW50W25hbWVdO1xyXG4gICAgICAgIGlmICghaXNTYW1lRXJyb3IoZ2V0KGVycm9yc1JlZi5jdXJyZW50LCBuYW1lKSwge1xyXG4gICAgICAgICAgICB0eXBlLFxyXG4gICAgICAgICAgICBtZXNzYWdlLFxyXG4gICAgICAgICAgICB0eXBlcyxcclxuICAgICAgICB9KSkge1xyXG4gICAgICAgICAgICBzZXQoZXJyb3JzUmVmLmN1cnJlbnQsIG5hbWUsIHtcclxuICAgICAgICAgICAgICAgIHR5cGUsXHJcbiAgICAgICAgICAgICAgICB0eXBlcyxcclxuICAgICAgICAgICAgICAgIG1lc3NhZ2UsXHJcbiAgICAgICAgICAgICAgICByZWY6IGZpZWxkID8gZmllbGQucmVmIDoge30sXHJcbiAgICAgICAgICAgICAgICBpc01hbnVhbDogdHJ1ZSxcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIGlmIChzaG91bGRSZW5kZXIpIHtcclxuICAgICAgICAgICAgICAgIHJlUmVuZGVyKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgZnVuY3Rpb24gc2V0RXJyb3IobmFtZSwgdHlwZSA9ICcnLCBtZXNzYWdlKSB7XHJcbiAgICAgICAgaWYgKGlzU3RyaW5nKG5hbWUpKSB7XHJcbiAgICAgICAgICAgIHNldEludGVybmFsRXJyb3IoT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHsgbmFtZSB9LCAoaXNPYmplY3QodHlwZSlcclxuICAgICAgICAgICAgICAgID8ge1xyXG4gICAgICAgICAgICAgICAgICAgIHR5cGVzOiB0eXBlLFxyXG4gICAgICAgICAgICAgICAgICAgIHR5cGU6ICcnLFxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgdHlwZSxcclxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLFxyXG4gICAgICAgICAgICAgICAgfSkpLCB7IHNob3VsZFJlbmRlcjogdHJ1ZSB9KSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKGlzQXJyYXkobmFtZSkpIHtcclxuICAgICAgICAgICAgbmFtZS5mb3JFYWNoKChlcnJvcikgPT4gc2V0SW50ZXJuYWxFcnJvcihPYmplY3QuYXNzaWduKHt9LCBlcnJvcikpKTtcclxuICAgICAgICAgICAgcmVSZW5kZXIoKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiB3YXRjaChmaWVsZE5hbWVzLCBkZWZhdWx0VmFsdWUpIHtcclxuICAgICAgICBjb25zdCB3YXRjaEZpZWxkcyA9IHdhdGNoRmllbGRzUmVmLmN1cnJlbnQ7XHJcbiAgICAgICAgY29uc3QgaXNEZWZhdWx0VmFsdWVVbmRlZmluZWQgPSBpc1VuZGVmaW5lZChkZWZhdWx0VmFsdWUpO1xyXG4gICAgICAgIGNvbnN0IGNvbWJpbmVkRGVmYXVsdFZhbHVlcyA9IGlzRGVmYXVsdFZhbHVlVW5kZWZpbmVkXHJcbiAgICAgICAgICAgID8gZGVmYXVsdFZhbHVlc1JlZi5jdXJyZW50XHJcbiAgICAgICAgICAgIDogZGVmYXVsdFZhbHVlO1xyXG4gICAgICAgIGNvbnN0IGZpZWxkVmFsdWVzID0gZ2V0RmllbGRzVmFsdWVzKGZpZWxkc1JlZi5jdXJyZW50LCBmaWVsZE5hbWVzKTtcclxuICAgICAgICBpZiAoaXNTdHJpbmcoZmllbGROYW1lcykpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGFzc2lnbldhdGNoRmllbGRzKGZpZWxkVmFsdWVzLCBmaWVsZE5hbWVzLCB3YXRjaEZpZWxkcywgaXNEZWZhdWx0VmFsdWVVbmRlZmluZWRcclxuICAgICAgICAgICAgICAgID8gZ2V0KGNvbWJpbmVkRGVmYXVsdFZhbHVlcywgZmllbGROYW1lcylcclxuICAgICAgICAgICAgICAgIDogZGVmYXVsdFZhbHVlLCB0cnVlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGlzQXJyYXkoZmllbGROYW1lcykpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZpZWxkTmFtZXMucmVkdWNlKChwcmV2aW91cywgbmFtZSkgPT4gKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgcHJldmlvdXMpLCB7IFtuYW1lXTogYXNzaWduV2F0Y2hGaWVsZHMoZmllbGRWYWx1ZXMsIG5hbWUsIHdhdGNoRmllbGRzLCBjb21iaW5lZERlZmF1bHRWYWx1ZXMpIH0pKSwge30pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpc1dhdGNoQWxsUmVmLmN1cnJlbnQgPSB0cnVlO1xyXG4gICAgICAgIGNvbnN0IHJlc3VsdCA9ICghaXNFbXB0eU9iamVjdChmaWVsZFZhbHVlcykgJiYgZmllbGRWYWx1ZXMpIHx8IGNvbWJpbmVkRGVmYXVsdFZhbHVlcztcclxuICAgICAgICByZXR1cm4gZmllbGROYW1lcyAmJiBmaWVsZE5hbWVzLm5lc3RcclxuICAgICAgICAgICAgPyB0cmFuc2Zvcm1Ub05lc3RPYmplY3QocmVzdWx0KVxyXG4gICAgICAgICAgICA6IHJlc3VsdDtcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIHVucmVnaXN0ZXIobmFtZSkge1xyXG4gICAgICAgIGlmIChmaWVsZHNSZWYuY3VycmVudCkge1xyXG4gICAgICAgICAgICAoaXNBcnJheShuYW1lKSA/IG5hbWUgOiBbbmFtZV0pLmZvckVhY2goKGZpZWxkTmFtZSkgPT4gcmVtb3ZlRmllbGRFdmVudExpc3RlbmVyQW5kUmVmKGZpZWxkc1JlZi5jdXJyZW50W2ZpZWxkTmFtZV0sIHRydWUpKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiByZWdpc3RlckZpZWxkc1JlZihyZWYsIHZhbGlkYXRlT3B0aW9ucyA9IHt9KSB7XHJcbiAgICAgICAgaWYgKCFyZWYubmFtZSkge1xyXG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29uc29sZVxyXG4gICAgICAgICAgICByZXR1cm4gY29uc29sZS53YXJuKCdNaXNzaW5nIG5hbWUgQCcsIHJlZik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IHsgbmFtZSwgdHlwZSwgdmFsdWUgfSA9IHJlZjtcclxuICAgICAgICBjb25zdCBmaWVsZFJlZkFuZFZhbGlkYXRpb25PcHRpb25zID0gT2JqZWN0LmFzc2lnbih7IHJlZiB9LCB2YWxpZGF0ZU9wdGlvbnMpO1xyXG4gICAgICAgIGNvbnN0IGZpZWxkcyA9IGZpZWxkc1JlZi5jdXJyZW50O1xyXG4gICAgICAgIGNvbnN0IGlzUmFkaW9PckNoZWNrYm94ID0gaXNSYWRpb09yQ2hlY2tib3hGdW5jdGlvbihyZWYpO1xyXG4gICAgICAgIGxldCBmaWVsZCA9IGZpZWxkc1tuYW1lXTtcclxuICAgICAgICBsZXQgaXNFbXB0eURlZmF1bHRWYWx1ZSA9IHRydWU7XHJcbiAgICAgICAgbGV0IGlzRmllbGRBcnJheTtcclxuICAgICAgICBsZXQgZGVmYXVsdFZhbHVlO1xyXG4gICAgICAgIGlmIChpc1JhZGlvT3JDaGVja2JveFxyXG4gICAgICAgICAgICA/IGZpZWxkICYmXHJcbiAgICAgICAgICAgICAgICBpc0FycmF5KGZpZWxkLm9wdGlvbnMpICYmXHJcbiAgICAgICAgICAgICAgICBmaWVsZC5vcHRpb25zLmZpbHRlcihCb29sZWFuKS5maW5kKChvcHRpb24pID0+IHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWUgPT09IG9wdGlvbi5yZWYudmFsdWUgJiYgb3B0aW9uLnJlZiA9PT0gcmVmO1xyXG4gICAgICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgOiBmaWVsZCAmJiByZWYgPT09IGZpZWxkLnJlZikge1xyXG4gICAgICAgICAgICBmaWVsZHNbbmFtZV0gPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGZpZWxkKSwgdmFsaWRhdGVPcHRpb25zKTtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodHlwZSkge1xyXG4gICAgICAgICAgICBjb25zdCBtdXRhdGlvbldhdGNoZXIgPSBvbkRvbVJlbW92ZShyZWYsICgpID0+IHJlbW92ZUZpZWxkRXZlbnRMaXN0ZW5lckFuZFJlZihmaWVsZCkpO1xyXG4gICAgICAgICAgICBmaWVsZCA9IGlzUmFkaW9PckNoZWNrYm94XHJcbiAgICAgICAgICAgICAgICA/IE9iamVjdC5hc3NpZ24oeyBvcHRpb25zOiBbXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC4uLigoZmllbGQgJiYgZmllbGQub3B0aW9ucykgfHwgW10pLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWYsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtdXRhdGlvbldhdGNoZXIsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICAgICAgXSwgcmVmOiB7IHR5cGUsIG5hbWUgfSB9LCB2YWxpZGF0ZU9wdGlvbnMpIDogT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBmaWVsZFJlZkFuZFZhbGlkYXRpb25PcHRpb25zKSwgeyBtdXRhdGlvbldhdGNoZXIgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBmaWVsZCA9IGZpZWxkUmVmQW5kVmFsaWRhdGlvbk9wdGlvbnM7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZpZWxkc1tuYW1lXSA9IGZpZWxkO1xyXG4gICAgICAgIGlmICghaXNFbXB0eU9iamVjdChkZWZhdWx0VmFsdWVzUmVmLmN1cnJlbnQpKSB7XHJcbiAgICAgICAgICAgIGRlZmF1bHRWYWx1ZSA9IGdldChkZWZhdWx0VmFsdWVzUmVmLmN1cnJlbnQsIG5hbWUpO1xyXG4gICAgICAgICAgICBpc0VtcHR5RGVmYXVsdFZhbHVlID0gaXNVbmRlZmluZWQoZGVmYXVsdFZhbHVlKTtcclxuICAgICAgICAgICAgaXNGaWVsZEFycmF5ID0gaXNOYW1lSW5GaWVsZEFycmF5KGZpZWxkQXJyYXlOYW1lc1JlZi5jdXJyZW50LCBuYW1lKTtcclxuICAgICAgICAgICAgaWYgKCFpc0VtcHR5RGVmYXVsdFZhbHVlICYmICFpc0ZpZWxkQXJyYXkpIHtcclxuICAgICAgICAgICAgICAgIHNldEZpZWxkVmFsdWUoZmllbGQsIGRlZmF1bHRWYWx1ZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHNob3VsZFZhbGlkYXRlU2NoZW1hT3JSZXNvbHZlciAmJlxyXG4gICAgICAgICAgICAhaXNGaWVsZEFycmF5ICYmXHJcbiAgICAgICAgICAgIHJlYWRGb3JtU3RhdGVSZWYuY3VycmVudC5pc1ZhbGlkKSB7XHJcbiAgICAgICAgICAgIHZhbGlkYXRlU2NoZW1hT3JSZXNvbHZlcigpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmICghaXNFbXB0eU9iamVjdCh2YWxpZGF0ZU9wdGlvbnMpKSB7XHJcbiAgICAgICAgICAgIGZpZWxkc1dpdGhWYWxpZGF0aW9uUmVmLmN1cnJlbnQuYWRkKG5hbWUpO1xyXG4gICAgICAgICAgICBpZiAoIWlzT25TdWJtaXQgJiYgcmVhZEZvcm1TdGF0ZVJlZi5jdXJyZW50LmlzVmFsaWQpIHtcclxuICAgICAgICAgICAgICAgIHZhbGlkYXRlRmllbGQoZmllbGRzUmVmLCB2YWxpZGF0ZUFsbEZpZWxkQ3JpdGVyaWEsIGZpZWxkKS50aGVuKChlcnJvcikgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHByZXZpb3VzRm9ybUlzVmFsaWQgPSBpc1ZhbGlkUmVmLmN1cnJlbnQ7XHJcbiAgICAgICAgICAgICAgICAgICAgaXNFbXB0eU9iamVjdChlcnJvcilcclxuICAgICAgICAgICAgICAgICAgICAgICAgPyB2YWxpZEZpZWxkc1JlZi5jdXJyZW50LmFkZChuYW1lKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICA6IChpc1ZhbGlkUmVmLmN1cnJlbnQgPSBmYWxzZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHByZXZpb3VzRm9ybUlzVmFsaWQgIT09IGlzVmFsaWRSZWYuY3VycmVudCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZVJlbmRlcigpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICghZGVmYXVsdFZhbHVlc0F0UmVuZGVyUmVmLmN1cnJlbnRbbmFtZV0gJiZcclxuICAgICAgICAgICAgIShpc0ZpZWxkQXJyYXkgJiYgaXNFbXB0eURlZmF1bHRWYWx1ZSkpIHtcclxuICAgICAgICAgICAgZGVmYXVsdFZhbHVlc0F0UmVuZGVyUmVmLmN1cnJlbnRbbmFtZV0gPSBpc0VtcHR5RGVmYXVsdFZhbHVlID8gZ2V0RmllbGRWYWx1ZShmaWVsZHMsIGZpZWxkLnJlZikgOiBkZWZhdWx0VmFsdWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0eXBlKSB7XHJcbiAgICAgICAgICAgIGF0dGFjaEV2ZW50TGlzdGVuZXJzKHtcclxuICAgICAgICAgICAgICAgIGZpZWxkOiBpc1JhZGlvT3JDaGVja2JveCAmJiBmaWVsZC5vcHRpb25zXHJcbiAgICAgICAgICAgICAgICAgICAgPyBmaWVsZC5vcHRpb25zW2ZpZWxkLm9wdGlvbnMubGVuZ3RoIC0gMV1cclxuICAgICAgICAgICAgICAgICAgICA6IGZpZWxkLFxyXG4gICAgICAgICAgICAgICAgaXNSYWRpb09yQ2hlY2tib3g6IGlzUmFkaW9PckNoZWNrYm94IHx8IGlzU2VsZWN0SW5wdXQocmVmKSxcclxuICAgICAgICAgICAgICAgIGhhbmRsZUNoYW5nZTogaGFuZGxlQ2hhbmdlUmVmLmN1cnJlbnQsXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIHJlZ2lzdGVyKHJlZk9yVmFsaWRhdGlvbk9wdGlvbnMsIHZhbGlkYXRpb25PcHRpb25zKSB7XHJcbiAgICAgICAgaWYgKGlzV2luZG93VW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGlzU3RyaW5nKHJlZk9yVmFsaWRhdGlvbk9wdGlvbnMpKSB7XHJcbiAgICAgICAgICAgIHJlZ2lzdGVyRmllbGRzUmVmKHsgbmFtZTogcmVmT3JWYWxpZGF0aW9uT3B0aW9ucyB9LCB2YWxpZGF0aW9uT3B0aW9ucyk7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGlzT2JqZWN0KHJlZk9yVmFsaWRhdGlvbk9wdGlvbnMpICYmICduYW1lJyBpbiByZWZPclZhbGlkYXRpb25PcHRpb25zKSB7XHJcbiAgICAgICAgICAgIHJlZ2lzdGVyRmllbGRzUmVmKHJlZk9yVmFsaWRhdGlvbk9wdGlvbnMsIHZhbGlkYXRpb25PcHRpb25zKTtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gKHJlZikgPT4gcmVmICYmIHJlZ2lzdGVyRmllbGRzUmVmKHJlZiwgcmVmT3JWYWxpZGF0aW9uT3B0aW9ucyk7XHJcbiAgICB9XHJcbiAgICBjb25zdCBoYW5kbGVTdWJtaXQgPSB1c2VDYWxsYmFjaygoY2FsbGJhY2spID0+IGFzeW5jIChlKSA9PiB7XHJcbiAgICAgICAgaWYgKGUpIHtcclxuICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xyXG4gICAgICAgICAgICBlLnBlcnNpc3QoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgbGV0IGZpZWxkRXJyb3JzID0ge307XHJcbiAgICAgICAgY29uc3QgZmllbGRzID0gZmllbGRzUmVmLmN1cnJlbnQ7XHJcbiAgICAgICAgbGV0IGZpZWxkVmFsdWVzID0gZ2V0RmllbGRzVmFsdWVzKGZpZWxkcyk7XHJcbiAgICAgICAgaWYgKHJlYWRGb3JtU3RhdGVSZWYuY3VycmVudC5pc1N1Ym1pdHRpbmcpIHtcclxuICAgICAgICAgICAgaXNTdWJtaXR0aW5nUmVmLmN1cnJlbnQgPSB0cnVlO1xyXG4gICAgICAgICAgICByZVJlbmRlcigpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICBpZiAoc2hvdWxkVmFsaWRhdGVTY2hlbWFPclJlc29sdmVyKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCB7IGVycm9ycywgdmFsdWVzIH0gPSBhd2FpdCB2YWxpZGF0ZVdpdGhTY2hlbWEodmFsaWRhdGlvblNjaGVtYSwgdmFsaWRhdGVBbGxGaWVsZENyaXRlcmlhLCB0cmFuc2Zvcm1Ub05lc3RPYmplY3QoZmllbGRWYWx1ZXMpLCB2YWxpZGF0aW9uUmVzb2x2ZXIsIHZhbGlkYXRpb25Db250ZXh0UmVmLmN1cnJlbnQpO1xyXG4gICAgICAgICAgICAgICAgZXJyb3JzUmVmLmN1cnJlbnQgPSBlcnJvcnM7XHJcbiAgICAgICAgICAgICAgICBmaWVsZEVycm9ycyA9IGVycm9ycztcclxuICAgICAgICAgICAgICAgIGZpZWxkVmFsdWVzID0gdmFsdWVzO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBmaWVsZCBvZiBPYmplY3QudmFsdWVzKGZpZWxkcykpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoZmllbGQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgeyByZWY6IHsgbmFtZSB9LCB9ID0gZmllbGQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGZpZWxkRXJyb3IgPSBhd2FpdCB2YWxpZGF0ZUZpZWxkKGZpZWxkc1JlZiwgdmFsaWRhdGVBbGxGaWVsZENyaXRlcmlhLCBmaWVsZCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChmaWVsZEVycm9yW25hbWVdKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXQoZmllbGRFcnJvcnMsIG5hbWUsIGZpZWxkRXJyb3JbbmFtZV0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsaWRGaWVsZHNSZWYuY3VycmVudC5kZWxldGUobmFtZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZmllbGRzV2l0aFZhbGlkYXRpb25SZWYuY3VycmVudC5oYXMobmFtZSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWxpZEZpZWxkc1JlZi5jdXJyZW50LmFkZChuYW1lKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoaXNFbXB0eU9iamVjdChmaWVsZEVycm9ycykpIHtcclxuICAgICAgICAgICAgICAgIGVycm9yc1JlZi5jdXJyZW50ID0ge307XHJcbiAgICAgICAgICAgICAgICByZVJlbmRlcigpO1xyXG4gICAgICAgICAgICAgICAgYXdhaXQgY2FsbGJhY2sodHJhbnNmb3JtVG9OZXN0T2JqZWN0KGZpZWxkVmFsdWVzKSwgZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBlcnJvcnNSZWYuY3VycmVudCA9IGZpZWxkRXJyb3JzO1xyXG4gICAgICAgICAgICAgICAgaWYgKHN1Ym1pdEZvY3VzRXJyb3IgJiYgaXNXZWIpIHtcclxuICAgICAgICAgICAgICAgICAgICBmb2N1c09uRXJyb3JGaWVsZChmaWVsZHMsIGZpZWxkRXJyb3JzKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBmaW5hbGx5IHtcclxuICAgICAgICAgICAgaXNTdWJtaXR0ZWRSZWYuY3VycmVudCA9IHRydWU7XHJcbiAgICAgICAgICAgIGlzU3VibWl0dGluZ1JlZi5jdXJyZW50ID0gZmFsc2U7XHJcbiAgICAgICAgICAgIHN1Ym1pdENvdW50UmVmLmN1cnJlbnQgPSBzdWJtaXRDb3VudFJlZi5jdXJyZW50ICsgMTtcclxuICAgICAgICAgICAgcmVSZW5kZXIoKTtcclxuICAgICAgICB9XHJcbiAgICB9LCBbXHJcbiAgICAgICAgaXNXZWIsXHJcbiAgICAgICAgcmVSZW5kZXIsXHJcbiAgICAgICAgc2hvdWxkVmFsaWRhdGVTY2hlbWFPclJlc29sdmVyLFxyXG4gICAgICAgIHN1Ym1pdEZvY3VzRXJyb3IsXHJcbiAgICAgICAgdmFsaWRhdGVBbGxGaWVsZENyaXRlcmlhLFxyXG4gICAgICAgIHZhbGlkYXRpb25SZXNvbHZlcixcclxuICAgICAgICB2YWxpZGF0aW9uU2NoZW1hLFxyXG4gICAgXSk7XHJcbiAgICBjb25zdCByZXNldFJlZnMgPSAoeyBlcnJvcnMsIGRpcnR5LCBpc1N1Ym1pdHRlZCwgdG91Y2hlZCwgaXNWYWxpZCwgc3VibWl0Q291bnQsIGRpcnR5RmllbGRzLCB9KSA9PiB7XHJcbiAgICAgICAgZmllbGRzUmVmLmN1cnJlbnQgPSB7fTtcclxuICAgICAgICBpZiAoIWVycm9ycykge1xyXG4gICAgICAgICAgICBlcnJvcnNSZWYuY3VycmVudCA9IHt9O1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoIXRvdWNoZWQpIHtcclxuICAgICAgICAgICAgdG91Y2hlZEZpZWxkc1JlZi5jdXJyZW50ID0ge307XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICghaXNWYWxpZCkge1xyXG4gICAgICAgICAgICB2YWxpZEZpZWxkc1JlZi5jdXJyZW50ID0gbmV3IFNldCgpO1xyXG4gICAgICAgICAgICBmaWVsZHNXaXRoVmFsaWRhdGlvblJlZi5jdXJyZW50ID0gbmV3IFNldCgpO1xyXG4gICAgICAgICAgICBpc1ZhbGlkUmVmLmN1cnJlbnQgPSB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoIWRpcnR5KSB7XHJcbiAgICAgICAgICAgIGlzRGlydHlSZWYuY3VycmVudCA9IGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoIWRpcnR5RmllbGRzKSB7XHJcbiAgICAgICAgICAgIGRpcnR5RmllbGRzUmVmLmN1cnJlbnQgPSBuZXcgU2V0KCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICghaXNTdWJtaXR0ZWQpIHtcclxuICAgICAgICAgICAgaXNTdWJtaXR0ZWRSZWYuY3VycmVudCA9IGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoIXN1Ym1pdENvdW50KSB7XHJcbiAgICAgICAgICAgIHN1Ym1pdENvdW50UmVmLmN1cnJlbnQgPSAwO1xyXG4gICAgICAgIH1cclxuICAgICAgICBkZWZhdWx0VmFsdWVzQXRSZW5kZXJSZWYuY3VycmVudCA9IHt9O1xyXG4gICAgICAgIGZpZWxkQXJyYXlEZWZhdWx0VmFsdWVzLmN1cnJlbnQgPSB7fTtcclxuICAgICAgICB3YXRjaEZpZWxkc1JlZi5jdXJyZW50ID0gbmV3IFNldCgpO1xyXG4gICAgICAgIGlzV2F0Y2hBbGxSZWYuY3VycmVudCA9IGZhbHNlO1xyXG4gICAgfTtcclxuICAgIGNvbnN0IHJlc2V0ID0gKHZhbHVlcywgb21pdFJlc2V0U3RhdGUgPSB7fSkgPT4ge1xyXG4gICAgICAgIGlmIChpc1dlYikge1xyXG4gICAgICAgICAgICBmb3IgKGNvbnN0IGZpZWxkIG9mIE9iamVjdC52YWx1ZXMoZmllbGRzUmVmLmN1cnJlbnQpKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoZmllbGQpIHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCB7IHJlZiwgb3B0aW9ucyB9ID0gZmllbGQ7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgaW5wdXRSZWYgPSBpc1JhZGlvT3JDaGVja2JveEZ1bmN0aW9uKHJlZikgJiYgaXNBcnJheShvcHRpb25zKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICA/IG9wdGlvbnNbMF0ucmVmXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDogcmVmO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChpc0hUTUxFbGVtZW50KGlucHV0UmVmKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5wdXRSZWYuY2xvc2VzdCgnZm9ybScpLnJlc2V0KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXRjaCAoX2EpIHsgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodmFsdWVzKSB7XHJcbiAgICAgICAgICAgIGRlZmF1bHRWYWx1ZXNSZWYuY3VycmVudCA9IHZhbHVlcztcclxuICAgICAgICB9XHJcbiAgICAgICAgT2JqZWN0LnZhbHVlcyhyZXNldEZpZWxkQXJyYXlGdW5jdGlvblJlZi5jdXJyZW50KS5mb3JFYWNoKChyZXNldEZpZWxkQXJyYXkpID0+IGlzRnVuY3Rpb24ocmVzZXRGaWVsZEFycmF5KSAmJiByZXNldEZpZWxkQXJyYXkoKSk7XHJcbiAgICAgICAgcmVzZXRSZWZzKG9taXRSZXNldFN0YXRlKTtcclxuICAgICAgICByZVJlbmRlcigpO1xyXG4gICAgfTtcclxuICAgIGZ1bmN0aW9uIGdldFZhbHVlcyhwYXlsb2FkKSB7XHJcbiAgICAgICAgaWYgKGlzU3RyaW5nKHBheWxvYWQpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmaWVsZHNSZWYuY3VycmVudFtwYXlsb2FkXVxyXG4gICAgICAgICAgICAgICAgPyBnZXRGaWVsZFZhbHVlKGZpZWxkc1JlZi5jdXJyZW50LCBmaWVsZHNSZWYuY3VycmVudFtwYXlsb2FkXS5yZWYpXHJcbiAgICAgICAgICAgICAgICA6IGdldChkZWZhdWx0VmFsdWVzUmVmLmN1cnJlbnQsIHBheWxvYWQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBmaWVsZFZhbHVlcyA9IGdldEZpZWxkc1ZhbHVlcyhmaWVsZHNSZWYuY3VycmVudCk7XHJcbiAgICAgICAgY29uc3Qgb3V0cHV0VmFsdWVzID0gaXNFbXB0eU9iamVjdChmaWVsZFZhbHVlcylcclxuICAgICAgICAgICAgPyBkZWZhdWx0VmFsdWVzUmVmLmN1cnJlbnRcclxuICAgICAgICAgICAgOiBmaWVsZFZhbHVlcztcclxuICAgICAgICByZXR1cm4gcGF5bG9hZCAmJiBwYXlsb2FkLm5lc3RcclxuICAgICAgICAgICAgPyB0cmFuc2Zvcm1Ub05lc3RPYmplY3Qob3V0cHV0VmFsdWVzKVxyXG4gICAgICAgICAgICA6IG91dHB1dFZhbHVlcztcclxuICAgIH1cclxuICAgIHVzZUVmZmVjdCgoKSA9PiAoKSA9PiB7XHJcbiAgICAgICAgaXNVbk1vdW50LmN1cnJlbnQgPSB0cnVlO1xyXG4gICAgICAgIGZpZWxkc1JlZi5jdXJyZW50ICYmXHJcbiAgICAgICAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAncHJvZHVjdGlvbicgJiZcclxuICAgICAgICAgICAgT2JqZWN0LnZhbHVlcyhmaWVsZHNSZWYuY3VycmVudCkuZm9yRWFjaCgoZmllbGQpID0+IHJlbW92ZUZpZWxkRXZlbnRMaXN0ZW5lckFuZFJlZihmaWVsZCwgdHJ1ZSkpO1xyXG4gICAgfSwgW3JlbW92ZUZpZWxkRXZlbnRMaXN0ZW5lckFuZFJlZl0pO1xyXG4gICAgaWYgKCFzaG91bGRWYWxpZGF0ZVNjaGVtYU9yUmVzb2x2ZXIpIHtcclxuICAgICAgICBpc1ZhbGlkUmVmLmN1cnJlbnQgPVxyXG4gICAgICAgICAgICB2YWxpZEZpZWxkc1JlZi5jdXJyZW50LnNpemUgPj0gZmllbGRzV2l0aFZhbGlkYXRpb25SZWYuY3VycmVudC5zaXplICYmXHJcbiAgICAgICAgICAgICAgICBpc0VtcHR5T2JqZWN0KGVycm9yc1JlZi5jdXJyZW50KTtcclxuICAgIH1cclxuICAgIGNvbnN0IGZvcm1TdGF0ZSA9IHtcclxuICAgICAgICBkaXJ0eTogaXNEaXJ0eVJlZi5jdXJyZW50LFxyXG4gICAgICAgIGRpcnR5RmllbGRzOiBkaXJ0eUZpZWxkc1JlZi5jdXJyZW50LFxyXG4gICAgICAgIGlzU3VibWl0dGVkOiBpc1N1Ym1pdHRlZFJlZi5jdXJyZW50LFxyXG4gICAgICAgIHN1Ym1pdENvdW50OiBzdWJtaXRDb3VudFJlZi5jdXJyZW50LFxyXG4gICAgICAgIHRvdWNoZWQ6IHRvdWNoZWRGaWVsZHNSZWYuY3VycmVudCxcclxuICAgICAgICBpc1N1Ym1pdHRpbmc6IGlzU3VibWl0dGluZ1JlZi5jdXJyZW50LFxyXG4gICAgICAgIGlzVmFsaWQ6IGlzT25TdWJtaXRcclxuICAgICAgICAgICAgPyBpc1N1Ym1pdHRlZFJlZi5jdXJyZW50ICYmIGlzRW1wdHlPYmplY3QoZXJyb3JzUmVmLmN1cnJlbnQpXHJcbiAgICAgICAgICAgIDogaXNWYWxpZFJlZi5jdXJyZW50LFxyXG4gICAgfTtcclxuICAgIGNvbnN0IGNvbW1vblByb3BzID0ge1xyXG4gICAgICAgIHRyaWdnZXJWYWxpZGF0aW9uLFxyXG4gICAgICAgIHNldFZhbHVlOiB1c2VDYWxsYmFjayhzZXRWYWx1ZSwgW1xyXG4gICAgICAgICAgICByZVJlbmRlcixcclxuICAgICAgICAgICAgc2V0SW50ZXJuYWxWYWx1ZSxcclxuICAgICAgICAgICAgdHJpZ2dlclZhbGlkYXRpb24sXHJcbiAgICAgICAgXSksXHJcbiAgICAgICAgcmVnaXN0ZXI6IHVzZUNhbGxiYWNrKHJlZ2lzdGVyLCBbXHJcbiAgICAgICAgICAgIGRlZmF1bHRWYWx1ZXNSZWYuY3VycmVudCxcclxuICAgICAgICAgICAgZGVmYXVsdFZhbHVlc0F0UmVuZGVyUmVmLmN1cnJlbnQsXHJcbiAgICAgICAgXSksXHJcbiAgICAgICAgdW5yZWdpc3RlcjogdXNlQ2FsbGJhY2sodW5yZWdpc3RlciwgW10pLFxyXG4gICAgICAgIGdldFZhbHVlczogdXNlQ2FsbGJhY2soZ2V0VmFsdWVzLCBbXSksXHJcbiAgICAgICAgZm9ybVN0YXRlOiBpc1Byb3h5RW5hYmxlZFxyXG4gICAgICAgICAgICA/IG5ldyBQcm94eShmb3JtU3RhdGUsIHtcclxuICAgICAgICAgICAgICAgIGdldDogKG9iaiwgcHJvcCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChwcm9wIGluIG9iaikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZWFkRm9ybVN0YXRlUmVmLmN1cnJlbnRbcHJvcF0gPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gb2JqW3Byb3BdO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgOiBmb3JtU3RhdGUsXHJcbiAgICB9O1xyXG4gICAgY29uc3QgY29udHJvbCA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHsgcmVtb3ZlRmllbGRFdmVudExpc3RlbmVyLFxyXG4gICAgICAgIHJlUmVuZGVyIH0sIChzaG91bGRWYWxpZGF0ZVNjaGVtYU9yUmVzb2x2ZXJcclxuICAgICAgICA/IHsgdmFsaWRhdGVTY2hlbWFJc1ZhbGlkOiB2YWxpZGF0ZVNjaGVtYU9yUmVzb2x2ZXIgfVxyXG4gICAgICAgIDoge30pKSwgeyBtb2RlOiB7XHJcbiAgICAgICAgICAgIGlzT25CbHVyLFxyXG4gICAgICAgICAgICBpc09uU3VibWl0LFxyXG4gICAgICAgICAgICBpc09uQ2hhbmdlLFxyXG4gICAgICAgIH0sIHJlVmFsaWRhdGVNb2RlOiB7XHJcbiAgICAgICAgICAgIGlzUmVWYWxpZGF0ZU9uQmx1cixcclxuICAgICAgICAgICAgaXNSZVZhbGlkYXRlT25TdWJtaXQsXHJcbiAgICAgICAgfSwgZXJyb3JzUmVmLFxyXG4gICAgICAgIHRvdWNoZWRGaWVsZHNSZWYsXHJcbiAgICAgICAgZmllbGRzUmVmLFxyXG4gICAgICAgIGlzV2F0Y2hBbGxSZWYsXHJcbiAgICAgICAgd2F0Y2hGaWVsZHNSZWYsXHJcbiAgICAgICAgcmVzZXRGaWVsZEFycmF5RnVuY3Rpb25SZWYsXHJcbiAgICAgICAgZmllbGRBcnJheURlZmF1bHRWYWx1ZXMsXHJcbiAgICAgICAgdmFsaWRGaWVsZHNSZWYsXHJcbiAgICAgICAgZGlydHlGaWVsZHNSZWYsXHJcbiAgICAgICAgZmllbGRzV2l0aFZhbGlkYXRpb25SZWYsXHJcbiAgICAgICAgZmllbGRBcnJheU5hbWVzUmVmLFxyXG4gICAgICAgIGlzRGlydHlSZWYsXHJcbiAgICAgICAgcmVhZEZvcm1TdGF0ZVJlZixcclxuICAgICAgICBkZWZhdWx0VmFsdWVzUmVmIH0pLCBjb21tb25Qcm9wcyk7XHJcbiAgICByZXR1cm4gT2JqZWN0LmFzc2lnbih7IHdhdGNoLFxyXG4gICAgICAgIGNvbnRyb2wsXHJcbiAgICAgICAgaGFuZGxlU3VibWl0LCByZXNldDogdXNlQ2FsbGJhY2socmVzZXQsIFtdKSwgY2xlYXJFcnJvcjogdXNlQ2FsbGJhY2soY2xlYXJFcnJvciwgW10pLCBzZXRFcnJvcjogdXNlQ2FsbGJhY2soc2V0RXJyb3IsIFtdKSwgZXJyb3JzOiBlcnJvcnNSZWYuY3VycmVudCB9LCBjb21tb25Qcm9wcyk7XHJcbn1cblxuLyohICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXHJcbkNvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG5MaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2VcclxudGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGVcclxuTGljZW5zZSBhdCBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuXHJcblRISVMgQ09ERSBJUyBQUk9WSURFRCBPTiBBTiAqQVMgSVMqIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcclxuS0lORCwgRUlUSEVSIEVYUFJFU1MgT1IgSU1QTElFRCwgSU5DTFVESU5HIFdJVEhPVVQgTElNSVRBVElPTiBBTlkgSU1QTElFRFxyXG5XQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgVElUTEUsIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLFxyXG5NRVJDSEFOVEFCTElUWSBPUiBOT04tSU5GUklOR0VNRU5ULlxyXG5cclxuU2VlIHRoZSBBcGFjaGUgVmVyc2lvbiAyLjAgTGljZW5zZSBmb3Igc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zXHJcbmFuZCBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiogKi9cclxuXHJcbmZ1bmN0aW9uIF9fcmVzdChzLCBlKSB7XHJcbiAgICB2YXIgdCA9IHt9O1xyXG4gICAgZm9yICh2YXIgcCBpbiBzKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHMsIHApICYmIGUuaW5kZXhPZihwKSA8IDApXHJcbiAgICAgICAgdFtwXSA9IHNbcF07XHJcbiAgICBpZiAocyAhPSBudWxsICYmIHR5cGVvZiBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzID09PSBcImZ1bmN0aW9uXCIpXHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIHAgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKHMpOyBpIDwgcC5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBpZiAoZS5pbmRleE9mKHBbaV0pIDwgMCAmJiBPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwocywgcFtpXSkpXHJcbiAgICAgICAgICAgICAgICB0W3BbaV1dID0gc1twW2ldXTtcclxuICAgICAgICB9XHJcbiAgICByZXR1cm4gdDtcclxufVxuXG5jb25zdCBGb3JtR2xvYmFsQ29udGV4dCA9IGNyZWF0ZUNvbnRleHQobnVsbCk7XHJcbmZ1bmN0aW9uIHVzZUZvcm1Db250ZXh0KCkge1xyXG4gICAgcmV0dXJuIHVzZUNvbnRleHQoRm9ybUdsb2JhbENvbnRleHQpO1xyXG59XHJcbmZ1bmN0aW9uIEZvcm1Db250ZXh0KF9hKSB7XHJcbiAgICB2YXIgeyBjaGlsZHJlbiwgZm9ybVN0YXRlLCBlcnJvcnMgfSA9IF9hLCByZXN0TWV0aG9kcyA9IF9fcmVzdChfYSwgW1wiY2hpbGRyZW5cIiwgXCJmb3JtU3RhdGVcIiwgXCJlcnJvcnNcIl0pO1xyXG4gICAgcmV0dXJuIChjcmVhdGVFbGVtZW50KEZvcm1HbG9iYWxDb250ZXh0LlByb3ZpZGVyLCB7IHZhbHVlOiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHJlc3RNZXRob2RzKSwgeyBmb3JtU3RhdGUsIGVycm9ycyB9KSB9LCBjaGlsZHJlbikpO1xyXG59XG5cbnZhciBnZW5lcmF0ZUlkID0gKCkgPT4ge1xyXG4gICAgY29uc3QgZCA9IHR5cGVvZiBwZXJmb3JtYW5jZSA9PT0gVU5ERUZJTkVEID8gRGF0ZS5ub3coKSA6IHBlcmZvcm1hbmNlLm5vdygpICogMTAwMDtcclxuICAgIHJldHVybiAneHh4eHh4eHgteHh4eC00eHh4LXl4eHgteHh4eHh4eHh4eHh4Jy5yZXBsYWNlKC9beHldL2csIGZ1bmN0aW9uIChjKSB7XHJcbiAgICAgICAgY29uc3QgciA9IChNYXRoLnJhbmRvbSgpICogMTYgKyBkKSAlIDE2IHwgMDtcclxuICAgICAgICByZXR1cm4gKGMgPT0gJ3gnID8gciA6IChyICYgMHgzKSB8IDB4OCkudG9TdHJpbmcoMTYpO1xyXG4gICAgfSk7XHJcbn07XG5cbmNvbnN0IGFwcGVuZElkID0gKHZhbHVlLCBrZXlOYW1lKSA9PiAoT2JqZWN0LmFzc2lnbih7IFtrZXlOYW1lXTogZ2VuZXJhdGVJZCgpIH0sIChpc09iamVjdCh2YWx1ZSkgPyB2YWx1ZSA6IHsgdmFsdWUgfSkpKTtcclxuY29uc3QgbWFwSWRzID0gKGRhdGEsIGtleU5hbWUpID0+IChpc0FycmF5KGRhdGEpID8gZGF0YSA6IFtdKS5tYXAoKHZhbHVlKSA9PiBhcHBlbmRJZCh2YWx1ZSwga2V5TmFtZSkpO1xuXG52YXIgZ2V0U29ydFJlbW92ZWRJdGVtcyA9IChpbmRleGVzLCByZW1vdmVJbmRleGVzLCB1cGRhdGVkSW5kZXhlcyA9IFtdLCBjb3VudCA9IDAsIG5vdEZvdW5kSW5kZXhlcyA9IFtdKSA9PiB7XHJcbiAgICBmb3IgKGNvbnN0IHJlbW92ZUluZGV4IG9mIHJlbW92ZUluZGV4ZXMpIHtcclxuICAgICAgICBpZiAoaW5kZXhlcy5pbmRleE9mKHJlbW92ZUluZGV4KSA8IDApIHtcclxuICAgICAgICAgICAgbm90Rm91bmRJbmRleGVzLnB1c2gocmVtb3ZlSW5kZXgpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGZvciAoY29uc3QgaW5kZXggb2YgaW5kZXhlcy5zb3J0KCkpIHtcclxuICAgICAgICBpZiAocmVtb3ZlSW5kZXhlcy5pbmRleE9mKGluZGV4KSA+IC0xKSB7XHJcbiAgICAgICAgICAgIHVwZGF0ZWRJbmRleGVzLnB1c2goLTEpO1xyXG4gICAgICAgICAgICBjb3VudCsrO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdXBkYXRlZEluZGV4ZXMucHVzaChpbmRleCAtXHJcbiAgICAgICAgICAgICAgICBjb3VudCAtXHJcbiAgICAgICAgICAgICAgICAobm90Rm91bmRJbmRleGVzLmxlbmd0aFxyXG4gICAgICAgICAgICAgICAgICAgID8gbm90Rm91bmRJbmRleGVzXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC5tYXAoKG5vdEZvdW5kSW5kZXgpID0+IG5vdEZvdW5kSW5kZXggPCBpbmRleClcclxuICAgICAgICAgICAgICAgICAgICAgICAgLmZpbHRlcihCb29sZWFuKS5sZW5ndGhcclxuICAgICAgICAgICAgICAgICAgICA6IDApKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdXBkYXRlZEluZGV4ZXM7XHJcbn07XG5cbmNvbnN0IHJlbW92ZUF0ID0gKGRhdGEsIGluZGV4KSA9PiBbXHJcbiAgICAuLi5kYXRhLnNsaWNlKDAsIGluZGV4KSxcclxuICAgIC4uLmRhdGEuc2xpY2UoaW5kZXggKyAxKSxcclxuXTtcclxuZnVuY3Rpb24gcmVtb3ZlQXRJbmRleGVzKGRhdGEsIGluZGV4KSB7XHJcbiAgICBsZXQgayA9IC0xO1xyXG4gICAgd2hpbGUgKCsrayA8IGRhdGEubGVuZ3RoKSB7XHJcbiAgICAgICAgaWYgKGluZGV4LmluZGV4T2YoaykgPj0gMCkge1xyXG4gICAgICAgICAgICBkZWxldGUgZGF0YVtrXTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gZGF0YS5maWx0ZXIoQm9vbGVhbik7XHJcbn1cclxudmFyIHJlbW92ZUFycmF5QXQgPSAoZGF0YSwgaW5kZXgpID0+IGlzVW5kZWZpbmVkKGluZGV4KVxyXG4gICAgPyBbXVxyXG4gICAgOiBpc0FycmF5KGluZGV4KVxyXG4gICAgICAgID8gcmVtb3ZlQXRJbmRleGVzKGRhdGEsIGluZGV4KVxyXG4gICAgICAgIDogcmVtb3ZlQXQoZGF0YSwgaW5kZXgpO1xuXG52YXIgbW92ZUFycmF5QXQgPSAoZGF0YSwgZnJvbSwgdG8pID0+IGlzQXJyYXkoZGF0YSkgPyBkYXRhLnNwbGljZSh0bywgMCwgZGF0YS5zcGxpY2UoZnJvbSwgMSlbMF0pIDogW107XG5cbnZhciBzd2FwQXJyYXlBdCA9IChkYXRhLCBpbmRleEEsIGluZGV4QikgPT4ge1xyXG4gICAgY29uc3QgdGVtcCA9IFtkYXRhW2luZGV4Ql0sIGRhdGFbaW5kZXhBXV07XHJcbiAgICBkYXRhW2luZGV4QV0gPSB0ZW1wWzBdO1xyXG4gICAgZGF0YVtpbmRleEJdID0gdGVtcFsxXTtcclxufTtcblxuZnVuY3Rpb24gcHJlcGVuZChkYXRhLCB2YWx1ZSkge1xyXG4gICAgcmV0dXJuIFsuLi4oaXNBcnJheSh2YWx1ZSkgPyB2YWx1ZSA6IFt2YWx1ZSB8fCBudWxsXSksIC4uLmRhdGFdO1xyXG59XG5cbmZ1bmN0aW9uIGluc2VydChkYXRhLCBpbmRleCwgdmFsdWUpIHtcclxuICAgIHJldHVybiBbXHJcbiAgICAgICAgLi4uZGF0YS5zbGljZSgwLCBpbmRleCksXHJcbiAgICAgICAgLi4uKGlzQXJyYXkodmFsdWUpID8gdmFsdWUgOiBbdmFsdWUgfHwgbnVsbF0pLFxyXG4gICAgICAgIC4uLmRhdGEuc2xpY2UoaW5kZXgpLFxyXG4gICAgXTtcclxufVxuXG52YXIgZmlsbEVtcHR5QXJyYXkgPSAodmFsdWUpID0+IGlzQXJyYXkodmFsdWUpID8gQXJyYXkodmFsdWUubGVuZ3RoKS5maWxsKG51bGwpIDogbnVsbDtcblxuY29uc3QgdXNlRmllbGRBcnJheSA9ICh7IGNvbnRyb2wsIG5hbWUsIGtleU5hbWUgPSAnaWQnLCB9KSA9PiB7XHJcbiAgICBjb25zdCBtZXRob2RzID0gdXNlRm9ybUNvbnRleHQoKTtcclxuICAgIGNvbnN0IHsgaXNXYXRjaEFsbFJlZiwgcmVzZXRGaWVsZEFycmF5RnVuY3Rpb25SZWYsIGZpZWxkQXJyYXlOYW1lc1JlZiwgcmVSZW5kZXIsIGZpZWxkc1JlZiwgZ2V0VmFsdWVzLCBkZWZhdWx0VmFsdWVzUmVmLCByZW1vdmVGaWVsZEV2ZW50TGlzdGVuZXIsIGVycm9yc1JlZiwgZGlydHlGaWVsZHNSZWYsIGlzRGlydHlSZWYsIHRvdWNoZWRGaWVsZHNSZWYsIHJlYWRGb3JtU3RhdGVSZWYsIHdhdGNoRmllbGRzUmVmLCB2YWxpZEZpZWxkc1JlZiwgZmllbGRzV2l0aFZhbGlkYXRpb25SZWYsIGZpZWxkQXJyYXlEZWZhdWx0VmFsdWVzLCB2YWxpZGF0ZVNjaGVtYUlzVmFsaWQsIH0gPSBjb250cm9sIHx8IG1ldGhvZHMuY29udHJvbDtcclxuICAgIGNvbnN0IGdldERlZmF1bHRWYWx1ZXMgPSAoKSA9PiBbXHJcbiAgICAgICAgLi4uZ2V0KGZpZWxkQXJyYXlEZWZhdWx0VmFsdWVzLmN1cnJlbnRbZ2V0RmllbGRBcnJheVBhcmVudE5hbWUobmFtZSldXHJcbiAgICAgICAgICAgID8gZmllbGRBcnJheURlZmF1bHRWYWx1ZXMuY3VycmVudFxyXG4gICAgICAgICAgICA6IGRlZmF1bHRWYWx1ZXNSZWYuY3VycmVudCwgbmFtZSwgW10pLFxyXG4gICAgXTtcclxuICAgIGNvbnN0IG1lbW9pemVkRGVmYXVsdFZhbHVlcyA9IHVzZVJlZihnZXREZWZhdWx0VmFsdWVzKCkpO1xyXG4gICAgY29uc3QgW2ZpZWxkcywgc2V0RmllbGRdID0gdXNlU3RhdGUobWFwSWRzKG1lbW9pemVkRGVmYXVsdFZhbHVlcy5jdXJyZW50LCBrZXlOYW1lKSk7XHJcbiAgICBjb25zdCBbaXNEZWxldGVkLCBzZXRJc0RlbGV0ZWRdID0gdXNlU3RhdGUoZmFsc2UpO1xyXG4gICAgY29uc3QgYWxsRmllbGRzID0gdXNlUmVmKGZpZWxkcyk7XHJcbiAgICBjb25zdCBpc05hbWVLZXkgPSBpc0tleShuYW1lKTtcclxuICAgIGFsbEZpZWxkcy5jdXJyZW50ID0gZmllbGRzO1xyXG4gICAgaWYgKGlzTmFtZUtleSkge1xyXG4gICAgICAgIGZpZWxkQXJyYXlEZWZhdWx0VmFsdWVzLmN1cnJlbnRbbmFtZV0gPSBtZW1vaXplZERlZmF1bHRWYWx1ZXMuY3VycmVudDtcclxuICAgIH1cclxuICAgIGNvbnN0IGFwcGVuZFZhbHVlV2l0aEtleSA9ICh2YWx1ZXMpID0+IHZhbHVlcy5tYXAoKHZhbHVlKSA9PiBhcHBlbmRJZCh2YWx1ZSwga2V5TmFtZSkpO1xyXG4gICAgY29uc3Qgc2V0RmllbGRBbmRWYWxpZFN0YXRlID0gKGZpZWxkc1ZhbHVlcykgPT4ge1xyXG4gICAgICAgIHNldEZpZWxkKGZpZWxkc1ZhbHVlcyk7XHJcbiAgICAgICAgaWYgKHJlYWRGb3JtU3RhdGVSZWYuY3VycmVudC5pc1ZhbGlkICYmIHZhbGlkYXRlU2NoZW1hSXNWYWxpZCkge1xyXG4gICAgICAgICAgICB2YWxpZGF0ZVNjaGVtYUlzVmFsaWQoe1xyXG4gICAgICAgICAgICAgICAgW25hbWVdOiBmaWVsZHNWYWx1ZXMsXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBjb25zdCBtb2RpZnlEaXJ0eUZpZWxkcyA9ICh7IHNob3VsZFJlbmRlciwgaXNSZW1vdmUsIGlzUHJlUGVuZCwgaW5kZXgsIHZhbHVlID0ge30sIH0gPSB7fSkgPT4ge1xyXG4gICAgICAgIGxldCByZW5kZXIgPSBzaG91bGRSZW5kZXI7XHJcbiAgICAgICAgY29uc3QgdmFsdWVzID0gaXNBcnJheSh2YWx1ZSkgPyB2YWx1ZSA6IFt2YWx1ZV07XHJcbiAgICAgICAgaWYgKHJlYWRGb3JtU3RhdGVSZWYuY3VycmVudC5kaXJ0eSkge1xyXG4gICAgICAgICAgICBjb25zdCBkaXJ0eUZpZWxkSW5kZXhlc0FuZFZhbHVlcyA9IHt9O1xyXG4gICAgICAgICAgICBpZiAoaXNQcmVQZW5kIHx8IGlzUmVtb3ZlKSB7XHJcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGRpcnR5RmllbGQgb2YgWy4uLmRpcnR5RmllbGRzUmVmLmN1cnJlbnRdLnNvcnQoKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChpc01hdGNoRmllbGRBcnJheU5hbWUoZGlydHlGaWVsZCwgbmFtZSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgbWF0Y2hlZEluZGV4ZXMgPSBkaXJ0eUZpZWxkLm1hdGNoKFJFR0VYX0FSUkFZX0ZJRUxEX0lOREVYKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG1hdGNoZWRJbmRleGVzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBtYXRjaEluZGV4ID0gK21hdGNoZWRJbmRleGVzW21hdGNoZWRJbmRleGVzLmxlbmd0aCAtIDFdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGRpcnR5RmllbGRJbmRleGVzQW5kVmFsdWVzW21hdGNoSW5kZXhdKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGlydHlGaWVsZEluZGV4ZXNBbmRWYWx1ZXNbbWF0Y2hJbmRleF0ucHVzaChkaXJ0eUZpZWxkKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRpcnR5RmllbGRJbmRleGVzQW5kVmFsdWVzW21hdGNoSW5kZXhdID0gW2RpcnR5RmllbGRdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGRpcnR5RmllbGRzUmVmLmN1cnJlbnQuZGVsZXRlKGRpcnR5RmllbGQpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoIWlzVW5kZWZpbmVkKGluZGV4KSB8fCBpc1ByZVBlbmQpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHVwZGF0ZWREaXJ0eUZpZWxkSW5kZXhlcyA9IGlzVW5kZWZpbmVkKGluZGV4KVxyXG4gICAgICAgICAgICAgICAgICAgID8gW11cclxuICAgICAgICAgICAgICAgICAgICA6IGdldFNvcnRSZW1vdmVkSXRlbXMoT2JqZWN0LmtleXMoZGlydHlGaWVsZEluZGV4ZXNBbmRWYWx1ZXMpLm1hcCgoaSkgPT4gK2kpLCBpc0FycmF5KGluZGV4KSA/IGluZGV4IDogW2luZGV4XSk7XHJcbiAgICAgICAgICAgICAgICBPYmplY3QudmFsdWVzKGRpcnR5RmllbGRJbmRleGVzQW5kVmFsdWVzKS5mb3JFYWNoKCh2YWx1ZXMsIGluZGV4KSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdXBkYXRlSW5kZXggPSBpc1ByZVBlbmQgPyAwIDogdXBkYXRlZERpcnR5RmllbGRJbmRleGVzW2luZGV4XTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAodXBkYXRlSW5kZXggPiAtMSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IHZhbHVlIG9mIHZhbHVlcykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgbWF0Y2hlZEluZGV4ZXMgPSB2YWx1ZS5tYXRjaChSRUdFWF9BUlJBWV9GSUVMRF9JTkRFWCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobWF0Y2hlZEluZGV4ZXMpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkaXJ0eUZpZWxkc1JlZi5jdXJyZW50LmFkZCh2YWx1ZS5yZXBsYWNlKC9bXFxkK10oW15bXFxkK10rKSQvLCBgJHtpc1ByZVBlbmRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPyArbWF0Y2hlZEluZGV4ZXNbbWF0Y2hlZEluZGV4ZXMubGVuZ3RoIC0gMV0gK1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWVzLmxlbmd0aFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IHVwZGF0ZUluZGV4fSQxYCkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKCFpc1JlbW92ZSkge1xyXG4gICAgICAgICAgICAgICAgdmFsdWVzLmZvckVhY2goKGZpZWxkVmFsdWUsIGluZGV4KSA9PiBPYmplY3Qua2V5cyhmaWVsZFZhbHVlKS5mb3JFYWNoKChrZXkpID0+IGRpcnR5RmllbGRzUmVmLmN1cnJlbnQuYWRkKGAke25hbWV9WyR7aXNQcmVQZW5kID8gaW5kZXggOiBhbGxGaWVsZHMuY3VycmVudC5sZW5ndGggKyBpbmRleH1dLiR7a2V5fWApKSk7XHJcbiAgICAgICAgICAgICAgICBpc0RpcnR5UmVmLmN1cnJlbnQgPSB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJlbmRlciA9IHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChyZW5kZXIgJiYgIWlzV2F0Y2hBbGxSZWYuY3VycmVudCkge1xyXG4gICAgICAgICAgICByZVJlbmRlcigpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBjb25zdCByZXNldEZpZWxkcyA9IChmbGFnT3JGaWVsZHMpID0+IHtcclxuICAgICAgICBpZiAocmVhZEZvcm1TdGF0ZVJlZi5jdXJyZW50LmRpcnR5KSB7XHJcbiAgICAgICAgICAgIGlzRGlydHlSZWYuY3VycmVudCA9IGlzVW5kZWZpbmVkKGZsYWdPckZpZWxkcylcclxuICAgICAgICAgICAgICAgID8gdHJ1ZVxyXG4gICAgICAgICAgICAgICAgOiBnZXRJc0ZpZWxkc0RpZmZlcmVudChmbGFnT3JGaWVsZHMsIGRlZmF1bHRWYWx1ZXNSZWYuY3VycmVudFtuYW1lXSB8fCBbXSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZvciAoY29uc3Qga2V5IGluIGZpZWxkc1JlZi5jdXJyZW50KSB7XHJcbiAgICAgICAgICAgIGlmIChpc01hdGNoRmllbGRBcnJheU5hbWUoa2V5LCBuYW1lKSAmJiBmaWVsZHNSZWYuY3VycmVudFtrZXldKSB7XHJcbiAgICAgICAgICAgICAgICByZW1vdmVGaWVsZEV2ZW50TGlzdGVuZXIoZmllbGRzUmVmLmN1cnJlbnRba2V5XSwgdHJ1ZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgY29uc3QgbWFwQ3VycmVudEZpZWxkc1ZhbHVlV2l0aFN0YXRlID0gKCkgPT4ge1xyXG4gICAgICAgIGNvbnN0IGN1cnJlbnRGaWVsZHNWYWx1ZSA9IGdldChnZXRWYWx1ZXMoeyBuZXN0OiB0cnVlIH0pLCBuYW1lKTtcclxuICAgICAgICBpZiAoaXNBcnJheShjdXJyZW50RmllbGRzVmFsdWUpKSB7XHJcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY3VycmVudEZpZWxkc1ZhbHVlLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICBhbGxGaWVsZHMuY3VycmVudFtpXSA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgYWxsRmllbGRzLmN1cnJlbnRbaV0pLCBjdXJyZW50RmllbGRzVmFsdWVbaV0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIGNvbnN0IGFwcGVuZCA9ICh2YWx1ZSkgPT4ge1xyXG4gICAgICAgIHNldEZpZWxkQW5kVmFsaWRTdGF0ZShbXHJcbiAgICAgICAgICAgIC4uLmFsbEZpZWxkcy5jdXJyZW50LFxyXG4gICAgICAgICAgICAuLi4oaXNBcnJheSh2YWx1ZSlcclxuICAgICAgICAgICAgICAgID8gYXBwZW5kVmFsdWVXaXRoS2V5KHZhbHVlKVxyXG4gICAgICAgICAgICAgICAgOiBbYXBwZW5kSWQodmFsdWUsIGtleU5hbWUpXSksXHJcbiAgICAgICAgXSk7XHJcbiAgICAgICAgbW9kaWZ5RGlydHlGaWVsZHMoeyB2YWx1ZSB9KTtcclxuICAgIH07XHJcbiAgICBjb25zdCBwcmVwZW5kJDEgPSAodmFsdWUpID0+IHtcclxuICAgICAgICBsZXQgc2hvdWxkUmVuZGVyID0gZmFsc2U7XHJcbiAgICAgICAgcmVzZXRGaWVsZHMoKTtcclxuICAgICAgICBzZXRGaWVsZEFuZFZhbGlkU3RhdGUocHJlcGVuZChhbGxGaWVsZHMuY3VycmVudCwgaXNBcnJheSh2YWx1ZSkgPyBhcHBlbmRWYWx1ZVdpdGhLZXkodmFsdWUpIDogW2FwcGVuZElkKHZhbHVlLCBrZXlOYW1lKV0pKTtcclxuICAgICAgICBpZiAoZXJyb3JzUmVmLmN1cnJlbnRbbmFtZV0pIHtcclxuICAgICAgICAgICAgZXJyb3JzUmVmLmN1cnJlbnRbbmFtZV0gPSBwcmVwZW5kKGVycm9yc1JlZi5jdXJyZW50W25hbWVdLCBmaWxsRW1wdHlBcnJheSh2YWx1ZSkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAocmVhZEZvcm1TdGF0ZVJlZi5jdXJyZW50LnRvdWNoZWQgJiYgdG91Y2hlZEZpZWxkc1JlZi5jdXJyZW50W25hbWVdKSB7XHJcbiAgICAgICAgICAgIHRvdWNoZWRGaWVsZHNSZWYuY3VycmVudFtuYW1lXSA9IHByZXBlbmQodG91Y2hlZEZpZWxkc1JlZi5jdXJyZW50W25hbWVdLCBmaWxsRW1wdHlBcnJheSh2YWx1ZSkpO1xyXG4gICAgICAgICAgICBzaG91bGRSZW5kZXIgPSB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBtb2RpZnlEaXJ0eUZpZWxkcyh7XHJcbiAgICAgICAgICAgIHNob3VsZFJlbmRlcixcclxuICAgICAgICAgICAgaXNQcmVQZW5kOiB0cnVlLFxyXG4gICAgICAgICAgICB2YWx1ZSxcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbiAgICBjb25zdCByZW1vdmUgPSAoaW5kZXgpID0+IHtcclxuICAgICAgICBsZXQgc2hvdWxkUmVuZGVyID0gZmFsc2U7XHJcbiAgICAgICAgY29uc3QgaXNJbmRleFVuZGVmaW5lZCA9IGlzVW5kZWZpbmVkKGluZGV4KTtcclxuICAgICAgICBpZiAoIWlzSW5kZXhVbmRlZmluZWQpIHtcclxuICAgICAgICAgICAgbWFwQ3VycmVudEZpZWxkc1ZhbHVlV2l0aFN0YXRlKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJlc2V0RmllbGRzKHJlbW92ZUFycmF5QXQoZ2V0RmllbGRWYWx1ZUJ5TmFtZShmaWVsZHNSZWYuY3VycmVudCwgbmFtZSksIGluZGV4KSk7XHJcbiAgICAgICAgc2V0RmllbGRBbmRWYWxpZFN0YXRlKHJlbW92ZUFycmF5QXQoYWxsRmllbGRzLmN1cnJlbnQsIGluZGV4KSk7XHJcbiAgICAgICAgc2V0SXNEZWxldGVkKHRydWUpO1xyXG4gICAgICAgIGlmIChlcnJvcnNSZWYuY3VycmVudFtuYW1lXSkge1xyXG4gICAgICAgICAgICBlcnJvcnNSZWYuY3VycmVudFtuYW1lXSA9IHJlbW92ZUFycmF5QXQoZXJyb3JzUmVmLmN1cnJlbnRbbmFtZV0sIGluZGV4KTtcclxuICAgICAgICAgICAgaWYgKCFlcnJvcnNSZWYuY3VycmVudFtuYW1lXS5maWx0ZXIoQm9vbGVhbikubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgICBkZWxldGUgZXJyb3JzUmVmLmN1cnJlbnRbbmFtZV07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHJlYWRGb3JtU3RhdGVSZWYuY3VycmVudC50b3VjaGVkICYmIHRvdWNoZWRGaWVsZHNSZWYuY3VycmVudFtuYW1lXSkge1xyXG4gICAgICAgICAgICB0b3VjaGVkRmllbGRzUmVmLmN1cnJlbnRbbmFtZV0gPSByZW1vdmVBcnJheUF0KHRvdWNoZWRGaWVsZHNSZWYuY3VycmVudFtuYW1lXSwgaW5kZXgpO1xyXG4gICAgICAgICAgICBzaG91bGRSZW5kZXIgPSB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAocmVhZEZvcm1TdGF0ZVJlZi5jdXJyZW50LmlzVmFsaWQgJiYgIXZhbGlkYXRlU2NoZW1hSXNWYWxpZCkge1xyXG4gICAgICAgICAgICBsZXQgZmllbGRJbmRleCA9IC0xO1xyXG4gICAgICAgICAgICBsZXQgaXNGb3VuZCA9IGZhbHNlO1xyXG4gICAgICAgICAgICBjb25zdCBpc0luZGV4VW5kZWZpbmVkID0gaXNVbmRlZmluZWQoaW5kZXgpO1xyXG4gICAgICAgICAgICB3aGlsZSAoZmllbGRJbmRleCsrIDwgZmllbGRzLmxlbmd0aCkge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgaXNMYXN0ID0gZmllbGRJbmRleCA9PT0gZmllbGRzLmxlbmd0aCAtIDE7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBpc0N1cnJlbnRJbmRleCA9IChpc0FycmF5KGluZGV4KSA/IGluZGV4IDogW2luZGV4XSkuaW5kZXhPZihmaWVsZEluZGV4KSA+PSAwO1xyXG4gICAgICAgICAgICAgICAgaWYgKGlzQ3VycmVudEluZGV4IHx8IGlzSW5kZXhVbmRlZmluZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICBpc0ZvdW5kID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmICghaXNGb3VuZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gZmllbGRzW2ZpZWxkSW5kZXhdKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgY3VycmVudEZpZWxkTmFtZSA9IGAke25hbWV9WyR7ZmllbGRJbmRleH1dLiR7a2V5fWA7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzQ3VycmVudEluZGV4IHx8IGlzTGFzdCB8fCBpc0luZGV4VW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbGlkRmllbGRzUmVmLmN1cnJlbnQuZGVsZXRlKGN1cnJlbnRGaWVsZE5hbWUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBmaWVsZHNXaXRoVmFsaWRhdGlvblJlZi5jdXJyZW50LmRlbGV0ZShjdXJyZW50RmllbGROYW1lKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHByZXZpb3VzRmllbGROYW1lID0gYCR7bmFtZX1bJHtmaWVsZEluZGV4IC0gMX1dLiR7a2V5fWA7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh2YWxpZEZpZWxkc1JlZi5jdXJyZW50LmhhcyhjdXJyZW50RmllbGROYW1lKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsaWRGaWVsZHNSZWYuY3VycmVudC5hZGQocHJldmlvdXNGaWVsZE5hbWUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChmaWVsZHNXaXRoVmFsaWRhdGlvblJlZi5jdXJyZW50LmhhcyhjdXJyZW50RmllbGROYW1lKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZmllbGRzV2l0aFZhbGlkYXRpb25SZWYuY3VycmVudC5hZGQocHJldmlvdXNGaWVsZE5hbWUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIG1vZGlmeURpcnR5RmllbGRzKHtcclxuICAgICAgICAgICAgc2hvdWxkUmVuZGVyLFxyXG4gICAgICAgICAgICBpc1JlbW92ZTogdHJ1ZSxcclxuICAgICAgICAgICAgaW5kZXgsXHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG4gICAgY29uc3QgaW5zZXJ0JDEgPSAoaW5kZXgsIHZhbHVlKSA9PiB7XHJcbiAgICAgICAgbWFwQ3VycmVudEZpZWxkc1ZhbHVlV2l0aFN0YXRlKCk7XHJcbiAgICAgICAgcmVzZXRGaWVsZHMoaW5zZXJ0KGdldEZpZWxkVmFsdWVCeU5hbWUoZmllbGRzUmVmLmN1cnJlbnQsIG5hbWUpLCBpbmRleCkpO1xyXG4gICAgICAgIHNldEZpZWxkQW5kVmFsaWRTdGF0ZShpbnNlcnQoYWxsRmllbGRzLmN1cnJlbnQsIGluZGV4LCBpc0FycmF5KHZhbHVlKSA/IGFwcGVuZFZhbHVlV2l0aEtleSh2YWx1ZSkgOiBbYXBwZW5kSWQodmFsdWUsIGtleU5hbWUpXSkpO1xyXG4gICAgICAgIGlmIChlcnJvcnNSZWYuY3VycmVudFtuYW1lXSkge1xyXG4gICAgICAgICAgICBlcnJvcnNSZWYuY3VycmVudFtuYW1lXSA9IGluc2VydChlcnJvcnNSZWYuY3VycmVudFtuYW1lXSwgaW5kZXgsIGZpbGxFbXB0eUFycmF5KHZhbHVlKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChyZWFkRm9ybVN0YXRlUmVmLmN1cnJlbnQudG91Y2hlZCAmJiB0b3VjaGVkRmllbGRzUmVmLmN1cnJlbnRbbmFtZV0pIHtcclxuICAgICAgICAgICAgdG91Y2hlZEZpZWxkc1JlZi5jdXJyZW50W25hbWVdID0gaW5zZXJ0KHRvdWNoZWRGaWVsZHNSZWYuY3VycmVudFtuYW1lXSwgaW5kZXgsIGZpbGxFbXB0eUFycmF5KHZhbHVlKSk7XHJcbiAgICAgICAgICAgIHJlUmVuZGVyKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIGNvbnN0IHN3YXAgPSAoaW5kZXhBLCBpbmRleEIpID0+IHtcclxuICAgICAgICBtYXBDdXJyZW50RmllbGRzVmFsdWVXaXRoU3RhdGUoKTtcclxuICAgICAgICBjb25zdCBmaWVsZFZhbHVlcyA9IGdldEZpZWxkVmFsdWVCeU5hbWUoZmllbGRzUmVmLmN1cnJlbnQsIG5hbWUpO1xyXG4gICAgICAgIHN3YXBBcnJheUF0KGZpZWxkVmFsdWVzLCBpbmRleEEsIGluZGV4Qik7XHJcbiAgICAgICAgcmVzZXRGaWVsZHMoZmllbGRWYWx1ZXMpO1xyXG4gICAgICAgIHN3YXBBcnJheUF0KGFsbEZpZWxkcy5jdXJyZW50LCBpbmRleEEsIGluZGV4Qik7XHJcbiAgICAgICAgc2V0RmllbGRBbmRWYWxpZFN0YXRlKFsuLi5hbGxGaWVsZHMuY3VycmVudF0pO1xyXG4gICAgICAgIGlmIChlcnJvcnNSZWYuY3VycmVudFtuYW1lXSkge1xyXG4gICAgICAgICAgICBzd2FwQXJyYXlBdChlcnJvcnNSZWYuY3VycmVudFtuYW1lXSwgaW5kZXhBLCBpbmRleEIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAocmVhZEZvcm1TdGF0ZVJlZi5jdXJyZW50LnRvdWNoZWQgJiYgdG91Y2hlZEZpZWxkc1JlZi5jdXJyZW50W25hbWVdKSB7XHJcbiAgICAgICAgICAgIHN3YXBBcnJheUF0KHRvdWNoZWRGaWVsZHNSZWYuY3VycmVudFtuYW1lXSwgaW5kZXhBLCBpbmRleEIpO1xyXG4gICAgICAgICAgICByZVJlbmRlcigpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBjb25zdCBtb3ZlID0gKGZyb20sIHRvKSA9PiB7XHJcbiAgICAgICAgbWFwQ3VycmVudEZpZWxkc1ZhbHVlV2l0aFN0YXRlKCk7XHJcbiAgICAgICAgY29uc3QgZmllbGRWYWx1ZXMgPSBnZXRGaWVsZFZhbHVlQnlOYW1lKGZpZWxkc1JlZi5jdXJyZW50LCBuYW1lKTtcclxuICAgICAgICBtb3ZlQXJyYXlBdChmaWVsZFZhbHVlcywgZnJvbSwgdG8pO1xyXG4gICAgICAgIHJlc2V0RmllbGRzKGZpZWxkVmFsdWVzKTtcclxuICAgICAgICBtb3ZlQXJyYXlBdChhbGxGaWVsZHMuY3VycmVudCwgZnJvbSwgdG8pO1xyXG4gICAgICAgIHNldEZpZWxkQW5kVmFsaWRTdGF0ZShbLi4uYWxsRmllbGRzLmN1cnJlbnRdKTtcclxuICAgICAgICBpZiAoZXJyb3JzUmVmLmN1cnJlbnRbbmFtZV0pIHtcclxuICAgICAgICAgICAgbW92ZUFycmF5QXQoZXJyb3JzUmVmLmN1cnJlbnRbbmFtZV0sIGZyb20sIHRvKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHJlYWRGb3JtU3RhdGVSZWYuY3VycmVudC50b3VjaGVkICYmIHRvdWNoZWRGaWVsZHNSZWYuY3VycmVudFtuYW1lXSkge1xyXG4gICAgICAgICAgICBtb3ZlQXJyYXlBdCh0b3VjaGVkRmllbGRzUmVmLmN1cnJlbnRbbmFtZV0sIGZyb20sIHRvKTtcclxuICAgICAgICAgICAgcmVSZW5kZXIoKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgY29uc3QgcmVzZXQgPSAoKSA9PiB7XHJcbiAgICAgICAgcmVzZXRGaWVsZHMoKTtcclxuICAgICAgICBtZW1vaXplZERlZmF1bHRWYWx1ZXMuY3VycmVudCA9IGdldERlZmF1bHRWYWx1ZXMoKTtcclxuICAgICAgICBzZXRGaWVsZChtYXBJZHMobWVtb2l6ZWREZWZhdWx0VmFsdWVzLmN1cnJlbnQsIGtleU5hbWUpKTtcclxuICAgIH07XHJcbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xyXG4gICAgICAgIGlmIChpc05hbWVLZXkgJiZcclxuICAgICAgICAgICAgaXNEZWxldGVkICYmXHJcbiAgICAgICAgICAgIGZpZWxkQXJyYXlEZWZhdWx0VmFsdWVzLmN1cnJlbnRbbmFtZV0gJiZcclxuICAgICAgICAgICAgZmllbGRzLmxlbmd0aCA8IGZpZWxkQXJyYXlEZWZhdWx0VmFsdWVzLmN1cnJlbnRbbmFtZV0ubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIGZpZWxkQXJyYXlEZWZhdWx0VmFsdWVzLmN1cnJlbnRbbmFtZV0ucG9wKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfSwgW2ZpZWxkcywgbmFtZSwgZmllbGRBcnJheURlZmF1bHRWYWx1ZXMsIGlzRGVsZXRlZCwgaXNOYW1lS2V5XSk7XHJcbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xyXG4gICAgICAgIGlmIChpc1dhdGNoQWxsUmVmICYmIGlzV2F0Y2hBbGxSZWYuY3VycmVudCkge1xyXG4gICAgICAgICAgICByZVJlbmRlcigpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmICh3YXRjaEZpZWxkc1JlZikge1xyXG4gICAgICAgICAgICBmb3IgKGNvbnN0IHdhdGNoRmllbGQgb2Ygd2F0Y2hGaWVsZHNSZWYuY3VycmVudCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKHdhdGNoRmllbGQuc3RhcnRzV2l0aChuYW1lKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJlUmVuZGVyKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9LCBbZmllbGRzLCBuYW1lLCByZVJlbmRlciwgd2F0Y2hGaWVsZHNSZWYsIGlzV2F0Y2hBbGxSZWZdKTtcclxuICAgIHVzZUVmZmVjdCgoKSA9PiB7XHJcbiAgICAgICAgY29uc3QgcmVzZXRGdW5jdGlvbnMgPSByZXNldEZpZWxkQXJyYXlGdW5jdGlvblJlZi5jdXJyZW50O1xyXG4gICAgICAgIGNvbnN0IGZpZWxkQXJyYXlOYW1lcyA9IGZpZWxkQXJyYXlOYW1lc1JlZi5jdXJyZW50O1xyXG4gICAgICAgIGZpZWxkQXJyYXlOYW1lcy5hZGQobmFtZSk7XHJcbiAgICAgICAgcmVzZXRGdW5jdGlvbnNbbmFtZV0gPSByZXNldDtcclxuICAgICAgICByZXR1cm4gKCkgPT4ge1xyXG4gICAgICAgICAgICByZXNldEZpZWxkcygpO1xyXG4gICAgICAgICAgICBkZWxldGUgcmVzZXRGdW5jdGlvbnNbbmFtZV07XHJcbiAgICAgICAgICAgIGZpZWxkQXJyYXlOYW1lcy5kZWxldGUobmFtZSk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaG9va3MvZXhoYXVzdGl2ZS1kZXBzXHJcbiAgICB9LCBbXSk7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIHN3YXA6IHVzZUNhbGxiYWNrKHN3YXAsIFtuYW1lXSksXHJcbiAgICAgICAgbW92ZTogdXNlQ2FsbGJhY2sobW92ZSwgW25hbWVdKSxcclxuICAgICAgICBwcmVwZW5kOiB1c2VDYWxsYmFjayhwcmVwZW5kJDEsIFtuYW1lXSksXHJcbiAgICAgICAgYXBwZW5kOiB1c2VDYWxsYmFjayhhcHBlbmQsIFtuYW1lXSksXHJcbiAgICAgICAgcmVtb3ZlOiB1c2VDYWxsYmFjayhyZW1vdmUsIFtmaWVsZHMsIG5hbWVdKSxcclxuICAgICAgICBpbnNlcnQ6IHVzZUNhbGxiYWNrKGluc2VydCQxLCBbbmFtZV0pLFxyXG4gICAgICAgIGZpZWxkcyxcclxuICAgIH07XHJcbn07XG5cbnZhciBnZXRJbnB1dFZhbHVlID0gKGV2ZW50LCBpc0NoZWNrYm94SW5wdXQpID0+IGlzUHJpbWl0aXZlKGV2ZW50KSB8fFxyXG4gICAgIWlzT2JqZWN0KGV2ZW50LnRhcmdldCkgfHxcclxuICAgIChpc09iamVjdChldmVudC50YXJnZXQpICYmICFldmVudC50eXBlKVxyXG4gICAgPyBldmVudFxyXG4gICAgOiBpc0NoZWNrYm94SW5wdXQgfHwgaXNVbmRlZmluZWQoZXZlbnQudGFyZ2V0LnZhbHVlKVxyXG4gICAgICAgID8gZXZlbnQudGFyZ2V0LmNoZWNrZWRcclxuICAgICAgICA6IGV2ZW50LnRhcmdldC52YWx1ZTtcblxuY29uc3QgQ29udHJvbGxlciA9IChfYSkgPT4ge1xyXG4gICAgdmFyIHsgbmFtZSwgcnVsZXMsIGFzOiBJbm5lckNvbXBvbmVudCwgb25CbHVyLCBvbkNoYW5nZSwgb25DaGFuZ2VOYW1lID0gVkFMSURBVElPTl9NT0RFLm9uQ2hhbmdlLCBvbkJsdXJOYW1lID0gVkFMSURBVElPTl9NT0RFLm9uQmx1ciwgdmFsdWVOYW1lLCBkZWZhdWx0VmFsdWUsIGNvbnRyb2wsIG9uRm9jdXMgfSA9IF9hLCByZXN0ID0gX19yZXN0KF9hLCBbXCJuYW1lXCIsIFwicnVsZXNcIiwgXCJhc1wiLCBcIm9uQmx1clwiLCBcIm9uQ2hhbmdlXCIsIFwib25DaGFuZ2VOYW1lXCIsIFwib25CbHVyTmFtZVwiLCBcInZhbHVlTmFtZVwiLCBcImRlZmF1bHRWYWx1ZVwiLCBcImNvbnRyb2xcIiwgXCJvbkZvY3VzXCJdKTtcclxuICAgIGNvbnN0IG1ldGhvZHMgPSB1c2VGb3JtQ29udGV4dCgpO1xyXG4gICAgY29uc3QgeyBkZWZhdWx0VmFsdWVzUmVmLCBzZXRWYWx1ZSwgcmVnaXN0ZXIsIHVucmVnaXN0ZXIsIGVycm9yc1JlZiwgcmVtb3ZlRmllbGRFdmVudExpc3RlbmVyLCB0cmlnZ2VyVmFsaWRhdGlvbiwgbW9kZTogeyBpc09uU3VibWl0LCBpc09uQmx1ciwgaXNPbkNoYW5nZSB9LCByZVZhbGlkYXRlTW9kZTogeyBpc1JlVmFsaWRhdGVPbkJsdXIsIGlzUmVWYWxpZGF0ZU9uU3VibWl0IH0sIGZvcm1TdGF0ZTogeyBpc1N1Ym1pdHRlZCB9LCB0b3VjaGVkRmllbGRzUmVmLCByZWFkRm9ybVN0YXRlUmVmLCByZVJlbmRlciwgZmllbGRzUmVmLCBmaWVsZEFycmF5TmFtZXNSZWYsIH0gPSBjb250cm9sIHx8IG1ldGhvZHMuY29udHJvbDtcclxuICAgIGNvbnN0IFt2YWx1ZSwgc2V0SW5wdXRTdGF0ZVZhbHVlXSA9IHVzZVN0YXRlKGlzVW5kZWZpbmVkKGRlZmF1bHRWYWx1ZSlcclxuICAgICAgICA/IGdldChkZWZhdWx0VmFsdWVzUmVmLmN1cnJlbnQsIG5hbWUpXHJcbiAgICAgICAgOiBkZWZhdWx0VmFsdWUpO1xyXG4gICAgY29uc3QgdmFsdWVSZWYgPSB1c2VSZWYodmFsdWUpO1xyXG4gICAgY29uc3QgaXNDaGVja2JveElucHV0ID0gaXNCb29sZWFuKHZhbHVlKTtcclxuICAgIGNvbnN0IHNob3VsZFJlVmFsaWRhdGVPbkJsdXIgPSBpc09uQmx1ciB8fCBpc1JlVmFsaWRhdGVPbkJsdXI7XHJcbiAgICBjb25zdCBydWxlc1JlZiA9IHVzZVJlZihydWxlcyk7XHJcbiAgICBjb25zdCBvbkZvY3VzUmVmID0gdXNlUmVmKG9uRm9jdXMpO1xyXG4gICAgY29uc3QgaXNOb3RGaWVsZEFycmF5ID0gIWlzTmFtZUluRmllbGRBcnJheShmaWVsZEFycmF5TmFtZXNSZWYuY3VycmVudCwgbmFtZSk7XHJcbiAgICBydWxlc1JlZi5jdXJyZW50ID0gcnVsZXM7XHJcbiAgICBjb25zdCBzaG91bGRWYWxpZGF0ZSA9ICgpID0+ICFza2lwVmFsaWRhdGlvbih7XHJcbiAgICAgICAgaGFzRXJyb3I6ICEhZ2V0KGVycm9yc1JlZi5jdXJyZW50LCBuYW1lKSxcclxuICAgICAgICBpc09uQmx1cixcclxuICAgICAgICBpc09uU3VibWl0LFxyXG4gICAgICAgIGlzT25DaGFuZ2UsXHJcbiAgICAgICAgaXNSZVZhbGlkYXRlT25CbHVyLFxyXG4gICAgICAgIGlzUmVWYWxpZGF0ZU9uU3VibWl0LFxyXG4gICAgICAgIGlzU3VibWl0dGVkLFxyXG4gICAgfSk7XHJcbiAgICBjb25zdCBjb21tb25UYXNrID0gKGV2ZW50KSA9PiB7XHJcbiAgICAgICAgY29uc3QgZGF0YSA9IGdldElucHV0VmFsdWUoZXZlbnQsIGlzQ2hlY2tib3hJbnB1dCk7XHJcbiAgICAgICAgc2V0SW5wdXRTdGF0ZVZhbHVlKGRhdGEpO1xyXG4gICAgICAgIHZhbHVlUmVmLmN1cnJlbnQgPSBkYXRhO1xyXG4gICAgICAgIHJldHVybiBkYXRhO1xyXG4gICAgfTtcclxuICAgIGNvbnN0IGV2ZW50V3JhcHBlciA9IChldmVudCkgPT4gKC4uLmFyZykgPT4gc2V0VmFsdWUobmFtZSwgY29tbW9uVGFzayhldmVudChhcmcpKSwgc2hvdWxkVmFsaWRhdGUoKSk7XHJcbiAgICBjb25zdCBoYW5kbGVDaGFuZ2UgPSAoZXZlbnQpID0+IHtcclxuICAgICAgICBjb25zdCBkYXRhID0gY29tbW9uVGFzayhldmVudCk7XHJcbiAgICAgICAgc2V0VmFsdWUobmFtZSwgZGF0YSwgc2hvdWxkVmFsaWRhdGUoKSk7XHJcbiAgICB9O1xyXG4gICAgY29uc3QgcmVnaXN0ZXJGaWVsZCA9IHVzZUNhbGxiYWNrKCgpID0+IHtcclxuICAgICAgICBpZiAoIWlzTm90RmllbGRBcnJheSkge1xyXG4gICAgICAgICAgICByZW1vdmVGaWVsZEV2ZW50TGlzdGVuZXIoZmllbGRzUmVmLmN1cnJlbnRbbmFtZV0sIHRydWUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZWdpc3RlcihPYmplY3QuZGVmaW5lUHJvcGVydHkoeyBuYW1lLCBmb2N1czogb25Gb2N1c1JlZi5jdXJyZW50IH0sIFZBTFVFLCB7XHJcbiAgICAgICAgICAgIHNldChkYXRhKSB7XHJcbiAgICAgICAgICAgICAgICBzZXRJbnB1dFN0YXRlVmFsdWUoZGF0YSk7XHJcbiAgICAgICAgICAgICAgICB2YWx1ZVJlZi5jdXJyZW50ID0gZGF0YTtcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgZ2V0KCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlUmVmLmN1cnJlbnQ7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgfSksIHJ1bGVzUmVmLmN1cnJlbnQpO1xyXG4gICAgfSwgW1xyXG4gICAgICAgIGlzTm90RmllbGRBcnJheSxcclxuICAgICAgICBmaWVsZHNSZWYsXHJcbiAgICAgICAgcnVsZXNSZWYsXHJcbiAgICAgICAgbmFtZSxcclxuICAgICAgICBvbkZvY3VzUmVmLFxyXG4gICAgICAgIHJlZ2lzdGVyLFxyXG4gICAgICAgIHJlbW92ZUZpZWxkRXZlbnRMaXN0ZW5lcixcclxuICAgIF0pO1xyXG4gICAgdXNlRWZmZWN0KCgpID0+ICgpID0+IHtcclxuICAgICAgICAhaXNOYW1lSW5GaWVsZEFycmF5KGZpZWxkQXJyYXlOYW1lc1JlZi5jdXJyZW50LCBuYW1lKSAmJiB1bnJlZ2lzdGVyKG5hbWUpO1xyXG4gICAgfSwgW3VucmVnaXN0ZXIsIG5hbWUsIGZpZWxkQXJyYXlOYW1lc1JlZl0pO1xyXG4gICAgdXNlRWZmZWN0KCgpID0+IHtcclxuICAgICAgICByZWdpc3RlckZpZWxkKCk7XHJcbiAgICB9LCBbcmVnaXN0ZXJGaWVsZF0pO1xyXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWhvb2tzL2V4aGF1c3RpdmUtZGVwc1xyXG4gICAgdXNlRWZmZWN0KCgpID0+IHtcclxuICAgICAgICBpZiAoIWZpZWxkc1JlZi5jdXJyZW50W25hbWVdKSB7XHJcbiAgICAgICAgICAgIHJlZ2lzdGVyRmllbGQoKTtcclxuICAgICAgICAgICAgaWYgKGlzTm90RmllbGRBcnJheSkge1xyXG4gICAgICAgICAgICAgICAgc2V0SW5wdXRTdGF0ZVZhbHVlKGlzVW5kZWZpbmVkKGRlZmF1bHRWYWx1ZSlcclxuICAgICAgICAgICAgICAgICAgICA/IGdldChkZWZhdWx0VmFsdWVzUmVmLmN1cnJlbnQsIG5hbWUpXHJcbiAgICAgICAgICAgICAgICAgICAgOiBkZWZhdWx0VmFsdWUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfSk7XHJcbiAgICBjb25zdCBwcm9wcyA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oeyBuYW1lIH0sIHJlc3QpLCAob25DaGFuZ2VcclxuICAgICAgICA/IHsgW29uQ2hhbmdlTmFtZV06IGV2ZW50V3JhcHBlcihvbkNoYW5nZSkgfVxyXG4gICAgICAgIDogeyBbb25DaGFuZ2VOYW1lXTogaGFuZGxlQ2hhbmdlIH0pKSwgeyBbb25CbHVyTmFtZV06ICguLi5hcmdzKSA9PiB7XHJcbiAgICAgICAgICAgIGlmIChvbkJsdXIpIHtcclxuICAgICAgICAgICAgICAgIG9uQmx1cihhcmdzKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAocmVhZEZvcm1TdGF0ZVJlZi5jdXJyZW50LnRvdWNoZWQgJiZcclxuICAgICAgICAgICAgICAgICFnZXQodG91Y2hlZEZpZWxkc1JlZi5jdXJyZW50LCBuYW1lKSkge1xyXG4gICAgICAgICAgICAgICAgc2V0KHRvdWNoZWRGaWVsZHNSZWYuY3VycmVudCwgbmFtZSwgdHJ1ZSk7XHJcbiAgICAgICAgICAgICAgICByZVJlbmRlcigpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChzaG91bGRSZVZhbGlkYXRlT25CbHVyKSB7XHJcbiAgICAgICAgICAgICAgICB0cmlnZ2VyVmFsaWRhdGlvbihuYW1lKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0gfSksIHsgW3ZhbHVlTmFtZSB8fCAoaXNDaGVja2JveElucHV0ID8gJ2NoZWNrZWQnIDogVkFMVUUpXTogdmFsdWUgfSk7XHJcbiAgICByZXR1cm4gaXNWYWxpZEVsZW1lbnQoSW5uZXJDb21wb25lbnQpXHJcbiAgICAgICAgPyBjbG9uZUVsZW1lbnQoSW5uZXJDb21wb25lbnQsIHByb3BzKVxyXG4gICAgICAgIDogY3JlYXRlRWxlbWVudChJbm5lckNvbXBvbmVudCwgcHJvcHMpO1xyXG59O1xuXG5jb25zdCBFcnJvck1lc3NhZ2UgPSAoX2EpID0+IHtcclxuICAgIHZhciB7IGFzOiBJbm5lckNvbXBvbmVudCwgZXJyb3JzLCBuYW1lLCBtZXNzYWdlLCBjaGlsZHJlbiB9ID0gX2EsIHJlc3QgPSBfX3Jlc3QoX2EsIFtcImFzXCIsIFwiZXJyb3JzXCIsIFwibmFtZVwiLCBcIm1lc3NhZ2VcIiwgXCJjaGlsZHJlblwiXSk7XHJcbiAgICBjb25zdCBtZXRob2RzID0gdXNlRm9ybUNvbnRleHQoKTtcclxuICAgIGNvbnN0IGVycm9yID0gZ2V0KGVycm9ycyB8fCBtZXRob2RzLmVycm9ycywgbmFtZSk7XHJcbiAgICBpZiAoIWVycm9yKSB7XHJcbiAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9XHJcbiAgICBjb25zdCB7IG1lc3NhZ2U6IG1lc3NhZ2VGcm9tUmVnaXN0ZXIsIHR5cGVzIH0gPSBlcnJvcjtcclxuICAgIGNvbnN0IHByb3BzID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCAoSW5uZXJDb21wb25lbnQgPyByZXN0IDoge30pKSwgeyBjaGlsZHJlbjogY2hpbGRyZW5cclxuICAgICAgICAgICAgPyBjaGlsZHJlbih7IG1lc3NhZ2U6IG1lc3NhZ2VGcm9tUmVnaXN0ZXIgfHwgbWVzc2FnZSwgbWVzc2FnZXM6IHR5cGVzIH0pXHJcbiAgICAgICAgICAgIDogbWVzc2FnZUZyb21SZWdpc3RlciB8fCBtZXNzYWdlIH0pO1xyXG4gICAgcmV0dXJuIElubmVyQ29tcG9uZW50ID8gKGlzVmFsaWRFbGVtZW50KElubmVyQ29tcG9uZW50KSA/IChjbG9uZUVsZW1lbnQoSW5uZXJDb21wb25lbnQsIHByb3BzKSkgOiAoY3JlYXRlRWxlbWVudChJbm5lckNvbXBvbmVudCwgcHJvcHMpKSkgOiAoY3JlYXRlRWxlbWVudChGcmFnbWVudCwgT2JqZWN0LmFzc2lnbih7fSwgcHJvcHMpKSk7XHJcbn07XG5cbmV4cG9ydCB7IENvbnRyb2xsZXIsIEVycm9yTWVzc2FnZSwgRm9ybUNvbnRleHQsIHVzZUZpZWxkQXJyYXksIHVzZUZvcm0sIHVzZUZvcm1Db250ZXh0IH07XG4iLCIvKiogQGxpY2Vuc2UgUmVhY3QgdjE2LjEzLjFcbiAqIHJlYWN0LWlzLmRldmVsb3BtZW50LmpzXG4gKlxuICogQ29weXJpZ2h0IChjKSBGYWNlYm9vaywgSW5jLiBhbmQgaXRzIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG5cblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAoZnVuY3Rpb24oKSB7XG4ndXNlIHN0cmljdCc7XG5cbi8vIFRoZSBTeW1ib2wgdXNlZCB0byB0YWcgdGhlIFJlYWN0RWxlbWVudC1saWtlIHR5cGVzLiBJZiB0aGVyZSBpcyBubyBuYXRpdmUgU3ltYm9sXG4vLyBub3IgcG9seWZpbGwsIHRoZW4gYSBwbGFpbiBudW1iZXIgaXMgdXNlZCBmb3IgcGVyZm9ybWFuY2UuXG52YXIgaGFzU3ltYm9sID0gdHlwZW9mIFN5bWJvbCA9PT0gJ2Z1bmN0aW9uJyAmJiBTeW1ib2wuZm9yO1xudmFyIFJFQUNUX0VMRU1FTlRfVFlQRSA9IGhhc1N5bWJvbCA/IFN5bWJvbC5mb3IoJ3JlYWN0LmVsZW1lbnQnKSA6IDB4ZWFjNztcbnZhciBSRUFDVF9QT1JUQUxfVFlQRSA9IGhhc1N5bWJvbCA/IFN5bWJvbC5mb3IoJ3JlYWN0LnBvcnRhbCcpIDogMHhlYWNhO1xudmFyIFJFQUNUX0ZSQUdNRU5UX1RZUEUgPSBoYXNTeW1ib2wgPyBTeW1ib2wuZm9yKCdyZWFjdC5mcmFnbWVudCcpIDogMHhlYWNiO1xudmFyIFJFQUNUX1NUUklDVF9NT0RFX1RZUEUgPSBoYXNTeW1ib2wgPyBTeW1ib2wuZm9yKCdyZWFjdC5zdHJpY3RfbW9kZScpIDogMHhlYWNjO1xudmFyIFJFQUNUX1BST0ZJTEVSX1RZUEUgPSBoYXNTeW1ib2wgPyBTeW1ib2wuZm9yKCdyZWFjdC5wcm9maWxlcicpIDogMHhlYWQyO1xudmFyIFJFQUNUX1BST1ZJREVSX1RZUEUgPSBoYXNTeW1ib2wgPyBTeW1ib2wuZm9yKCdyZWFjdC5wcm92aWRlcicpIDogMHhlYWNkO1xudmFyIFJFQUNUX0NPTlRFWFRfVFlQRSA9IGhhc1N5bWJvbCA/IFN5bWJvbC5mb3IoJ3JlYWN0LmNvbnRleHQnKSA6IDB4ZWFjZTsgLy8gVE9ETzogV2UgZG9uJ3QgdXNlIEFzeW5jTW9kZSBvciBDb25jdXJyZW50TW9kZSBhbnltb3JlLiBUaGV5IHdlcmUgdGVtcG9yYXJ5XG4vLyAodW5zdGFibGUpIEFQSXMgdGhhdCBoYXZlIGJlZW4gcmVtb3ZlZC4gQ2FuIHdlIHJlbW92ZSB0aGUgc3ltYm9scz9cblxudmFyIFJFQUNUX0FTWU5DX01PREVfVFlQRSA9IGhhc1N5bWJvbCA/IFN5bWJvbC5mb3IoJ3JlYWN0LmFzeW5jX21vZGUnKSA6IDB4ZWFjZjtcbnZhciBSRUFDVF9DT05DVVJSRU5UX01PREVfVFlQRSA9IGhhc1N5bWJvbCA/IFN5bWJvbC5mb3IoJ3JlYWN0LmNvbmN1cnJlbnRfbW9kZScpIDogMHhlYWNmO1xudmFyIFJFQUNUX0ZPUldBUkRfUkVGX1RZUEUgPSBoYXNTeW1ib2wgPyBTeW1ib2wuZm9yKCdyZWFjdC5mb3J3YXJkX3JlZicpIDogMHhlYWQwO1xudmFyIFJFQUNUX1NVU1BFTlNFX1RZUEUgPSBoYXNTeW1ib2wgPyBTeW1ib2wuZm9yKCdyZWFjdC5zdXNwZW5zZScpIDogMHhlYWQxO1xudmFyIFJFQUNUX1NVU1BFTlNFX0xJU1RfVFlQRSA9IGhhc1N5bWJvbCA/IFN5bWJvbC5mb3IoJ3JlYWN0LnN1c3BlbnNlX2xpc3QnKSA6IDB4ZWFkODtcbnZhciBSRUFDVF9NRU1PX1RZUEUgPSBoYXNTeW1ib2wgPyBTeW1ib2wuZm9yKCdyZWFjdC5tZW1vJykgOiAweGVhZDM7XG52YXIgUkVBQ1RfTEFaWV9UWVBFID0gaGFzU3ltYm9sID8gU3ltYm9sLmZvcigncmVhY3QubGF6eScpIDogMHhlYWQ0O1xudmFyIFJFQUNUX0JMT0NLX1RZUEUgPSBoYXNTeW1ib2wgPyBTeW1ib2wuZm9yKCdyZWFjdC5ibG9jaycpIDogMHhlYWQ5O1xudmFyIFJFQUNUX0ZVTkRBTUVOVEFMX1RZUEUgPSBoYXNTeW1ib2wgPyBTeW1ib2wuZm9yKCdyZWFjdC5mdW5kYW1lbnRhbCcpIDogMHhlYWQ1O1xudmFyIFJFQUNUX1JFU1BPTkRFUl9UWVBFID0gaGFzU3ltYm9sID8gU3ltYm9sLmZvcigncmVhY3QucmVzcG9uZGVyJykgOiAweGVhZDY7XG52YXIgUkVBQ1RfU0NPUEVfVFlQRSA9IGhhc1N5bWJvbCA/IFN5bWJvbC5mb3IoJ3JlYWN0LnNjb3BlJykgOiAweGVhZDc7XG5cbmZ1bmN0aW9uIGlzVmFsaWRFbGVtZW50VHlwZSh0eXBlKSB7XG4gIHJldHVybiB0eXBlb2YgdHlwZSA9PT0gJ3N0cmluZycgfHwgdHlwZW9mIHR5cGUgPT09ICdmdW5jdGlvbicgfHwgLy8gTm90ZTogaXRzIHR5cGVvZiBtaWdodCBiZSBvdGhlciB0aGFuICdzeW1ib2wnIG9yICdudW1iZXInIGlmIGl0J3MgYSBwb2x5ZmlsbC5cbiAgdHlwZSA9PT0gUkVBQ1RfRlJBR01FTlRfVFlQRSB8fCB0eXBlID09PSBSRUFDVF9DT05DVVJSRU5UX01PREVfVFlQRSB8fCB0eXBlID09PSBSRUFDVF9QUk9GSUxFUl9UWVBFIHx8IHR5cGUgPT09IFJFQUNUX1NUUklDVF9NT0RFX1RZUEUgfHwgdHlwZSA9PT0gUkVBQ1RfU1VTUEVOU0VfVFlQRSB8fCB0eXBlID09PSBSRUFDVF9TVVNQRU5TRV9MSVNUX1RZUEUgfHwgdHlwZW9mIHR5cGUgPT09ICdvYmplY3QnICYmIHR5cGUgIT09IG51bGwgJiYgKHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0xBWllfVFlQRSB8fCB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9NRU1PX1RZUEUgfHwgdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfUFJPVklERVJfVFlQRSB8fCB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9DT05URVhUX1RZUEUgfHwgdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRSB8fCB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9GVU5EQU1FTlRBTF9UWVBFIHx8IHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX1JFU1BPTkRFUl9UWVBFIHx8IHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX1NDT1BFX1RZUEUgfHwgdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfQkxPQ0tfVFlQRSk7XG59XG5cbmZ1bmN0aW9uIHR5cGVPZihvYmplY3QpIHtcbiAgaWYgKHR5cGVvZiBvYmplY3QgPT09ICdvYmplY3QnICYmIG9iamVjdCAhPT0gbnVsbCkge1xuICAgIHZhciAkJHR5cGVvZiA9IG9iamVjdC4kJHR5cGVvZjtcblxuICAgIHN3aXRjaCAoJCR0eXBlb2YpIHtcbiAgICAgIGNhc2UgUkVBQ1RfRUxFTUVOVF9UWVBFOlxuICAgICAgICB2YXIgdHlwZSA9IG9iamVjdC50eXBlO1xuXG4gICAgICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICAgIGNhc2UgUkVBQ1RfQVNZTkNfTU9ERV9UWVBFOlxuICAgICAgICAgIGNhc2UgUkVBQ1RfQ09OQ1VSUkVOVF9NT0RFX1RZUEU6XG4gICAgICAgICAgY2FzZSBSRUFDVF9GUkFHTUVOVF9UWVBFOlxuICAgICAgICAgIGNhc2UgUkVBQ1RfUFJPRklMRVJfVFlQRTpcbiAgICAgICAgICBjYXNlIFJFQUNUX1NUUklDVF9NT0RFX1RZUEU6XG4gICAgICAgICAgY2FzZSBSRUFDVF9TVVNQRU5TRV9UWVBFOlxuICAgICAgICAgICAgcmV0dXJuIHR5cGU7XG5cbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgdmFyICQkdHlwZW9mVHlwZSA9IHR5cGUgJiYgdHlwZS4kJHR5cGVvZjtcblxuICAgICAgICAgICAgc3dpdGNoICgkJHR5cGVvZlR5cGUpIHtcbiAgICAgICAgICAgICAgY2FzZSBSRUFDVF9DT05URVhUX1RZUEU6XG4gICAgICAgICAgICAgIGNhc2UgUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRTpcbiAgICAgICAgICAgICAgY2FzZSBSRUFDVF9MQVpZX1RZUEU6XG4gICAgICAgICAgICAgIGNhc2UgUkVBQ1RfTUVNT19UWVBFOlxuICAgICAgICAgICAgICBjYXNlIFJFQUNUX1BST1ZJREVSX1RZUEU6XG4gICAgICAgICAgICAgICAgcmV0dXJuICQkdHlwZW9mVHlwZTtcblxuICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHJldHVybiAkJHR5cGVvZjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICB9XG5cbiAgICAgIGNhc2UgUkVBQ1RfUE9SVEFMX1RZUEU6XG4gICAgICAgIHJldHVybiAkJHR5cGVvZjtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdW5kZWZpbmVkO1xufSAvLyBBc3luY01vZGUgaXMgZGVwcmVjYXRlZCBhbG9uZyB3aXRoIGlzQXN5bmNNb2RlXG5cbnZhciBBc3luY01vZGUgPSBSRUFDVF9BU1lOQ19NT0RFX1RZUEU7XG52YXIgQ29uY3VycmVudE1vZGUgPSBSRUFDVF9DT05DVVJSRU5UX01PREVfVFlQRTtcbnZhciBDb250ZXh0Q29uc3VtZXIgPSBSRUFDVF9DT05URVhUX1RZUEU7XG52YXIgQ29udGV4dFByb3ZpZGVyID0gUkVBQ1RfUFJPVklERVJfVFlQRTtcbnZhciBFbGVtZW50ID0gUkVBQ1RfRUxFTUVOVF9UWVBFO1xudmFyIEZvcndhcmRSZWYgPSBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFO1xudmFyIEZyYWdtZW50ID0gUkVBQ1RfRlJBR01FTlRfVFlQRTtcbnZhciBMYXp5ID0gUkVBQ1RfTEFaWV9UWVBFO1xudmFyIE1lbW8gPSBSRUFDVF9NRU1PX1RZUEU7XG52YXIgUG9ydGFsID0gUkVBQ1RfUE9SVEFMX1RZUEU7XG52YXIgUHJvZmlsZXIgPSBSRUFDVF9QUk9GSUxFUl9UWVBFO1xudmFyIFN0cmljdE1vZGUgPSBSRUFDVF9TVFJJQ1RfTU9ERV9UWVBFO1xudmFyIFN1c3BlbnNlID0gUkVBQ1RfU1VTUEVOU0VfVFlQRTtcbnZhciBoYXNXYXJuZWRBYm91dERlcHJlY2F0ZWRJc0FzeW5jTW9kZSA9IGZhbHNlOyAvLyBBc3luY01vZGUgc2hvdWxkIGJlIGRlcHJlY2F0ZWRcblxuZnVuY3Rpb24gaXNBc3luY01vZGUob2JqZWN0KSB7XG4gIHtcbiAgICBpZiAoIWhhc1dhcm5lZEFib3V0RGVwcmVjYXRlZElzQXN5bmNNb2RlKSB7XG4gICAgICBoYXNXYXJuZWRBYm91dERlcHJlY2F0ZWRJc0FzeW5jTW9kZSA9IHRydWU7IC8vIFVzaW5nIGNvbnNvbGVbJ3dhcm4nXSB0byBldmFkZSBCYWJlbCBhbmQgRVNMaW50XG5cbiAgICAgIGNvbnNvbGVbJ3dhcm4nXSgnVGhlIFJlYWN0SXMuaXNBc3luY01vZGUoKSBhbGlhcyBoYXMgYmVlbiBkZXByZWNhdGVkLCAnICsgJ2FuZCB3aWxsIGJlIHJlbW92ZWQgaW4gUmVhY3QgMTcrLiBVcGRhdGUgeW91ciBjb2RlIHRvIHVzZSAnICsgJ1JlYWN0SXMuaXNDb25jdXJyZW50TW9kZSgpIGluc3RlYWQuIEl0IGhhcyB0aGUgZXhhY3Qgc2FtZSBBUEkuJyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGlzQ29uY3VycmVudE1vZGUob2JqZWN0KSB8fCB0eXBlT2Yob2JqZWN0KSA9PT0gUkVBQ1RfQVNZTkNfTU9ERV9UWVBFO1xufVxuZnVuY3Rpb24gaXNDb25jdXJyZW50TW9kZShvYmplY3QpIHtcbiAgcmV0dXJuIHR5cGVPZihvYmplY3QpID09PSBSRUFDVF9DT05DVVJSRU5UX01PREVfVFlQRTtcbn1cbmZ1bmN0aW9uIGlzQ29udGV4dENvbnN1bWVyKG9iamVjdCkge1xuICByZXR1cm4gdHlwZU9mKG9iamVjdCkgPT09IFJFQUNUX0NPTlRFWFRfVFlQRTtcbn1cbmZ1bmN0aW9uIGlzQ29udGV4dFByb3ZpZGVyKG9iamVjdCkge1xuICByZXR1cm4gdHlwZU9mKG9iamVjdCkgPT09IFJFQUNUX1BST1ZJREVSX1RZUEU7XG59XG5mdW5jdGlvbiBpc0VsZW1lbnQob2JqZWN0KSB7XG4gIHJldHVybiB0eXBlb2Ygb2JqZWN0ID09PSAnb2JqZWN0JyAmJiBvYmplY3QgIT09IG51bGwgJiYgb2JqZWN0LiQkdHlwZW9mID09PSBSRUFDVF9FTEVNRU5UX1RZUEU7XG59XG5mdW5jdGlvbiBpc0ZvcndhcmRSZWYob2JqZWN0KSB7XG4gIHJldHVybiB0eXBlT2Yob2JqZWN0KSA9PT0gUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRTtcbn1cbmZ1bmN0aW9uIGlzRnJhZ21lbnQob2JqZWN0KSB7XG4gIHJldHVybiB0eXBlT2Yob2JqZWN0KSA9PT0gUkVBQ1RfRlJBR01FTlRfVFlQRTtcbn1cbmZ1bmN0aW9uIGlzTGF6eShvYmplY3QpIHtcbiAgcmV0dXJuIHR5cGVPZihvYmplY3QpID09PSBSRUFDVF9MQVpZX1RZUEU7XG59XG5mdW5jdGlvbiBpc01lbW8ob2JqZWN0KSB7XG4gIHJldHVybiB0eXBlT2Yob2JqZWN0KSA9PT0gUkVBQ1RfTUVNT19UWVBFO1xufVxuZnVuY3Rpb24gaXNQb3J0YWwob2JqZWN0KSB7XG4gIHJldHVybiB0eXBlT2Yob2JqZWN0KSA9PT0gUkVBQ1RfUE9SVEFMX1RZUEU7XG59XG5mdW5jdGlvbiBpc1Byb2ZpbGVyKG9iamVjdCkge1xuICByZXR1cm4gdHlwZU9mKG9iamVjdCkgPT09IFJFQUNUX1BST0ZJTEVSX1RZUEU7XG59XG5mdW5jdGlvbiBpc1N0cmljdE1vZGUob2JqZWN0KSB7XG4gIHJldHVybiB0eXBlT2Yob2JqZWN0KSA9PT0gUkVBQ1RfU1RSSUNUX01PREVfVFlQRTtcbn1cbmZ1bmN0aW9uIGlzU3VzcGVuc2Uob2JqZWN0KSB7XG4gIHJldHVybiB0eXBlT2Yob2JqZWN0KSA9PT0gUkVBQ1RfU1VTUEVOU0VfVFlQRTtcbn1cblxuZXhwb3J0cy5Bc3luY01vZGUgPSBBc3luY01vZGU7XG5leHBvcnRzLkNvbmN1cnJlbnRNb2RlID0gQ29uY3VycmVudE1vZGU7XG5leHBvcnRzLkNvbnRleHRDb25zdW1lciA9IENvbnRleHRDb25zdW1lcjtcbmV4cG9ydHMuQ29udGV4dFByb3ZpZGVyID0gQ29udGV4dFByb3ZpZGVyO1xuZXhwb3J0cy5FbGVtZW50ID0gRWxlbWVudDtcbmV4cG9ydHMuRm9yd2FyZFJlZiA9IEZvcndhcmRSZWY7XG5leHBvcnRzLkZyYWdtZW50ID0gRnJhZ21lbnQ7XG5leHBvcnRzLkxhenkgPSBMYXp5O1xuZXhwb3J0cy5NZW1vID0gTWVtbztcbmV4cG9ydHMuUG9ydGFsID0gUG9ydGFsO1xuZXhwb3J0cy5Qcm9maWxlciA9IFByb2ZpbGVyO1xuZXhwb3J0cy5TdHJpY3RNb2RlID0gU3RyaWN0TW9kZTtcbmV4cG9ydHMuU3VzcGVuc2UgPSBTdXNwZW5zZTtcbmV4cG9ydHMuaXNBc3luY01vZGUgPSBpc0FzeW5jTW9kZTtcbmV4cG9ydHMuaXNDb25jdXJyZW50TW9kZSA9IGlzQ29uY3VycmVudE1vZGU7XG5leHBvcnRzLmlzQ29udGV4dENvbnN1bWVyID0gaXNDb250ZXh0Q29uc3VtZXI7XG5leHBvcnRzLmlzQ29udGV4dFByb3ZpZGVyID0gaXNDb250ZXh0UHJvdmlkZXI7XG5leHBvcnRzLmlzRWxlbWVudCA9IGlzRWxlbWVudDtcbmV4cG9ydHMuaXNGb3J3YXJkUmVmID0gaXNGb3J3YXJkUmVmO1xuZXhwb3J0cy5pc0ZyYWdtZW50ID0gaXNGcmFnbWVudDtcbmV4cG9ydHMuaXNMYXp5ID0gaXNMYXp5O1xuZXhwb3J0cy5pc01lbW8gPSBpc01lbW87XG5leHBvcnRzLmlzUG9ydGFsID0gaXNQb3J0YWw7XG5leHBvcnRzLmlzUHJvZmlsZXIgPSBpc1Byb2ZpbGVyO1xuZXhwb3J0cy5pc1N0cmljdE1vZGUgPSBpc1N0cmljdE1vZGU7XG5leHBvcnRzLmlzU3VzcGVuc2UgPSBpc1N1c3BlbnNlO1xuZXhwb3J0cy5pc1ZhbGlkRWxlbWVudFR5cGUgPSBpc1ZhbGlkRWxlbWVudFR5cGU7XG5leHBvcnRzLnR5cGVPZiA9IHR5cGVPZjtcbiAgfSkoKTtcbn1cbiIsIid1c2Ugc3RyaWN0JztcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAncHJvZHVjdGlvbicpIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2Nqcy9yZWFjdC1pcy5wcm9kdWN0aW9uLm1pbi5qcycpO1xufSBlbHNlIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2Nqcy9yZWFjdC1pcy5kZXZlbG9wbWVudC5qcycpO1xufVxuIiwiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTQtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuXG52YXIgcnVudGltZSA9IChmdW5jdGlvbiAoZXhwb3J0cykge1xuICBcInVzZSBzdHJpY3RcIjtcblxuICB2YXIgT3AgPSBPYmplY3QucHJvdG90eXBlO1xuICB2YXIgaGFzT3duID0gT3AuaGFzT3duUHJvcGVydHk7XG4gIHZhciB1bmRlZmluZWQ7IC8vIE1vcmUgY29tcHJlc3NpYmxlIHRoYW4gdm9pZCAwLlxuICB2YXIgJFN5bWJvbCA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiA/IFN5bWJvbCA6IHt9O1xuICB2YXIgaXRlcmF0b3JTeW1ib2wgPSAkU3ltYm9sLml0ZXJhdG9yIHx8IFwiQEBpdGVyYXRvclwiO1xuICB2YXIgYXN5bmNJdGVyYXRvclN5bWJvbCA9ICRTeW1ib2wuYXN5bmNJdGVyYXRvciB8fCBcIkBAYXN5bmNJdGVyYXRvclwiO1xuICB2YXIgdG9TdHJpbmdUYWdTeW1ib2wgPSAkU3ltYm9sLnRvU3RyaW5nVGFnIHx8IFwiQEB0b1N0cmluZ1RhZ1wiO1xuXG4gIGZ1bmN0aW9uIGRlZmluZShvYmosIGtleSwgdmFsdWUpIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHtcbiAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICB3cml0YWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIHJldHVybiBvYmpba2V5XTtcbiAgfVxuICB0cnkge1xuICAgIC8vIElFIDggaGFzIGEgYnJva2VuIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSB0aGF0IG9ubHkgd29ya3Mgb24gRE9NIG9iamVjdHMuXG4gICAgZGVmaW5lKHt9LCBcIlwiKTtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgZGVmaW5lID0gZnVuY3Rpb24ob2JqLCBrZXksIHZhbHVlKSB7XG4gICAgICByZXR1cm4gb2JqW2tleV0gPSB2YWx1ZTtcbiAgICB9O1xuICB9XG5cbiAgZnVuY3Rpb24gd3JhcChpbm5lckZuLCBvdXRlckZuLCBzZWxmLCB0cnlMb2NzTGlzdCkge1xuICAgIC8vIElmIG91dGVyRm4gcHJvdmlkZWQgYW5kIG91dGVyRm4ucHJvdG90eXBlIGlzIGEgR2VuZXJhdG9yLCB0aGVuIG91dGVyRm4ucHJvdG90eXBlIGluc3RhbmNlb2YgR2VuZXJhdG9yLlxuICAgIHZhciBwcm90b0dlbmVyYXRvciA9IG91dGVyRm4gJiYgb3V0ZXJGbi5wcm90b3R5cGUgaW5zdGFuY2VvZiBHZW5lcmF0b3IgPyBvdXRlckZuIDogR2VuZXJhdG9yO1xuICAgIHZhciBnZW5lcmF0b3IgPSBPYmplY3QuY3JlYXRlKHByb3RvR2VuZXJhdG9yLnByb3RvdHlwZSk7XG4gICAgdmFyIGNvbnRleHQgPSBuZXcgQ29udGV4dCh0cnlMb2NzTGlzdCB8fCBbXSk7XG5cbiAgICAvLyBUaGUgLl9pbnZva2UgbWV0aG9kIHVuaWZpZXMgdGhlIGltcGxlbWVudGF0aW9ucyBvZiB0aGUgLm5leHQsXG4gICAgLy8gLnRocm93LCBhbmQgLnJldHVybiBtZXRob2RzLlxuICAgIGdlbmVyYXRvci5faW52b2tlID0gbWFrZUludm9rZU1ldGhvZChpbm5lckZuLCBzZWxmLCBjb250ZXh0KTtcblxuICAgIHJldHVybiBnZW5lcmF0b3I7XG4gIH1cbiAgZXhwb3J0cy53cmFwID0gd3JhcDtcblxuICAvLyBUcnkvY2F0Y2ggaGVscGVyIHRvIG1pbmltaXplIGRlb3B0aW1pemF0aW9ucy4gUmV0dXJucyBhIGNvbXBsZXRpb25cbiAgLy8gcmVjb3JkIGxpa2UgY29udGV4dC50cnlFbnRyaWVzW2ldLmNvbXBsZXRpb24uIFRoaXMgaW50ZXJmYWNlIGNvdWxkXG4gIC8vIGhhdmUgYmVlbiAoYW5kIHdhcyBwcmV2aW91c2x5KSBkZXNpZ25lZCB0byB0YWtlIGEgY2xvc3VyZSB0byBiZVxuICAvLyBpbnZva2VkIHdpdGhvdXQgYXJndW1lbnRzLCBidXQgaW4gYWxsIHRoZSBjYXNlcyB3ZSBjYXJlIGFib3V0IHdlXG4gIC8vIGFscmVhZHkgaGF2ZSBhbiBleGlzdGluZyBtZXRob2Qgd2Ugd2FudCB0byBjYWxsLCBzbyB0aGVyZSdzIG5vIG5lZWRcbiAgLy8gdG8gY3JlYXRlIGEgbmV3IGZ1bmN0aW9uIG9iamVjdC4gV2UgY2FuIGV2ZW4gZ2V0IGF3YXkgd2l0aCBhc3N1bWluZ1xuICAvLyB0aGUgbWV0aG9kIHRha2VzIGV4YWN0bHkgb25lIGFyZ3VtZW50LCBzaW5jZSB0aGF0IGhhcHBlbnMgdG8gYmUgdHJ1ZVxuICAvLyBpbiBldmVyeSBjYXNlLCBzbyB3ZSBkb24ndCBoYXZlIHRvIHRvdWNoIHRoZSBhcmd1bWVudHMgb2JqZWN0LiBUaGVcbiAgLy8gb25seSBhZGRpdGlvbmFsIGFsbG9jYXRpb24gcmVxdWlyZWQgaXMgdGhlIGNvbXBsZXRpb24gcmVjb3JkLCB3aGljaFxuICAvLyBoYXMgYSBzdGFibGUgc2hhcGUgYW5kIHNvIGhvcGVmdWxseSBzaG91bGQgYmUgY2hlYXAgdG8gYWxsb2NhdGUuXG4gIGZ1bmN0aW9uIHRyeUNhdGNoKGZuLCBvYmosIGFyZykge1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4geyB0eXBlOiBcIm5vcm1hbFwiLCBhcmc6IGZuLmNhbGwob2JqLCBhcmcpIH07XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICByZXR1cm4geyB0eXBlOiBcInRocm93XCIsIGFyZzogZXJyIH07XG4gICAgfVxuICB9XG5cbiAgdmFyIEdlblN0YXRlU3VzcGVuZGVkU3RhcnQgPSBcInN1c3BlbmRlZFN0YXJ0XCI7XG4gIHZhciBHZW5TdGF0ZVN1c3BlbmRlZFlpZWxkID0gXCJzdXNwZW5kZWRZaWVsZFwiO1xuICB2YXIgR2VuU3RhdGVFeGVjdXRpbmcgPSBcImV4ZWN1dGluZ1wiO1xuICB2YXIgR2VuU3RhdGVDb21wbGV0ZWQgPSBcImNvbXBsZXRlZFwiO1xuXG4gIC8vIFJldHVybmluZyB0aGlzIG9iamVjdCBmcm9tIHRoZSBpbm5lckZuIGhhcyB0aGUgc2FtZSBlZmZlY3QgYXNcbiAgLy8gYnJlYWtpbmcgb3V0IG9mIHRoZSBkaXNwYXRjaCBzd2l0Y2ggc3RhdGVtZW50LlxuICB2YXIgQ29udGludWVTZW50aW5lbCA9IHt9O1xuXG4gIC8vIER1bW15IGNvbnN0cnVjdG9yIGZ1bmN0aW9ucyB0aGF0IHdlIHVzZSBhcyB0aGUgLmNvbnN0cnVjdG9yIGFuZFxuICAvLyAuY29uc3RydWN0b3IucHJvdG90eXBlIHByb3BlcnRpZXMgZm9yIGZ1bmN0aW9ucyB0aGF0IHJldHVybiBHZW5lcmF0b3JcbiAgLy8gb2JqZWN0cy4gRm9yIGZ1bGwgc3BlYyBjb21wbGlhbmNlLCB5b3UgbWF5IHdpc2ggdG8gY29uZmlndXJlIHlvdXJcbiAgLy8gbWluaWZpZXIgbm90IHRvIG1hbmdsZSB0aGUgbmFtZXMgb2YgdGhlc2UgdHdvIGZ1bmN0aW9ucy5cbiAgZnVuY3Rpb24gR2VuZXJhdG9yKCkge31cbiAgZnVuY3Rpb24gR2VuZXJhdG9yRnVuY3Rpb24oKSB7fVxuICBmdW5jdGlvbiBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZSgpIHt9XG5cbiAgLy8gVGhpcyBpcyBhIHBvbHlmaWxsIGZvciAlSXRlcmF0b3JQcm90b3R5cGUlIGZvciBlbnZpcm9ubWVudHMgdGhhdFxuICAvLyBkb24ndCBuYXRpdmVseSBzdXBwb3J0IGl0LlxuICB2YXIgSXRlcmF0b3JQcm90b3R5cGUgPSB7fTtcbiAgSXRlcmF0b3JQcm90b3R5cGVbaXRlcmF0b3JTeW1ib2xdID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIHZhciBnZXRQcm90byA9IE9iamVjdC5nZXRQcm90b3R5cGVPZjtcbiAgdmFyIE5hdGl2ZUl0ZXJhdG9yUHJvdG90eXBlID0gZ2V0UHJvdG8gJiYgZ2V0UHJvdG8oZ2V0UHJvdG8odmFsdWVzKFtdKSkpO1xuICBpZiAoTmF0aXZlSXRlcmF0b3JQcm90b3R5cGUgJiZcbiAgICAgIE5hdGl2ZUl0ZXJhdG9yUHJvdG90eXBlICE9PSBPcCAmJlxuICAgICAgaGFzT3duLmNhbGwoTmF0aXZlSXRlcmF0b3JQcm90b3R5cGUsIGl0ZXJhdG9yU3ltYm9sKSkge1xuICAgIC8vIFRoaXMgZW52aXJvbm1lbnQgaGFzIGEgbmF0aXZlICVJdGVyYXRvclByb3RvdHlwZSU7IHVzZSBpdCBpbnN0ZWFkXG4gICAgLy8gb2YgdGhlIHBvbHlmaWxsLlxuICAgIEl0ZXJhdG9yUHJvdG90eXBlID0gTmF0aXZlSXRlcmF0b3JQcm90b3R5cGU7XG4gIH1cblxuICB2YXIgR3AgPSBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZS5wcm90b3R5cGUgPVxuICAgIEdlbmVyYXRvci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEl0ZXJhdG9yUHJvdG90eXBlKTtcbiAgR2VuZXJhdG9yRnVuY3Rpb24ucHJvdG90eXBlID0gR3AuY29uc3RydWN0b3IgPSBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZTtcbiAgR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGUuY29uc3RydWN0b3IgPSBHZW5lcmF0b3JGdW5jdGlvbjtcbiAgR2VuZXJhdG9yRnVuY3Rpb24uZGlzcGxheU5hbWUgPSBkZWZpbmUoXG4gICAgR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGUsXG4gICAgdG9TdHJpbmdUYWdTeW1ib2wsXG4gICAgXCJHZW5lcmF0b3JGdW5jdGlvblwiXG4gICk7XG5cbiAgLy8gSGVscGVyIGZvciBkZWZpbmluZyB0aGUgLm5leHQsIC50aHJvdywgYW5kIC5yZXR1cm4gbWV0aG9kcyBvZiB0aGVcbiAgLy8gSXRlcmF0b3IgaW50ZXJmYWNlIGluIHRlcm1zIG9mIGEgc2luZ2xlIC5faW52b2tlIG1ldGhvZC5cbiAgZnVuY3Rpb24gZGVmaW5lSXRlcmF0b3JNZXRob2RzKHByb3RvdHlwZSkge1xuICAgIFtcIm5leHRcIiwgXCJ0aHJvd1wiLCBcInJldHVyblwiXS5mb3JFYWNoKGZ1bmN0aW9uKG1ldGhvZCkge1xuICAgICAgZGVmaW5lKHByb3RvdHlwZSwgbWV0aG9kLCBmdW5jdGlvbihhcmcpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2ludm9rZShtZXRob2QsIGFyZyk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuXG4gIGV4cG9ydHMuaXNHZW5lcmF0b3JGdW5jdGlvbiA9IGZ1bmN0aW9uKGdlbkZ1bikge1xuICAgIHZhciBjdG9yID0gdHlwZW9mIGdlbkZ1biA9PT0gXCJmdW5jdGlvblwiICYmIGdlbkZ1bi5jb25zdHJ1Y3RvcjtcbiAgICByZXR1cm4gY3RvclxuICAgICAgPyBjdG9yID09PSBHZW5lcmF0b3JGdW5jdGlvbiB8fFxuICAgICAgICAvLyBGb3IgdGhlIG5hdGl2ZSBHZW5lcmF0b3JGdW5jdGlvbiBjb25zdHJ1Y3RvciwgdGhlIGJlc3Qgd2UgY2FuXG4gICAgICAgIC8vIGRvIGlzIHRvIGNoZWNrIGl0cyAubmFtZSBwcm9wZXJ0eS5cbiAgICAgICAgKGN0b3IuZGlzcGxheU5hbWUgfHwgY3Rvci5uYW1lKSA9PT0gXCJHZW5lcmF0b3JGdW5jdGlvblwiXG4gICAgICA6IGZhbHNlO1xuICB9O1xuXG4gIGV4cG9ydHMubWFyayA9IGZ1bmN0aW9uKGdlbkZ1bikge1xuICAgIGlmIChPYmplY3Quc2V0UHJvdG90eXBlT2YpIHtcbiAgICAgIE9iamVjdC5zZXRQcm90b3R5cGVPZihnZW5GdW4sIEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZ2VuRnVuLl9fcHJvdG9fXyA9IEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlO1xuICAgICAgZGVmaW5lKGdlbkZ1biwgdG9TdHJpbmdUYWdTeW1ib2wsIFwiR2VuZXJhdG9yRnVuY3Rpb25cIik7XG4gICAgfVxuICAgIGdlbkZ1bi5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEdwKTtcbiAgICByZXR1cm4gZ2VuRnVuO1xuICB9O1xuXG4gIC8vIFdpdGhpbiB0aGUgYm9keSBvZiBhbnkgYXN5bmMgZnVuY3Rpb24sIGBhd2FpdCB4YCBpcyB0cmFuc2Zvcm1lZCB0b1xuICAvLyBgeWllbGQgcmVnZW5lcmF0b3JSdW50aW1lLmF3cmFwKHgpYCwgc28gdGhhdCB0aGUgcnVudGltZSBjYW4gdGVzdFxuICAvLyBgaGFzT3duLmNhbGwodmFsdWUsIFwiX19hd2FpdFwiKWAgdG8gZGV0ZXJtaW5lIGlmIHRoZSB5aWVsZGVkIHZhbHVlIGlzXG4gIC8vIG1lYW50IHRvIGJlIGF3YWl0ZWQuXG4gIGV4cG9ydHMuYXdyYXAgPSBmdW5jdGlvbihhcmcpIHtcbiAgICByZXR1cm4geyBfX2F3YWl0OiBhcmcgfTtcbiAgfTtcblxuICBmdW5jdGlvbiBBc3luY0l0ZXJhdG9yKGdlbmVyYXRvciwgUHJvbWlzZUltcGwpIHtcbiAgICBmdW5jdGlvbiBpbnZva2UobWV0aG9kLCBhcmcsIHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgdmFyIHJlY29yZCA9IHRyeUNhdGNoKGdlbmVyYXRvclttZXRob2RdLCBnZW5lcmF0b3IsIGFyZyk7XG4gICAgICBpZiAocmVjb3JkLnR5cGUgPT09IFwidGhyb3dcIikge1xuICAgICAgICByZWplY3QocmVjb3JkLmFyZyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgcmVzdWx0ID0gcmVjb3JkLmFyZztcbiAgICAgICAgdmFyIHZhbHVlID0gcmVzdWx0LnZhbHVlO1xuICAgICAgICBpZiAodmFsdWUgJiZcbiAgICAgICAgICAgIHR5cGVvZiB2YWx1ZSA9PT0gXCJvYmplY3RcIiAmJlxuICAgICAgICAgICAgaGFzT3duLmNhbGwodmFsdWUsIFwiX19hd2FpdFwiKSkge1xuICAgICAgICAgIHJldHVybiBQcm9taXNlSW1wbC5yZXNvbHZlKHZhbHVlLl9fYXdhaXQpLnRoZW4oZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgICAgIGludm9rZShcIm5leHRcIiwgdmFsdWUsIHJlc29sdmUsIHJlamVjdCk7XG4gICAgICAgICAgfSwgZnVuY3Rpb24oZXJyKSB7XG4gICAgICAgICAgICBpbnZva2UoXCJ0aHJvd1wiLCBlcnIsIHJlc29sdmUsIHJlamVjdCk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gUHJvbWlzZUltcGwucmVzb2x2ZSh2YWx1ZSkudGhlbihmdW5jdGlvbih1bndyYXBwZWQpIHtcbiAgICAgICAgICAvLyBXaGVuIGEgeWllbGRlZCBQcm9taXNlIGlzIHJlc29sdmVkLCBpdHMgZmluYWwgdmFsdWUgYmVjb21lc1xuICAgICAgICAgIC8vIHRoZSAudmFsdWUgb2YgdGhlIFByb21pc2U8e3ZhbHVlLGRvbmV9PiByZXN1bHQgZm9yIHRoZVxuICAgICAgICAgIC8vIGN1cnJlbnQgaXRlcmF0aW9uLlxuICAgICAgICAgIHJlc3VsdC52YWx1ZSA9IHVud3JhcHBlZDtcbiAgICAgICAgICByZXNvbHZlKHJlc3VsdCk7XG4gICAgICAgIH0sIGZ1bmN0aW9uKGVycm9yKSB7XG4gICAgICAgICAgLy8gSWYgYSByZWplY3RlZCBQcm9taXNlIHdhcyB5aWVsZGVkLCB0aHJvdyB0aGUgcmVqZWN0aW9uIGJhY2tcbiAgICAgICAgICAvLyBpbnRvIHRoZSBhc3luYyBnZW5lcmF0b3IgZnVuY3Rpb24gc28gaXQgY2FuIGJlIGhhbmRsZWQgdGhlcmUuXG4gICAgICAgICAgcmV0dXJuIGludm9rZShcInRocm93XCIsIGVycm9yLCByZXNvbHZlLCByZWplY3QpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgcHJldmlvdXNQcm9taXNlO1xuXG4gICAgZnVuY3Rpb24gZW5xdWV1ZShtZXRob2QsIGFyZykge1xuICAgICAgZnVuY3Rpb24gY2FsbEludm9rZVdpdGhNZXRob2RBbmRBcmcoKSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZUltcGwoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgICAgaW52b2tlKG1ldGhvZCwgYXJnLCByZXNvbHZlLCByZWplY3QpO1xuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHByZXZpb3VzUHJvbWlzZSA9XG4gICAgICAgIC8vIElmIGVucXVldWUgaGFzIGJlZW4gY2FsbGVkIGJlZm9yZSwgdGhlbiB3ZSB3YW50IHRvIHdhaXQgdW50aWxcbiAgICAgICAgLy8gYWxsIHByZXZpb3VzIFByb21pc2VzIGhhdmUgYmVlbiByZXNvbHZlZCBiZWZvcmUgY2FsbGluZyBpbnZva2UsXG4gICAgICAgIC8vIHNvIHRoYXQgcmVzdWx0cyBhcmUgYWx3YXlzIGRlbGl2ZXJlZCBpbiB0aGUgY29ycmVjdCBvcmRlci4gSWZcbiAgICAgICAgLy8gZW5xdWV1ZSBoYXMgbm90IGJlZW4gY2FsbGVkIGJlZm9yZSwgdGhlbiBpdCBpcyBpbXBvcnRhbnQgdG9cbiAgICAgICAgLy8gY2FsbCBpbnZva2UgaW1tZWRpYXRlbHksIHdpdGhvdXQgd2FpdGluZyBvbiBhIGNhbGxiYWNrIHRvIGZpcmUsXG4gICAgICAgIC8vIHNvIHRoYXQgdGhlIGFzeW5jIGdlbmVyYXRvciBmdW5jdGlvbiBoYXMgdGhlIG9wcG9ydHVuaXR5IHRvIGRvXG4gICAgICAgIC8vIGFueSBuZWNlc3Nhcnkgc2V0dXAgaW4gYSBwcmVkaWN0YWJsZSB3YXkuIFRoaXMgcHJlZGljdGFiaWxpdHlcbiAgICAgICAgLy8gaXMgd2h5IHRoZSBQcm9taXNlIGNvbnN0cnVjdG9yIHN5bmNocm9ub3VzbHkgaW52b2tlcyBpdHNcbiAgICAgICAgLy8gZXhlY3V0b3IgY2FsbGJhY2ssIGFuZCB3aHkgYXN5bmMgZnVuY3Rpb25zIHN5bmNocm9ub3VzbHlcbiAgICAgICAgLy8gZXhlY3V0ZSBjb2RlIGJlZm9yZSB0aGUgZmlyc3QgYXdhaXQuIFNpbmNlIHdlIGltcGxlbWVudCBzaW1wbGVcbiAgICAgICAgLy8gYXN5bmMgZnVuY3Rpb25zIGluIHRlcm1zIG9mIGFzeW5jIGdlbmVyYXRvcnMsIGl0IGlzIGVzcGVjaWFsbHlcbiAgICAgICAgLy8gaW1wb3J0YW50IHRvIGdldCB0aGlzIHJpZ2h0LCBldmVuIHRob3VnaCBpdCByZXF1aXJlcyBjYXJlLlxuICAgICAgICBwcmV2aW91c1Byb21pc2UgPyBwcmV2aW91c1Byb21pc2UudGhlbihcbiAgICAgICAgICBjYWxsSW52b2tlV2l0aE1ldGhvZEFuZEFyZyxcbiAgICAgICAgICAvLyBBdm9pZCBwcm9wYWdhdGluZyBmYWlsdXJlcyB0byBQcm9taXNlcyByZXR1cm5lZCBieSBsYXRlclxuICAgICAgICAgIC8vIGludm9jYXRpb25zIG9mIHRoZSBpdGVyYXRvci5cbiAgICAgICAgICBjYWxsSW52b2tlV2l0aE1ldGhvZEFuZEFyZ1xuICAgICAgICApIDogY2FsbEludm9rZVdpdGhNZXRob2RBbmRBcmcoKTtcbiAgICB9XG5cbiAgICAvLyBEZWZpbmUgdGhlIHVuaWZpZWQgaGVscGVyIG1ldGhvZCB0aGF0IGlzIHVzZWQgdG8gaW1wbGVtZW50IC5uZXh0LFxuICAgIC8vIC50aHJvdywgYW5kIC5yZXR1cm4gKHNlZSBkZWZpbmVJdGVyYXRvck1ldGhvZHMpLlxuICAgIHRoaXMuX2ludm9rZSA9IGVucXVldWU7XG4gIH1cblxuICBkZWZpbmVJdGVyYXRvck1ldGhvZHMoQXN5bmNJdGVyYXRvci5wcm90b3R5cGUpO1xuICBBc3luY0l0ZXJhdG9yLnByb3RvdHlwZVthc3luY0l0ZXJhdG9yU3ltYm9sXSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcbiAgZXhwb3J0cy5Bc3luY0l0ZXJhdG9yID0gQXN5bmNJdGVyYXRvcjtcblxuICAvLyBOb3RlIHRoYXQgc2ltcGxlIGFzeW5jIGZ1bmN0aW9ucyBhcmUgaW1wbGVtZW50ZWQgb24gdG9wIG9mXG4gIC8vIEFzeW5jSXRlcmF0b3Igb2JqZWN0czsgdGhleSBqdXN0IHJldHVybiBhIFByb21pc2UgZm9yIHRoZSB2YWx1ZSBvZlxuICAvLyB0aGUgZmluYWwgcmVzdWx0IHByb2R1Y2VkIGJ5IHRoZSBpdGVyYXRvci5cbiAgZXhwb3J0cy5hc3luYyA9IGZ1bmN0aW9uKGlubmVyRm4sIG91dGVyRm4sIHNlbGYsIHRyeUxvY3NMaXN0LCBQcm9taXNlSW1wbCkge1xuICAgIGlmIChQcm9taXNlSW1wbCA9PT0gdm9pZCAwKSBQcm9taXNlSW1wbCA9IFByb21pc2U7XG5cbiAgICB2YXIgaXRlciA9IG5ldyBBc3luY0l0ZXJhdG9yKFxuICAgICAgd3JhcChpbm5lckZuLCBvdXRlckZuLCBzZWxmLCB0cnlMb2NzTGlzdCksXG4gICAgICBQcm9taXNlSW1wbFxuICAgICk7XG5cbiAgICByZXR1cm4gZXhwb3J0cy5pc0dlbmVyYXRvckZ1bmN0aW9uKG91dGVyRm4pXG4gICAgICA/IGl0ZXIgLy8gSWYgb3V0ZXJGbiBpcyBhIGdlbmVyYXRvciwgcmV0dXJuIHRoZSBmdWxsIGl0ZXJhdG9yLlxuICAgICAgOiBpdGVyLm5leHQoKS50aGVuKGZ1bmN0aW9uKHJlc3VsdCkge1xuICAgICAgICAgIHJldHVybiByZXN1bHQuZG9uZSA/IHJlc3VsdC52YWx1ZSA6IGl0ZXIubmV4dCgpO1xuICAgICAgICB9KTtcbiAgfTtcblxuICBmdW5jdGlvbiBtYWtlSW52b2tlTWV0aG9kKGlubmVyRm4sIHNlbGYsIGNvbnRleHQpIHtcbiAgICB2YXIgc3RhdGUgPSBHZW5TdGF0ZVN1c3BlbmRlZFN0YXJ0O1xuXG4gICAgcmV0dXJuIGZ1bmN0aW9uIGludm9rZShtZXRob2QsIGFyZykge1xuICAgICAgaWYgKHN0YXRlID09PSBHZW5TdGF0ZUV4ZWN1dGluZykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJHZW5lcmF0b3IgaXMgYWxyZWFkeSBydW5uaW5nXCIpO1xuICAgICAgfVxuXG4gICAgICBpZiAoc3RhdGUgPT09IEdlblN0YXRlQ29tcGxldGVkKSB7XG4gICAgICAgIGlmIChtZXRob2QgPT09IFwidGhyb3dcIikge1xuICAgICAgICAgIHRocm93IGFyZztcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEJlIGZvcmdpdmluZywgcGVyIDI1LjMuMy4zLjMgb2YgdGhlIHNwZWM6XG4gICAgICAgIC8vIGh0dHBzOi8vcGVvcGxlLm1vemlsbGEub3JnL35qb3JlbmRvcmZmL2VzNi1kcmFmdC5odG1sI3NlYy1nZW5lcmF0b3JyZXN1bWVcbiAgICAgICAgcmV0dXJuIGRvbmVSZXN1bHQoKTtcbiAgICAgIH1cblxuICAgICAgY29udGV4dC5tZXRob2QgPSBtZXRob2Q7XG4gICAgICBjb250ZXh0LmFyZyA9IGFyZztcblxuICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgdmFyIGRlbGVnYXRlID0gY29udGV4dC5kZWxlZ2F0ZTtcbiAgICAgICAgaWYgKGRlbGVnYXRlKSB7XG4gICAgICAgICAgdmFyIGRlbGVnYXRlUmVzdWx0ID0gbWF5YmVJbnZva2VEZWxlZ2F0ZShkZWxlZ2F0ZSwgY29udGV4dCk7XG4gICAgICAgICAgaWYgKGRlbGVnYXRlUmVzdWx0KSB7XG4gICAgICAgICAgICBpZiAoZGVsZWdhdGVSZXN1bHQgPT09IENvbnRpbnVlU2VudGluZWwpIGNvbnRpbnVlO1xuICAgICAgICAgICAgcmV0dXJuIGRlbGVnYXRlUmVzdWx0O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChjb250ZXh0Lm1ldGhvZCA9PT0gXCJuZXh0XCIpIHtcbiAgICAgICAgICAvLyBTZXR0aW5nIGNvbnRleHQuX3NlbnQgZm9yIGxlZ2FjeSBzdXBwb3J0IG9mIEJhYmVsJ3NcbiAgICAgICAgICAvLyBmdW5jdGlvbi5zZW50IGltcGxlbWVudGF0aW9uLlxuICAgICAgICAgIGNvbnRleHQuc2VudCA9IGNvbnRleHQuX3NlbnQgPSBjb250ZXh0LmFyZztcblxuICAgICAgICB9IGVsc2UgaWYgKGNvbnRleHQubWV0aG9kID09PSBcInRocm93XCIpIHtcbiAgICAgICAgICBpZiAoc3RhdGUgPT09IEdlblN0YXRlU3VzcGVuZGVkU3RhcnQpIHtcbiAgICAgICAgICAgIHN0YXRlID0gR2VuU3RhdGVDb21wbGV0ZWQ7XG4gICAgICAgICAgICB0aHJvdyBjb250ZXh0LmFyZztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjb250ZXh0LmRpc3BhdGNoRXhjZXB0aW9uKGNvbnRleHQuYXJnKTtcblxuICAgICAgICB9IGVsc2UgaWYgKGNvbnRleHQubWV0aG9kID09PSBcInJldHVyblwiKSB7XG4gICAgICAgICAgY29udGV4dC5hYnJ1cHQoXCJyZXR1cm5cIiwgY29udGV4dC5hcmcpO1xuICAgICAgICB9XG5cbiAgICAgICAgc3RhdGUgPSBHZW5TdGF0ZUV4ZWN1dGluZztcblxuICAgICAgICB2YXIgcmVjb3JkID0gdHJ5Q2F0Y2goaW5uZXJGbiwgc2VsZiwgY29udGV4dCk7XG4gICAgICAgIGlmIChyZWNvcmQudHlwZSA9PT0gXCJub3JtYWxcIikge1xuICAgICAgICAgIC8vIElmIGFuIGV4Y2VwdGlvbiBpcyB0aHJvd24gZnJvbSBpbm5lckZuLCB3ZSBsZWF2ZSBzdGF0ZSA9PT1cbiAgICAgICAgICAvLyBHZW5TdGF0ZUV4ZWN1dGluZyBhbmQgbG9vcCBiYWNrIGZvciBhbm90aGVyIGludm9jYXRpb24uXG4gICAgICAgICAgc3RhdGUgPSBjb250ZXh0LmRvbmVcbiAgICAgICAgICAgID8gR2VuU3RhdGVDb21wbGV0ZWRcbiAgICAgICAgICAgIDogR2VuU3RhdGVTdXNwZW5kZWRZaWVsZDtcblxuICAgICAgICAgIGlmIChyZWNvcmQuYXJnID09PSBDb250aW51ZVNlbnRpbmVsKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdmFsdWU6IHJlY29yZC5hcmcsXG4gICAgICAgICAgICBkb25lOiBjb250ZXh0LmRvbmVcbiAgICAgICAgICB9O1xuXG4gICAgICAgIH0gZWxzZSBpZiAocmVjb3JkLnR5cGUgPT09IFwidGhyb3dcIikge1xuICAgICAgICAgIHN0YXRlID0gR2VuU3RhdGVDb21wbGV0ZWQ7XG4gICAgICAgICAgLy8gRGlzcGF0Y2ggdGhlIGV4Y2VwdGlvbiBieSBsb29waW5nIGJhY2sgYXJvdW5kIHRvIHRoZVxuICAgICAgICAgIC8vIGNvbnRleHQuZGlzcGF0Y2hFeGNlcHRpb24oY29udGV4dC5hcmcpIGNhbGwgYWJvdmUuXG4gICAgICAgICAgY29udGV4dC5tZXRob2QgPSBcInRocm93XCI7XG4gICAgICAgICAgY29udGV4dC5hcmcgPSByZWNvcmQuYXJnO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcbiAgfVxuXG4gIC8vIENhbGwgZGVsZWdhdGUuaXRlcmF0b3JbY29udGV4dC5tZXRob2RdKGNvbnRleHQuYXJnKSBhbmQgaGFuZGxlIHRoZVxuICAvLyByZXN1bHQsIGVpdGhlciBieSByZXR1cm5pbmcgYSB7IHZhbHVlLCBkb25lIH0gcmVzdWx0IGZyb20gdGhlXG4gIC8vIGRlbGVnYXRlIGl0ZXJhdG9yLCBvciBieSBtb2RpZnlpbmcgY29udGV4dC5tZXRob2QgYW5kIGNvbnRleHQuYXJnLFxuICAvLyBzZXR0aW5nIGNvbnRleHQuZGVsZWdhdGUgdG8gbnVsbCwgYW5kIHJldHVybmluZyB0aGUgQ29udGludWVTZW50aW5lbC5cbiAgZnVuY3Rpb24gbWF5YmVJbnZva2VEZWxlZ2F0ZShkZWxlZ2F0ZSwgY29udGV4dCkge1xuICAgIHZhciBtZXRob2QgPSBkZWxlZ2F0ZS5pdGVyYXRvcltjb250ZXh0Lm1ldGhvZF07XG4gICAgaWYgKG1ldGhvZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAvLyBBIC50aHJvdyBvciAucmV0dXJuIHdoZW4gdGhlIGRlbGVnYXRlIGl0ZXJhdG9yIGhhcyBubyAudGhyb3dcbiAgICAgIC8vIG1ldGhvZCBhbHdheXMgdGVybWluYXRlcyB0aGUgeWllbGQqIGxvb3AuXG4gICAgICBjb250ZXh0LmRlbGVnYXRlID0gbnVsbDtcblxuICAgICAgaWYgKGNvbnRleHQubWV0aG9kID09PSBcInRocm93XCIpIHtcbiAgICAgICAgLy8gTm90ZTogW1wicmV0dXJuXCJdIG11c3QgYmUgdXNlZCBmb3IgRVMzIHBhcnNpbmcgY29tcGF0aWJpbGl0eS5cbiAgICAgICAgaWYgKGRlbGVnYXRlLml0ZXJhdG9yW1wicmV0dXJuXCJdKSB7XG4gICAgICAgICAgLy8gSWYgdGhlIGRlbGVnYXRlIGl0ZXJhdG9yIGhhcyBhIHJldHVybiBtZXRob2QsIGdpdmUgaXQgYVxuICAgICAgICAgIC8vIGNoYW5jZSB0byBjbGVhbiB1cC5cbiAgICAgICAgICBjb250ZXh0Lm1ldGhvZCA9IFwicmV0dXJuXCI7XG4gICAgICAgICAgY29udGV4dC5hcmcgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgbWF5YmVJbnZva2VEZWxlZ2F0ZShkZWxlZ2F0ZSwgY29udGV4dCk7XG5cbiAgICAgICAgICBpZiAoY29udGV4dC5tZXRob2QgPT09IFwidGhyb3dcIikge1xuICAgICAgICAgICAgLy8gSWYgbWF5YmVJbnZva2VEZWxlZ2F0ZShjb250ZXh0KSBjaGFuZ2VkIGNvbnRleHQubWV0aG9kIGZyb21cbiAgICAgICAgICAgIC8vIFwicmV0dXJuXCIgdG8gXCJ0aHJvd1wiLCBsZXQgdGhhdCBvdmVycmlkZSB0aGUgVHlwZUVycm9yIGJlbG93LlxuICAgICAgICAgICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgY29udGV4dC5tZXRob2QgPSBcInRocm93XCI7XG4gICAgICAgIGNvbnRleHQuYXJnID0gbmV3IFR5cGVFcnJvcihcbiAgICAgICAgICBcIlRoZSBpdGVyYXRvciBkb2VzIG5vdCBwcm92aWRlIGEgJ3Rocm93JyBtZXRob2RcIik7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICAgIH1cblxuICAgIHZhciByZWNvcmQgPSB0cnlDYXRjaChtZXRob2QsIGRlbGVnYXRlLml0ZXJhdG9yLCBjb250ZXh0LmFyZyk7XG5cbiAgICBpZiAocmVjb3JkLnR5cGUgPT09IFwidGhyb3dcIikge1xuICAgICAgY29udGV4dC5tZXRob2QgPSBcInRocm93XCI7XG4gICAgICBjb250ZXh0LmFyZyA9IHJlY29yZC5hcmc7XG4gICAgICBjb250ZXh0LmRlbGVnYXRlID0gbnVsbDtcbiAgICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICAgIH1cblxuICAgIHZhciBpbmZvID0gcmVjb3JkLmFyZztcblxuICAgIGlmICghIGluZm8pIHtcbiAgICAgIGNvbnRleHQubWV0aG9kID0gXCJ0aHJvd1wiO1xuICAgICAgY29udGV4dC5hcmcgPSBuZXcgVHlwZUVycm9yKFwiaXRlcmF0b3IgcmVzdWx0IGlzIG5vdCBhbiBvYmplY3RcIik7XG4gICAgICBjb250ZXh0LmRlbGVnYXRlID0gbnVsbDtcbiAgICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICAgIH1cblxuICAgIGlmIChpbmZvLmRvbmUpIHtcbiAgICAgIC8vIEFzc2lnbiB0aGUgcmVzdWx0IG9mIHRoZSBmaW5pc2hlZCBkZWxlZ2F0ZSB0byB0aGUgdGVtcG9yYXJ5XG4gICAgICAvLyB2YXJpYWJsZSBzcGVjaWZpZWQgYnkgZGVsZWdhdGUucmVzdWx0TmFtZSAoc2VlIGRlbGVnYXRlWWllbGQpLlxuICAgICAgY29udGV4dFtkZWxlZ2F0ZS5yZXN1bHROYW1lXSA9IGluZm8udmFsdWU7XG5cbiAgICAgIC8vIFJlc3VtZSBleGVjdXRpb24gYXQgdGhlIGRlc2lyZWQgbG9jYXRpb24gKHNlZSBkZWxlZ2F0ZVlpZWxkKS5cbiAgICAgIGNvbnRleHQubmV4dCA9IGRlbGVnYXRlLm5leHRMb2M7XG5cbiAgICAgIC8vIElmIGNvbnRleHQubWV0aG9kIHdhcyBcInRocm93XCIgYnV0IHRoZSBkZWxlZ2F0ZSBoYW5kbGVkIHRoZVxuICAgICAgLy8gZXhjZXB0aW9uLCBsZXQgdGhlIG91dGVyIGdlbmVyYXRvciBwcm9jZWVkIG5vcm1hbGx5LiBJZlxuICAgICAgLy8gY29udGV4dC5tZXRob2Qgd2FzIFwibmV4dFwiLCBmb3JnZXQgY29udGV4dC5hcmcgc2luY2UgaXQgaGFzIGJlZW5cbiAgICAgIC8vIFwiY29uc3VtZWRcIiBieSB0aGUgZGVsZWdhdGUgaXRlcmF0b3IuIElmIGNvbnRleHQubWV0aG9kIHdhc1xuICAgICAgLy8gXCJyZXR1cm5cIiwgYWxsb3cgdGhlIG9yaWdpbmFsIC5yZXR1cm4gY2FsbCB0byBjb250aW51ZSBpbiB0aGVcbiAgICAgIC8vIG91dGVyIGdlbmVyYXRvci5cbiAgICAgIGlmIChjb250ZXh0Lm1ldGhvZCAhPT0gXCJyZXR1cm5cIikge1xuICAgICAgICBjb250ZXh0Lm1ldGhvZCA9IFwibmV4dFwiO1xuICAgICAgICBjb250ZXh0LmFyZyA9IHVuZGVmaW5lZDtcbiAgICAgIH1cblxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBSZS15aWVsZCB0aGUgcmVzdWx0IHJldHVybmVkIGJ5IHRoZSBkZWxlZ2F0ZSBtZXRob2QuXG4gICAgICByZXR1cm4gaW5mbztcbiAgICB9XG5cbiAgICAvLyBUaGUgZGVsZWdhdGUgaXRlcmF0b3IgaXMgZmluaXNoZWQsIHNvIGZvcmdldCBpdCBhbmQgY29udGludWUgd2l0aFxuICAgIC8vIHRoZSBvdXRlciBnZW5lcmF0b3IuXG4gICAgY29udGV4dC5kZWxlZ2F0ZSA9IG51bGw7XG4gICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XG4gIH1cblxuICAvLyBEZWZpbmUgR2VuZXJhdG9yLnByb3RvdHlwZS57bmV4dCx0aHJvdyxyZXR1cm59IGluIHRlcm1zIG9mIHRoZVxuICAvLyB1bmlmaWVkIC5faW52b2tlIGhlbHBlciBtZXRob2QuXG4gIGRlZmluZUl0ZXJhdG9yTWV0aG9kcyhHcCk7XG5cbiAgZGVmaW5lKEdwLCB0b1N0cmluZ1RhZ1N5bWJvbCwgXCJHZW5lcmF0b3JcIik7XG5cbiAgLy8gQSBHZW5lcmF0b3Igc2hvdWxkIGFsd2F5cyByZXR1cm4gaXRzZWxmIGFzIHRoZSBpdGVyYXRvciBvYmplY3Qgd2hlbiB0aGVcbiAgLy8gQEBpdGVyYXRvciBmdW5jdGlvbiBpcyBjYWxsZWQgb24gaXQuIFNvbWUgYnJvd3NlcnMnIGltcGxlbWVudGF0aW9ucyBvZiB0aGVcbiAgLy8gaXRlcmF0b3IgcHJvdG90eXBlIGNoYWluIGluY29ycmVjdGx5IGltcGxlbWVudCB0aGlzLCBjYXVzaW5nIHRoZSBHZW5lcmF0b3JcbiAgLy8gb2JqZWN0IHRvIG5vdCBiZSByZXR1cm5lZCBmcm9tIHRoaXMgY2FsbC4gVGhpcyBlbnN1cmVzIHRoYXQgZG9lc24ndCBoYXBwZW4uXG4gIC8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVnZW5lcmF0b3IvaXNzdWVzLzI3NCBmb3IgbW9yZSBkZXRhaWxzLlxuICBHcFtpdGVyYXRvclN5bWJvbF0gPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICBHcC50b1N0cmluZyA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBcIltvYmplY3QgR2VuZXJhdG9yXVwiO1xuICB9O1xuXG4gIGZ1bmN0aW9uIHB1c2hUcnlFbnRyeShsb2NzKSB7XG4gICAgdmFyIGVudHJ5ID0geyB0cnlMb2M6IGxvY3NbMF0gfTtcblxuICAgIGlmICgxIGluIGxvY3MpIHtcbiAgICAgIGVudHJ5LmNhdGNoTG9jID0gbG9jc1sxXTtcbiAgICB9XG5cbiAgICBpZiAoMiBpbiBsb2NzKSB7XG4gICAgICBlbnRyeS5maW5hbGx5TG9jID0gbG9jc1syXTtcbiAgICAgIGVudHJ5LmFmdGVyTG9jID0gbG9jc1szXTtcbiAgICB9XG5cbiAgICB0aGlzLnRyeUVudHJpZXMucHVzaChlbnRyeSk7XG4gIH1cblxuICBmdW5jdGlvbiByZXNldFRyeUVudHJ5KGVudHJ5KSB7XG4gICAgdmFyIHJlY29yZCA9IGVudHJ5LmNvbXBsZXRpb24gfHwge307XG4gICAgcmVjb3JkLnR5cGUgPSBcIm5vcm1hbFwiO1xuICAgIGRlbGV0ZSByZWNvcmQuYXJnO1xuICAgIGVudHJ5LmNvbXBsZXRpb24gPSByZWNvcmQ7XG4gIH1cblxuICBmdW5jdGlvbiBDb250ZXh0KHRyeUxvY3NMaXN0KSB7XG4gICAgLy8gVGhlIHJvb3QgZW50cnkgb2JqZWN0IChlZmZlY3RpdmVseSBhIHRyeSBzdGF0ZW1lbnQgd2l0aG91dCBhIGNhdGNoXG4gICAgLy8gb3IgYSBmaW5hbGx5IGJsb2NrKSBnaXZlcyB1cyBhIHBsYWNlIHRvIHN0b3JlIHZhbHVlcyB0aHJvd24gZnJvbVxuICAgIC8vIGxvY2F0aW9ucyB3aGVyZSB0aGVyZSBpcyBubyBlbmNsb3NpbmcgdHJ5IHN0YXRlbWVudC5cbiAgICB0aGlzLnRyeUVudHJpZXMgPSBbeyB0cnlMb2M6IFwicm9vdFwiIH1dO1xuICAgIHRyeUxvY3NMaXN0LmZvckVhY2gocHVzaFRyeUVudHJ5LCB0aGlzKTtcbiAgICB0aGlzLnJlc2V0KHRydWUpO1xuICB9XG5cbiAgZXhwb3J0cy5rZXlzID0gZnVuY3Rpb24ob2JqZWN0KSB7XG4gICAgdmFyIGtleXMgPSBbXTtcbiAgICBmb3IgKHZhciBrZXkgaW4gb2JqZWN0KSB7XG4gICAgICBrZXlzLnB1c2goa2V5KTtcbiAgICB9XG4gICAga2V5cy5yZXZlcnNlKCk7XG5cbiAgICAvLyBSYXRoZXIgdGhhbiByZXR1cm5pbmcgYW4gb2JqZWN0IHdpdGggYSBuZXh0IG1ldGhvZCwgd2Uga2VlcFxuICAgIC8vIHRoaW5ncyBzaW1wbGUgYW5kIHJldHVybiB0aGUgbmV4dCBmdW5jdGlvbiBpdHNlbGYuXG4gICAgcmV0dXJuIGZ1bmN0aW9uIG5leHQoKSB7XG4gICAgICB3aGlsZSAoa2V5cy5sZW5ndGgpIHtcbiAgICAgICAgdmFyIGtleSA9IGtleXMucG9wKCk7XG4gICAgICAgIGlmIChrZXkgaW4gb2JqZWN0KSB7XG4gICAgICAgICAgbmV4dC52YWx1ZSA9IGtleTtcbiAgICAgICAgICBuZXh0LmRvbmUgPSBmYWxzZTtcbiAgICAgICAgICByZXR1cm4gbmV4dDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBUbyBhdm9pZCBjcmVhdGluZyBhbiBhZGRpdGlvbmFsIG9iamVjdCwgd2UganVzdCBoYW5nIHRoZSAudmFsdWVcbiAgICAgIC8vIGFuZCAuZG9uZSBwcm9wZXJ0aWVzIG9mZiB0aGUgbmV4dCBmdW5jdGlvbiBvYmplY3QgaXRzZWxmLiBUaGlzXG4gICAgICAvLyBhbHNvIGVuc3VyZXMgdGhhdCB0aGUgbWluaWZpZXIgd2lsbCBub3QgYW5vbnltaXplIHRoZSBmdW5jdGlvbi5cbiAgICAgIG5leHQuZG9uZSA9IHRydWU7XG4gICAgICByZXR1cm4gbmV4dDtcbiAgICB9O1xuICB9O1xuXG4gIGZ1bmN0aW9uIHZhbHVlcyhpdGVyYWJsZSkge1xuICAgIGlmIChpdGVyYWJsZSkge1xuICAgICAgdmFyIGl0ZXJhdG9yTWV0aG9kID0gaXRlcmFibGVbaXRlcmF0b3JTeW1ib2xdO1xuICAgICAgaWYgKGl0ZXJhdG9yTWV0aG9kKSB7XG4gICAgICAgIHJldHVybiBpdGVyYXRvck1ldGhvZC5jYWxsKGl0ZXJhYmxlKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHR5cGVvZiBpdGVyYWJsZS5uZXh0ID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgcmV0dXJuIGl0ZXJhYmxlO1xuICAgICAgfVxuXG4gICAgICBpZiAoIWlzTmFOKGl0ZXJhYmxlLmxlbmd0aCkpIHtcbiAgICAgICAgdmFyIGkgPSAtMSwgbmV4dCA9IGZ1bmN0aW9uIG5leHQoKSB7XG4gICAgICAgICAgd2hpbGUgKCsraSA8IGl0ZXJhYmxlLmxlbmd0aCkge1xuICAgICAgICAgICAgaWYgKGhhc093bi5jYWxsKGl0ZXJhYmxlLCBpKSkge1xuICAgICAgICAgICAgICBuZXh0LnZhbHVlID0gaXRlcmFibGVbaV07XG4gICAgICAgICAgICAgIG5leHQuZG9uZSA9IGZhbHNlO1xuICAgICAgICAgICAgICByZXR1cm4gbmV4dDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBuZXh0LnZhbHVlID0gdW5kZWZpbmVkO1xuICAgICAgICAgIG5leHQuZG9uZSA9IHRydWU7XG5cbiAgICAgICAgICByZXR1cm4gbmV4dDtcbiAgICAgICAgfTtcblxuICAgICAgICByZXR1cm4gbmV4dC5uZXh0ID0gbmV4dDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBSZXR1cm4gYW4gaXRlcmF0b3Igd2l0aCBubyB2YWx1ZXMuXG4gICAgcmV0dXJuIHsgbmV4dDogZG9uZVJlc3VsdCB9O1xuICB9XG4gIGV4cG9ydHMudmFsdWVzID0gdmFsdWVzO1xuXG4gIGZ1bmN0aW9uIGRvbmVSZXN1bHQoKSB7XG4gICAgcmV0dXJuIHsgdmFsdWU6IHVuZGVmaW5lZCwgZG9uZTogdHJ1ZSB9O1xuICB9XG5cbiAgQ29udGV4dC5wcm90b3R5cGUgPSB7XG4gICAgY29uc3RydWN0b3I6IENvbnRleHQsXG5cbiAgICByZXNldDogZnVuY3Rpb24oc2tpcFRlbXBSZXNldCkge1xuICAgICAgdGhpcy5wcmV2ID0gMDtcbiAgICAgIHRoaXMubmV4dCA9IDA7XG4gICAgICAvLyBSZXNldHRpbmcgY29udGV4dC5fc2VudCBmb3IgbGVnYWN5IHN1cHBvcnQgb2YgQmFiZWwnc1xuICAgICAgLy8gZnVuY3Rpb24uc2VudCBpbXBsZW1lbnRhdGlvbi5cbiAgICAgIHRoaXMuc2VudCA9IHRoaXMuX3NlbnQgPSB1bmRlZmluZWQ7XG4gICAgICB0aGlzLmRvbmUgPSBmYWxzZTtcbiAgICAgIHRoaXMuZGVsZWdhdGUgPSBudWxsO1xuXG4gICAgICB0aGlzLm1ldGhvZCA9IFwibmV4dFwiO1xuICAgICAgdGhpcy5hcmcgPSB1bmRlZmluZWQ7XG5cbiAgICAgIHRoaXMudHJ5RW50cmllcy5mb3JFYWNoKHJlc2V0VHJ5RW50cnkpO1xuXG4gICAgICBpZiAoIXNraXBUZW1wUmVzZXQpIHtcbiAgICAgICAgZm9yICh2YXIgbmFtZSBpbiB0aGlzKSB7XG4gICAgICAgICAgLy8gTm90IHN1cmUgYWJvdXQgdGhlIG9wdGltYWwgb3JkZXIgb2YgdGhlc2UgY29uZGl0aW9uczpcbiAgICAgICAgICBpZiAobmFtZS5jaGFyQXQoMCkgPT09IFwidFwiICYmXG4gICAgICAgICAgICAgIGhhc093bi5jYWxsKHRoaXMsIG5hbWUpICYmXG4gICAgICAgICAgICAgICFpc05hTigrbmFtZS5zbGljZSgxKSkpIHtcbiAgICAgICAgICAgIHRoaXNbbmFtZV0gPSB1bmRlZmluZWQ7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcblxuICAgIHN0b3A6IGZ1bmN0aW9uKCkge1xuICAgICAgdGhpcy5kb25lID0gdHJ1ZTtcblxuICAgICAgdmFyIHJvb3RFbnRyeSA9IHRoaXMudHJ5RW50cmllc1swXTtcbiAgICAgIHZhciByb290UmVjb3JkID0gcm9vdEVudHJ5LmNvbXBsZXRpb247XG4gICAgICBpZiAocm9vdFJlY29yZC50eXBlID09PSBcInRocm93XCIpIHtcbiAgICAgICAgdGhyb3cgcm9vdFJlY29yZC5hcmc7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzLnJ2YWw7XG4gICAgfSxcblxuICAgIGRpc3BhdGNoRXhjZXB0aW9uOiBmdW5jdGlvbihleGNlcHRpb24pIHtcbiAgICAgIGlmICh0aGlzLmRvbmUpIHtcbiAgICAgICAgdGhyb3cgZXhjZXB0aW9uO1xuICAgICAgfVxuXG4gICAgICB2YXIgY29udGV4dCA9IHRoaXM7XG4gICAgICBmdW5jdGlvbiBoYW5kbGUobG9jLCBjYXVnaHQpIHtcbiAgICAgICAgcmVjb3JkLnR5cGUgPSBcInRocm93XCI7XG4gICAgICAgIHJlY29yZC5hcmcgPSBleGNlcHRpb247XG4gICAgICAgIGNvbnRleHQubmV4dCA9IGxvYztcblxuICAgICAgICBpZiAoY2F1Z2h0KSB7XG4gICAgICAgICAgLy8gSWYgdGhlIGRpc3BhdGNoZWQgZXhjZXB0aW9uIHdhcyBjYXVnaHQgYnkgYSBjYXRjaCBibG9jayxcbiAgICAgICAgICAvLyB0aGVuIGxldCB0aGF0IGNhdGNoIGJsb2NrIGhhbmRsZSB0aGUgZXhjZXB0aW9uIG5vcm1hbGx5LlxuICAgICAgICAgIGNvbnRleHQubWV0aG9kID0gXCJuZXh0XCI7XG4gICAgICAgICAgY29udGV4dC5hcmcgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gISEgY2F1Z2h0O1xuICAgICAgfVxuXG4gICAgICBmb3IgKHZhciBpID0gdGhpcy50cnlFbnRyaWVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICAgIHZhciBlbnRyeSA9IHRoaXMudHJ5RW50cmllc1tpXTtcbiAgICAgICAgdmFyIHJlY29yZCA9IGVudHJ5LmNvbXBsZXRpb247XG5cbiAgICAgICAgaWYgKGVudHJ5LnRyeUxvYyA9PT0gXCJyb290XCIpIHtcbiAgICAgICAgICAvLyBFeGNlcHRpb24gdGhyb3duIG91dHNpZGUgb2YgYW55IHRyeSBibG9jayB0aGF0IGNvdWxkIGhhbmRsZVxuICAgICAgICAgIC8vIGl0LCBzbyBzZXQgdGhlIGNvbXBsZXRpb24gdmFsdWUgb2YgdGhlIGVudGlyZSBmdW5jdGlvbiB0b1xuICAgICAgICAgIC8vIHRocm93IHRoZSBleGNlcHRpb24uXG4gICAgICAgICAgcmV0dXJuIGhhbmRsZShcImVuZFwiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChlbnRyeS50cnlMb2MgPD0gdGhpcy5wcmV2KSB7XG4gICAgICAgICAgdmFyIGhhc0NhdGNoID0gaGFzT3duLmNhbGwoZW50cnksIFwiY2F0Y2hMb2NcIik7XG4gICAgICAgICAgdmFyIGhhc0ZpbmFsbHkgPSBoYXNPd24uY2FsbChlbnRyeSwgXCJmaW5hbGx5TG9jXCIpO1xuXG4gICAgICAgICAgaWYgKGhhc0NhdGNoICYmIGhhc0ZpbmFsbHkpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnByZXYgPCBlbnRyeS5jYXRjaExvYykge1xuICAgICAgICAgICAgICByZXR1cm4gaGFuZGxlKGVudHJ5LmNhdGNoTG9jLCB0cnVlKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodGhpcy5wcmV2IDwgZW50cnkuZmluYWxseUxvYykge1xuICAgICAgICAgICAgICByZXR1cm4gaGFuZGxlKGVudHJ5LmZpbmFsbHlMb2MpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgfSBlbHNlIGlmIChoYXNDYXRjaCkge1xuICAgICAgICAgICAgaWYgKHRoaXMucHJldiA8IGVudHJ5LmNhdGNoTG9jKSB7XG4gICAgICAgICAgICAgIHJldHVybiBoYW5kbGUoZW50cnkuY2F0Y2hMb2MsIHRydWUpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgfSBlbHNlIGlmIChoYXNGaW5hbGx5KSB7XG4gICAgICAgICAgICBpZiAodGhpcy5wcmV2IDwgZW50cnkuZmluYWxseUxvYykge1xuICAgICAgICAgICAgICByZXR1cm4gaGFuZGxlKGVudHJ5LmZpbmFsbHlMb2MpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcInRyeSBzdGF0ZW1lbnQgd2l0aG91dCBjYXRjaCBvciBmaW5hbGx5XCIpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG5cbiAgICBhYnJ1cHQ6IGZ1bmN0aW9uKHR5cGUsIGFyZykge1xuICAgICAgZm9yICh2YXIgaSA9IHRoaXMudHJ5RW50cmllcy5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgICB2YXIgZW50cnkgPSB0aGlzLnRyeUVudHJpZXNbaV07XG4gICAgICAgIGlmIChlbnRyeS50cnlMb2MgPD0gdGhpcy5wcmV2ICYmXG4gICAgICAgICAgICBoYXNPd24uY2FsbChlbnRyeSwgXCJmaW5hbGx5TG9jXCIpICYmXG4gICAgICAgICAgICB0aGlzLnByZXYgPCBlbnRyeS5maW5hbGx5TG9jKSB7XG4gICAgICAgICAgdmFyIGZpbmFsbHlFbnRyeSA9IGVudHJ5O1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChmaW5hbGx5RW50cnkgJiZcbiAgICAgICAgICAodHlwZSA9PT0gXCJicmVha1wiIHx8XG4gICAgICAgICAgIHR5cGUgPT09IFwiY29udGludWVcIikgJiZcbiAgICAgICAgICBmaW5hbGx5RW50cnkudHJ5TG9jIDw9IGFyZyAmJlxuICAgICAgICAgIGFyZyA8PSBmaW5hbGx5RW50cnkuZmluYWxseUxvYykge1xuICAgICAgICAvLyBJZ25vcmUgdGhlIGZpbmFsbHkgZW50cnkgaWYgY29udHJvbCBpcyBub3QganVtcGluZyB0byBhXG4gICAgICAgIC8vIGxvY2F0aW9uIG91dHNpZGUgdGhlIHRyeS9jYXRjaCBibG9jay5cbiAgICAgICAgZmluYWxseUVudHJ5ID0gbnVsbDtcbiAgICAgIH1cblxuICAgICAgdmFyIHJlY29yZCA9IGZpbmFsbHlFbnRyeSA/IGZpbmFsbHlFbnRyeS5jb21wbGV0aW9uIDoge307XG4gICAgICByZWNvcmQudHlwZSA9IHR5cGU7XG4gICAgICByZWNvcmQuYXJnID0gYXJnO1xuXG4gICAgICBpZiAoZmluYWxseUVudHJ5KSB7XG4gICAgICAgIHRoaXMubWV0aG9kID0gXCJuZXh0XCI7XG4gICAgICAgIHRoaXMubmV4dCA9IGZpbmFsbHlFbnRyeS5maW5hbGx5TG9jO1xuICAgICAgICByZXR1cm4gQ29udGludWVTZW50aW5lbDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXMuY29tcGxldGUocmVjb3JkKTtcbiAgICB9LFxuXG4gICAgY29tcGxldGU6IGZ1bmN0aW9uKHJlY29yZCwgYWZ0ZXJMb2MpIHtcbiAgICAgIGlmIChyZWNvcmQudHlwZSA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgIHRocm93IHJlY29yZC5hcmc7XG4gICAgICB9XG5cbiAgICAgIGlmIChyZWNvcmQudHlwZSA9PT0gXCJicmVha1wiIHx8XG4gICAgICAgICAgcmVjb3JkLnR5cGUgPT09IFwiY29udGludWVcIikge1xuICAgICAgICB0aGlzLm5leHQgPSByZWNvcmQuYXJnO1xuICAgICAgfSBlbHNlIGlmIChyZWNvcmQudHlwZSA9PT0gXCJyZXR1cm5cIikge1xuICAgICAgICB0aGlzLnJ2YWwgPSB0aGlzLmFyZyA9IHJlY29yZC5hcmc7XG4gICAgICAgIHRoaXMubWV0aG9kID0gXCJyZXR1cm5cIjtcbiAgICAgICAgdGhpcy5uZXh0ID0gXCJlbmRcIjtcbiAgICAgIH0gZWxzZSBpZiAocmVjb3JkLnR5cGUgPT09IFwibm9ybWFsXCIgJiYgYWZ0ZXJMb2MpIHtcbiAgICAgICAgdGhpcy5uZXh0ID0gYWZ0ZXJMb2M7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICAgIH0sXG5cbiAgICBmaW5pc2g6IGZ1bmN0aW9uKGZpbmFsbHlMb2MpIHtcbiAgICAgIGZvciAodmFyIGkgPSB0aGlzLnRyeUVudHJpZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgICAgdmFyIGVudHJ5ID0gdGhpcy50cnlFbnRyaWVzW2ldO1xuICAgICAgICBpZiAoZW50cnkuZmluYWxseUxvYyA9PT0gZmluYWxseUxvYykge1xuICAgICAgICAgIHRoaXMuY29tcGxldGUoZW50cnkuY29tcGxldGlvbiwgZW50cnkuYWZ0ZXJMb2MpO1xuICAgICAgICAgIHJlc2V0VHJ5RW50cnkoZW50cnkpO1xuICAgICAgICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcblxuICAgIFwiY2F0Y2hcIjogZnVuY3Rpb24odHJ5TG9jKSB7XG4gICAgICBmb3IgKHZhciBpID0gdGhpcy50cnlFbnRyaWVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICAgIHZhciBlbnRyeSA9IHRoaXMudHJ5RW50cmllc1tpXTtcbiAgICAgICAgaWYgKGVudHJ5LnRyeUxvYyA9PT0gdHJ5TG9jKSB7XG4gICAgICAgICAgdmFyIHJlY29yZCA9IGVudHJ5LmNvbXBsZXRpb247XG4gICAgICAgICAgaWYgKHJlY29yZC50eXBlID09PSBcInRocm93XCIpIHtcbiAgICAgICAgICAgIHZhciB0aHJvd24gPSByZWNvcmQuYXJnO1xuICAgICAgICAgICAgcmVzZXRUcnlFbnRyeShlbnRyeSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiB0aHJvd247XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gVGhlIGNvbnRleHQuY2F0Y2ggbWV0aG9kIG11c3Qgb25seSBiZSBjYWxsZWQgd2l0aCBhIGxvY2F0aW9uXG4gICAgICAvLyBhcmd1bWVudCB0aGF0IGNvcnJlc3BvbmRzIHRvIGEga25vd24gY2F0Y2ggYmxvY2suXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbGxlZ2FsIGNhdGNoIGF0dGVtcHRcIik7XG4gICAgfSxcblxuICAgIGRlbGVnYXRlWWllbGQ6IGZ1bmN0aW9uKGl0ZXJhYmxlLCByZXN1bHROYW1lLCBuZXh0TG9jKSB7XG4gICAgICB0aGlzLmRlbGVnYXRlID0ge1xuICAgICAgICBpdGVyYXRvcjogdmFsdWVzKGl0ZXJhYmxlKSxcbiAgICAgICAgcmVzdWx0TmFtZTogcmVzdWx0TmFtZSxcbiAgICAgICAgbmV4dExvYzogbmV4dExvY1xuICAgICAgfTtcblxuICAgICAgaWYgKHRoaXMubWV0aG9kID09PSBcIm5leHRcIikge1xuICAgICAgICAvLyBEZWxpYmVyYXRlbHkgZm9yZ2V0IHRoZSBsYXN0IHNlbnQgdmFsdWUgc28gdGhhdCB3ZSBkb24ndFxuICAgICAgICAvLyBhY2NpZGVudGFsbHkgcGFzcyBpdCBvbiB0byB0aGUgZGVsZWdhdGUuXG4gICAgICAgIHRoaXMuYXJnID0gdW5kZWZpbmVkO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gQ29udGludWVTZW50aW5lbDtcbiAgICB9XG4gIH07XG5cbiAgLy8gUmVnYXJkbGVzcyBvZiB3aGV0aGVyIHRoaXMgc2NyaXB0IGlzIGV4ZWN1dGluZyBhcyBhIENvbW1vbkpTIG1vZHVsZVxuICAvLyBvciBub3QsIHJldHVybiB0aGUgcnVudGltZSBvYmplY3Qgc28gdGhhdCB3ZSBjYW4gZGVjbGFyZSB0aGUgdmFyaWFibGVcbiAgLy8gcmVnZW5lcmF0b3JSdW50aW1lIGluIHRoZSBvdXRlciBzY29wZSwgd2hpY2ggYWxsb3dzIHRoaXMgbW9kdWxlIHRvIGJlXG4gIC8vIGluamVjdGVkIGVhc2lseSBieSBgYmluL3JlZ2VuZXJhdG9yIC0taW5jbHVkZS1ydW50aW1lIHNjcmlwdC5qc2AuXG4gIHJldHVybiBleHBvcnRzO1xuXG59KFxuICAvLyBJZiB0aGlzIHNjcmlwdCBpcyBleGVjdXRpbmcgYXMgYSBDb21tb25KUyBtb2R1bGUsIHVzZSBtb2R1bGUuZXhwb3J0c1xuICAvLyBhcyB0aGUgcmVnZW5lcmF0b3JSdW50aW1lIG5hbWVzcGFjZS4gT3RoZXJ3aXNlIGNyZWF0ZSBhIG5ldyBlbXB0eVxuICAvLyBvYmplY3QuIEVpdGhlciB3YXksIHRoZSByZXN1bHRpbmcgb2JqZWN0IHdpbGwgYmUgdXNlZCB0byBpbml0aWFsaXplXG4gIC8vIHRoZSByZWdlbmVyYXRvclJ1bnRpbWUgdmFyaWFibGUgYXQgdGhlIHRvcCBvZiB0aGlzIGZpbGUuXG4gIHR5cGVvZiBtb2R1bGUgPT09IFwib2JqZWN0XCIgPyBtb2R1bGUuZXhwb3J0cyA6IHt9XG4pKTtcblxudHJ5IHtcbiAgcmVnZW5lcmF0b3JSdW50aW1lID0gcnVudGltZTtcbn0gY2F0Y2ggKGFjY2lkZW50YWxTdHJpY3RNb2RlKSB7XG4gIC8vIFRoaXMgbW9kdWxlIHNob3VsZCBub3QgYmUgcnVubmluZyBpbiBzdHJpY3QgbW9kZSwgc28gdGhlIGFib3ZlXG4gIC8vIGFzc2lnbm1lbnQgc2hvdWxkIGFsd2F5cyB3b3JrIHVubGVzcyBzb21ldGhpbmcgaXMgbWlzY29uZmlndXJlZC4gSnVzdFxuICAvLyBpbiBjYXNlIHJ1bnRpbWUuanMgYWNjaWRlbnRhbGx5IHJ1bnMgaW4gc3RyaWN0IG1vZGUsIHdlIGNhbiBlc2NhcGVcbiAgLy8gc3RyaWN0IG1vZGUgdXNpbmcgYSBnbG9iYWwgRnVuY3Rpb24gY2FsbC4gVGhpcyBjb3VsZCBjb25jZWl2YWJseSBmYWlsXG4gIC8vIGlmIGEgQ29udGVudCBTZWN1cml0eSBQb2xpY3kgZm9yYmlkcyB1c2luZyBGdW5jdGlvbiwgYnV0IGluIHRoYXQgY2FzZVxuICAvLyB0aGUgcHJvcGVyIHNvbHV0aW9uIGlzIHRvIGZpeCB0aGUgYWNjaWRlbnRhbCBzdHJpY3QgbW9kZSBwcm9ibGVtLiBJZlxuICAvLyB5b3UndmUgbWlzY29uZmlndXJlZCB5b3VyIGJ1bmRsZXIgdG8gZm9yY2Ugc3RyaWN0IG1vZGUgYW5kIGFwcGxpZWQgYVxuICAvLyBDU1AgdG8gZm9yYmlkIEZ1bmN0aW9uLCBhbmQgeW91J3JlIG5vdCB3aWxsaW5nIHRvIGZpeCBlaXRoZXIgb2YgdGhvc2VcbiAgLy8gcHJvYmxlbXMsIHBsZWFzZSBkZXRhaWwgeW91ciB1bmlxdWUgcHJlZGljYW1lbnQgaW4gYSBHaXRIdWIgaXNzdWUuXG4gIEZ1bmN0aW9uKFwiclwiLCBcInJlZ2VuZXJhdG9yUnVudGltZSA9IHJcIikocnVudGltZSk7XG59XG4iLCJpbXBvcnR7Y3JlYXRlQ29udGV4dCBhcyByfWZyb21cInByZWFjdFwiO2ltcG9ydHt1c2VDb250ZXh0IGFzIG4sdXNlTWVtbyBhcyB0LHVzZVJlZHVjZXIgYXMgaSx1c2VFZmZlY3QgYXMgbyx1c2VDYWxsYmFjayBhcyBlfWZyb21cInByZWFjdC9ob29rc1wiO2Z1bmN0aW9uIGYocixuLHQsaSxvKXtmb3Iobj1uLnNwbGl0P24uc3BsaXQoXCIuXCIpOm4saT0wO2k8bi5sZW5ndGg7aSsrKXI9cj9yW25baV1dOm87cmV0dXJuIHI9PT1vP3Q6cn12YXIgdT1yKCksYT11LlByb3ZpZGVyO2Z1bmN0aW9uIGMocixuKXt2YXIgdD0hMTtmb3IodmFyIGkgaW4gbilyW2ldIT09bltpXSYmKCExPT09dCYmKHQ9ITAscj1PYmplY3QuYXNzaWduKHt9LHIpKSxyW2ldPW5baV0pO3JldHVybiByfWZ1bmN0aW9uIHAoKXtyZXR1cm4gbih1KX1mdW5jdGlvbiBzKHIpe3ZhciBlPW4odSksYT10KGZ1bmN0aW9uKCl7cmV0dXJuXCJmdW5jdGlvblwiPT0odD10eXBlb2Yobj1yKSk/bjooXCJzdHJpbmdcIj09dCYmKG49bi5zcGxpdCgvXFxzKixcXHMqLykpLEFycmF5LmlzQXJyYXkobikmJihuPW4ucmVkdWNlKGZ1bmN0aW9uKHIsbil7cmV0dXJuIHJbbl09bixyfSx7fSkpLGZ1bmN0aW9uKHIpe3ZhciB0PXt9O2lmKHIpZm9yKHZhciBpIGluIG4pdFtpXT1pIGluIHI/cltpXTpmKHIsbltpXSk7cmV0dXJuIHR9KTt2YXIgbix0fSxbXSkscD1pKGMsZT9hKGUuZ2V0U3RhdGUoKSk6e30pLHM9cFswXSx2PXBbMV07cmV0dXJuIG8oZnVuY3Rpb24oKXtyZXR1cm4gZS5zdWJzY3JpYmUoZnVuY3Rpb24ocil7cmV0dXJuIHYoYShyKSl9KX0sW2VdKSxzfWZ1bmN0aW9uIHYocixpLG8pe2lmKFwiZnVuY3Rpb25cIj09dHlwZW9mIG8pe3ZhciBmPVtpLG9dO289ZlswXSxpPWZbMV19dmFyIGE9bih1KSxjPXQoZnVuY3Rpb24oKXtyZXR1cm4gZnVuY3Rpb24ocixuKXt2YXIgdD1uLmJpbmRpbmdzfHwobi5iaW5kaW5ncz1uZXcoXCJmdW5jdGlvblwiPT10eXBlb2YgV2Vha01hcD9XZWFrTWFwOk1hcCkpLGk9dC5nZXQocik7aWYoIWkpZm9yKHZhciBvIGluIHQuc2V0KHIsaT17fSksXCJmdW5jdGlvblwiPT10eXBlb2YgciYmKHI9cihuKSkscilpW29dPW4uYWN0aW9uKHJbb10pO3JldHVybiBpfShyLGEpfSxbcixhXSk7cmV0dXJuIGk9ZShpLG98fFtdKSx0KGZ1bmN0aW9uKCl7dmFyIHI9aSxuPXt9O2lmKCFyKXJldHVybiBjO2Zvcih2YXIgdCBpblwiZnVuY3Rpb25cIj09dHlwZW9mIHImJihyPXIoYykpLHIpe3ZhciBvPXJbdF07QXJyYXkuaXNBcnJheShvKSYmKG89b1swXS5iaW5kLmFwcGx5KG9bMF0sbykpLG5bdF09b31yZXR1cm4gbn0sW2MsaV0pfWV4cG9ydHthIGFzIFByb3ZpZGVyLHYgYXMgdXNlQWN0aW9ucyxwIGFzIHVzZVN0b3JlLHMgYXMgdXNlU3RvcmVTdGF0ZX07XG4iLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHVuaXN0b3JlRGV2VG9vbHMoc3RvcmUpIHtcblx0dmFyIGV4dGVuc2lvbiA9IHdpbmRvdy5fX1JFRFVYX0RFVlRPT0xTX0VYVEVOU0lPTl9fIHx8IHdpbmRvdy50b3AuX19SRURVWF9ERVZUT09MU19FWFRFTlNJT05fXztcblx0dmFyIGlnbm9yZVN0YXRlID0gZmFsc2U7XG5cblx0aWYgKCFleHRlbnNpb24pIHtcblx0XHRjb25zb2xlLndhcm4oJ1BsZWFzZSBpbnN0YWxsL2VuYWJsZSBSZWR1eCBkZXZ0b29scyBleHRlbnNpb24nKTtcblx0XHRzdG9yZS5kZXZ0b29scyA9IG51bGw7XG5cblx0XHRyZXR1cm4gc3RvcmU7XG5cdH1cblxuXHRpZiAoIXN0b3JlLmRldnRvb2xzKSB7XG5cdFx0c3RvcmUuZGV2dG9vbHMgPSBleHRlbnNpb24uY29ubmVjdCgpO1xuXHRcdHN0b3JlLmRldnRvb2xzLnN1YnNjcmliZShmdW5jdGlvbiAobWVzc2FnZSkge1xuXHRcdFx0aWYgKG1lc3NhZ2UudHlwZSA9PT0gJ0RJU1BBVENIJyAmJiBtZXNzYWdlLnN0YXRlKSB7XG5cdFx0XHRcdGlnbm9yZVN0YXRlID0gKG1lc3NhZ2UucGF5bG9hZC50eXBlID09PSAnSlVNUF9UT19BQ1RJT04nIHx8IG1lc3NhZ2UucGF5bG9hZC50eXBlID09PSAnSlVNUF9UT19TVEFURScpO1xuXHRcdFx0XHRzdG9yZS5zZXRTdGF0ZShKU09OLnBhcnNlKG1lc3NhZ2Uuc3RhdGUpLCB0cnVlKTtcblx0XHRcdH1cblx0XHR9KTtcblx0XHRzdG9yZS5kZXZ0b29scy5pbml0KHN0b3JlLmdldFN0YXRlKCkpO1xuXHRcdHN0b3JlLnN1YnNjcmliZShmdW5jdGlvbiAoc3RhdGUsIGFjdGlvbikge1xuXHRcdFx0dmFyIGFjdGlvbk5hbWUgPSBhY3Rpb24gJiYgYWN0aW9uLm5hbWUgfHwgJ3NldFN0YXRlJztcblxuXHRcdFx0aWYgKCFpZ25vcmVTdGF0ZSkge1xuXHRcdFx0XHRzdG9yZS5kZXZ0b29scy5zZW5kKGFjdGlvbk5hbWUsIHN0YXRlKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGlnbm9yZVN0YXRlID0gZmFsc2U7XG5cdFx0XHR9XG5cdFx0fSk7XG5cdH1cblxuXHRyZXR1cm4gc3RvcmU7XG59XG4iLCJmdW5jdGlvbiBuKG4sdCl7Zm9yKHZhciByIGluIHQpbltyXT10W3JdO3JldHVybiBufWV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKHQpe3ZhciByPVtdO2Z1bmN0aW9uIHUobil7Zm9yKHZhciB0PVtdLHU9MDt1PHIubGVuZ3RoO3UrKylyW3VdPT09bj9uPW51bGw6dC5wdXNoKHJbdV0pO3I9dH1mdW5jdGlvbiBlKHUsZSxmKXt0PWU/dTpuKG4oe30sdCksdSk7Zm9yKHZhciBpPXIsbz0wO288aS5sZW5ndGg7bysrKWlbb10odCxmKX1yZXR1cm4gdD10fHx7fSx7YWN0aW9uOmZ1bmN0aW9uKG4pe2Z1bmN0aW9uIHIodCl7ZSh0LCExLG4pfXJldHVybiBmdW5jdGlvbigpe2Zvcih2YXIgdT1hcmd1bWVudHMsZT1bdF0sZj0wO2Y8YXJndW1lbnRzLmxlbmd0aDtmKyspZS5wdXNoKHVbZl0pO3ZhciBpPW4uYXBwbHkodGhpcyxlKTtpZihudWxsIT1pKXJldHVybiBpLnRoZW4/aS50aGVuKHIpOnIoaSl9fSxzZXRTdGF0ZTplLHN1YnNjcmliZTpmdW5jdGlvbihuKXtyZXR1cm4gci5wdXNoKG4pLGZ1bmN0aW9uKCl7dShuKX19LHVuc3Vic2NyaWJlOnUsZ2V0U3RhdGU6ZnVuY3Rpb24oKXtyZXR1cm4gdH19fVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dW5pc3RvcmUuZXMuanMubWFwXG4iLCJ2YXIgYXBpID0gcmVxdWlyZShcIiEuLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2J1aWxkL3dlYnBhY2svbG9hZGVycy9uZXh0LXN0eWxlLWxvYWRlci9ydW50aW1lL2luamVjdFN0eWxlc0ludG9TdHlsZVRhZy5qc1wiKTtcbiAgICAgICAgICAgIHZhciBjb250ZW50ID0gcmVxdWlyZShcIiEhLi4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jb21waWxlZC9jc3MtbG9hZGVyL2Nqcy5qcz8/cmVmLS01LW9uZU9mLTYtMSEuLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NvbXBpbGVkL3Bvc3Rjc3MtbG9hZGVyL2Nqcy5qcz8/cmVmLS01LW9uZU9mLTYtMiEuL19hcHAuY3NzXCIpO1xuXG4gICAgICAgICAgICBjb250ZW50ID0gY29udGVudC5fX2VzTW9kdWxlID8gY29udGVudC5kZWZhdWx0IDogY29udGVudDtcblxuICAgICAgICAgICAgaWYgKHR5cGVvZiBjb250ZW50ID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICBjb250ZW50ID0gW1ttb2R1bGUuaWQsIGNvbnRlbnQsICcnXV07XG4gICAgICAgICAgICB9XG5cbnZhciBvcHRpb25zID0ge307XG5cbm9wdGlvbnMuaW5zZXJ0ID0gZnVuY3Rpb24oZWxlbWVudCl7Ly8gVGhlc2UgZWxlbWVudHMgc2hvdWxkIGFsd2F5cyBleGlzdC4gSWYgdGhleSBkbyBub3QsXG4vLyB0aGlzIGNvZGUgc2hvdWxkIGZhaWwuXG52YXIgYW5jaG9yRWxlbWVudD1kb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcjX19uZXh0X2Nzc19fRE9fTk9UX1VTRV9fJyk7dmFyIHBhcmVudE5vZGU9YW5jaG9yRWxlbWVudC5wYXJlbnROb2RlOy8vIE5vcm1hbGx5IDxoZWFkPlxuLy8gRWFjaCBzdHlsZSB0YWcgc2hvdWxkIGJlIHBsYWNlZCByaWdodCBiZWZvcmUgb3VyXG4vLyBhbmNob3IuIEJ5IGluc2VydGluZyBiZWZvcmUgYW5kIG5vdCBhZnRlciwgd2UgZG8gbm90XG4vLyBuZWVkIHRvIHRyYWNrIHRoZSBsYXN0IGluc2VydGVkIGVsZW1lbnQuXG5wYXJlbnROb2RlLmluc2VydEJlZm9yZShlbGVtZW50LGFuY2hvckVsZW1lbnQpO307XG5vcHRpb25zLnNpbmdsZXRvbiA9IGZhbHNlO1xuXG52YXIgdXBkYXRlID0gYXBpKGNvbnRlbnQsIG9wdGlvbnMpO1xuXG5cbmlmIChtb2R1bGUuaG90KSB7XG4gIGlmICghY29udGVudC5sb2NhbHMgfHwgbW9kdWxlLmhvdC5pbnZhbGlkYXRlKSB7XG4gICAgdmFyIGlzRXF1YWxMb2NhbHMgPSBmdW5jdGlvbiBpc0VxdWFsTG9jYWxzKGEsYixpc05hbWVkRXhwb3J0KXtpZighYSYmYnx8YSYmIWIpe3JldHVybiBmYWxzZTt9bGV0IHA7Zm9yKHAgaW4gYSl7aWYoaXNOYW1lZEV4cG9ydCYmcD09PSdkZWZhdWx0Jyl7Ly8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnRpbnVlXG5jb250aW51ZTt9aWYoYVtwXSE9PWJbcF0pe3JldHVybiBmYWxzZTt9fWZvcihwIGluIGIpe2lmKGlzTmFtZWRFeHBvcnQmJnA9PT0nZGVmYXVsdCcpey8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb250aW51ZVxuY29udGludWU7fWlmKCFhW3BdKXtyZXR1cm4gZmFsc2U7fX1yZXR1cm4gdHJ1ZTt9O1xuICAgIHZhciBvbGRMb2NhbHMgPSBjb250ZW50LmxvY2FscztcblxuICAgIG1vZHVsZS5ob3QuYWNjZXB0KFxuICAgICAgXCIhIS4uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvY3NzLWxvYWRlci9janMuanM/P3JlZi0tNS1vbmVPZi02LTEhLi4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jb21waWxlZC9wb3N0Y3NzLWxvYWRlci9janMuanM/P3JlZi0tNS1vbmVPZi02LTIhLi9fYXBwLmNzc1wiLFxuICAgICAgZnVuY3Rpb24gKCkge1xuICAgICAgICBjb250ZW50ID0gcmVxdWlyZShcIiEhLi4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jb21waWxlZC9jc3MtbG9hZGVyL2Nqcy5qcz8/cmVmLS01LW9uZU9mLTYtMSEuLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NvbXBpbGVkL3Bvc3Rjc3MtbG9hZGVyL2Nqcy5qcz8/cmVmLS01LW9uZU9mLTYtMiEuL19hcHAuY3NzXCIpO1xuXG4gICAgICAgICAgICAgIGNvbnRlbnQgPSBjb250ZW50Ll9fZXNNb2R1bGUgPyBjb250ZW50LmRlZmF1bHQgOiBjb250ZW50O1xuXG4gICAgICAgICAgICAgIGlmICh0eXBlb2YgY29udGVudCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICBjb250ZW50ID0gW1ttb2R1bGUuaWQsIGNvbnRlbnQsICcnXV07XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBpZiAoIWlzRXF1YWxMb2NhbHMob2xkTG9jYWxzLCBjb250ZW50LmxvY2FscykpIHtcbiAgICAgICAgICAgICAgICBtb2R1bGUuaG90LmludmFsaWRhdGUoKTtcblxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIG9sZExvY2FscyA9IGNvbnRlbnQubG9jYWxzO1xuXG4gICAgICAgICAgICAgIHVwZGF0ZShjb250ZW50KTtcbiAgICAgIH1cbiAgICApXG4gIH1cblxuICBtb2R1bGUuaG90LmRpc3Bvc2UoZnVuY3Rpb24oKSB7XG4gICAgdXBkYXRlKCk7XG4gIH0pO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNvbnRlbnQubG9jYWxzIHx8IHt9OyIsImltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyBQcm92aWRlciwgdXNlQWN0aW9ucywgdXNlU3RvcmVTdGF0ZSB9IGZyb20gJ3VuaXN0b3JlLWhvb2tzJztcbmltcG9ydCB7IFNub3cgfSBmcm9tICdAdGhlbWUnO1xuaW1wb3J0IEFib3V0IGZyb20gJ0Bjb21wcy9BYm91dC9BYm91dCc7XG5pbXBvcnQgQ2FsZW5kYXIgZnJvbSAnQGNvbXBzL0NhbGVuZGFyL0NhbGVuZGFyJztcbmltcG9ydCBDb250ZW50IGZyb20gJ0Bjb21wcy9Db250ZW50L0NvbnRlbnQnO1xuaW1wb3J0IHVzZVdpbmRvd1NpemUgZnJvbSAnQGNvbXBzL2hvb2tzL3VzZVdpbmRvd1NpemUnO1xuaW1wb3J0IHsgYWN0aW9ucywgc3RvcmUgfSBmcm9tICdAc3RvcmUvaW5kZXgnO1xuaW1wb3J0IHsgU3RhdGUgfSBmcm9tICdAc3RvcmUvdHlwZXMnO1xuaW1wb3J0ICcuL19hcHAuY3NzJztcblxubGV0IHN0YXJ0WCA9IDA7XG5sZXQgY3VycmVudFggPSAwO1xuY29uc3QgdG91Y2hMZW5ndGggPSAxMDA7XG5jb25zdCBNT0JJTEVfQlAgPSA5MDA7XG5cbmV4cG9ydCBkZWZhdWx0ICh7IENvbXBvbmVudCwgcGFnZVByb3BzIH0pID0+IHtcbiAgY29uc3QgeyBzZXRPZmZsaW5lLCBzZXRNZW51T3BlbiB9ID0gdXNlQWN0aW9ucyhhY3Rpb25zKTtcbiAgY29uc3QgeyBtZW51T3BlbiB9ID0gdXNlU3RvcmVTdGF0ZTxTdGF0ZT4oWydtZW51T3BlbiddKTtcbiAgY29uc3QgW2lzTW9iaWxlLCBzZXRJc01vYmlsZV0gPSBSZWFjdC51c2VTdGF0ZTxib29sZWFuPihmYWxzZSk7XG4gIGNvbnN0IFt0cmFuc2l0aW9uLCBzZXRUcmFuc2l0aW9uXSA9IFJlYWN0LnVzZVN0YXRlPGJvb2xlYW4+KGZhbHNlKTtcbiAgY29uc3Qgd2luZG93U2l6ZSA9IHVzZVdpbmRvd1NpemUoKTtcbiAgY29uc3QgW3Nob3csIHNldFNob3ddID0gUmVhY3QudXNlU3RhdGU8Ym9vbGVhbj4oZmFsc2UpO1xuXG4gIFJlYWN0LnVzZUVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKHdpbmRvd1NpemUud2lkdGggPT09IG51bGwpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHdpbmRvd1NpemUud2lkdGggPj0gTU9CSUxFX0JQICYmIGlzTW9iaWxlKSB7XG4gICAgICBzZXRNZW51T3BlbihmYWxzZSk7XG4gICAgICBzZXRJc01vYmlsZShmYWxzZSk7XG4gICAgfSBlbHNlIGlmICh3aW5kb3dTaXplLndpZHRoIDwgTU9CSUxFX0JQKSB7XG4gICAgICBzZXRUaW1lb3V0KCgpID0+IHNldFRyYW5zaXRpb24odHJ1ZSksIDIwMCk7XG4gICAgICBzZXRJc01vYmlsZSh0cnVlKTtcbiAgICB9XG4gICAgc2V0U2hvdyh0cnVlKTtcbiAgfSwgW3dpbmRvd1NpemVdKTtcblxuICBSZWFjdC51c2VFZmZlY3QoKCkgPT4ge1xuICAgIHNldE9mZmxpbmUoIW5hdmlnYXRvci5vbkxpbmUpO1xuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdvbmxpbmUnLCAoKSA9PiBzZXRPZmZsaW5lKGZhbHNlKSwgZmFsc2UpO1xuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdvZmZsaW5lJywgKCkgPT4gc2V0T2ZmbGluZSh0cnVlKSwgZmFsc2UpO1xuICB9LCBbXSk7XG5cbiAgY29uc3QgdG91Y2hTdGFydCA9IChlKSA9PiB7XG4gICAgc3RhcnRYID0gZS50b3VjaGVzWzBdLmNsaWVudFg7XG4gIH07XG4gIGNvbnN0IHRvdWNoRW5kID0gKCkgPT4ge1xuICAgIGNvbnN0IG1vdmVkID0gY3VycmVudFggPT09IDAgPyAwIDogY3VycmVudFggLSBzdGFydFg7XG4gICAgaWYgKG1vdmVkIDw9IHRvdWNoTGVuZ3RoICogLTEpIHtcbiAgICAgIHNldE1lbnVPcGVuKGZhbHNlKTtcbiAgICB9IGVsc2UgaWYgKG1vdmVkID49IHRvdWNoTGVuZ3RoKSB7XG4gICAgICBzZXRNZW51T3Blbih0cnVlKTtcbiAgICB9XG4gICAgc3RhcnRYID0gMDtcbiAgICBjdXJyZW50WCA9IDA7XG4gIH07XG4gIGNvbnN0IHRvdWNoTW92ZSA9IChlKSA9PiB7XG4gICAgY3VycmVudFggPSBlLnRvdWNoZXNbMF0uY2xpZW50WDtcbiAgfTtcblxuICBSZWFjdC51c2VFZmZlY3QoKCkgPT4ge1xuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCd0b3VjaHN0YXJ0JywgdG91Y2hTdGFydCk7XG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNoZW5kJywgdG91Y2hFbmQpO1xuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCd0b3VjaG1vdmUnLCB0b3VjaE1vdmUpO1xuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcigndG91Y2hzdGFydCcsIHRvdWNoU3RhcnQpO1xuICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3RvdWNoZW5kJywgdG91Y2hFbmQpO1xuICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3RvdWNobW92ZScsIHRvdWNoTW92ZSk7XG4gICAgfTtcbiAgfSwgW10pO1xuXG4gIHJldHVybiAoXG4gICAgPFByb3ZpZGVyIHZhbHVlPXtzdG9yZX0+XG4gICAgICA8Q29tcG9uZW50IHsuLi5wYWdlUHJvcHN9IC8+XG4gICAgICA8Q29udGVudCBjbGFzc05hbWU9XCJhcHAtY29udGVudFwiIC8+XG4gICAgICA8ZGl2XG4gICAgICAgIGRhdGEtbWVudT17bWVudU9wZW4gPyAnb3BlbicgOiAnY2xvc2VkJ31cbiAgICAgICAgZGF0YS1sYXlvdXQ9e2lzTW9iaWxlID8gJ21vYmlsZScgOiAnZGVza3RvcCd9XG4gICAgICAgIGRhdGEtbGF5b3V0LXRyYW5zaXRpb249e3RyYW5zaXRpb259XG4gICAgICAgIGNsYXNzTmFtZT1cImFwcFwiXG4gICAgICAgIHN0eWxlPXt7IG9wYWNpdHk6IHNob3cgPyAxIDogMCB9fVxuICAgICAgPlxuICAgICAgICB7c2hvdyAmJiAoXG4gICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJhcHBfX2lubmVyXCI+XG4gICAgICAgICAgICA8QWJvdXQgY2xhc3NOYW1lPVwiYXBwX19zaWRlYmFyXCIgLz5cbiAgICAgICAgICAgIDxDYWxlbmRhciBjbGFzc05hbWU9XCJhcHBfX2NvbnRlbnRcIiAvPlxuICAgICAgICAgIDwvZGl2PlxuICAgICAgICApfVxuICAgICAgPC9kaXY+XG4gICAgICA8U25vdyBjbGFzc05hbWU9XCJhcHBfX3Nub3dcIiAvPlxuICAgIDwvUHJvdmlkZXI+XG4gICk7XG59O1xuIiwidmFyIG1hcCA9IHtcblx0XCIuL21kaS9iZWxsLW91dGxpbmUuc3ZnXCI6IFwiLi9wdWJsaWMvaWNvbi9tZGkvYmVsbC1vdXRsaW5lLnN2Z1wiLFxuXHRcIi4vbWRpL2JlbGwuc3ZnXCI6IFwiLi9wdWJsaWMvaWNvbi9tZGkvYmVsbC5zdmdcIixcblx0XCIuL21kaS9jYWxlbmRhci1tb250aC5zdmdcIjogXCIuL3B1YmxpYy9pY29uL21kaS9jYWxlbmRhci1tb250aC5zdmdcIixcblx0XCIuL21kaS9jYWxlbmRhci5zdmdcIjogXCIuL3B1YmxpYy9pY29uL21kaS9jYWxlbmRhci5zdmdcIixcblx0XCIuL21kaS9jaGVjay5zdmdcIjogXCIuL3B1YmxpYy9pY29uL21kaS9jaGVjay5zdmdcIixcblx0XCIuL21kaS9kb3dubG9hZC5zdmdcIjogXCIuL3B1YmxpYy9pY29uL21kaS9kb3dubG9hZC5zdmdcIixcblx0XCIuL21kaS9lbWFpbC1vdXRsaW5lLnN2Z1wiOiBcIi4vcHVibGljL2ljb24vbWRpL2VtYWlsLW91dGxpbmUuc3ZnXCIsXG5cdFwiLi9tZGkvbGlzdC5zdmdcIjogXCIuL3B1YmxpYy9pY29uL21kaS9saXN0LnN2Z1wiLFxuXHRcIi4vbWRpL21lbnUuc3ZnXCI6IFwiLi9wdWJsaWMvaWNvbi9tZGkvbWVudS5zdmdcIixcblx0XCIuL21kaS9zZW5kLnN2Z1wiOiBcIi4vcHVibGljL2ljb24vbWRpL3NlbmQuc3ZnXCIsXG5cdFwiLi9tZGkvc2hhcmUuc3ZnXCI6IFwiLi9wdWJsaWMvaWNvbi9tZGkvc2hhcmUuc3ZnXCIsXG5cdFwiLi9wd2EtbG9nby5zdmdcIjogXCIuL3B1YmxpYy9pY29uL3B3YS1sb2dvLnN2Z1wiLFxuXHRcIi4vcHdhZHZlbnQtbG9nby1zYW1laGVpZ2h0LnN2Z1wiOiBcIi4vcHVibGljL2ljb24vcHdhZHZlbnQtbG9nby1zYW1laGVpZ2h0LnN2Z1wiLFxuXHRcIi4vcHdhZHZlbnQtbG9nby5zdmdcIjogXCIuL3B1YmxpYy9pY29uL3B3YWR2ZW50LWxvZ28uc3ZnXCJcbn07XG5cblxuZnVuY3Rpb24gd2VicGFja0FzeW5jQ29udGV4dChyZXEpIHtcblx0cmV0dXJuIHdlYnBhY2tBc3luY0NvbnRleHRSZXNvbHZlKHJlcSkudGhlbihmdW5jdGlvbihpZCkge1xuXHRcdHJldHVybiBfX3dlYnBhY2tfcmVxdWlyZV9fLnQoaWQsIDcpO1xuXHR9KTtcbn1cbmZ1bmN0aW9uIHdlYnBhY2tBc3luY0NvbnRleHRSZXNvbHZlKHJlcSkge1xuXHQvLyBIZXJlIFByb21pc2UucmVzb2x2ZSgpLnRoZW4oKSBpcyB1c2VkIGluc3RlYWQgb2YgbmV3IFByb21pc2UoKSB0byBwcmV2ZW50XG5cdC8vIHVuY2F1Z2h0IGV4Y2VwdGlvbiBwb3BwaW5nIHVwIGluIGRldnRvb2xzXG5cdHJldHVybiBQcm9taXNlLnJlc29sdmUoKS50aGVuKGZ1bmN0aW9uKCkge1xuXHRcdGlmKCFfX3dlYnBhY2tfcmVxdWlyZV9fLm8obWFwLCByZXEpKSB7XG5cdFx0XHR2YXIgZSA9IG5ldyBFcnJvcihcIkNhbm5vdCBmaW5kIG1vZHVsZSAnXCIgKyByZXEgKyBcIidcIik7XG5cdFx0XHRlLmNvZGUgPSAnTU9EVUxFX05PVF9GT1VORCc7XG5cdFx0XHR0aHJvdyBlO1xuXHRcdH1cblx0XHRyZXR1cm4gbWFwW3JlcV07XG5cdH0pO1xufVxud2VicGFja0FzeW5jQ29udGV4dC5rZXlzID0gZnVuY3Rpb24gd2VicGFja0FzeW5jQ29udGV4dEtleXMoKSB7XG5cdHJldHVybiBPYmplY3Qua2V5cyhtYXApO1xufTtcbndlYnBhY2tBc3luY0NvbnRleHQucmVzb2x2ZSA9IHdlYnBhY2tBc3luY0NvbnRleHRSZXNvbHZlO1xud2VicGFja0FzeW5jQ29udGV4dC5pZCA9IFwiLi9wdWJsaWMvaWNvbiBlYWdlciByZWN1cnNpdmUgXlxcXFwuXFxcXC8uKiRcIjtcbm1vZHVsZS5leHBvcnRzID0gd2VicGFja0FzeW5jQ29udGV4dDsiLCJpbXBvcnQgeyBvcGVuREIsIERCU2NoZW1hIH0gZnJvbSAnaWRiJztcbmltcG9ydCB7IERheURhdGEgfSBmcm9tICdAY29tcHMvdHlwZXMnO1xuXG5jb25zdCBkYk5hbWUgPSAncHdhZHZlbnQnO1xuXG5pbnRlcmZhY2UgUFdBZHZlbnREQiBleHRlbmRzIERCU2NoZW1hIHtcbiAgZGF5czoge1xuICAgIGtleTogc3RyaW5nO1xuICAgIHZhbHVlOiBhbnk7XG4gIH07XG4gIHBhZ2U6IHtcbiAgICBrZXk6IHN0cmluZztcbiAgICB2YWx1ZTogRGF5RGF0YTtcbiAgfTtcbiAgc2V0dGluZ3M6IHtcbiAgICBrZXk6IHN0cmluZztcbiAgICB2YWx1ZTogYW55O1xuICB9O1xufVxuXG5jb25zdCBkYlByb21pc2UgPVxuICB0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJ1xuICAgID8gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHJlc29sdmUoJycpKVxuICAgIDogb3BlbkRCPFBXQWR2ZW50REI+KGRiTmFtZSwgMiwge1xuICAgICAgICB1cGdyYWRlKGRiLCBvbGRWZXJzaW9uKSB7XG4gICAgICAgICAgaWYgKG9sZFZlcnNpb24gPCAxKSB7XG4gICAgICAgICAgICBkYi5jcmVhdGVPYmplY3RTdG9yZSgnZGF5cycpO1xuICAgICAgICAgICAgZGIuY3JlYXRlT2JqZWN0U3RvcmUoJ3BhZ2UnKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKG9sZFZlcnNpb24gPCAyKSB7XG4gICAgICAgICAgICBkYi5jcmVhdGVPYmplY3RTdG9yZSgnc2V0dGluZ3MnKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICB9KTtcblxuZXhwb3J0IGNvbnN0IGRheXNEQiA9IHtcbiAgZ2V0OiBhc3luYyAoa2V5OiBzdHJpbmcpID0+IChhd2FpdCBkYlByb21pc2UpLmdldCgnZGF5cycsIGtleSksXG4gIHNldDogYXN5bmMgKGtleTogc3RyaW5nLCB2YWw6IGFueSkgPT4gKGF3YWl0IGRiUHJvbWlzZSkucHV0KCdkYXlzJywgdmFsLCBrZXkpLFxuICBkZWxldGU6IGFzeW5jIChrZXk6IHN0cmluZykgPT4gKGF3YWl0IGRiUHJvbWlzZSkuZGVsZXRlKCdkYXlzJywga2V5KSxcbn07XG5cbmV4cG9ydCBjb25zdCBwYWdlREIgPSB7XG4gIGdldDogYXN5bmMgKGtleTogc3RyaW5nKSA9PiAoYXdhaXQgZGJQcm9taXNlKS5nZXQoJ3BhZ2UnLCBrZXkpLFxuICBzZXQ6IGFzeW5jIChrZXk6IHN0cmluZywgdmFsOiBhbnkpID0+IChhd2FpdCBkYlByb21pc2UpLnB1dCgncGFnZScsIHZhbCwga2V5KSxcbiAgZGVsZXRlOiBhc3luYyAoa2V5OiBzdHJpbmcpID0+IChhd2FpdCBkYlByb21pc2UpLmRlbGV0ZSgncGFnZScsIGtleSksXG59O1xuXG5leHBvcnQgY29uc3Qgc2V0dGluZ3NEQiA9IHtcbiAgZ2V0OiBhc3luYyAoa2V5OiBzdHJpbmcpID0+IChhd2FpdCBkYlByb21pc2UpLmdldCgnc2V0dGluZ3MnLCBrZXkpLFxuICBzZXQ6IGFzeW5jIChrZXk6IHN0cmluZywgdmFsOiBhbnkpID0+XG4gICAgKGF3YWl0IGRiUHJvbWlzZSkucHV0KCdzZXR0aW5ncycsIHZhbCwga2V5KSxcbiAgZGVsZXRlOiBhc3luYyAoa2V5OiBzdHJpbmcpID0+IChhd2FpdCBkYlByb21pc2UpLmRlbGV0ZSgnc2V0dGluZ3MnLCBrZXkpLFxufTtcbiIsImltcG9ydCBjcmVhdGVTdG9yZSwgeyBTdG9yZSB9IGZyb20gJ3VuaXN0b3JlJztcbmltcG9ydCBkZXZ0b29scyBmcm9tICd1bmlzdG9yZS9kZXZ0b29scyc7XG5pbXBvcnQgeyBkYXlzREIsIHBhZ2VEQiB9IGZyb20gJ0BzdG9yZS9pZGInO1xuaW1wb3J0IHtcbiAgQ0FMRU5EQVIsXG4gIERBVEVfU1RBUlQsXG4gIERBVEVfVE9EQVksXG4gIERBVEVfVE9EQVlfWkVSTyxcbiAgWUVBUixcbn0gZnJvbSAnQHV0aWxzL2NhbGVuZGFyJztcbmltcG9ydCB7IGFwaUJhc2UsIGFwaUtleSB9IGZyb20gJ0B1dGlscy9jb25zdGFudHMnO1xuaW1wb3J0IHsgaXNEZXYgfSBmcm9tICdAdXRpbHMvY29uc3RhbnRzJztcbmltcG9ydCBkYXlqcyBmcm9tICdAdXRpbHMvZGF5anMnO1xuaW1wb3J0IHsgemVyb1BhZCB9IGZyb20gJ0B1dGlscy9oZWxwZXJzJztcbmltcG9ydCB7IFN0YXRlIH0gZnJvbSAnLi90eXBlcyc7XG5cbmNvbnN0IGluaXRpYWxEYXlzID0ge307XG5DQUxFTkRBUi5tYXAoKGRheSkgPT4ge1xuICBpbml0aWFsRGF5c1tkYXldID0ge1xuICAgIGxvYWRpbmc6IGZhbHNlLFxuICAgIGVycm9yOiAnJyxcbiAgICBkYXRhOiB7XG4gICAgICBkYXRlOiBgJHtZRUFSfS0xMi0ke3plcm9QYWQoZGF5LCAyKX1gLFxuICAgICAgdGl0bGU6ICcnLFxuICAgICAgY29udGVudDogJycsXG4gICAgfSxcbiAgfTtcbn0pO1xuXG5jb25zdCBpbml0aWFsU3RhdGU6IFN0YXRlID0ge1xuICBvZmZsaW5lOiBmYWxzZSxcbiAgbWVudU9wZW46IERBVEVfVE9EQVkuaXNCZWZvcmUoREFURV9TVEFSVCksXG4gIGRheXM6IGluaXRpYWxEYXlzLFxuICBwYWdlOiB7XG4gICAgbG9hZGluZzogZmFsc2UsXG4gICAgc2x1ZzogJycsXG4gICAgZGF0YToge1xuICAgICAgdGl0bGU6ICcnLFxuICAgICAgY29udGVudDogJycsXG4gICAgfSxcbiAgfSxcbn07XG5cbmNvbnN0IHNldERheSA9IChkYXk6IG51bWJlciwgc3RvcmU6IFN0b3JlPFN0YXRlPiwgdmFsdWUgPSB7fSk6IHZvaWQgPT4ge1xuICBjb25zdCBzdGF0ZSA9IHN0b3JlLmdldFN0YXRlKCk7XG4gIGNvbnN0IGRheXNOb3cgPSBzdGF0ZS5kYXlzO1xuICBzdG9yZS5zZXRTdGF0ZSh7XG4gICAgZGF5czoge1xuICAgICAgLi4uZGF5c05vdyxcbiAgICAgIFtkYXldOiB7XG4gICAgICAgIC4uLmRheXNOb3dbZGF5XSxcbiAgICAgICAgLi4udmFsdWUsXG4gICAgICB9LFxuICAgIH0sXG4gIH0pO1xufTtcblxuY29uc3Qgc2V0UGFnZSA9IChcbiAgc2x1Zzogc3RyaW5nLFxuICBzdG9yZTogU3RvcmU8U3RhdGU+LFxuICB0aXRsZTogc3RyaW5nLFxuICBjb250ZW50OiBzdHJpbmdcbik6IHZvaWQgPT4ge1xuICBjb25zdCBzdGF0ZSA9IHN0b3JlLmdldFN0YXRlKCk7XG4gIGlmIChzdGF0ZS5wYWdlLnNsdWcgIT09IHNsdWcpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgc3RvcmUuc2V0U3RhdGUoe1xuICAgIHBhZ2U6IHtcbiAgICAgIC4uLnN0YXRlLnBhZ2UsXG4gICAgICBsb2FkaW5nOiBmYWxzZSxcbiAgICAgIGRhdGE6IHtcbiAgICAgICAgdGl0bGUsXG4gICAgICAgIGNvbnRlbnQsXG4gICAgICB9LFxuICAgIH0sXG4gIH0pO1xufTtcblxuZXhwb3J0IGNvbnN0IGFjdGlvbnMgPSAoc3RvcmU6IFN0b3JlPFN0YXRlPikgPT4gKHtcbiAgc2V0T2ZmbGluZTogKHN0YXRlLCBvZmZsaW5lOiBib29sZWFuKSA9PiBzdG9yZS5zZXRTdGF0ZSh7IG9mZmxpbmUgfSksXG4gIGxvYWREYXk6IGFzeW5jICh7IGRheXMgfSwgZGF5OiBudW1iZXIpID0+IHtcbiAgICBjb25zdCBzdG9yZURheSA9IGRheXNbZGF5XTtcblxuICAgIGlmICghc3RvcmVEYXkgfHwgIXN0b3JlRGF5LmRhdGEgfHwgIXN0b3JlRGF5LmRhdGEuZGF0ZSkge1xuICAgICAgc2V0RGF5KGRheSwgc3RvcmUsIHtcbiAgICAgICAgbG9hZGluZzogZmFsc2UsXG4gICAgICAgIGVycm9yOiAnU29tZXRoaW5nIHdlbnQgd3JvbmcnLFxuICAgICAgfSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gY2hlY2sgaWYgQVBJIGhhcyBhbHJlYWR5IHJlbGVhc2VkIGFydGljbGVcbiAgICBpZiAoXG4gICAgICBkYXlqcyhzdG9yZURheS5kYXRhLmRhdGUpXG4gICAgICAgIC50eignQW50YXJjdGljYS9NY011cmRvJywgdHJ1ZSlcbiAgICAgICAgLmlzQWZ0ZXIoREFURV9UT0RBWV9aRVJPKVxuICAgICkge1xuICAgICAgc2V0RGF5KGRheSwgc3RvcmUsIHtcbiAgICAgICAgbG9hZGluZzogZmFsc2UsXG4gICAgICAgIGVycm9yOiAnVGhpcyBhcnRpY2xlIGlzIG5vdCB5ZXQgcHVibGlzaGVkLicsXG4gICAgICB9KTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBzZXREYXkoZGF5LCBzdG9yZSwge1xuICAgICAgbG9hZGluZzogdHJ1ZSxcbiAgICAgIGVycm9yOiAnJyxcbiAgICB9KTtcblxuICAgIGxldCBkYXlPYmplY3QgPSBhd2FpdCBkYXlzREIuZ2V0KFN0cmluZyhkYXkpKTtcbiAgICBpZiAoZGF5T2JqZWN0KSB7XG4gICAgICBzZXREYXkoZGF5LCBzdG9yZSwge1xuICAgICAgICBsb2FkaW5nOiBmYWxzZSxcbiAgICAgICAgZGF0YTogZGF5T2JqZWN0LFxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgY29uc3QgcmVzcCA9IGF3YWl0IGZldGNoKFxuICAgICAgYCR7YXBpQmFzZX13cC1qc29uL2FkdmVudC1jYWxlbmRhci92MS9kYXlzLyR7ZGF5fS8ke1xuICAgICAgICBhcGlLZXkgPyBgP2FwaUtleT0ke2FwaUtleX1gIDogJydcbiAgICAgIH1gXG4gICAgKTtcblxuICAgIC8vIG5vdCBmb3VuZFxuICAgIGlmICghcmVzcC5vayAmJiAhZGF5T2JqZWN0KSB7XG4gICAgICBzZXREYXkoZGF5LCBzdG9yZSwge1xuICAgICAgICBsb2FkaW5nOiBmYWxzZSxcbiAgICAgICAgZXJyb3I6ICdUaGVyZSBpcyBubyBBcnRpY2xlIGZvciB0aGlzIGRheS4nLFxuICAgICAgfSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gb2tcbiAgICBjb25zdCByZXNwSnNvbiA9IGF3YWl0IHJlc3AuanNvbigpO1xuXG4gICAgZGF5T2JqZWN0ID0ge1xuICAgICAgLi4uc3RvcmVEYXkuZGF0YSxcbiAgICAgIHRpdGxlOiByZXNwSnNvbi50aXRsZSxcbiAgICAgIGV4Y2VycHQ6IHJlc3BKc29uLmV4Y2VycHQsXG4gICAgICBjb250ZW50OiByZXNwSnNvbi5jb250ZW50LFxuICAgICAgYXV0aG9yOiByZXNwSnNvbi5hdXRob3IsXG4gICAgICBpbWFnZTogcmVzcEpzb24uaW1hZ2UsXG4gICAgICBzb3VyY2U6IHJlc3BKc29uLnNvdXJjZSxcbiAgICB9O1xuICAgIC8vfVxuXG4gICAgc2V0RGF5KGRheSwgc3RvcmUsIHtcbiAgICAgIGxvYWRpbmc6IGZhbHNlLFxuICAgICAgZGF0YTogZGF5T2JqZWN0LFxuICAgIH0pO1xuICAgIGF3YWl0IGRheXNEQi5zZXQoU3RyaW5nKGRheSksIHsgLi4uZGF5T2JqZWN0IH0pO1xuICB9LFxuICBzZXRNZW51T3BlbjogKHN0YXRlLCBtZW51T3BlbjogYm9vbGVhbikgPT4gc3RvcmUuc2V0U3RhdGUoeyBtZW51T3BlbiB9KSxcbiAgbG9hZFBhZ2U6IGFzeW5jIChzdGF0ZSwgc2x1Zzogc3RyaW5nKSA9PiB7XG4gICAgc3RvcmUuc2V0U3RhdGUoeyBwYWdlOiB7IC4uLnN0YXRlLnBhZ2UsIGxvYWRpbmc6IHRydWUsIHNsdWcgfSB9KTtcbiAgICBjb25zdCBjb250ZW50ID0gYXdhaXQgcGFnZURCLmdldChzbHVnKTtcbiAgICBpZiAoY29udGVudCkge1xuICAgICAgc2V0UGFnZShzbHVnLCBzdG9yZSwgY29udGVudC50aXRsZSwgY29udGVudC5jb250ZW50KTtcbiAgICB9XG5cbiAgICBjb25zdCByZXNwID0gYXdhaXQgZmV0Y2goXG4gICAgICBgJHthcGlCYXNlfXdwLWpzb24vYWR2ZW50LWNhbGVuZGFyL3YxL3BhZ2UvJHtzbHVnfS9gXG4gICAgKTtcbiAgICBpZiAocmVzcC5zdGF0dXMgIT09IDIwMCAmJiAhY29udGVudCkge1xuICAgICAgc2V0UGFnZShcbiAgICAgICAgc2x1ZyxcbiAgICAgICAgc3RvcmUsXG4gICAgICAgICdFcnJvciA0MDQnLFxuICAgICAgICAnVGhlIFBhZ2UgeW91IGFyZSBsb29raW5nIGZvciBkZXMgbm90IGV4aXN0J1xuICAgICAgKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCByZXNwSnNvbiA9IGF3YWl0IHJlc3AuanNvbigpO1xuICAgIHNldFBhZ2Uoc2x1Zywgc3RvcmUsIHJlc3BKc29uLnRpdGxlLCByZXNwSnNvbi5jb250ZW50KTtcblxuICAgIGF3YWl0IHBhZ2VEQi5zZXQoc2x1Zywge1xuICAgICAgdGl0bGU6IHJlc3BKc29uLnRpdGxlLFxuICAgICAgY29udHNudDogcmVzcEpzb24uY29udGVudCxcbiAgICB9KTtcbiAgfSxcbn0pO1xuXG5leHBvcnQgY29uc3Qgc3RvcmUgPSBpc0RldlxuICA/IGNyZWF0ZVN0b3JlKGluaXRpYWxTdGF0ZSlcbiAgOiBkZXZ0b29scyhjcmVhdGVTdG9yZShpbml0aWFsU3RhdGUpKTtcbiIsInZhciBhcGkgPSByZXF1aXJlKFwiIS4uLy4uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvYnVpbGQvd2VicGFjay9sb2FkZXJzL25leHQtc3R5bGUtbG9hZGVyL3J1bnRpbWUvaW5qZWN0U3R5bGVzSW50b1N0eWxlVGFnLmpzXCIpO1xuICAgICAgICAgICAgdmFyIGNvbnRlbnQgPSByZXF1aXJlKFwiISEuLi8uLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NvbXBpbGVkL2Nzcy1sb2FkZXIvY2pzLmpzPz9yZWYtLTUtb25lT2YtMi0xIS4uLy4uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvcG9zdGNzcy1sb2FkZXIvY2pzLmpzPz9yZWYtLTUtb25lT2YtMi0yIS4vQnV0dG9uLm1vZHVsZS5jc3NcIik7XG5cbiAgICAgICAgICAgIGNvbnRlbnQgPSBjb250ZW50Ll9fZXNNb2R1bGUgPyBjb250ZW50LmRlZmF1bHQgOiBjb250ZW50O1xuXG4gICAgICAgICAgICBpZiAodHlwZW9mIGNvbnRlbnQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgIGNvbnRlbnQgPSBbW21vZHVsZS5pZCwgY29udGVudCwgJyddXTtcbiAgICAgICAgICAgIH1cblxudmFyIG9wdGlvbnMgPSB7fTtcblxub3B0aW9ucy5pbnNlcnQgPSBmdW5jdGlvbihlbGVtZW50KXsvLyBUaGVzZSBlbGVtZW50cyBzaG91bGQgYWx3YXlzIGV4aXN0LiBJZiB0aGV5IGRvIG5vdCxcbi8vIHRoaXMgY29kZSBzaG91bGQgZmFpbC5cbnZhciBhbmNob3JFbGVtZW50PWRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJyNfX25leHRfY3NzX19ET19OT1RfVVNFX18nKTt2YXIgcGFyZW50Tm9kZT1hbmNob3JFbGVtZW50LnBhcmVudE5vZGU7Ly8gTm9ybWFsbHkgPGhlYWQ+XG4vLyBFYWNoIHN0eWxlIHRhZyBzaG91bGQgYmUgcGxhY2VkIHJpZ2h0IGJlZm9yZSBvdXJcbi8vIGFuY2hvci4gQnkgaW5zZXJ0aW5nIGJlZm9yZSBhbmQgbm90IGFmdGVyLCB3ZSBkbyBub3Rcbi8vIG5lZWQgdG8gdHJhY2sgdGhlIGxhc3QgaW5zZXJ0ZWQgZWxlbWVudC5cbnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKGVsZW1lbnQsYW5jaG9yRWxlbWVudCk7fTtcbm9wdGlvbnMuc2luZ2xldG9uID0gZmFsc2U7XG5cbnZhciB1cGRhdGUgPSBhcGkoY29udGVudCwgb3B0aW9ucyk7XG5cblxuaWYgKG1vZHVsZS5ob3QpIHtcbiAgaWYgKCFjb250ZW50LmxvY2FscyB8fCBtb2R1bGUuaG90LmludmFsaWRhdGUpIHtcbiAgICB2YXIgaXNFcXVhbExvY2FscyA9IGZ1bmN0aW9uIGlzRXF1YWxMb2NhbHMoYSxiLGlzTmFtZWRFeHBvcnQpe2lmKCFhJiZifHxhJiYhYil7cmV0dXJuIGZhbHNlO31sZXQgcDtmb3IocCBpbiBhKXtpZihpc05hbWVkRXhwb3J0JiZwPT09J2RlZmF1bHQnKXsvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29udGludWVcbmNvbnRpbnVlO31pZihhW3BdIT09YltwXSl7cmV0dXJuIGZhbHNlO319Zm9yKHAgaW4gYil7aWYoaXNOYW1lZEV4cG9ydCYmcD09PSdkZWZhdWx0Jyl7Ly8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnRpbnVlXG5jb250aW51ZTt9aWYoIWFbcF0pe3JldHVybiBmYWxzZTt9fXJldHVybiB0cnVlO307XG4gICAgdmFyIG9sZExvY2FscyA9IGNvbnRlbnQubG9jYWxzO1xuXG4gICAgbW9kdWxlLmhvdC5hY2NlcHQoXG4gICAgICBcIiEhLi4vLi4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jb21waWxlZC9jc3MtbG9hZGVyL2Nqcy5qcz8/cmVmLS01LW9uZU9mLTItMSEuLi8uLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NvbXBpbGVkL3Bvc3Rjc3MtbG9hZGVyL2Nqcy5qcz8/cmVmLS01LW9uZU9mLTItMiEuL0J1dHRvbi5tb2R1bGUuY3NzXCIsXG4gICAgICBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGNvbnRlbnQgPSByZXF1aXJlKFwiISEuLi8uLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NvbXBpbGVkL2Nzcy1sb2FkZXIvY2pzLmpzPz9yZWYtLTUtb25lT2YtMi0xIS4uLy4uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvcG9zdGNzcy1sb2FkZXIvY2pzLmpzPz9yZWYtLTUtb25lT2YtMi0yIS4vQnV0dG9uLm1vZHVsZS5jc3NcIik7XG5cbiAgICAgICAgICAgICAgY29udGVudCA9IGNvbnRlbnQuX19lc01vZHVsZSA/IGNvbnRlbnQuZGVmYXVsdCA6IGNvbnRlbnQ7XG5cbiAgICAgICAgICAgICAgaWYgKHR5cGVvZiBjb250ZW50ID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIGNvbnRlbnQgPSBbW21vZHVsZS5pZCwgY29udGVudCwgJyddXTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGlmICghaXNFcXVhbExvY2FscyhvbGRMb2NhbHMsIGNvbnRlbnQubG9jYWxzKSkge1xuICAgICAgICAgICAgICAgIG1vZHVsZS5ob3QuaW52YWxpZGF0ZSgpO1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgb2xkTG9jYWxzID0gY29udGVudC5sb2NhbHM7XG5cbiAgICAgICAgICAgICAgdXBkYXRlKGNvbnRlbnQpO1xuICAgICAgfVxuICAgIClcbiAgfVxuXG4gIG1vZHVsZS5ob3QuZGlzcG9zZShmdW5jdGlvbigpIHtcbiAgICB1cGRhdGUoKTtcbiAgfSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gY29udGVudC5sb2NhbHMgfHwge307IiwiaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCBjbiBmcm9tICdAdXRpbHMvY2xhc3NuYW1lcyc7XG5pbXBvcnQgeyBMb2FkZXIsIEljb24gfSBmcm9tICcuLi9pbmRleCc7XG5pbXBvcnQgc3R5bGVzIGZyb20gJy4vQnV0dG9uLm1vZHVsZS5jc3MnO1xuXG5jb25zdCBCdXR0b24gPSAoe1xuICBjaGlsZHJlbiA9ICcnLFxuICBjbGFzc05hbWUgPSAnJyxcbiAgb25DbGljayA9ICgpID0+IHt9LFxuICBsYXlvdXQgPSAnc29saWQnLFxuICByb3VuZCA9IGZhbHNlLFxuICBpY29uID0gJycsXG4gIGljb25SaWdodCA9IGZhbHNlLFxuICBpY29uQ2lyY2xlID0gZmFsc2UsXG4gIHNpemUgPSAnbWVkaXVtJyxcbiAgbG9hZGluZyA9IGZhbHNlLFxuICBkaXNhYmxlZCA9IGZhbHNlLFxuICBjb2xvciA9ICdibGFjaycsXG4gIHplcm9QYWRkaW5nID0gZmFsc2UsXG4gIGZvbnRXZWlnaHQgPSAnYm9sZCcsXG4gIC4uLnByb3BzXG59OiB7XG4gIGNoaWxkcmVuPzogYW55O1xuICBjbGFzc05hbWU/OiBzdHJpbmc7XG4gIG9uQ2xpY2s/OiBGdW5jdGlvbjtcbiAgbGF5b3V0PzogJ3NvbGlkJyB8ICdnaG9zdCcgfCAnZW1wdHknO1xuICByb3VuZD86IGJvb2xlYW47XG4gIGljb24/OiBzdHJpbmc7XG4gIGljb25SaWdodD86IGJvb2xlYW47XG4gIGljb25DaXJjbGU/OiBib29sZWFuO1xuICBzaXplPzogJ21lZGl1bScgfCAnc21hbGwnIHwgJ2xhcmdlJztcbiAgbG9hZGluZz86IGJvb2xlYW47XG4gIGRpc2FibGVkPzogYm9vbGVhbjtcbiAgY29sb3I/OiAnYmxhY2snIHwgJ3JlZCc7XG4gIHplcm9QYWRkaW5nPzogYm9vbGVhbjtcbiAgZm9udFdlaWdodD86ICdub3JtYWwnIHwgJ2JvbGQnO1xuICBba2V5OiBzdHJpbmddOiBhbnk7XG59KSA9PiB7XG4gIHJldHVybiAoXG4gICAgPGJ1dHRvblxuICAgICAgey4uLnByb3BzfVxuICAgICAgZGlzYWJsZWQ9e2Rpc2FibGVkfVxuICAgICAgY2xhc3NOYW1lPXtjbihcbiAgICAgICAgY2xhc3NOYW1lLFxuICAgICAgICBzdHlsZXMuYnV0dG9uLFxuICAgICAgICBzdHlsZXNbYHR5cGUtJHtsYXlvdXR9YF0sXG4gICAgICAgIHN0eWxlc1tgc2l6ZS0ke3NpemV9YF0sXG4gICAgICAgIHN0eWxlc1tgY29sb3ItJHtjb2xvcn1gXSxcbiAgICAgICAgc3R5bGVzW2Bmb250V2VpZ2h0LSR7Zm9udFdlaWdodH1gXSxcbiAgICAgICAge1xuICAgICAgICAgIFtzdHlsZXMuaXNSb3VuZF06IHJvdW5kLFxuICAgICAgICAgIFtzdHlsZXMuaXNMb2FkaW5nXTogbG9hZGluZyxcbiAgICAgICAgICBbc3R5bGVzLmlzRGlzYWJsZWRdOiBkaXNhYmxlZCxcbiAgICAgICAgICBbc3R5bGVzLnplcm9wYWRkaW5nXTogemVyb1BhZGRpbmcsXG4gICAgICAgIH1cbiAgICAgICl9XG4gICAgICBvbkNsaWNrPXsoKSA9PiBvbkNsaWNrKCl9XG4gICAgPlxuICAgICAgPExvYWRlciBjbGFzc05hbWU9e3N0eWxlcy5sb2FkZXJ9IC8+XG4gICAgICB7aWNvbiAhPT0gJycgJiYgIWljb25SaWdodCAmJiAoXG4gICAgICAgIDxJY29uXG4gICAgICAgICAgY2xhc3NOYW1lPXtjbihzdHlsZXMuaWNvbiwgc3R5bGVzLmljb25MZWZ0KX1cbiAgICAgICAgICBpY29uPXtpY29ufVxuICAgICAgICAgIGNpcmNsZT17aWNvbkNpcmNsZX1cbiAgICAgICAgLz5cbiAgICAgICl9XG4gICAgICA8c3BhbiBjbGFzc05hbWU9e3N0eWxlcy5jb250ZW50fT57Y2hpbGRyZW59PC9zcGFuPlxuICAgICAge2ljb24gIT09ICcnICYmIGljb25SaWdodCAmJiAoXG4gICAgICAgIDxJY29uXG4gICAgICAgICAgY2xhc3NOYW1lPXtjbihzdHlsZXMuaWNvbiwgc3R5bGVzLmljb25SaWdodCl9XG4gICAgICAgICAgaWNvbj17aWNvbn1cbiAgICAgICAgICBjaXJjbGU9e2ljb25DaXJjbGV9XG4gICAgICAgIC8+XG4gICAgICApfVxuICAgIDwvYnV0dG9uPlxuICApO1xufTtcblxuZXhwb3J0IGRlZmF1bHQgQnV0dG9uO1xuIiwidmFyIGFwaSA9IHJlcXVpcmUoXCIhLi4vLi4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9idWlsZC93ZWJwYWNrL2xvYWRlcnMvbmV4dC1zdHlsZS1sb2FkZXIvcnVudGltZS9pbmplY3RTdHlsZXNJbnRvU3R5bGVUYWcuanNcIik7XG4gICAgICAgICAgICB2YXIgY29udGVudCA9IHJlcXVpcmUoXCIhIS4uLy4uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvY3NzLWxvYWRlci9janMuanM/P3JlZi0tNS1vbmVPZi0yLTEhLi4vLi4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jb21waWxlZC9wb3N0Y3NzLWxvYWRlci9janMuanM/P3JlZi0tNS1vbmVPZi0yLTIhLi9DbG9zZUJ1dHRvbi5tb2R1bGUuY3NzXCIpO1xuXG4gICAgICAgICAgICBjb250ZW50ID0gY29udGVudC5fX2VzTW9kdWxlID8gY29udGVudC5kZWZhdWx0IDogY29udGVudDtcblxuICAgICAgICAgICAgaWYgKHR5cGVvZiBjb250ZW50ID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICBjb250ZW50ID0gW1ttb2R1bGUuaWQsIGNvbnRlbnQsICcnXV07XG4gICAgICAgICAgICB9XG5cbnZhciBvcHRpb25zID0ge307XG5cbm9wdGlvbnMuaW5zZXJ0ID0gZnVuY3Rpb24oZWxlbWVudCl7Ly8gVGhlc2UgZWxlbWVudHMgc2hvdWxkIGFsd2F5cyBleGlzdC4gSWYgdGhleSBkbyBub3QsXG4vLyB0aGlzIGNvZGUgc2hvdWxkIGZhaWwuXG52YXIgYW5jaG9yRWxlbWVudD1kb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcjX19uZXh0X2Nzc19fRE9fTk9UX1VTRV9fJyk7dmFyIHBhcmVudE5vZGU9YW5jaG9yRWxlbWVudC5wYXJlbnROb2RlOy8vIE5vcm1hbGx5IDxoZWFkPlxuLy8gRWFjaCBzdHlsZSB0YWcgc2hvdWxkIGJlIHBsYWNlZCByaWdodCBiZWZvcmUgb3VyXG4vLyBhbmNob3IuIEJ5IGluc2VydGluZyBiZWZvcmUgYW5kIG5vdCBhZnRlciwgd2UgZG8gbm90XG4vLyBuZWVkIHRvIHRyYWNrIHRoZSBsYXN0IGluc2VydGVkIGVsZW1lbnQuXG5wYXJlbnROb2RlLmluc2VydEJlZm9yZShlbGVtZW50LGFuY2hvckVsZW1lbnQpO307XG5vcHRpb25zLnNpbmdsZXRvbiA9IGZhbHNlO1xuXG52YXIgdXBkYXRlID0gYXBpKGNvbnRlbnQsIG9wdGlvbnMpO1xuXG5cbmlmIChtb2R1bGUuaG90KSB7XG4gIGlmICghY29udGVudC5sb2NhbHMgfHwgbW9kdWxlLmhvdC5pbnZhbGlkYXRlKSB7XG4gICAgdmFyIGlzRXF1YWxMb2NhbHMgPSBmdW5jdGlvbiBpc0VxdWFsTG9jYWxzKGEsYixpc05hbWVkRXhwb3J0KXtpZighYSYmYnx8YSYmIWIpe3JldHVybiBmYWxzZTt9bGV0IHA7Zm9yKHAgaW4gYSl7aWYoaXNOYW1lZEV4cG9ydCYmcD09PSdkZWZhdWx0Jyl7Ly8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnRpbnVlXG5jb250aW51ZTt9aWYoYVtwXSE9PWJbcF0pe3JldHVybiBmYWxzZTt9fWZvcihwIGluIGIpe2lmKGlzTmFtZWRFeHBvcnQmJnA9PT0nZGVmYXVsdCcpey8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb250aW51ZVxuY29udGludWU7fWlmKCFhW3BdKXtyZXR1cm4gZmFsc2U7fX1yZXR1cm4gdHJ1ZTt9O1xuICAgIHZhciBvbGRMb2NhbHMgPSBjb250ZW50LmxvY2FscztcblxuICAgIG1vZHVsZS5ob3QuYWNjZXB0KFxuICAgICAgXCIhIS4uLy4uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvY3NzLWxvYWRlci9janMuanM/P3JlZi0tNS1vbmVPZi0yLTEhLi4vLi4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jb21waWxlZC9wb3N0Y3NzLWxvYWRlci9janMuanM/P3JlZi0tNS1vbmVPZi0yLTIhLi9DbG9zZUJ1dHRvbi5tb2R1bGUuY3NzXCIsXG4gICAgICBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGNvbnRlbnQgPSByZXF1aXJlKFwiISEuLi8uLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NvbXBpbGVkL2Nzcy1sb2FkZXIvY2pzLmpzPz9yZWYtLTUtb25lT2YtMi0xIS4uLy4uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvcG9zdGNzcy1sb2FkZXIvY2pzLmpzPz9yZWYtLTUtb25lT2YtMi0yIS4vQ2xvc2VCdXR0b24ubW9kdWxlLmNzc1wiKTtcblxuICAgICAgICAgICAgICBjb250ZW50ID0gY29udGVudC5fX2VzTW9kdWxlID8gY29udGVudC5kZWZhdWx0IDogY29udGVudDtcblxuICAgICAgICAgICAgICBpZiAodHlwZW9mIGNvbnRlbnQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgY29udGVudCA9IFtbbW9kdWxlLmlkLCBjb250ZW50LCAnJ11dO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgaWYgKCFpc0VxdWFsTG9jYWxzKG9sZExvY2FscywgY29udGVudC5sb2NhbHMpKSB7XG4gICAgICAgICAgICAgICAgbW9kdWxlLmhvdC5pbnZhbGlkYXRlKCk7XG5cbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBvbGRMb2NhbHMgPSBjb250ZW50LmxvY2FscztcblxuICAgICAgICAgICAgICB1cGRhdGUoY29udGVudCk7XG4gICAgICB9XG4gICAgKVxuICB9XG5cbiAgbW9kdWxlLmhvdC5kaXNwb3NlKGZ1bmN0aW9uKCkge1xuICAgIHVwZGF0ZSgpO1xuICB9KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjb250ZW50LmxvY2FscyB8fCB7fTsiLCJpbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0IGNuIGZyb20gJ0B1dGlscy9jbGFzc25hbWVzJztcbmltcG9ydCBzdHlsZXMgZnJvbSAnLi9DbG9zZUJ1dHRvbi5tb2R1bGUuY3NzJztcblxuY29uc3QgQ2xvc2VCdXR0b24gPSAoe1xuICBjbGFzc05hbWUgPSAnJyxcbiAgb25DbGljayxcbn06IHtcbiAgY2xhc3NOYW1lPzogc3RyaW5nO1xuICBvbkNsaWNrOiBGdW5jdGlvbjtcbn0pID0+IChcbiAgPGJ1dHRvbiBjbGFzc05hbWU9e2NuKHN0eWxlcy5yb290LCBjbGFzc05hbWUpfSBvbkNsaWNrPXsoKSA9PiBvbkNsaWNrKCl9PlxuICAgIGNsb3NlXG4gIDwvYnV0dG9uPlxuKTtcblxuZXhwb3J0IGRlZmF1bHQgQ2xvc2VCdXR0b247XG4iLCJ2YXIgYXBpID0gcmVxdWlyZShcIiEuLi8uLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2J1aWxkL3dlYnBhY2svbG9hZGVycy9uZXh0LXN0eWxlLWxvYWRlci9ydW50aW1lL2luamVjdFN0eWxlc0ludG9TdHlsZVRhZy5qc1wiKTtcbiAgICAgICAgICAgIHZhciBjb250ZW50ID0gcmVxdWlyZShcIiEhLi4vLi4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jb21waWxlZC9jc3MtbG9hZGVyL2Nqcy5qcz8/cmVmLS01LW9uZU9mLTItMSEuLi8uLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NvbXBpbGVkL3Bvc3Rjc3MtbG9hZGVyL2Nqcy5qcz8/cmVmLS01LW9uZU9mLTItMiEuL0NvbnRlbnRNb2RhbC5tb2R1bGUuY3NzXCIpO1xuXG4gICAgICAgICAgICBjb250ZW50ID0gY29udGVudC5fX2VzTW9kdWxlID8gY29udGVudC5kZWZhdWx0IDogY29udGVudDtcblxuICAgICAgICAgICAgaWYgKHR5cGVvZiBjb250ZW50ID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICBjb250ZW50ID0gW1ttb2R1bGUuaWQsIGNvbnRlbnQsICcnXV07XG4gICAgICAgICAgICB9XG5cbnZhciBvcHRpb25zID0ge307XG5cbm9wdGlvbnMuaW5zZXJ0ID0gZnVuY3Rpb24oZWxlbWVudCl7Ly8gVGhlc2UgZWxlbWVudHMgc2hvdWxkIGFsd2F5cyBleGlzdC4gSWYgdGhleSBkbyBub3QsXG4vLyB0aGlzIGNvZGUgc2hvdWxkIGZhaWwuXG52YXIgYW5jaG9yRWxlbWVudD1kb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcjX19uZXh0X2Nzc19fRE9fTk9UX1VTRV9fJyk7dmFyIHBhcmVudE5vZGU9YW5jaG9yRWxlbWVudC5wYXJlbnROb2RlOy8vIE5vcm1hbGx5IDxoZWFkPlxuLy8gRWFjaCBzdHlsZSB0YWcgc2hvdWxkIGJlIHBsYWNlZCByaWdodCBiZWZvcmUgb3VyXG4vLyBhbmNob3IuIEJ5IGluc2VydGluZyBiZWZvcmUgYW5kIG5vdCBhZnRlciwgd2UgZG8gbm90XG4vLyBuZWVkIHRvIHRyYWNrIHRoZSBsYXN0IGluc2VydGVkIGVsZW1lbnQuXG5wYXJlbnROb2RlLmluc2VydEJlZm9yZShlbGVtZW50LGFuY2hvckVsZW1lbnQpO307XG5vcHRpb25zLnNpbmdsZXRvbiA9IGZhbHNlO1xuXG52YXIgdXBkYXRlID0gYXBpKGNvbnRlbnQsIG9wdGlvbnMpO1xuXG5cbmlmIChtb2R1bGUuaG90KSB7XG4gIGlmICghY29udGVudC5sb2NhbHMgfHwgbW9kdWxlLmhvdC5pbnZhbGlkYXRlKSB7XG4gICAgdmFyIGlzRXF1YWxMb2NhbHMgPSBmdW5jdGlvbiBpc0VxdWFsTG9jYWxzKGEsYixpc05hbWVkRXhwb3J0KXtpZighYSYmYnx8YSYmIWIpe3JldHVybiBmYWxzZTt9bGV0IHA7Zm9yKHAgaW4gYSl7aWYoaXNOYW1lZEV4cG9ydCYmcD09PSdkZWZhdWx0Jyl7Ly8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnRpbnVlXG5jb250aW51ZTt9aWYoYVtwXSE9PWJbcF0pe3JldHVybiBmYWxzZTt9fWZvcihwIGluIGIpe2lmKGlzTmFtZWRFeHBvcnQmJnA9PT0nZGVmYXVsdCcpey8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb250aW51ZVxuY29udGludWU7fWlmKCFhW3BdKXtyZXR1cm4gZmFsc2U7fX1yZXR1cm4gdHJ1ZTt9O1xuICAgIHZhciBvbGRMb2NhbHMgPSBjb250ZW50LmxvY2FscztcblxuICAgIG1vZHVsZS5ob3QuYWNjZXB0KFxuICAgICAgXCIhIS4uLy4uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvY3NzLWxvYWRlci9janMuanM/P3JlZi0tNS1vbmVPZi0yLTEhLi4vLi4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jb21waWxlZC9wb3N0Y3NzLWxvYWRlci9janMuanM/P3JlZi0tNS1vbmVPZi0yLTIhLi9Db250ZW50TW9kYWwubW9kdWxlLmNzc1wiLFxuICAgICAgZnVuY3Rpb24gKCkge1xuICAgICAgICBjb250ZW50ID0gcmVxdWlyZShcIiEhLi4vLi4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jb21waWxlZC9jc3MtbG9hZGVyL2Nqcy5qcz8/cmVmLS01LW9uZU9mLTItMSEuLi8uLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NvbXBpbGVkL3Bvc3Rjc3MtbG9hZGVyL2Nqcy5qcz8/cmVmLS01LW9uZU9mLTItMiEuL0NvbnRlbnRNb2RhbC5tb2R1bGUuY3NzXCIpO1xuXG4gICAgICAgICAgICAgIGNvbnRlbnQgPSBjb250ZW50Ll9fZXNNb2R1bGUgPyBjb250ZW50LmRlZmF1bHQgOiBjb250ZW50O1xuXG4gICAgICAgICAgICAgIGlmICh0eXBlb2YgY29udGVudCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICBjb250ZW50ID0gW1ttb2R1bGUuaWQsIGNvbnRlbnQsICcnXV07XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBpZiAoIWlzRXF1YWxMb2NhbHMob2xkTG9jYWxzLCBjb250ZW50LmxvY2FscykpIHtcbiAgICAgICAgICAgICAgICBtb2R1bGUuaG90LmludmFsaWRhdGUoKTtcblxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIG9sZExvY2FscyA9IGNvbnRlbnQubG9jYWxzO1xuXG4gICAgICAgICAgICAgIHVwZGF0ZShjb250ZW50KTtcbiAgICAgIH1cbiAgICApXG4gIH1cblxuICBtb2R1bGUuaG90LmRpc3Bvc2UoZnVuY3Rpb24oKSB7XG4gICAgdXBkYXRlKCk7XG4gIH0pO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNvbnRlbnQubG9jYWxzIHx8IHt9OyIsImltcG9ydCBIZWFkIGZyb20gJ25leHQvaGVhZCc7XG5pbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0IGNuIGZyb20gJ0B1dGlscy9jbGFzc25hbWVzJztcbmltcG9ydCB7IG1ldGFUaXRsZSB9IGZyb20gJ0B1dGlscy9tZXRhcyc7XG5pbXBvcnQgeyBMb2FkZXIsIFNoYWRvd0JveCB9IGZyb20gJy4uL2luZGV4JztcbmltcG9ydCBzdHlsZXMgZnJvbSAnLi9Db250ZW50TW9kYWwubW9kdWxlLmNzcyc7XG5cbmNvbnN0IENvbnRlbnRNb2RhbCA9ICh7XG4gIHRpdGxlLFxuICBjaGlsZHJlbixcbiAgb25DbG9zZSxcbiAgY2xhc3NOYW1lID0gJycsXG4gIGxvYWRpbmcgPSBmYWxzZSxcbiAgZnVsbCA9IHRydWUsXG59OiB7XG4gIHRpdGxlOiBzdHJpbmc7XG4gIGNoaWxkcmVuPzogYW55O1xuICBvbkNsb3NlOiBGdW5jdGlvbjtcbiAgY2xhc3NOYW1lPzogc3RyaW5nO1xuICBsb2FkaW5nPzogYm9vbGVhbjtcbiAgZnVsbD86IGJvb2xlYW47XG59KSA9PiAoXG4gIDxSZWFjdC5GcmFnbWVudD5cbiAgICA8SGVhZD5cbiAgICAgIDx0aXRsZT57bWV0YVRpdGxlKHRpdGxlKX08L3RpdGxlPlxuICAgIDwvSGVhZD5cbiAgICA8U2hhZG93Qm94XG4gICAgICB0aXRsZT17dGl0bGV9XG4gICAgICBjbG9zZT17b25DbG9zZX1cbiAgICAgIGNsYXNzTmFtZT17Y24oY2xhc3NOYW1lKX1cbiAgICAgIHNpemU9e2Z1bGwgPyAnbGFyZ2UnIDogJ3NtYWxsJ31cbiAgICA+XG4gICAgICA8ZGl2IGNsYXNzTmFtZT17c3R5bGVzLmNvbnRlbnR9PlxuICAgICAgICB7bG9hZGluZyA/IDxMb2FkZXIgY2xhc3NOYW1lPXtzdHlsZXMubG9hZGVyfSAvPiA6IGNoaWxkcmVufVxuICAgICAgPC9kaXY+XG4gICAgPC9TaGFkb3dCb3g+XG4gIDwvUmVhY3QuRnJhZ21lbnQ+XG4pO1xuXG5leHBvcnQgZGVmYXVsdCBDb250ZW50TW9kYWw7XG4iLCJpbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsgdXNlRm9ybUNvbnRleHQgfSBmcm9tICdyZWFjdC1ob29rLWZvcm0nO1xuXG5leHBvcnQgY29uc3QgQ29ubmVjdEZvcm0gPSAoeyBjaGlsZHJlbiB9KSA9PiB7XG4gIGNvbnN0IG1ldGhvZHMgPSB1c2VGb3JtQ29udGV4dCgpO1xuXG4gIHJldHVybiBjaGlsZHJlbih7XG4gICAgLi4ubWV0aG9kcyxcbiAgfSk7XG59O1xuIiwiaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IHVzZUZvcm0sIEZvcm1Db250ZXh0IH0gZnJvbSAncmVhY3QtaG9vay1mb3JtJztcblxuY29uc3QgRm9ybSA9ICh7XG4gIG9uU3VibWl0LFxuICBjbGFzc05hbWUsXG4gIGNoaWxkcmVuLFxuICAuLi5wcm9wc1xufToge1xuICBvblN1Ym1pdDogRnVuY3Rpb247XG4gIGNsYXNzTmFtZT86IHN0cmluZztcbiAgY2hpbGRyZW4/OiBhbnk7XG59KSA9PiB7XG4gIC8vIEB0cy1pZ25vcmVcbiAgY29uc3QgbWV0aG9kcyA9IHVzZUZvcm0oKTtcblxuICByZXR1cm4gKFxuICAgIDxGb3JtQ29udGV4dCB7Li4ubWV0aG9kc30+XG4gICAgICA8Zm9ybVxuICAgICAgICBvblN1Ym1pdD17bWV0aG9kcy5oYW5kbGVTdWJtaXQoKHYpID0+IG9uU3VibWl0KHYpKX1cbiAgICAgICAgY2xhc3NOYW1lPXtgJHtjbGFzc05hbWV9IGZvcm1gfVxuICAgICAgICB7Li4ucHJvcHN9XG4gICAgICA+XG4gICAgICAgIHtjaGlsZHJlbn1cbiAgICAgIDwvZm9ybT5cbiAgICA8L0Zvcm1Db250ZXh0PlxuICApO1xufTtcblxuZXhwb3J0IGRlZmF1bHQgRm9ybTtcbiIsInZhciBhcGkgPSByZXF1aXJlKFwiIS4uLy4uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvYnVpbGQvd2VicGFjay9sb2FkZXJzL25leHQtc3R5bGUtbG9hZGVyL3J1bnRpbWUvaW5qZWN0U3R5bGVzSW50b1N0eWxlVGFnLmpzXCIpO1xuICAgICAgICAgICAgdmFyIGNvbnRlbnQgPSByZXF1aXJlKFwiISEuLi8uLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NvbXBpbGVkL2Nzcy1sb2FkZXIvY2pzLmpzPz9yZWYtLTUtb25lT2YtMi0xIS4uLy4uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvcG9zdGNzcy1sb2FkZXIvY2pzLmpzPz9yZWYtLTUtb25lT2YtMi0yIS4vRm9ybUNvbnRyb2xzLm1vZHVsZS5jc3NcIik7XG5cbiAgICAgICAgICAgIGNvbnRlbnQgPSBjb250ZW50Ll9fZXNNb2R1bGUgPyBjb250ZW50LmRlZmF1bHQgOiBjb250ZW50O1xuXG4gICAgICAgICAgICBpZiAodHlwZW9mIGNvbnRlbnQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgIGNvbnRlbnQgPSBbW21vZHVsZS5pZCwgY29udGVudCwgJyddXTtcbiAgICAgICAgICAgIH1cblxudmFyIG9wdGlvbnMgPSB7fTtcblxub3B0aW9ucy5pbnNlcnQgPSBmdW5jdGlvbihlbGVtZW50KXsvLyBUaGVzZSBlbGVtZW50cyBzaG91bGQgYWx3YXlzIGV4aXN0LiBJZiB0aGV5IGRvIG5vdCxcbi8vIHRoaXMgY29kZSBzaG91bGQgZmFpbC5cbnZhciBhbmNob3JFbGVtZW50PWRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJyNfX25leHRfY3NzX19ET19OT1RfVVNFX18nKTt2YXIgcGFyZW50Tm9kZT1hbmNob3JFbGVtZW50LnBhcmVudE5vZGU7Ly8gTm9ybWFsbHkgPGhlYWQ+XG4vLyBFYWNoIHN0eWxlIHRhZyBzaG91bGQgYmUgcGxhY2VkIHJpZ2h0IGJlZm9yZSBvdXJcbi8vIGFuY2hvci4gQnkgaW5zZXJ0aW5nIGJlZm9yZSBhbmQgbm90IGFmdGVyLCB3ZSBkbyBub3Rcbi8vIG5lZWQgdG8gdHJhY2sgdGhlIGxhc3QgaW5zZXJ0ZWQgZWxlbWVudC5cbnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKGVsZW1lbnQsYW5jaG9yRWxlbWVudCk7fTtcbm9wdGlvbnMuc2luZ2xldG9uID0gZmFsc2U7XG5cbnZhciB1cGRhdGUgPSBhcGkoY29udGVudCwgb3B0aW9ucyk7XG5cblxuaWYgKG1vZHVsZS5ob3QpIHtcbiAgaWYgKCFjb250ZW50LmxvY2FscyB8fCBtb2R1bGUuaG90LmludmFsaWRhdGUpIHtcbiAgICB2YXIgaXNFcXVhbExvY2FscyA9IGZ1bmN0aW9uIGlzRXF1YWxMb2NhbHMoYSxiLGlzTmFtZWRFeHBvcnQpe2lmKCFhJiZifHxhJiYhYil7cmV0dXJuIGZhbHNlO31sZXQgcDtmb3IocCBpbiBhKXtpZihpc05hbWVkRXhwb3J0JiZwPT09J2RlZmF1bHQnKXsvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29udGludWVcbmNvbnRpbnVlO31pZihhW3BdIT09YltwXSl7cmV0dXJuIGZhbHNlO319Zm9yKHAgaW4gYil7aWYoaXNOYW1lZEV4cG9ydCYmcD09PSdkZWZhdWx0Jyl7Ly8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnRpbnVlXG5jb250aW51ZTt9aWYoIWFbcF0pe3JldHVybiBmYWxzZTt9fXJldHVybiB0cnVlO307XG4gICAgdmFyIG9sZExvY2FscyA9IGNvbnRlbnQubG9jYWxzO1xuXG4gICAgbW9kdWxlLmhvdC5hY2NlcHQoXG4gICAgICBcIiEhLi4vLi4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jb21waWxlZC9jc3MtbG9hZGVyL2Nqcy5qcz8/cmVmLS01LW9uZU9mLTItMSEuLi8uLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NvbXBpbGVkL3Bvc3Rjc3MtbG9hZGVyL2Nqcy5qcz8/cmVmLS01LW9uZU9mLTItMiEuL0Zvcm1Db250cm9scy5tb2R1bGUuY3NzXCIsXG4gICAgICBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGNvbnRlbnQgPSByZXF1aXJlKFwiISEuLi8uLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NvbXBpbGVkL2Nzcy1sb2FkZXIvY2pzLmpzPz9yZWYtLTUtb25lT2YtMi0xIS4uLy4uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvcG9zdGNzcy1sb2FkZXIvY2pzLmpzPz9yZWYtLTUtb25lT2YtMi0yIS4vRm9ybUNvbnRyb2xzLm1vZHVsZS5jc3NcIik7XG5cbiAgICAgICAgICAgICAgY29udGVudCA9IGNvbnRlbnQuX19lc01vZHVsZSA/IGNvbnRlbnQuZGVmYXVsdCA6IGNvbnRlbnQ7XG5cbiAgICAgICAgICAgICAgaWYgKHR5cGVvZiBjb250ZW50ID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIGNvbnRlbnQgPSBbW21vZHVsZS5pZCwgY29udGVudCwgJyddXTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGlmICghaXNFcXVhbExvY2FscyhvbGRMb2NhbHMsIGNvbnRlbnQubG9jYWxzKSkge1xuICAgICAgICAgICAgICAgIG1vZHVsZS5ob3QuaW52YWxpZGF0ZSgpO1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgb2xkTG9jYWxzID0gY29udGVudC5sb2NhbHM7XG5cbiAgICAgICAgICAgICAgdXBkYXRlKGNvbnRlbnQpO1xuICAgICAgfVxuICAgIClcbiAgfVxuXG4gIG1vZHVsZS5ob3QuZGlzcG9zZShmdW5jdGlvbigpIHtcbiAgICB1cGRhdGUoKTtcbiAgfSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gY29udGVudC5sb2NhbHMgfHwge307IiwiaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCBjbiBmcm9tICdAdXRpbHMvY2xhc3NuYW1lcyc7XG5pbXBvcnQgc3R5bGVzIGZyb20gJy4vRm9ybUNvbnRyb2xzLm1vZHVsZS5jc3MnO1xuXG5jb25zdCBGb3JtQ29udHJvbHMgPSAoe1xuICBjbGFzc05hbWUgPSAnJyxcbiAgY2hpbGRyZW4sXG59OiB7XG4gIGNsYXNzTmFtZT86IHN0cmluZztcbiAgY2hpbGRyZW4/OiBhbnk7XG59KSA9PiB7XG4gIHJldHVybiA8ZGl2IGNsYXNzTmFtZT17Y24oc3R5bGVzLnJvb3QsIGNsYXNzTmFtZSl9PntjaGlsZHJlbn08L2Rpdj47XG59O1xuXG5leHBvcnQgZGVmYXVsdCBGb3JtQ29udHJvbHM7XG4iLCJpbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsgQ29ubmVjdEZvcm0gfSBmcm9tICcuL0Nvbm5lY3RGb3JtJztcbmltcG9ydCBzdHlsZXMgZnJvbSAnLi9Gb3JtRmllbGQubW9kdWxlLmNzcyc7XG5pbXBvcnQgSW5wdXRUZXh0IGZyb20gJy4vSW5wdXQnO1xuXG5jb25zdCBGb3JtRmllbGQgPSAoe1xuICBuYW1lLFxuICBsYWJlbCxcbiAgY29tcG9uZW50ID0gSW5wdXRUZXh0LFxuICByZWdpc3RlcjogZmllbGRSZWdpc3RlcixcbiAgY2xhc3NOYW1lID0gJycsXG4gIGNsYXNzTmFtZUxhYmVsID0gJycsXG4gIGNsYXNzTmFtZUlucHV0ID0gJycsXG4gIHdpZGUgPSBmYWxzZSxcbiAgLi4ucHJvcHNcbn06IHtcbiAgbmFtZTogc3RyaW5nO1xuICBsYWJlbDogc3RyaW5nO1xuICBjb21wb25lbnQ/OiBhbnk7XG4gIHJlZ2lzdGVyPzogYW55O1xuICBjbGFzc05hbWU/OiBzdHJpbmc7XG4gIGNsYXNzTmFtZUxhYmVsPzogc3RyaW5nO1xuICBjbGFzc05hbWVJbnB1dD86IHN0cmluZztcbiAgd2lkZT86IGJvb2xlYW47XG4gIFtrOiBzdHJpbmddOiBhbnk7XG59KSA9PiAoXG4gIDxDb25uZWN0Rm9ybT5cbiAgICB7KHsgcmVnaXN0ZXIsIGVycm9ycyB9KSA9PiB7XG4gICAgICByZXR1cm4gY29tcG9uZW50KHtcbiAgICAgICAgLi4ucHJvcHMsXG4gICAgICAgIG5hbWUsXG4gICAgICAgIGlkOiBuYW1lLFxuICAgICAgICBsYWJlbCxcbiAgICAgICAgcmVmOiByZWdpc3RlcihmaWVsZFJlZ2lzdGVyKSxcbiAgICAgICAgY2xhc3NOYW1lOiBjbGFzc05hbWUsXG4gICAgICAgIGNsYXNzTmFtZUlucHV0OiBjbGFzc05hbWVJbnB1dCxcbiAgICAgICAgY2xhc3NOYW1lTGFiZWw6IGNsYXNzTmFtZUxhYmVsLFxuICAgICAgICBlcnJvcjogZXJyb3JzW25hbWVdID8gZXJyb3JzW25hbWVdLm1lc3NhZ2UgOiAnJyxcbiAgICAgIH0pO1xuICAgIH19XG4gIDwvQ29ubmVjdEZvcm0+XG4pO1xuXG5leHBvcnQgZGVmYXVsdCBGb3JtRmllbGQ7XG4iLCJ2YXIgYXBpID0gcmVxdWlyZShcIiEuLi8uLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2J1aWxkL3dlYnBhY2svbG9hZGVycy9uZXh0LXN0eWxlLWxvYWRlci9ydW50aW1lL2luamVjdFN0eWxlc0ludG9TdHlsZVRhZy5qc1wiKTtcbiAgICAgICAgICAgIHZhciBjb250ZW50ID0gcmVxdWlyZShcIiEhLi4vLi4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jb21waWxlZC9jc3MtbG9hZGVyL2Nqcy5qcz8/cmVmLS01LW9uZU9mLTItMSEuLi8uLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NvbXBpbGVkL3Bvc3Rjc3MtbG9hZGVyL2Nqcy5qcz8/cmVmLS01LW9uZU9mLTItMiEuL0Zvcm1GaWVsZHNldC5tb2R1bGUuY3NzXCIpO1xuXG4gICAgICAgICAgICBjb250ZW50ID0gY29udGVudC5fX2VzTW9kdWxlID8gY29udGVudC5kZWZhdWx0IDogY29udGVudDtcblxuICAgICAgICAgICAgaWYgKHR5cGVvZiBjb250ZW50ID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICBjb250ZW50ID0gW1ttb2R1bGUuaWQsIGNvbnRlbnQsICcnXV07XG4gICAgICAgICAgICB9XG5cbnZhciBvcHRpb25zID0ge307XG5cbm9wdGlvbnMuaW5zZXJ0ID0gZnVuY3Rpb24oZWxlbWVudCl7Ly8gVGhlc2UgZWxlbWVudHMgc2hvdWxkIGFsd2F5cyBleGlzdC4gSWYgdGhleSBkbyBub3QsXG4vLyB0aGlzIGNvZGUgc2hvdWxkIGZhaWwuXG52YXIgYW5jaG9yRWxlbWVudD1kb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcjX19uZXh0X2Nzc19fRE9fTk9UX1VTRV9fJyk7dmFyIHBhcmVudE5vZGU9YW5jaG9yRWxlbWVudC5wYXJlbnROb2RlOy8vIE5vcm1hbGx5IDxoZWFkPlxuLy8gRWFjaCBzdHlsZSB0YWcgc2hvdWxkIGJlIHBsYWNlZCByaWdodCBiZWZvcmUgb3VyXG4vLyBhbmNob3IuIEJ5IGluc2VydGluZyBiZWZvcmUgYW5kIG5vdCBhZnRlciwgd2UgZG8gbm90XG4vLyBuZWVkIHRvIHRyYWNrIHRoZSBsYXN0IGluc2VydGVkIGVsZW1lbnQuXG5wYXJlbnROb2RlLmluc2VydEJlZm9yZShlbGVtZW50LGFuY2hvckVsZW1lbnQpO307XG5vcHRpb25zLnNpbmdsZXRvbiA9IGZhbHNlO1xuXG52YXIgdXBkYXRlID0gYXBpKGNvbnRlbnQsIG9wdGlvbnMpO1xuXG5cbmlmIChtb2R1bGUuaG90KSB7XG4gIGlmICghY29udGVudC5sb2NhbHMgfHwgbW9kdWxlLmhvdC5pbnZhbGlkYXRlKSB7XG4gICAgdmFyIGlzRXF1YWxMb2NhbHMgPSBmdW5jdGlvbiBpc0VxdWFsTG9jYWxzKGEsYixpc05hbWVkRXhwb3J0KXtpZighYSYmYnx8YSYmIWIpe3JldHVybiBmYWxzZTt9bGV0IHA7Zm9yKHAgaW4gYSl7aWYoaXNOYW1lZEV4cG9ydCYmcD09PSdkZWZhdWx0Jyl7Ly8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnRpbnVlXG5jb250aW51ZTt9aWYoYVtwXSE9PWJbcF0pe3JldHVybiBmYWxzZTt9fWZvcihwIGluIGIpe2lmKGlzTmFtZWRFeHBvcnQmJnA9PT0nZGVmYXVsdCcpey8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb250aW51ZVxuY29udGludWU7fWlmKCFhW3BdKXtyZXR1cm4gZmFsc2U7fX1yZXR1cm4gdHJ1ZTt9O1xuICAgIHZhciBvbGRMb2NhbHMgPSBjb250ZW50LmxvY2FscztcblxuICAgIG1vZHVsZS5ob3QuYWNjZXB0KFxuICAgICAgXCIhIS4uLy4uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvY3NzLWxvYWRlci9janMuanM/P3JlZi0tNS1vbmVPZi0yLTEhLi4vLi4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jb21waWxlZC9wb3N0Y3NzLWxvYWRlci9janMuanM/P3JlZi0tNS1vbmVPZi0yLTIhLi9Gb3JtRmllbGRzZXQubW9kdWxlLmNzc1wiLFxuICAgICAgZnVuY3Rpb24gKCkge1xuICAgICAgICBjb250ZW50ID0gcmVxdWlyZShcIiEhLi4vLi4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jb21waWxlZC9jc3MtbG9hZGVyL2Nqcy5qcz8/cmVmLS01LW9uZU9mLTItMSEuLi8uLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NvbXBpbGVkL3Bvc3Rjc3MtbG9hZGVyL2Nqcy5qcz8/cmVmLS01LW9uZU9mLTItMiEuL0Zvcm1GaWVsZHNldC5tb2R1bGUuY3NzXCIpO1xuXG4gICAgICAgICAgICAgIGNvbnRlbnQgPSBjb250ZW50Ll9fZXNNb2R1bGUgPyBjb250ZW50LmRlZmF1bHQgOiBjb250ZW50O1xuXG4gICAgICAgICAgICAgIGlmICh0eXBlb2YgY29udGVudCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICBjb250ZW50ID0gW1ttb2R1bGUuaWQsIGNvbnRlbnQsICcnXV07XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBpZiAoIWlzRXF1YWxMb2NhbHMob2xkTG9jYWxzLCBjb250ZW50LmxvY2FscykpIHtcbiAgICAgICAgICAgICAgICBtb2R1bGUuaG90LmludmFsaWRhdGUoKTtcblxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIG9sZExvY2FscyA9IGNvbnRlbnQubG9jYWxzO1xuXG4gICAgICAgICAgICAgIHVwZGF0ZShjb250ZW50KTtcbiAgICAgIH1cbiAgICApXG4gIH1cblxuICBtb2R1bGUuaG90LmRpc3Bvc2UoZnVuY3Rpb24oKSB7XG4gICAgdXBkYXRlKCk7XG4gIH0pO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNvbnRlbnQubG9jYWxzIHx8IHt9OyIsImltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgY24gZnJvbSAnQHV0aWxzL2NsYXNzbmFtZXMnO1xuaW1wb3J0IHN0eWxlcyBmcm9tICcuL0Zvcm1GaWVsZHNldC5tb2R1bGUuY3NzJztcblxuY29uc3QgRm9ybUZpZWxkc2V0ID0gKHtcbiAgY2xhc3NOYW1lID0gJycsXG4gIGxhYmVsID0gJycsXG4gIGNoaWxkcmVuLFxuICBzdGFja2VkID0gZmFsc2UsXG59OiB7XG4gIGNsYXNzTmFtZT86IHN0cmluZztcbiAgbGFiZWw/OiBzdHJpbmc7XG4gIGNoaWxkcmVuPzogYW55O1xuICBzdGFja2VkPzogYm9vbGVhbjtcbn0pID0+IChcbiAgPGRpdlxuICAgIGNsYXNzTmFtZT17Y24oc3R5bGVzLnJvb3QsIGNsYXNzTmFtZSwge1xuICAgICAgW3N0eWxlcy5pc1N0YWNrZWRdOiBzdGFja2VkLFxuICAgIH0pfVxuICA+XG4gICAge2xhYmVsICE9PSAnJyAmJiA8aDIgY2xhc3NOYW1lPXtzdHlsZXMubGFiZWx9PntsYWJlbH08L2gyPn1cbiAgICA8ZGl2IGNsYXNzTmFtZT17c3R5bGVzLmZpZWxkc30+e2NoaWxkcmVufTwvZGl2PlxuICA8L2Rpdj5cbik7XG5cbmV4cG9ydCBkZWZhdWx0IEZvcm1GaWVsZHNldDtcbiIsInZhciBhcGkgPSByZXF1aXJlKFwiIS4uLy4uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvYnVpbGQvd2VicGFjay9sb2FkZXJzL25leHQtc3R5bGUtbG9hZGVyL3J1bnRpbWUvaW5qZWN0U3R5bGVzSW50b1N0eWxlVGFnLmpzXCIpO1xuICAgICAgICAgICAgdmFyIGNvbnRlbnQgPSByZXF1aXJlKFwiISEuLi8uLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NvbXBpbGVkL2Nzcy1sb2FkZXIvY2pzLmpzPz9yZWYtLTUtb25lT2YtMi0xIS4uLy4uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvcG9zdGNzcy1sb2FkZXIvY2pzLmpzPz9yZWYtLTUtb25lT2YtMi0yIS4vSW5wdXQubW9kdWxlLmNzc1wiKTtcblxuICAgICAgICAgICAgY29udGVudCA9IGNvbnRlbnQuX19lc01vZHVsZSA/IGNvbnRlbnQuZGVmYXVsdCA6IGNvbnRlbnQ7XG5cbiAgICAgICAgICAgIGlmICh0eXBlb2YgY29udGVudCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgY29udGVudCA9IFtbbW9kdWxlLmlkLCBjb250ZW50LCAnJ11dO1xuICAgICAgICAgICAgfVxuXG52YXIgb3B0aW9ucyA9IHt9O1xuXG5vcHRpb25zLmluc2VydCA9IGZ1bmN0aW9uKGVsZW1lbnQpey8vIFRoZXNlIGVsZW1lbnRzIHNob3VsZCBhbHdheXMgZXhpc3QuIElmIHRoZXkgZG8gbm90LFxuLy8gdGhpcyBjb2RlIHNob3VsZCBmYWlsLlxudmFyIGFuY2hvckVsZW1lbnQ9ZG9jdW1lbnQucXVlcnlTZWxlY3RvcignI19fbmV4dF9jc3NfX0RPX05PVF9VU0VfXycpO3ZhciBwYXJlbnROb2RlPWFuY2hvckVsZW1lbnQucGFyZW50Tm9kZTsvLyBOb3JtYWxseSA8aGVhZD5cbi8vIEVhY2ggc3R5bGUgdGFnIHNob3VsZCBiZSBwbGFjZWQgcmlnaHQgYmVmb3JlIG91clxuLy8gYW5jaG9yLiBCeSBpbnNlcnRpbmcgYmVmb3JlIGFuZCBub3QgYWZ0ZXIsIHdlIGRvIG5vdFxuLy8gbmVlZCB0byB0cmFjayB0aGUgbGFzdCBpbnNlcnRlZCBlbGVtZW50LlxucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUoZWxlbWVudCxhbmNob3JFbGVtZW50KTt9O1xub3B0aW9ucy5zaW5nbGV0b24gPSBmYWxzZTtcblxudmFyIHVwZGF0ZSA9IGFwaShjb250ZW50LCBvcHRpb25zKTtcblxuXG5pZiAobW9kdWxlLmhvdCkge1xuICBpZiAoIWNvbnRlbnQubG9jYWxzIHx8IG1vZHVsZS5ob3QuaW52YWxpZGF0ZSkge1xuICAgIHZhciBpc0VxdWFsTG9jYWxzID0gZnVuY3Rpb24gaXNFcXVhbExvY2FscyhhLGIsaXNOYW1lZEV4cG9ydCl7aWYoIWEmJmJ8fGEmJiFiKXtyZXR1cm4gZmFsc2U7fWxldCBwO2ZvcihwIGluIGEpe2lmKGlzTmFtZWRFeHBvcnQmJnA9PT0nZGVmYXVsdCcpey8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb250aW51ZVxuY29udGludWU7fWlmKGFbcF0hPT1iW3BdKXtyZXR1cm4gZmFsc2U7fX1mb3IocCBpbiBiKXtpZihpc05hbWVkRXhwb3J0JiZwPT09J2RlZmF1bHQnKXsvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29udGludWVcbmNvbnRpbnVlO31pZighYVtwXSl7cmV0dXJuIGZhbHNlO319cmV0dXJuIHRydWU7fTtcbiAgICB2YXIgb2xkTG9jYWxzID0gY29udGVudC5sb2NhbHM7XG5cbiAgICBtb2R1bGUuaG90LmFjY2VwdChcbiAgICAgIFwiISEuLi8uLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NvbXBpbGVkL2Nzcy1sb2FkZXIvY2pzLmpzPz9yZWYtLTUtb25lT2YtMi0xIS4uLy4uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvcG9zdGNzcy1sb2FkZXIvY2pzLmpzPz9yZWYtLTUtb25lT2YtMi0yIS4vSW5wdXQubW9kdWxlLmNzc1wiLFxuICAgICAgZnVuY3Rpb24gKCkge1xuICAgICAgICBjb250ZW50ID0gcmVxdWlyZShcIiEhLi4vLi4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jb21waWxlZC9jc3MtbG9hZGVyL2Nqcy5qcz8/cmVmLS01LW9uZU9mLTItMSEuLi8uLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NvbXBpbGVkL3Bvc3Rjc3MtbG9hZGVyL2Nqcy5qcz8/cmVmLS01LW9uZU9mLTItMiEuL0lucHV0Lm1vZHVsZS5jc3NcIik7XG5cbiAgICAgICAgICAgICAgY29udGVudCA9IGNvbnRlbnQuX19lc01vZHVsZSA/IGNvbnRlbnQuZGVmYXVsdCA6IGNvbnRlbnQ7XG5cbiAgICAgICAgICAgICAgaWYgKHR5cGVvZiBjb250ZW50ID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIGNvbnRlbnQgPSBbW21vZHVsZS5pZCwgY29udGVudCwgJyddXTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGlmICghaXNFcXVhbExvY2FscyhvbGRMb2NhbHMsIGNvbnRlbnQubG9jYWxzKSkge1xuICAgICAgICAgICAgICAgIG1vZHVsZS5ob3QuaW52YWxpZGF0ZSgpO1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgb2xkTG9jYWxzID0gY29udGVudC5sb2NhbHM7XG5cbiAgICAgICAgICAgICAgdXBkYXRlKGNvbnRlbnQpO1xuICAgICAgfVxuICAgIClcbiAgfVxuXG4gIG1vZHVsZS5ob3QuZGlzcG9zZShmdW5jdGlvbigpIHtcbiAgICB1cGRhdGUoKTtcbiAgfSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gY29udGVudC5sb2NhbHMgfHwge307IiwiaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCBjbiBmcm9tICdAdXRpbHMvY2xhc3NuYW1lcyc7XG5pbXBvcnQgc3R5bGVzIGZyb20gJy4vSW5wdXQubW9kdWxlLmNzcyc7XG5cbmNvbnN0IElucHV0ID0gKHtcbiAgbmFtZSxcbiAgaWQsXG4gIGxhYmVsLFxuICBjbGFzc05hbWUgPSAnJyxcbiAgY2xhc3NOYW1lTGFiZWwgPSAnJyxcbiAgY2xhc3NOYW1lSW5wdXQgPSAnJyxcbiAgdHlwZSA9ICd0ZXh0JyxcbiAgc3VidHlwZSA9ICd0ZXh0JyxcbiAgdmFsdWU6IGluaXRpYWxWYWx1ZSA9ICcnLFxuICBjaG9pY2VzID0ge30sXG4gIGVycm9yID0gJycsXG4gIG9uQ2hhbmdlID0gKCkgPT4ge30sXG4gIG9uVmFsdWVDaGFuZ2VkID0gKCkgPT4ge30sXG4gIC4uLnByb3BzXG59OiB7XG4gIG5hbWU6IHN0cmluZztcbiAgaWQ6IHN0cmluZztcbiAgY2xhc3NOYW1lPzogc3RyaW5nO1xuICBjbGFzc05hbWVMYWJlbD86IHN0cmluZztcbiAgY2xhc3NOYW1lSW5wdXQ/OiBzdHJpbmc7XG4gIGxhYmVsOiBzdHJpbmc7XG4gIHR5cGU/OiAndGV4dCcgfCAndGV4dGFyZWEnIHwgJ3NlbGVjdCc7XG4gIHN1YnR5cGU/OiBzdHJpbmc7XG4gIHZhbHVlPzogc3RyaW5nO1xuICBjaG9pY2VzPzoge1xuICAgIFtrOiBzdHJpbmddOiBzdHJpbmc7XG4gIH07XG4gIGVycm9yPzogc3RyaW5nO1xuICBvbkNoYW5nZT86IEZ1bmN0aW9uO1xuICBvblZhbHVlQ2hhbmdlZD86IEZ1bmN0aW9uO1xuICBbazogc3RyaW5nXTogYW55O1xufSkgPT4ge1xuICBjb25zdCBbdmFsdWUsIHNldFZhbHVlXSA9IFJlYWN0LnVzZVN0YXRlKGluaXRpYWxWYWx1ZSk7XG4gIGNvbnN0IHByZXZWYWx1ZSA9IFJlYWN0LnVzZVJlZihudWxsKTtcblxuICBjb25zdCBpbnB1dFByb3BzID0ge1xuICAgIC4uLnByb3BzLFxuICAgIGNsYXNzTmFtZTogY24oXG4gICAgICBjbGFzc05hbWVJbnB1dCxcbiAgICAgIHN0eWxlcy5lbGVtZW50LFxuICAgICAgYGlucHV0X19lbGVtZW50LS0ke3R5cGV9YCxcbiAgICAgIGBpbnB1dF9fZWxlbWVudC0tJHtcbiAgICAgICAgdmFsdWUgIT09ICcnIHx8XG4gICAgICAgICh0eXBlID09PSAnc2VsZWN0JyAmJlxuICAgICAgICAgIE9iamVjdC52YWx1ZXMoY2hvaWNlcykubGVuZ3RoICYmXG4gICAgICAgICAgT2JqZWN0LnZhbHVlcyhjaG9pY2VzKVswXSAhPT0gJycpXG4gICAgICAgICAgPyAndmFsdWUnXG4gICAgICAgICAgOiAnZW1wdHknXG4gICAgICB9YFxuICAgICksXG4gICAgbmFtZSxcbiAgICBpZCxcbiAgICBvbkNoYW5nZTogKGUpID0+IHtcbiAgICAgIG9uQ2hhbmdlKGUpO1xuICAgICAgc2V0VmFsdWUoZS50YXJnZXQudmFsdWUpO1xuICAgIH0sXG4gIH07XG5cbiAgUmVhY3QudXNlRWZmZWN0KCgpID0+IHtcbiAgICBvblZhbHVlQ2hhbmdlZCAmJiBvblZhbHVlQ2hhbmdlZCh2YWx1ZSwgcHJldlZhbHVlLmN1cnJlbnQpO1xuICAgIHByZXZWYWx1ZS5jdXJyZW50ID0gdmFsdWU7XG4gIH0sIFt2YWx1ZV0pO1xuXG4gIHJldHVybiAoXG4gICAgPGRpdlxuICAgICAgY2xhc3NOYW1lPXtjbihjbGFzc05hbWUsIHN0eWxlcy5yb290LCB7XG4gICAgICAgIFtzdHlsZXMuaXNFcnJvcl06IGVycm9yICE9PSAnJyxcbiAgICAgIH0pfVxuICAgID5cbiAgICAgIDxsYWJlbCBjbGFzc05hbWU9e2NuKGNsYXNzTmFtZUxhYmVsLCBzdHlsZXMubGFiZWwpfSBodG1sRm9yPXtpZH0+XG4gICAgICAgIHtsYWJlbH1cbiAgICAgIDwvbGFiZWw+XG4gICAgICB7dHlwZSA9PT0gJ3RleHRhcmVhJyAmJiA8dGV4dGFyZWEgey4uLmlucHV0UHJvcHN9Pnt2YWx1ZX08L3RleHRhcmVhPn1cbiAgICAgIHt0eXBlID09PSAndGV4dCcgJiYgKFxuICAgICAgICA8aW5wdXQgdHlwZT17c3VidHlwZX0gey4uLmlucHV0UHJvcHN9IHsuLi4odmFsdWUgPyB7IHZhbHVlIH0gOiB7fSl9IC8+XG4gICAgICApfVxuICAgICAge3R5cGUgPT09ICdzZWxlY3QnICYmIChcbiAgICAgICAgPHNlbGVjdCB7Li4uaW5wdXRQcm9wc30+XG4gICAgICAgICAge09iamVjdC5lbnRyaWVzKGNob2ljZXMpLm1hcCgoW2tleSwgdmFsXSkgPT4gKFxuICAgICAgICAgICAgPG9wdGlvbiBrZXk9e2tleX0gc2VsZWN0ZWQ9e2tleSA9PT0gdmFsdWV9PlxuICAgICAgICAgICAgICB7dmFsfVxuICAgICAgICAgICAgPC9vcHRpb24+XG4gICAgICAgICAgKSl9XG4gICAgICAgIDwvc2VsZWN0PlxuICAgICAgKX1cbiAgICAgIHtlcnJvciAhPT0gJycgJiYgPHNwYW4gY2xhc3NOYW1lPXtzdHlsZXMuZXJyb3J9PntlcnJvcn08L3NwYW4+fVxuICAgIDwvZGl2PlxuICApO1xufTtcblxuZXhwb3J0IGRlZmF1bHQgSW5wdXQ7XG4iLCJpbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xyXG5pbXBvcnQgSW5wdXQgZnJvbSAnLi9JbnB1dCc7XHJcblxyXG5jb25zdCBJbnB1dFNlbGVjdCA9IHByb3BzID0+XHJcbiAgSW5wdXQoe1xyXG4gICAgLi4ucHJvcHMsXHJcbiAgICB0eXBlOiAnc2VsZWN0JyxcclxuICAgIHZhbHVlOiBwcm9wcy52YWx1ZSBpbiBwcm9wcy5jaG9pY2VzID8gcHJvcHMudmFsdWUgOiAnJyxcclxuICB9KTtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IElucHV0U2VsZWN0O1xyXG4iLCJpbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0IElucHV0IGZyb20gJy4vSW5wdXQnO1xuXG5jb25zdCBJbnB1dFRleHQgPSBwcm9wcyA9PlxuICBJbnB1dCh7IC4uLnByb3BzLCB0eXBlOiAndGV4dCcsIHN1YnR5cGU6IHByb3BzLnR5cGUgfSk7XG5cbmV4cG9ydCBkZWZhdWx0IElucHV0VGV4dDtcbiIsImltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XHJcbmltcG9ydCBJbnB1dCBmcm9tICcuL0lucHV0JztcclxuXHJcbmNvbnN0IElucHV0VGV4dGFyZWEgPSBwcm9wcyA9PlxyXG4gIElucHV0KHsgLi4ucHJvcHMsIHR5cGU6ICd0ZXh0YXJlYScsIHN1YnR5cGU6IHByb3BzLnR5cGUgfSk7XHJcblxyXG5leHBvcnQgZGVmYXVsdCBJbnB1dFRleHRhcmVhO1xyXG4iLCJ2YXIgYXBpID0gcmVxdWlyZShcIiEuLi8uLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2J1aWxkL3dlYnBhY2svbG9hZGVycy9uZXh0LXN0eWxlLWxvYWRlci9ydW50aW1lL2luamVjdFN0eWxlc0ludG9TdHlsZVRhZy5qc1wiKTtcbiAgICAgICAgICAgIHZhciBjb250ZW50ID0gcmVxdWlyZShcIiEhLi4vLi4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jb21waWxlZC9jc3MtbG9hZGVyL2Nqcy5qcz8/cmVmLS01LW9uZU9mLTItMSEuLi8uLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NvbXBpbGVkL3Bvc3Rjc3MtbG9hZGVyL2Nqcy5qcz8/cmVmLS01LW9uZU9mLTItMiEuL0xhenlJbWFnZS5tb2R1bGUuY3NzXCIpO1xuXG4gICAgICAgICAgICBjb250ZW50ID0gY29udGVudC5fX2VzTW9kdWxlID8gY29udGVudC5kZWZhdWx0IDogY29udGVudDtcblxuICAgICAgICAgICAgaWYgKHR5cGVvZiBjb250ZW50ID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICBjb250ZW50ID0gW1ttb2R1bGUuaWQsIGNvbnRlbnQsICcnXV07XG4gICAgICAgICAgICB9XG5cbnZhciBvcHRpb25zID0ge307XG5cbm9wdGlvbnMuaW5zZXJ0ID0gZnVuY3Rpb24oZWxlbWVudCl7Ly8gVGhlc2UgZWxlbWVudHMgc2hvdWxkIGFsd2F5cyBleGlzdC4gSWYgdGhleSBkbyBub3QsXG4vLyB0aGlzIGNvZGUgc2hvdWxkIGZhaWwuXG52YXIgYW5jaG9yRWxlbWVudD1kb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcjX19uZXh0X2Nzc19fRE9fTk9UX1VTRV9fJyk7dmFyIHBhcmVudE5vZGU9YW5jaG9yRWxlbWVudC5wYXJlbnROb2RlOy8vIE5vcm1hbGx5IDxoZWFkPlxuLy8gRWFjaCBzdHlsZSB0YWcgc2hvdWxkIGJlIHBsYWNlZCByaWdodCBiZWZvcmUgb3VyXG4vLyBhbmNob3IuIEJ5IGluc2VydGluZyBiZWZvcmUgYW5kIG5vdCBhZnRlciwgd2UgZG8gbm90XG4vLyBuZWVkIHRvIHRyYWNrIHRoZSBsYXN0IGluc2VydGVkIGVsZW1lbnQuXG5wYXJlbnROb2RlLmluc2VydEJlZm9yZShlbGVtZW50LGFuY2hvckVsZW1lbnQpO307XG5vcHRpb25zLnNpbmdsZXRvbiA9IGZhbHNlO1xuXG52YXIgdXBkYXRlID0gYXBpKGNvbnRlbnQsIG9wdGlvbnMpO1xuXG5cbmlmIChtb2R1bGUuaG90KSB7XG4gIGlmICghY29udGVudC5sb2NhbHMgfHwgbW9kdWxlLmhvdC5pbnZhbGlkYXRlKSB7XG4gICAgdmFyIGlzRXF1YWxMb2NhbHMgPSBmdW5jdGlvbiBpc0VxdWFsTG9jYWxzKGEsYixpc05hbWVkRXhwb3J0KXtpZighYSYmYnx8YSYmIWIpe3JldHVybiBmYWxzZTt9bGV0IHA7Zm9yKHAgaW4gYSl7aWYoaXNOYW1lZEV4cG9ydCYmcD09PSdkZWZhdWx0Jyl7Ly8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnRpbnVlXG5jb250aW51ZTt9aWYoYVtwXSE9PWJbcF0pe3JldHVybiBmYWxzZTt9fWZvcihwIGluIGIpe2lmKGlzTmFtZWRFeHBvcnQmJnA9PT0nZGVmYXVsdCcpey8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb250aW51ZVxuY29udGludWU7fWlmKCFhW3BdKXtyZXR1cm4gZmFsc2U7fX1yZXR1cm4gdHJ1ZTt9O1xuICAgIHZhciBvbGRMb2NhbHMgPSBjb250ZW50LmxvY2FscztcblxuICAgIG1vZHVsZS5ob3QuYWNjZXB0KFxuICAgICAgXCIhIS4uLy4uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvY3NzLWxvYWRlci9janMuanM/P3JlZi0tNS1vbmVPZi0yLTEhLi4vLi4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jb21waWxlZC9wb3N0Y3NzLWxvYWRlci9janMuanM/P3JlZi0tNS1vbmVPZi0yLTIhLi9MYXp5SW1hZ2UubW9kdWxlLmNzc1wiLFxuICAgICAgZnVuY3Rpb24gKCkge1xuICAgICAgICBjb250ZW50ID0gcmVxdWlyZShcIiEhLi4vLi4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jb21waWxlZC9jc3MtbG9hZGVyL2Nqcy5qcz8/cmVmLS01LW9uZU9mLTItMSEuLi8uLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NvbXBpbGVkL3Bvc3Rjc3MtbG9hZGVyL2Nqcy5qcz8/cmVmLS01LW9uZU9mLTItMiEuL0xhenlJbWFnZS5tb2R1bGUuY3NzXCIpO1xuXG4gICAgICAgICAgICAgIGNvbnRlbnQgPSBjb250ZW50Ll9fZXNNb2R1bGUgPyBjb250ZW50LmRlZmF1bHQgOiBjb250ZW50O1xuXG4gICAgICAgICAgICAgIGlmICh0eXBlb2YgY29udGVudCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICBjb250ZW50ID0gW1ttb2R1bGUuaWQsIGNvbnRlbnQsICcnXV07XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBpZiAoIWlzRXF1YWxMb2NhbHMob2xkTG9jYWxzLCBjb250ZW50LmxvY2FscykpIHtcbiAgICAgICAgICAgICAgICBtb2R1bGUuaG90LmludmFsaWRhdGUoKTtcblxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIG9sZExvY2FscyA9IGNvbnRlbnQubG9jYWxzO1xuXG4gICAgICAgICAgICAgIHVwZGF0ZShjb250ZW50KTtcbiAgICAgIH1cbiAgICApXG4gIH1cblxuICBtb2R1bGUuaG90LmRpc3Bvc2UoZnVuY3Rpb24oKSB7XG4gICAgdXBkYXRlKCk7XG4gIH0pO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNvbnRlbnQubG9jYWxzIHx8IHt9OyIsIi8vIEB0cy1pZ25vcmVcblxuLypcbmltcG9ydCBsYXp5U2l6ZXMgZnJvbSAnbGF6eXNpemVzJztcbmltcG9ydCAnbGF6eXNpemVzL3BsdWdpbnMvYXR0cmNoYW5nZS9scy5hdHRyY2hhbmdlJztcbmltcG9ydCAnbGF6eXNpemVzL3BsdWdpbnMvYmdzZXQvbHMuYmdzZXQnO1xuaW1wb3J0ICdsYXp5c2l6ZXMvcGx1Z2lucy9yZXNwaW1nL2xzLnJlc3BpbWcnOyovXG5pbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsgQXBpSW1hZ2UgfSBmcm9tICdAY29tcHMvdHlwZXMnO1xuaW1wb3J0IGNuIGZyb20gJ0B1dGlscy9jbGFzc25hbWVzJztcbmltcG9ydCBzdHlsZXMgZnJvbSAnLi9MYXp5SW1hZ2UubW9kdWxlLmNzcyc7XG5cbmNvbnN0IEJBU0UgPSAnbGF6eWltYWdlJztcblxuLypcbmxhenlTaXplcy5jZmcubGF6eUNsYXNzID0gc3R5bGVzLmltYWdlTGF6eWxvYWQ7XG5sYXp5U2l6ZXMuY2ZnLmxvYWRpbmdDbGFzcyA9IHN0eWxlcy5pbWFnZUxhenlsb2FkaW5nO1xubGF6eVNpemVzLmNmZy5sb2FkZWRDbGFzcyA9IHN0eWxlcy5pbWFnZUxhenlsb2FkZWQ7XG5kb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdsYXp5bG9hZGVkJywgKGUpID0+IHtcbiAgbGF6eVNpemVzRmluZFBhcmVudChlLnRhcmdldCkuY2xhc3NMaXN0LmFkZChzdHlsZXMuaXNMb2FkZWQpO1xufSk7Ki9cblxuY29uc3QgbGF6eVNpemVzRmluZFBhcmVudCA9IChlbCkgPT4ge1xuICB3aGlsZSAoKGVsID0gZWwucGFyZW50RWxlbWVudCkgJiYgIWVsLmNsYXNzTGlzdC5jb250YWlucyhCQVNFKSk7XG4gIHJldHVybiBlbDtcbn07XG5cbmNvbnN0IExhenlJbWFnZSA9ICh7XG4gIGltYWdlLFxuICBiYWNrZ3JvdW5kID0gZmFsc2UsXG4gIGFsdCxcbiAgd2lkdGggPSAwLFxuICBoZWlnaHQgPSAwLFxuICBjbGFzc05hbWUgPSAnJyxcbiAgLi4ucHJvcHNcbn06IHtcbiAgaW1hZ2U6IEFwaUltYWdlO1xuICBiYWNrZ3JvdW5kPzogYm9vbGVhbjtcbiAgYWx0Pzogc3RyaW5nO1xuICB3aWR0aD86IG51bWJlcjtcbiAgaGVpZ2h0PzogbnVtYmVyO1xuICBjbGFzc05hbWU/OiBzdHJpbmc7XG4gIFtrZXk6IHN0cmluZ106IGFueTtcbn0pID0+IHtcbiAgY29uc3QgbWFpbkltYWdlID0gUmVhY3QudXNlTWVtbyhcbiAgICAoKSA9PlxuICAgICAgT2JqZWN0LnZhbHVlcyhpbWFnZS5zaXplcykubWFwKChzaXplKSA9PiAoe1xuICAgICAgICB1cmw6IHNpemUudXJsLFxuICAgICAgICB3aWR0aDogc2l6ZS53aWR0aCxcbiAgICAgICAgaGVpZ2h0OiBzaXplLmhlaWdodCxcbiAgICAgIH0pKVswXSxcbiAgICBbaW1hZ2VdXG4gICk7XG5cbiAgcmV0dXJuIChcbiAgICA8ZmlndXJlXG4gICAgICBjbGFzc05hbWU9e2NuKFxuICAgICAgICBzdHlsZXMucm9vdCxcbiAgICAgICAgeyBbc3R5bGVzLmJhY2tncm91bmRdOiBiYWNrZ3JvdW5kIH0sXG4gICAgICAgIGNsYXNzTmFtZVxuICAgICAgKX1cbiAgICAgIHsuLi5wcm9wc31cbiAgICA+XG4gICAgICB7YmFja2dyb3VuZCA/IChcbiAgICAgICAgPFJlYWN0LkZyYWdtZW50PlxuICAgICAgICAgIDxkaXZcbiAgICAgICAgICAgIGFyaWEtaGlkZGVuPVwidHJ1ZVwiXG4gICAgICAgICAgICBjbGFzc05hbWU9e3N0eWxlcy5iYWNrZ3JvdW5kfVxuICAgICAgICAgICAgc3R5bGU9e3tcbiAgICAgICAgICAgICAgYmFja2dyb3VuZEltYWdlOiBcInVybCgnXCIgKyBpbWFnZS5wbGFjZWhvbGRlciArIFwiJylcIixcbiAgICAgICAgICAgIH19XG4gICAgICAgICAgLz5cbiAgICAgICAgICA8ZGl2XG4gICAgICAgICAgICB0aXRsZT17YWx0IHx8IGltYWdlLmFsdH1cbiAgICAgICAgICAgIGNsYXNzTmFtZT17Y24oc3R5bGVzLmltYWdlLCBzdHlsZXMuaW1hZ2VMYXp5bG9hZCl9XG4gICAgICAgICAgICBzdHlsZT17eyBiYWNrZ3JvdW5kSW1hZ2U6IFwidXJsKCdcIiArIGltYWdlLnBsYWNlaG9sZGVyICsgXCInKVwiIH19XG4gICAgICAgICAgICBkYXRhLWJnc2V0PXtPYmplY3QuZW50cmllcyhpbWFnZS5zaXplcylcbiAgICAgICAgICAgICAgLm1hcCgoW3dpZHRoLCB1cmxdKSA9PiBgJHt1cmx9ICR7d2lkdGh9d2ApXG4gICAgICAgICAgICAgIC5qb2luKCcsICcpfVxuICAgICAgICAgIC8+XG4gICAgICAgIDwvUmVhY3QuRnJhZ21lbnQ+XG4gICAgICApIDogKFxuICAgICAgICA8UmVhY3QuRnJhZ21lbnQ+XG4gICAgICAgICAgPGltZ1xuICAgICAgICAgICAgYXJpYS1oaWRkZW49XCJ0cnVlXCJcbiAgICAgICAgICAgIGNsYXNzTmFtZT17c3R5bGVzLnByZXZpZXd9XG4gICAgICAgICAgICBzcmM9e2ltYWdlLnBsYWNlaG9sZGVyfVxuICAgICAgICAgIC8+XG4gICAgICAgICAgPGltZ1xuICAgICAgICAgICAgYWx0PXthbHQgfHwgaW1hZ2UuYWx0fVxuICAgICAgICAgICAgd2lkdGg9e21haW5JbWFnZS53aWR0aH1cbiAgICAgICAgICAgIGhlaWdodD17bWFpbkltYWdlLmhlaWdodH1cbiAgICAgICAgICAgIGNsYXNzTmFtZT17Y24oc3R5bGVzLmltYWdlLCBzdHlsZXMuaW1hZ2VMYXp5bG9hZCl9XG4gICAgICAgICAgICBkYXRhLXNpemVzPVwiYXV0b1wiXG4gICAgICAgICAgICBzcmM9e2ltYWdlLnBsYWNlaG9sZGVyfVxuICAgICAgICAgICAgZGF0YS1zcmM9e21haW5JbWFnZS51cmx9XG4gICAgICAgICAgICBkYXRhLXNyY3NldD17T2JqZWN0LmVudHJpZXMoaW1hZ2Uuc2l6ZXMpXG4gICAgICAgICAgICAgIC5tYXAoKFtuYW1lLCB7IHdpZHRoLCB1cmwgfV0pID0+IGAke3VybH0gJHt3aWR0aH13YClcbiAgICAgICAgICAgICAgLmpvaW4oJywgJyl9XG4gICAgICAgICAgLz5cbiAgICAgICAgPC9SZWFjdC5GcmFnbWVudD5cbiAgICAgICl9XG4gICAgPC9maWd1cmU+XG4gICk7XG59O1xuXG5leHBvcnQgZGVmYXVsdCBMYXp5SW1hZ2U7XG4iLCJ2YXIgYXBpID0gcmVxdWlyZShcIiEuLi8uLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2J1aWxkL3dlYnBhY2svbG9hZGVycy9uZXh0LXN0eWxlLWxvYWRlci9ydW50aW1lL2luamVjdFN0eWxlc0ludG9TdHlsZVRhZy5qc1wiKTtcbiAgICAgICAgICAgIHZhciBjb250ZW50ID0gcmVxdWlyZShcIiEhLi4vLi4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jb21waWxlZC9jc3MtbG9hZGVyL2Nqcy5qcz8/cmVmLS01LW9uZU9mLTItMSEuLi8uLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NvbXBpbGVkL3Bvc3Rjc3MtbG9hZGVyL2Nqcy5qcz8/cmVmLS01LW9uZU9mLTItMiEuL0xvYWRlci5tb2R1bGUuY3NzXCIpO1xuXG4gICAgICAgICAgICBjb250ZW50ID0gY29udGVudC5fX2VzTW9kdWxlID8gY29udGVudC5kZWZhdWx0IDogY29udGVudDtcblxuICAgICAgICAgICAgaWYgKHR5cGVvZiBjb250ZW50ID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICBjb250ZW50ID0gW1ttb2R1bGUuaWQsIGNvbnRlbnQsICcnXV07XG4gICAgICAgICAgICB9XG5cbnZhciBvcHRpb25zID0ge307XG5cbm9wdGlvbnMuaW5zZXJ0ID0gZnVuY3Rpb24oZWxlbWVudCl7Ly8gVGhlc2UgZWxlbWVudHMgc2hvdWxkIGFsd2F5cyBleGlzdC4gSWYgdGhleSBkbyBub3QsXG4vLyB0aGlzIGNvZGUgc2hvdWxkIGZhaWwuXG52YXIgYW5jaG9yRWxlbWVudD1kb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcjX19uZXh0X2Nzc19fRE9fTk9UX1VTRV9fJyk7dmFyIHBhcmVudE5vZGU9YW5jaG9yRWxlbWVudC5wYXJlbnROb2RlOy8vIE5vcm1hbGx5IDxoZWFkPlxuLy8gRWFjaCBzdHlsZSB0YWcgc2hvdWxkIGJlIHBsYWNlZCByaWdodCBiZWZvcmUgb3VyXG4vLyBhbmNob3IuIEJ5IGluc2VydGluZyBiZWZvcmUgYW5kIG5vdCBhZnRlciwgd2UgZG8gbm90XG4vLyBuZWVkIHRvIHRyYWNrIHRoZSBsYXN0IGluc2VydGVkIGVsZW1lbnQuXG5wYXJlbnROb2RlLmluc2VydEJlZm9yZShlbGVtZW50LGFuY2hvckVsZW1lbnQpO307XG5vcHRpb25zLnNpbmdsZXRvbiA9IGZhbHNlO1xuXG52YXIgdXBkYXRlID0gYXBpKGNvbnRlbnQsIG9wdGlvbnMpO1xuXG5cbmlmIChtb2R1bGUuaG90KSB7XG4gIGlmICghY29udGVudC5sb2NhbHMgfHwgbW9kdWxlLmhvdC5pbnZhbGlkYXRlKSB7XG4gICAgdmFyIGlzRXF1YWxMb2NhbHMgPSBmdW5jdGlvbiBpc0VxdWFsTG9jYWxzKGEsYixpc05hbWVkRXhwb3J0KXtpZighYSYmYnx8YSYmIWIpe3JldHVybiBmYWxzZTt9bGV0IHA7Zm9yKHAgaW4gYSl7aWYoaXNOYW1lZEV4cG9ydCYmcD09PSdkZWZhdWx0Jyl7Ly8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnRpbnVlXG5jb250aW51ZTt9aWYoYVtwXSE9PWJbcF0pe3JldHVybiBmYWxzZTt9fWZvcihwIGluIGIpe2lmKGlzTmFtZWRFeHBvcnQmJnA9PT0nZGVmYXVsdCcpey8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb250aW51ZVxuY29udGludWU7fWlmKCFhW3BdKXtyZXR1cm4gZmFsc2U7fX1yZXR1cm4gdHJ1ZTt9O1xuICAgIHZhciBvbGRMb2NhbHMgPSBjb250ZW50LmxvY2FscztcblxuICAgIG1vZHVsZS5ob3QuYWNjZXB0KFxuICAgICAgXCIhIS4uLy4uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvY3NzLWxvYWRlci9janMuanM/P3JlZi0tNS1vbmVPZi0yLTEhLi4vLi4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jb21waWxlZC9wb3N0Y3NzLWxvYWRlci9janMuanM/P3JlZi0tNS1vbmVPZi0yLTIhLi9Mb2FkZXIubW9kdWxlLmNzc1wiLFxuICAgICAgZnVuY3Rpb24gKCkge1xuICAgICAgICBjb250ZW50ID0gcmVxdWlyZShcIiEhLi4vLi4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jb21waWxlZC9jc3MtbG9hZGVyL2Nqcy5qcz8/cmVmLS01LW9uZU9mLTItMSEuLi8uLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NvbXBpbGVkL3Bvc3Rjc3MtbG9hZGVyL2Nqcy5qcz8/cmVmLS01LW9uZU9mLTItMiEuL0xvYWRlci5tb2R1bGUuY3NzXCIpO1xuXG4gICAgICAgICAgICAgIGNvbnRlbnQgPSBjb250ZW50Ll9fZXNNb2R1bGUgPyBjb250ZW50LmRlZmF1bHQgOiBjb250ZW50O1xuXG4gICAgICAgICAgICAgIGlmICh0eXBlb2YgY29udGVudCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICBjb250ZW50ID0gW1ttb2R1bGUuaWQsIGNvbnRlbnQsICcnXV07XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBpZiAoIWlzRXF1YWxMb2NhbHMob2xkTG9jYWxzLCBjb250ZW50LmxvY2FscykpIHtcbiAgICAgICAgICAgICAgICBtb2R1bGUuaG90LmludmFsaWRhdGUoKTtcblxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIG9sZExvY2FscyA9IGNvbnRlbnQubG9jYWxzO1xuXG4gICAgICAgICAgICAgIHVwZGF0ZShjb250ZW50KTtcbiAgICAgIH1cbiAgICApXG4gIH1cblxuICBtb2R1bGUuaG90LmRpc3Bvc2UoZnVuY3Rpb24oKSB7XG4gICAgdXBkYXRlKCk7XG4gIH0pO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNvbnRlbnQubG9jYWxzIHx8IHt9OyIsImltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgY24gZnJvbSAnQHV0aWxzL2NsYXNzbmFtZXMnO1xuaW1wb3J0IHN0eWxlcyBmcm9tICcuL0xvYWRlci5tb2R1bGUuY3NzJztcblxuY29uc3QgTG9hZGVyID0gKHsgY2xhc3NOYW1lID0gJycgfTogeyBjbGFzc05hbWU/OiBzdHJpbmcgfSkgPT4gKFxuICA8ZGl2IGNsYXNzTmFtZT17Y24oc3R5bGVzLnJvb3QsIGNsYXNzTmFtZSl9IC8+XG4pO1xuXG5leHBvcnQgZGVmYXVsdCBMb2FkZXI7XG4iLCJ2YXIgYXBpID0gcmVxdWlyZShcIiEuLi8uLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2J1aWxkL3dlYnBhY2svbG9hZGVycy9uZXh0LXN0eWxlLWxvYWRlci9ydW50aW1lL2luamVjdFN0eWxlc0ludG9TdHlsZVRhZy5qc1wiKTtcbiAgICAgICAgICAgIHZhciBjb250ZW50ID0gcmVxdWlyZShcIiEhLi4vLi4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jb21waWxlZC9jc3MtbG9hZGVyL2Nqcy5qcz8/cmVmLS01LW9uZU9mLTItMSEuLi8uLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NvbXBpbGVkL3Bvc3Rjc3MtbG9hZGVyL2Nqcy5qcz8/cmVmLS01LW9uZU9mLTItMiEuL0xvZ28ubW9kdWxlLmNzc1wiKTtcblxuICAgICAgICAgICAgY29udGVudCA9IGNvbnRlbnQuX19lc01vZHVsZSA/IGNvbnRlbnQuZGVmYXVsdCA6IGNvbnRlbnQ7XG5cbiAgICAgICAgICAgIGlmICh0eXBlb2YgY29udGVudCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgY29udGVudCA9IFtbbW9kdWxlLmlkLCBjb250ZW50LCAnJ11dO1xuICAgICAgICAgICAgfVxuXG52YXIgb3B0aW9ucyA9IHt9O1xuXG5vcHRpb25zLmluc2VydCA9IGZ1bmN0aW9uKGVsZW1lbnQpey8vIFRoZXNlIGVsZW1lbnRzIHNob3VsZCBhbHdheXMgZXhpc3QuIElmIHRoZXkgZG8gbm90LFxuLy8gdGhpcyBjb2RlIHNob3VsZCBmYWlsLlxudmFyIGFuY2hvckVsZW1lbnQ9ZG9jdW1lbnQucXVlcnlTZWxlY3RvcignI19fbmV4dF9jc3NfX0RPX05PVF9VU0VfXycpO3ZhciBwYXJlbnROb2RlPWFuY2hvckVsZW1lbnQucGFyZW50Tm9kZTsvLyBOb3JtYWxseSA8aGVhZD5cbi8vIEVhY2ggc3R5bGUgdGFnIHNob3VsZCBiZSBwbGFjZWQgcmlnaHQgYmVmb3JlIG91clxuLy8gYW5jaG9yLiBCeSBpbnNlcnRpbmcgYmVmb3JlIGFuZCBub3QgYWZ0ZXIsIHdlIGRvIG5vdFxuLy8gbmVlZCB0byB0cmFjayB0aGUgbGFzdCBpbnNlcnRlZCBlbGVtZW50LlxucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUoZWxlbWVudCxhbmNob3JFbGVtZW50KTt9O1xub3B0aW9ucy5zaW5nbGV0b24gPSBmYWxzZTtcblxudmFyIHVwZGF0ZSA9IGFwaShjb250ZW50LCBvcHRpb25zKTtcblxuXG5pZiAobW9kdWxlLmhvdCkge1xuICBpZiAoIWNvbnRlbnQubG9jYWxzIHx8IG1vZHVsZS5ob3QuaW52YWxpZGF0ZSkge1xuICAgIHZhciBpc0VxdWFsTG9jYWxzID0gZnVuY3Rpb24gaXNFcXVhbExvY2FscyhhLGIsaXNOYW1lZEV4cG9ydCl7aWYoIWEmJmJ8fGEmJiFiKXtyZXR1cm4gZmFsc2U7fWxldCBwO2ZvcihwIGluIGEpe2lmKGlzTmFtZWRFeHBvcnQmJnA9PT0nZGVmYXVsdCcpey8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb250aW51ZVxuY29udGludWU7fWlmKGFbcF0hPT1iW3BdKXtyZXR1cm4gZmFsc2U7fX1mb3IocCBpbiBiKXtpZihpc05hbWVkRXhwb3J0JiZwPT09J2RlZmF1bHQnKXsvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29udGludWVcbmNvbnRpbnVlO31pZighYVtwXSl7cmV0dXJuIGZhbHNlO319cmV0dXJuIHRydWU7fTtcbiAgICB2YXIgb2xkTG9jYWxzID0gY29udGVudC5sb2NhbHM7XG5cbiAgICBtb2R1bGUuaG90LmFjY2VwdChcbiAgICAgIFwiISEuLi8uLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NvbXBpbGVkL2Nzcy1sb2FkZXIvY2pzLmpzPz9yZWYtLTUtb25lT2YtMi0xIS4uLy4uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvcG9zdGNzcy1sb2FkZXIvY2pzLmpzPz9yZWYtLTUtb25lT2YtMi0yIS4vTG9nby5tb2R1bGUuY3NzXCIsXG4gICAgICBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGNvbnRlbnQgPSByZXF1aXJlKFwiISEuLi8uLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NvbXBpbGVkL2Nzcy1sb2FkZXIvY2pzLmpzPz9yZWYtLTUtb25lT2YtMi0xIS4uLy4uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvcG9zdGNzcy1sb2FkZXIvY2pzLmpzPz9yZWYtLTUtb25lT2YtMi0yIS4vTG9nby5tb2R1bGUuY3NzXCIpO1xuXG4gICAgICAgICAgICAgIGNvbnRlbnQgPSBjb250ZW50Ll9fZXNNb2R1bGUgPyBjb250ZW50LmRlZmF1bHQgOiBjb250ZW50O1xuXG4gICAgICAgICAgICAgIGlmICh0eXBlb2YgY29udGVudCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICBjb250ZW50ID0gW1ttb2R1bGUuaWQsIGNvbnRlbnQsICcnXV07XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBpZiAoIWlzRXF1YWxMb2NhbHMob2xkTG9jYWxzLCBjb250ZW50LmxvY2FscykpIHtcbiAgICAgICAgICAgICAgICBtb2R1bGUuaG90LmludmFsaWRhdGUoKTtcblxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIG9sZExvY2FscyA9IGNvbnRlbnQubG9jYWxzO1xuXG4gICAgICAgICAgICAgIHVwZGF0ZShjb250ZW50KTtcbiAgICAgIH1cbiAgICApXG4gIH1cblxuICBtb2R1bGUuaG90LmRpc3Bvc2UoZnVuY3Rpb24oKSB7XG4gICAgdXBkYXRlKCk7XG4gIH0pO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNvbnRlbnQubG9jYWxzIHx8IHt9OyIsImltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyBTVkcgfSBmcm9tICdAdGhlbWUnO1xuaW1wb3J0IGNuIGZyb20gJ0B1dGlscy9jbGFzc25hbWVzJztcbmltcG9ydCBzdHlsZXMgZnJvbSAnLi9Mb2dvLm1vZHVsZS5jc3MnO1xuXG5jb25zdCBMb2dvID0gKHtcbiAgY2xhc3NOYW1lID0gJycsXG4gIHRpdGxlLFxuICBhbHQsXG4gIHNhbWVoZWlnaHQgPSBmYWxzZSxcbiAgLi4ucHJvcHNcbn06IHtcbiAgdGl0bGU6IHN0cmluZztcbiAgYWx0OiBzdHJpbmc7XG4gIGNsYXNzTmFtZT86IHN0cmluZztcbiAgc2FtZWhlaWdodD86IGJvb2xlYW47XG4gIFtrZXk6IHN0cmluZ106IGFueTtcbn0pID0+IChcbiAgPFNWR1xuICAgIGNsYXNzTmFtZT17Y24oY2xhc3NOYW1lLCBzdHlsZXMucm9vdCl9XG4gICAgcGF0aD17XG4gICAgICBzYW1laGVpZ2h0XG4gICAgICAgID8gYGljb24vcHdhZHZlbnQtbG9nby1zYW1laGVpZ2h0LnN2Z2BcbiAgICAgICAgOiBgaWNvbi9wd2FkdmVudC1sb2dvLnN2Z2BcbiAgICB9XG4gICAgdGl0bGU9e3RpdGxlfVxuICAgIGFsdD17YWx0fVxuICAgIHsuLi5wcm9wc31cbiAgLz5cbik7XG5cbmV4cG9ydCBkZWZhdWx0IExvZ287XG4iLCJ2YXIgYXBpID0gcmVxdWlyZShcIiEuLi8uLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2J1aWxkL3dlYnBhY2svbG9hZGVycy9uZXh0LXN0eWxlLWxvYWRlci9ydW50aW1lL2luamVjdFN0eWxlc0ludG9TdHlsZVRhZy5qc1wiKTtcbiAgICAgICAgICAgIHZhciBjb250ZW50ID0gcmVxdWlyZShcIiEhLi4vLi4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jb21waWxlZC9jc3MtbG9hZGVyL2Nqcy5qcz8/cmVmLS01LW9uZU9mLTItMSEuLi8uLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NvbXBpbGVkL3Bvc3Rjc3MtbG9hZGVyL2Nqcy5qcz8/cmVmLS01LW9uZU9mLTItMiEuL05vdGlmaWNhdGlvbi5tb2R1bGUuY3NzXCIpO1xuXG4gICAgICAgICAgICBjb250ZW50ID0gY29udGVudC5fX2VzTW9kdWxlID8gY29udGVudC5kZWZhdWx0IDogY29udGVudDtcblxuICAgICAgICAgICAgaWYgKHR5cGVvZiBjb250ZW50ID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICBjb250ZW50ID0gW1ttb2R1bGUuaWQsIGNvbnRlbnQsICcnXV07XG4gICAgICAgICAgICB9XG5cbnZhciBvcHRpb25zID0ge307XG5cbm9wdGlvbnMuaW5zZXJ0ID0gZnVuY3Rpb24oZWxlbWVudCl7Ly8gVGhlc2UgZWxlbWVudHMgc2hvdWxkIGFsd2F5cyBleGlzdC4gSWYgdGhleSBkbyBub3QsXG4vLyB0aGlzIGNvZGUgc2hvdWxkIGZhaWwuXG52YXIgYW5jaG9yRWxlbWVudD1kb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcjX19uZXh0X2Nzc19fRE9fTk9UX1VTRV9fJyk7dmFyIHBhcmVudE5vZGU9YW5jaG9yRWxlbWVudC5wYXJlbnROb2RlOy8vIE5vcm1hbGx5IDxoZWFkPlxuLy8gRWFjaCBzdHlsZSB0YWcgc2hvdWxkIGJlIHBsYWNlZCByaWdodCBiZWZvcmUgb3VyXG4vLyBhbmNob3IuIEJ5IGluc2VydGluZyBiZWZvcmUgYW5kIG5vdCBhZnRlciwgd2UgZG8gbm90XG4vLyBuZWVkIHRvIHRyYWNrIHRoZSBsYXN0IGluc2VydGVkIGVsZW1lbnQuXG5wYXJlbnROb2RlLmluc2VydEJlZm9yZShlbGVtZW50LGFuY2hvckVsZW1lbnQpO307XG5vcHRpb25zLnNpbmdsZXRvbiA9IGZhbHNlO1xuXG52YXIgdXBkYXRlID0gYXBpKGNvbnRlbnQsIG9wdGlvbnMpO1xuXG5cbmlmIChtb2R1bGUuaG90KSB7XG4gIGlmICghY29udGVudC5sb2NhbHMgfHwgbW9kdWxlLmhvdC5pbnZhbGlkYXRlKSB7XG4gICAgdmFyIGlzRXF1YWxMb2NhbHMgPSBmdW5jdGlvbiBpc0VxdWFsTG9jYWxzKGEsYixpc05hbWVkRXhwb3J0KXtpZighYSYmYnx8YSYmIWIpe3JldHVybiBmYWxzZTt9bGV0IHA7Zm9yKHAgaW4gYSl7aWYoaXNOYW1lZEV4cG9ydCYmcD09PSdkZWZhdWx0Jyl7Ly8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnRpbnVlXG5jb250aW51ZTt9aWYoYVtwXSE9PWJbcF0pe3JldHVybiBmYWxzZTt9fWZvcihwIGluIGIpe2lmKGlzTmFtZWRFeHBvcnQmJnA9PT0nZGVmYXVsdCcpey8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb250aW51ZVxuY29udGludWU7fWlmKCFhW3BdKXtyZXR1cm4gZmFsc2U7fX1yZXR1cm4gdHJ1ZTt9O1xuICAgIHZhciBvbGRMb2NhbHMgPSBjb250ZW50LmxvY2FscztcblxuICAgIG1vZHVsZS5ob3QuYWNjZXB0KFxuICAgICAgXCIhIS4uLy4uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvY3NzLWxvYWRlci9janMuanM/P3JlZi0tNS1vbmVPZi0yLTEhLi4vLi4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jb21waWxlZC9wb3N0Y3NzLWxvYWRlci9janMuanM/P3JlZi0tNS1vbmVPZi0yLTIhLi9Ob3RpZmljYXRpb24ubW9kdWxlLmNzc1wiLFxuICAgICAgZnVuY3Rpb24gKCkge1xuICAgICAgICBjb250ZW50ID0gcmVxdWlyZShcIiEhLi4vLi4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jb21waWxlZC9jc3MtbG9hZGVyL2Nqcy5qcz8/cmVmLS01LW9uZU9mLTItMSEuLi8uLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NvbXBpbGVkL3Bvc3Rjc3MtbG9hZGVyL2Nqcy5qcz8/cmVmLS01LW9uZU9mLTItMiEuL05vdGlmaWNhdGlvbi5tb2R1bGUuY3NzXCIpO1xuXG4gICAgICAgICAgICAgIGNvbnRlbnQgPSBjb250ZW50Ll9fZXNNb2R1bGUgPyBjb250ZW50LmRlZmF1bHQgOiBjb250ZW50O1xuXG4gICAgICAgICAgICAgIGlmICh0eXBlb2YgY29udGVudCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICBjb250ZW50ID0gW1ttb2R1bGUuaWQsIGNvbnRlbnQsICcnXV07XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBpZiAoIWlzRXF1YWxMb2NhbHMob2xkTG9jYWxzLCBjb250ZW50LmxvY2FscykpIHtcbiAgICAgICAgICAgICAgICBtb2R1bGUuaG90LmludmFsaWRhdGUoKTtcblxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIG9sZExvY2FscyA9IGNvbnRlbnQubG9jYWxzO1xuXG4gICAgICAgICAgICAgIHVwZGF0ZShjb250ZW50KTtcbiAgICAgIH1cbiAgICApXG4gIH1cblxuICBtb2R1bGUuaG90LmRpc3Bvc2UoZnVuY3Rpb24oKSB7XG4gICAgdXBkYXRlKCk7XG4gIH0pO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNvbnRlbnQubG9jYWxzIHx8IHt9OyIsImltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgY24gZnJvbSAnQHV0aWxzL2NsYXNzbmFtZXMnO1xuaW1wb3J0IHN0eWxlcyBmcm9tICcuL05vdGlmaWNhdGlvbi5tb2R1bGUuY3NzJztcblxuY29uc3QgTm90aWZpY2F0aW9uID0gKHtcbiAgY2xhc3NOYW1lID0gJycsXG4gIHR5cGUgPSAnbWVzc2FnZScsXG4gIGNoaWxkcmVuLFxufToge1xuICBjbGFzc05hbWU/OiBzdHJpbmc7XG4gIHR5cGU/OiAnbWVzc2FnZScgfCAnc3VjY2VzcycgfCAnZXJyb3InO1xuICBjaGlsZHJlbjogYW55O1xufSkgPT4gKFxuICA8ZGl2IGNsYXNzTmFtZT17Y24oY2xhc3NOYW1lLCBzdHlsZXMucm9vdCwgc3R5bGVzW2B0eXBlLSR7dHlwZX1gXSl9PlxuICAgIDxwIGNsYXNzTmFtZT17c3R5bGVzLnRleHR9PntjaGlsZHJlbn08L3A+XG4gIDwvZGl2PlxuKTtcblxuZXhwb3J0IGRlZmF1bHQgTm90aWZpY2F0aW9uO1xuIiwidmFyIGFwaSA9IHJlcXVpcmUoXCIhLi4vLi4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9idWlsZC93ZWJwYWNrL2xvYWRlcnMvbmV4dC1zdHlsZS1sb2FkZXIvcnVudGltZS9pbmplY3RTdHlsZXNJbnRvU3R5bGVUYWcuanNcIik7XG4gICAgICAgICAgICB2YXIgY29udGVudCA9IHJlcXVpcmUoXCIhIS4uLy4uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvY3NzLWxvYWRlci9janMuanM/P3JlZi0tNS1vbmVPZi0yLTEhLi4vLi4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jb21waWxlZC9wb3N0Y3NzLWxvYWRlci9janMuanM/P3JlZi0tNS1vbmVPZi0yLTIhLi9Tbm93Lm1vZHVsZS5jc3NcIik7XG5cbiAgICAgICAgICAgIGNvbnRlbnQgPSBjb250ZW50Ll9fZXNNb2R1bGUgPyBjb250ZW50LmRlZmF1bHQgOiBjb250ZW50O1xuXG4gICAgICAgICAgICBpZiAodHlwZW9mIGNvbnRlbnQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgIGNvbnRlbnQgPSBbW21vZHVsZS5pZCwgY29udGVudCwgJyddXTtcbiAgICAgICAgICAgIH1cblxudmFyIG9wdGlvbnMgPSB7fTtcblxub3B0aW9ucy5pbnNlcnQgPSBmdW5jdGlvbihlbGVtZW50KXsvLyBUaGVzZSBlbGVtZW50cyBzaG91bGQgYWx3YXlzIGV4aXN0LiBJZiB0aGV5IGRvIG5vdCxcbi8vIHRoaXMgY29kZSBzaG91bGQgZmFpbC5cbnZhciBhbmNob3JFbGVtZW50PWRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJyNfX25leHRfY3NzX19ET19OT1RfVVNFX18nKTt2YXIgcGFyZW50Tm9kZT1hbmNob3JFbGVtZW50LnBhcmVudE5vZGU7Ly8gTm9ybWFsbHkgPGhlYWQ+XG4vLyBFYWNoIHN0eWxlIHRhZyBzaG91bGQgYmUgcGxhY2VkIHJpZ2h0IGJlZm9yZSBvdXJcbi8vIGFuY2hvci4gQnkgaW5zZXJ0aW5nIGJlZm9yZSBhbmQgbm90IGFmdGVyLCB3ZSBkbyBub3Rcbi8vIG5lZWQgdG8gdHJhY2sgdGhlIGxhc3QgaW5zZXJ0ZWQgZWxlbWVudC5cbnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKGVsZW1lbnQsYW5jaG9yRWxlbWVudCk7fTtcbm9wdGlvbnMuc2luZ2xldG9uID0gZmFsc2U7XG5cbnZhciB1cGRhdGUgPSBhcGkoY29udGVudCwgb3B0aW9ucyk7XG5cblxuaWYgKG1vZHVsZS5ob3QpIHtcbiAgaWYgKCFjb250ZW50LmxvY2FscyB8fCBtb2R1bGUuaG90LmludmFsaWRhdGUpIHtcbiAgICB2YXIgaXNFcXVhbExvY2FscyA9IGZ1bmN0aW9uIGlzRXF1YWxMb2NhbHMoYSxiLGlzTmFtZWRFeHBvcnQpe2lmKCFhJiZifHxhJiYhYil7cmV0dXJuIGZhbHNlO31sZXQgcDtmb3IocCBpbiBhKXtpZihpc05hbWVkRXhwb3J0JiZwPT09J2RlZmF1bHQnKXsvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29udGludWVcbmNvbnRpbnVlO31pZihhW3BdIT09YltwXSl7cmV0dXJuIGZhbHNlO319Zm9yKHAgaW4gYil7aWYoaXNOYW1lZEV4cG9ydCYmcD09PSdkZWZhdWx0Jyl7Ly8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnRpbnVlXG5jb250aW51ZTt9aWYoIWFbcF0pe3JldHVybiBmYWxzZTt9fXJldHVybiB0cnVlO307XG4gICAgdmFyIG9sZExvY2FscyA9IGNvbnRlbnQubG9jYWxzO1xuXG4gICAgbW9kdWxlLmhvdC5hY2NlcHQoXG4gICAgICBcIiEhLi4vLi4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jb21waWxlZC9jc3MtbG9hZGVyL2Nqcy5qcz8/cmVmLS01LW9uZU9mLTItMSEuLi8uLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NvbXBpbGVkL3Bvc3Rjc3MtbG9hZGVyL2Nqcy5qcz8/cmVmLS01LW9uZU9mLTItMiEuL1Nub3cubW9kdWxlLmNzc1wiLFxuICAgICAgZnVuY3Rpb24gKCkge1xuICAgICAgICBjb250ZW50ID0gcmVxdWlyZShcIiEhLi4vLi4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jb21waWxlZC9jc3MtbG9hZGVyL2Nqcy5qcz8/cmVmLS01LW9uZU9mLTItMSEuLi8uLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NvbXBpbGVkL3Bvc3Rjc3MtbG9hZGVyL2Nqcy5qcz8/cmVmLS01LW9uZU9mLTItMiEuL1Nub3cubW9kdWxlLmNzc1wiKTtcblxuICAgICAgICAgICAgICBjb250ZW50ID0gY29udGVudC5fX2VzTW9kdWxlID8gY29udGVudC5kZWZhdWx0IDogY29udGVudDtcblxuICAgICAgICAgICAgICBpZiAodHlwZW9mIGNvbnRlbnQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgY29udGVudCA9IFtbbW9kdWxlLmlkLCBjb250ZW50LCAnJ11dO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgaWYgKCFpc0VxdWFsTG9jYWxzKG9sZExvY2FscywgY29udGVudC5sb2NhbHMpKSB7XG4gICAgICAgICAgICAgICAgbW9kdWxlLmhvdC5pbnZhbGlkYXRlKCk7XG5cbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBvbGRMb2NhbHMgPSBjb250ZW50LmxvY2FscztcblxuICAgICAgICAgICAgICB1cGRhdGUoY29udGVudCk7XG4gICAgICB9XG4gICAgKVxuICB9XG5cbiAgbW9kdWxlLmhvdC5kaXNwb3NlKGZ1bmN0aW9uKCkge1xuICAgIHVwZGF0ZSgpO1xuICB9KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjb250ZW50LmxvY2FscyB8fCB7fTsiLCJpbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0IGNuIGZyb20gJ0B1dGlscy9jbGFzc25hbWVzJztcbmltcG9ydCBzdHlsZXMgZnJvbSAnLi9Tbm93Lm1vZHVsZS5jc3MnO1xuXG5jb25zdCBTbm93ID0gKHsgY2xhc3NOYW1lID0gJycgfTogeyBjbGFzc05hbWU/OiBzdHJpbmcgfSkgPT4gKFxuICA8ZGl2IGNsYXNzTmFtZT17Y24oY2xhc3NOYW1lLCBzdHlsZXMucm9vdCl9PlxuICAgIHtbJ25lYXInLCAnbWlkJywgJ2ZhciddLm1hcCgocG9zaXRpb24pID0+IChcbiAgICAgIDxSZWFjdC5GcmFnbWVudCBrZXk9e3Bvc2l0aW9ufT5cbiAgICAgICAgPGRpdiBjbGFzc05hbWU9e2NuKHN0eWxlcy5sZXZlbCwgc3R5bGVzW2Bwb3NpdGlvbi0ke3Bvc2l0aW9ufWBdKX0gLz5cbiAgICAgICAgPGRpdlxuICAgICAgICAgIGNsYXNzTmFtZT17Y24oXG4gICAgICAgICAgICBzdHlsZXMubGV2ZWwsXG4gICAgICAgICAgICBzdHlsZXNbYHBvc2l0aW9uLSR7cG9zaXRpb259YF0sXG4gICAgICAgICAgICBzdHlsZXMubGV2ZWxBbHRcbiAgICAgICAgICApfVxuICAgICAgICAvPlxuICAgICAgPC9SZWFjdC5GcmFnbWVudD5cbiAgICApKX1cbiAgPC9kaXY+XG4pO1xuXG5leHBvcnQgZGVmYXVsdCBTbm93O1xuIiwidmFyIGFwaSA9IHJlcXVpcmUoXCIhLi4vLi4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9idWlsZC93ZWJwYWNrL2xvYWRlcnMvbmV4dC1zdHlsZS1sb2FkZXIvcnVudGltZS9pbmplY3RTdHlsZXNJbnRvU3R5bGVUYWcuanNcIik7XG4gICAgICAgICAgICB2YXIgY29udGVudCA9IHJlcXVpcmUoXCIhIS4uLy4uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvY3NzLWxvYWRlci9janMuanM/P3JlZi0tNS1vbmVPZi0yLTEhLi4vLi4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jb21waWxlZC9wb3N0Y3NzLWxvYWRlci9janMuanM/P3JlZi0tNS1vbmVPZi0yLTIhLi9JY29uLm1vZHVsZS5jc3NcIik7XG5cbiAgICAgICAgICAgIGNvbnRlbnQgPSBjb250ZW50Ll9fZXNNb2R1bGUgPyBjb250ZW50LmRlZmF1bHQgOiBjb250ZW50O1xuXG4gICAgICAgICAgICBpZiAodHlwZW9mIGNvbnRlbnQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgIGNvbnRlbnQgPSBbW21vZHVsZS5pZCwgY29udGVudCwgJyddXTtcbiAgICAgICAgICAgIH1cblxudmFyIG9wdGlvbnMgPSB7fTtcblxub3B0aW9ucy5pbnNlcnQgPSBmdW5jdGlvbihlbGVtZW50KXsvLyBUaGVzZSBlbGVtZW50cyBzaG91bGQgYWx3YXlzIGV4aXN0LiBJZiB0aGV5IGRvIG5vdCxcbi8vIHRoaXMgY29kZSBzaG91bGQgZmFpbC5cbnZhciBhbmNob3JFbGVtZW50PWRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJyNfX25leHRfY3NzX19ET19OT1RfVVNFX18nKTt2YXIgcGFyZW50Tm9kZT1hbmNob3JFbGVtZW50LnBhcmVudE5vZGU7Ly8gTm9ybWFsbHkgPGhlYWQ+XG4vLyBFYWNoIHN0eWxlIHRhZyBzaG91bGQgYmUgcGxhY2VkIHJpZ2h0IGJlZm9yZSBvdXJcbi8vIGFuY2hvci4gQnkgaW5zZXJ0aW5nIGJlZm9yZSBhbmQgbm90IGFmdGVyLCB3ZSBkbyBub3Rcbi8vIG5lZWQgdG8gdHJhY2sgdGhlIGxhc3QgaW5zZXJ0ZWQgZWxlbWVudC5cbnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKGVsZW1lbnQsYW5jaG9yRWxlbWVudCk7fTtcbm9wdGlvbnMuc2luZ2xldG9uID0gZmFsc2U7XG5cbnZhciB1cGRhdGUgPSBhcGkoY29udGVudCwgb3B0aW9ucyk7XG5cblxuaWYgKG1vZHVsZS5ob3QpIHtcbiAgaWYgKCFjb250ZW50LmxvY2FscyB8fCBtb2R1bGUuaG90LmludmFsaWRhdGUpIHtcbiAgICB2YXIgaXNFcXVhbExvY2FscyA9IGZ1bmN0aW9uIGlzRXF1YWxMb2NhbHMoYSxiLGlzTmFtZWRFeHBvcnQpe2lmKCFhJiZifHxhJiYhYil7cmV0dXJuIGZhbHNlO31sZXQgcDtmb3IocCBpbiBhKXtpZihpc05hbWVkRXhwb3J0JiZwPT09J2RlZmF1bHQnKXsvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29udGludWVcbmNvbnRpbnVlO31pZihhW3BdIT09YltwXSl7cmV0dXJuIGZhbHNlO319Zm9yKHAgaW4gYil7aWYoaXNOYW1lZEV4cG9ydCYmcD09PSdkZWZhdWx0Jyl7Ly8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnRpbnVlXG5jb250aW51ZTt9aWYoIWFbcF0pe3JldHVybiBmYWxzZTt9fXJldHVybiB0cnVlO307XG4gICAgdmFyIG9sZExvY2FscyA9IGNvbnRlbnQubG9jYWxzO1xuXG4gICAgbW9kdWxlLmhvdC5hY2NlcHQoXG4gICAgICBcIiEhLi4vLi4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jb21waWxlZC9jc3MtbG9hZGVyL2Nqcy5qcz8/cmVmLS01LW9uZU9mLTItMSEuLi8uLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NvbXBpbGVkL3Bvc3Rjc3MtbG9hZGVyL2Nqcy5qcz8/cmVmLS01LW9uZU9mLTItMiEuL0ljb24ubW9kdWxlLmNzc1wiLFxuICAgICAgZnVuY3Rpb24gKCkge1xuICAgICAgICBjb250ZW50ID0gcmVxdWlyZShcIiEhLi4vLi4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jb21waWxlZC9jc3MtbG9hZGVyL2Nqcy5qcz8/cmVmLS01LW9uZU9mLTItMSEuLi8uLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NvbXBpbGVkL3Bvc3Rjc3MtbG9hZGVyL2Nqcy5qcz8/cmVmLS01LW9uZU9mLTItMiEuL0ljb24ubW9kdWxlLmNzc1wiKTtcblxuICAgICAgICAgICAgICBjb250ZW50ID0gY29udGVudC5fX2VzTW9kdWxlID8gY29udGVudC5kZWZhdWx0IDogY29udGVudDtcblxuICAgICAgICAgICAgICBpZiAodHlwZW9mIGNvbnRlbnQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgY29udGVudCA9IFtbbW9kdWxlLmlkLCBjb250ZW50LCAnJ11dO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgaWYgKCFpc0VxdWFsTG9jYWxzKG9sZExvY2FscywgY29udGVudC5sb2NhbHMpKSB7XG4gICAgICAgICAgICAgICAgbW9kdWxlLmhvdC5pbnZhbGlkYXRlKCk7XG5cbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBvbGRMb2NhbHMgPSBjb250ZW50LmxvY2FscztcblxuICAgICAgICAgICAgICB1cGRhdGUoY29udGVudCk7XG4gICAgICB9XG4gICAgKVxuICB9XG5cbiAgbW9kdWxlLmhvdC5kaXNwb3NlKGZ1bmN0aW9uKCkge1xuICAgIHVwZGF0ZSgpO1xuICB9KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjb250ZW50LmxvY2FscyB8fCB7fTsiLCJpbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0IGNuIGZyb20gJ0B1dGlscy9jbGFzc25hbWVzJztcbmltcG9ydCBzdHlsZXMgZnJvbSAnLi9JY29uLm1vZHVsZS5jc3MnO1xuaW1wb3J0IFNWRyBmcm9tICcuL1NWRyc7XG5cbmNvbnN0IEljb24gPSAoe1xuICBpY29uLFxuICBjbGFzc05hbWUgPSAnJyxcbiAgc3Bpbm5pbmcgPSBmYWxzZSxcbiAgcm90YXRlID0gZmFsc2UsXG4gIGJ1dHRvbiA9IGZhbHNlLFxuICByb3VuZCA9IGZhbHNlLFxuICBjaXJjbGUgPSBmYWxzZSxcbiAgLi4ucHJvcHNcbn06IHtcbiAgaWNvbjogc3RyaW5nO1xuICBjbGFzc05hbWU/OiBzdHJpbmc7XG4gIHJvdGF0ZT86IDkwIHwgMTgwIHwgMjcwIHwgZmFsc2U7XG4gIHNwaW5uaW5nPzogYm9vbGVhbjtcbiAgYnV0dG9uPzogYm9vbGVhbjtcbiAgcm91bmQ/OiBib29sZWFuO1xuICBjaXJjbGU/OiBib29sZWFuO1xuICBba2V5OiBzdHJpbmddOiBhbnk7XG59KSA9PiB7XG4gIHJldHVybiAoXG4gICAgPFNWR1xuICAgICAgY2xhc3NOYW1lPXtjbihjbGFzc05hbWUsIHN0eWxlcy5yb290LCB7XG4gICAgICAgIFtzdHlsZXNbYHJvdGF0ZS0ke3JvdGF0ZX1gXV06IHJvdGF0ZSAhPT0gZmFsc2UsXG4gICAgICAgIFtzdHlsZXMuYW5pbWF0aW9uU3Bpbl06IHNwaW5uaW5nLFxuICAgICAgICBbc3R5bGVzLmlzUm91bmRdOiByb3VuZCxcbiAgICAgICAgW3N0eWxlcy5jaXJjbGVdOiBjaXJjbGUsXG4gICAgICB9KX1cbiAgICAgIHBhdGg9e2BpY29uLyR7aWNvbn0uc3ZnYH1cbiAgICAgIHsuLi5wcm9wc31cbiAgICAvPlxuICApO1xufTtcblxuZXhwb3J0IGRlZmF1bHQgSWNvbjtcbiIsInZhciBhcGkgPSByZXF1aXJlKFwiIS4uLy4uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvYnVpbGQvd2VicGFjay9sb2FkZXJzL25leHQtc3R5bGUtbG9hZGVyL3J1bnRpbWUvaW5qZWN0U3R5bGVzSW50b1N0eWxlVGFnLmpzXCIpO1xuICAgICAgICAgICAgdmFyIGNvbnRlbnQgPSByZXF1aXJlKFwiISEuLi8uLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NvbXBpbGVkL2Nzcy1sb2FkZXIvY2pzLmpzPz9yZWYtLTUtb25lT2YtMi0xIS4uLy4uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvcG9zdGNzcy1sb2FkZXIvY2pzLmpzPz9yZWYtLTUtb25lT2YtMi0yIS4vU1ZHLm1vZHVsZS5jc3NcIik7XG5cbiAgICAgICAgICAgIGNvbnRlbnQgPSBjb250ZW50Ll9fZXNNb2R1bGUgPyBjb250ZW50LmRlZmF1bHQgOiBjb250ZW50O1xuXG4gICAgICAgICAgICBpZiAodHlwZW9mIGNvbnRlbnQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgIGNvbnRlbnQgPSBbW21vZHVsZS5pZCwgY29udGVudCwgJyddXTtcbiAgICAgICAgICAgIH1cblxudmFyIG9wdGlvbnMgPSB7fTtcblxub3B0aW9ucy5pbnNlcnQgPSBmdW5jdGlvbihlbGVtZW50KXsvLyBUaGVzZSBlbGVtZW50cyBzaG91bGQgYWx3YXlzIGV4aXN0LiBJZiB0aGV5IGRvIG5vdCxcbi8vIHRoaXMgY29kZSBzaG91bGQgZmFpbC5cbnZhciBhbmNob3JFbGVtZW50PWRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJyNfX25leHRfY3NzX19ET19OT1RfVVNFX18nKTt2YXIgcGFyZW50Tm9kZT1hbmNob3JFbGVtZW50LnBhcmVudE5vZGU7Ly8gTm9ybWFsbHkgPGhlYWQ+XG4vLyBFYWNoIHN0eWxlIHRhZyBzaG91bGQgYmUgcGxhY2VkIHJpZ2h0IGJlZm9yZSBvdXJcbi8vIGFuY2hvci4gQnkgaW5zZXJ0aW5nIGJlZm9yZSBhbmQgbm90IGFmdGVyLCB3ZSBkbyBub3Rcbi8vIG5lZWQgdG8gdHJhY2sgdGhlIGxhc3QgaW5zZXJ0ZWQgZWxlbWVudC5cbnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKGVsZW1lbnQsYW5jaG9yRWxlbWVudCk7fTtcbm9wdGlvbnMuc2luZ2xldG9uID0gZmFsc2U7XG5cbnZhciB1cGRhdGUgPSBhcGkoY29udGVudCwgb3B0aW9ucyk7XG5cblxuaWYgKG1vZHVsZS5ob3QpIHtcbiAgaWYgKCFjb250ZW50LmxvY2FscyB8fCBtb2R1bGUuaG90LmludmFsaWRhdGUpIHtcbiAgICB2YXIgaXNFcXVhbExvY2FscyA9IGZ1bmN0aW9uIGlzRXF1YWxMb2NhbHMoYSxiLGlzTmFtZWRFeHBvcnQpe2lmKCFhJiZifHxhJiYhYil7cmV0dXJuIGZhbHNlO31sZXQgcDtmb3IocCBpbiBhKXtpZihpc05hbWVkRXhwb3J0JiZwPT09J2RlZmF1bHQnKXsvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29udGludWVcbmNvbnRpbnVlO31pZihhW3BdIT09YltwXSl7cmV0dXJuIGZhbHNlO319Zm9yKHAgaW4gYil7aWYoaXNOYW1lZEV4cG9ydCYmcD09PSdkZWZhdWx0Jyl7Ly8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnRpbnVlXG5jb250aW51ZTt9aWYoIWFbcF0pe3JldHVybiBmYWxzZTt9fXJldHVybiB0cnVlO307XG4gICAgdmFyIG9sZExvY2FscyA9IGNvbnRlbnQubG9jYWxzO1xuXG4gICAgbW9kdWxlLmhvdC5hY2NlcHQoXG4gICAgICBcIiEhLi4vLi4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jb21waWxlZC9jc3MtbG9hZGVyL2Nqcy5qcz8/cmVmLS01LW9uZU9mLTItMSEuLi8uLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NvbXBpbGVkL3Bvc3Rjc3MtbG9hZGVyL2Nqcy5qcz8/cmVmLS01LW9uZU9mLTItMiEuL1NWRy5tb2R1bGUuY3NzXCIsXG4gICAgICBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGNvbnRlbnQgPSByZXF1aXJlKFwiISEuLi8uLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NvbXBpbGVkL2Nzcy1sb2FkZXIvY2pzLmpzPz9yZWYtLTUtb25lT2YtMi0xIS4uLy4uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvcG9zdGNzcy1sb2FkZXIvY2pzLmpzPz9yZWYtLTUtb25lT2YtMi0yIS4vU1ZHLm1vZHVsZS5jc3NcIik7XG5cbiAgICAgICAgICAgICAgY29udGVudCA9IGNvbnRlbnQuX19lc01vZHVsZSA/IGNvbnRlbnQuZGVmYXVsdCA6IGNvbnRlbnQ7XG5cbiAgICAgICAgICAgICAgaWYgKHR5cGVvZiBjb250ZW50ID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIGNvbnRlbnQgPSBbW21vZHVsZS5pZCwgY29udGVudCwgJyddXTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGlmICghaXNFcXVhbExvY2FscyhvbGRMb2NhbHMsIGNvbnRlbnQubG9jYWxzKSkge1xuICAgICAgICAgICAgICAgIG1vZHVsZS5ob3QuaW52YWxpZGF0ZSgpO1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgb2xkTG9jYWxzID0gY29udGVudC5sb2NhbHM7XG5cbiAgICAgICAgICAgICAgdXBkYXRlKGNvbnRlbnQpO1xuICAgICAgfVxuICAgIClcbiAgfVxuXG4gIG1vZHVsZS5ob3QuZGlzcG9zZShmdW5jdGlvbigpIHtcbiAgICB1cGRhdGUoKTtcbiAgfSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gY29udGVudC5sb2NhbHMgfHwge307IiwiaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCBjbiBmcm9tICdAdXRpbHMvY2xhc3NuYW1lcyc7XG5pbXBvcnQgc3R5bGVzIGZyb20gJy4vU1ZHLm1vZHVsZS5jc3MnO1xuXG5jb25zdCBTVkcgPSAoe1xuICBwYXRoLFxuICBjbGFzc05hbWUgPSAnJyxcbiAgaW5saW5lID0gZmFsc2UsXG4gIC4uLnByb3BzXG59OiB7XG4gIHBhdGg6IHN0cmluZztcbiAgY2xhc3NOYW1lPzogc3RyaW5nO1xuICBpbmxpbmU/OiBib29sZWFuO1xuICBba2V5OiBzdHJpbmddOiBhbnk7XG59KSA9PiB7XG4gIGNvbnN0IFtsb2FkZWRJY29uLCBzZXRMb2FkZWRJY29uXSA9IFJlYWN0LnVzZVN0YXRlKCcnKTtcblxuICBSZWFjdC51c2VFZmZlY3QoKCkgPT4ge1xuICAgIGFzeW5jIGZ1bmN0aW9uIGxvYWRJY29uKCkge1xuICAgICAgcmV0dXJuIGF3YWl0IGltcG9ydChcbiAgICAgICAgLyogd2VicGFja01vZGU6IFwiZWFnZXJcIiAqLyBgLi4vLi4vcHVibGljL2ljb24vJHtwYXRofWBcbiAgICAgICk7XG4gICAgfVxuICAgIGxvYWRJY29uKCkudGhlbigobG9hZGVkKSA9PiBzZXRMb2FkZWRJY29uKGxvYWRlZC5kZWZhdWx0KSk7XG4gIH0sIFtwYXRoXSk7XG5cbiAgcmV0dXJuIChcbiAgICA8ZmlndXJlXG4gICAgICBjbGFzc05hbWU9e2NuKGNsYXNzTmFtZSwgc3R5bGVzLnJvb3QsIHtcbiAgICAgICAgW3N0eWxlcy5pc0lubGluZV06IGlubGluZSxcbiAgICAgIH0pfVxuICAgICAgZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUw9e3sgX19odG1sOiBsb2FkZWRJY29uIH19XG4gICAgICB7Li4ucHJvcHN9XG4gICAgLz5cbiAgKTtcbn07XG5cbmV4cG9ydCBkZWZhdWx0IFNWRztcbiIsImltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgUmVhY3RET00gZnJvbSAncmVhY3QtZG9tJztcbmltcG9ydCB7IFNoYWRvd0JveCB9IGZyb20gJy4uL2luZGV4JztcblxuY29uc3QgUG9ydGFsID0gKHsgY2hpbGRyZW4gfTogeyBjaGlsZHJlbj86IFJlYWN0LkpTWC5FbGVtZW50IH0pID0+XG4gIFJlYWN0RE9NLmNyZWF0ZVBvcnRhbChjaGlsZHJlbiwgZG9jdW1lbnQucXVlcnlTZWxlY3RvcignI3NoYWRvd2JveCcpKTtcblxuZXhwb3J0IGRlZmF1bHQgKHtcbiAgY2hpbGRyZW4sXG4gIGNsb3NlLFxuICBzaXplLFxuICAuLi5wcm9wc1xufToge1xuICBjaGlsZHJlbj86IFJlYWN0LkpTWC5FbGVtZW50IHwgUmVhY3QuSlNYLkVsZW1lbnRbXSB8IHN0cmluZztcbiAgY2xvc2U6IEZ1bmN0aW9uO1xuICBzaXplPzogJ2xhcmdlJyB8ICdzbWFsbCc7XG4gIFtrZXk6IHN0cmluZ106IGFueTtcbn0pID0+IChcbiAgPFBvcnRhbD5cbiAgICA8U2hhZG93Qm94IGNoaWxkcmVuPXtjaGlsZHJlbn0gY2xvc2U9e2Nsb3NlfSBzaXplPXtzaXplfSB7Li4ucHJvcHN9IC8+XG4gIDwvUG9ydGFsPlxuKTtcbiIsInZhciBhcGkgPSByZXF1aXJlKFwiIS4uLy4uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvYnVpbGQvd2VicGFjay9sb2FkZXJzL25leHQtc3R5bGUtbG9hZGVyL3J1bnRpbWUvaW5qZWN0U3R5bGVzSW50b1N0eWxlVGFnLmpzXCIpO1xuICAgICAgICAgICAgdmFyIGNvbnRlbnQgPSByZXF1aXJlKFwiISEuLi8uLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NvbXBpbGVkL2Nzcy1sb2FkZXIvY2pzLmpzPz9yZWYtLTUtb25lT2YtMi0xIS4uLy4uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvcG9zdGNzcy1sb2FkZXIvY2pzLmpzPz9yZWYtLTUtb25lT2YtMi0yIS4vU2hhZG93Qm94Lm1vZHVsZS5jc3NcIik7XG5cbiAgICAgICAgICAgIGNvbnRlbnQgPSBjb250ZW50Ll9fZXNNb2R1bGUgPyBjb250ZW50LmRlZmF1bHQgOiBjb250ZW50O1xuXG4gICAgICAgICAgICBpZiAodHlwZW9mIGNvbnRlbnQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgIGNvbnRlbnQgPSBbW21vZHVsZS5pZCwgY29udGVudCwgJyddXTtcbiAgICAgICAgICAgIH1cblxudmFyIG9wdGlvbnMgPSB7fTtcblxub3B0aW9ucy5pbnNlcnQgPSBmdW5jdGlvbihlbGVtZW50KXsvLyBUaGVzZSBlbGVtZW50cyBzaG91bGQgYWx3YXlzIGV4aXN0LiBJZiB0aGV5IGRvIG5vdCxcbi8vIHRoaXMgY29kZSBzaG91bGQgZmFpbC5cbnZhciBhbmNob3JFbGVtZW50PWRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJyNfX25leHRfY3NzX19ET19OT1RfVVNFX18nKTt2YXIgcGFyZW50Tm9kZT1hbmNob3JFbGVtZW50LnBhcmVudE5vZGU7Ly8gTm9ybWFsbHkgPGhlYWQ+XG4vLyBFYWNoIHN0eWxlIHRhZyBzaG91bGQgYmUgcGxhY2VkIHJpZ2h0IGJlZm9yZSBvdXJcbi8vIGFuY2hvci4gQnkgaW5zZXJ0aW5nIGJlZm9yZSBhbmQgbm90IGFmdGVyLCB3ZSBkbyBub3Rcbi8vIG5lZWQgdG8gdHJhY2sgdGhlIGxhc3QgaW5zZXJ0ZWQgZWxlbWVudC5cbnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKGVsZW1lbnQsYW5jaG9yRWxlbWVudCk7fTtcbm9wdGlvbnMuc2luZ2xldG9uID0gZmFsc2U7XG5cbnZhciB1cGRhdGUgPSBhcGkoY29udGVudCwgb3B0aW9ucyk7XG5cblxuaWYgKG1vZHVsZS5ob3QpIHtcbiAgaWYgKCFjb250ZW50LmxvY2FscyB8fCBtb2R1bGUuaG90LmludmFsaWRhdGUpIHtcbiAgICB2YXIgaXNFcXVhbExvY2FscyA9IGZ1bmN0aW9uIGlzRXF1YWxMb2NhbHMoYSxiLGlzTmFtZWRFeHBvcnQpe2lmKCFhJiZifHxhJiYhYil7cmV0dXJuIGZhbHNlO31sZXQgcDtmb3IocCBpbiBhKXtpZihpc05hbWVkRXhwb3J0JiZwPT09J2RlZmF1bHQnKXsvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29udGludWVcbmNvbnRpbnVlO31pZihhW3BdIT09YltwXSl7cmV0dXJuIGZhbHNlO319Zm9yKHAgaW4gYil7aWYoaXNOYW1lZEV4cG9ydCYmcD09PSdkZWZhdWx0Jyl7Ly8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnRpbnVlXG5jb250aW51ZTt9aWYoIWFbcF0pe3JldHVybiBmYWxzZTt9fXJldHVybiB0cnVlO307XG4gICAgdmFyIG9sZExvY2FscyA9IGNvbnRlbnQubG9jYWxzO1xuXG4gICAgbW9kdWxlLmhvdC5hY2NlcHQoXG4gICAgICBcIiEhLi4vLi4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jb21waWxlZC9jc3MtbG9hZGVyL2Nqcy5qcz8/cmVmLS01LW9uZU9mLTItMSEuLi8uLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NvbXBpbGVkL3Bvc3Rjc3MtbG9hZGVyL2Nqcy5qcz8/cmVmLS01LW9uZU9mLTItMiEuL1NoYWRvd0JveC5tb2R1bGUuY3NzXCIsXG4gICAgICBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGNvbnRlbnQgPSByZXF1aXJlKFwiISEuLi8uLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NvbXBpbGVkL2Nzcy1sb2FkZXIvY2pzLmpzPz9yZWYtLTUtb25lT2YtMi0xIS4uLy4uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvcG9zdGNzcy1sb2FkZXIvY2pzLmpzPz9yZWYtLTUtb25lT2YtMi0yIS4vU2hhZG93Qm94Lm1vZHVsZS5jc3NcIik7XG5cbiAgICAgICAgICAgICAgY29udGVudCA9IGNvbnRlbnQuX19lc01vZHVsZSA/IGNvbnRlbnQuZGVmYXVsdCA6IGNvbnRlbnQ7XG5cbiAgICAgICAgICAgICAgaWYgKHR5cGVvZiBjb250ZW50ID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIGNvbnRlbnQgPSBbW21vZHVsZS5pZCwgY29udGVudCwgJyddXTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGlmICghaXNFcXVhbExvY2FscyhvbGRMb2NhbHMsIGNvbnRlbnQubG9jYWxzKSkge1xuICAgICAgICAgICAgICAgIG1vZHVsZS5ob3QuaW52YWxpZGF0ZSgpO1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgb2xkTG9jYWxzID0gY29udGVudC5sb2NhbHM7XG5cbiAgICAgICAgICAgICAgdXBkYXRlKGNvbnRlbnQpO1xuICAgICAgfVxuICAgIClcbiAgfVxuXG4gIG1vZHVsZS5ob3QuZGlzcG9zZShmdW5jdGlvbigpIHtcbiAgICB1cGRhdGUoKTtcbiAgfSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gY29udGVudC5sb2NhbHMgfHwge307IiwiaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCBjbiBmcm9tICdAdXRpbHMvY2xhc3NuYW1lcyc7XG5pbXBvcnQgeyBpc0lvcyB9IGZyb20gJ0B1dGlscy9oZWxwZXJzJztcbmltcG9ydCB7IENsb3NlQnV0dG9uIH0gZnJvbSAnLi4vaW5kZXgnO1xuaW1wb3J0IHN0eWxlcyBmcm9tICcuL1NoYWRvd0JveC5tb2R1bGUuY3NzJztcblxuZXhwb3J0IGRlZmF1bHQgKHtcbiAgdGl0bGUsXG4gIGNoaWxkcmVuLFxuICBjbG9zZSxcbiAgc2l6ZSA9ICdsYXJnZScsXG4gIGNsYXNzTmFtZSA9ICcnLFxufToge1xuICB0aXRsZT86IHN0cmluZztcbiAgY2hpbGRyZW4/OiBhbnk7XG4gIGNsb3NlOiBGdW5jdGlvbjtcbiAgc2l6ZT86ICdsYXJnZScgfCAnc21hbGwnO1xuICBjbGFzc05hbWU/OiBzdHJpbmc7XG59KSA9PiB7XG4gIGNvbnN0IFtzaG93LCBzZXRTaG93XSA9IFJlYWN0LnVzZVN0YXRlPGJvb2xlYW4+KGZhbHNlKTtcbiAgY29uc3QgW3NoYWRvdywgc2V0U2hhZG93XSA9IFJlYWN0LnVzZVN0YXRlPGJvb2xlYW4+KGZhbHNlKTtcblxuICBSZWFjdC51c2VFZmZlY3QoKCkgPT4ge1xuICAgIHNldFNob3codHJ1ZSk7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIHNldFNob3coZmFsc2UpO1xuICAgIH07XG4gIH0sIFtdKTtcblxuICBjb25zdCBvbkNsb3NlID0gKCkgPT4ge1xuICAgIHNldFNob3coZmFsc2UpO1xuICAgIHdpbmRvdy5zZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIGNsb3NlKCk7XG4gICAgfSwgMjAwKTtcbiAgfTtcblxuICByZXR1cm4gKFxuICAgIDxkaXZcbiAgICAgIGNsYXNzTmFtZT17Y24oY2xhc3NOYW1lLCBzdHlsZXMucm9vdCwgc3R5bGVzW2BzaXplLSR7c2l6ZX1gXSl9XG4gICAgICBkYXRhLXZpc2libGU9e3Nob3d9XG4gICAgPlxuICAgICAgPGRpdiBjbGFzc05hbWU9e3N0eWxlcy5zaGFkb3d9IG9uQ2xpY2s9e29uQ2xvc2V9IC8+XG4gICAgICA8YXJ0aWNsZVxuICAgICAgICBjbGFzc05hbWU9e3N0eWxlcy5ib3h9XG4gICAgICAgIG9uU2Nyb2xsPXsoZSkgPT4ge1xuICAgICAgICAgIGNvbnN0IHNjcm9sbCA9IChlLnRhcmdldCBhcyBIVE1MSHRtbEVsZW1lbnQpLnNjcm9sbFRvcDtcbiAgICAgICAgICBpZiAoc2hhZG93ICYmIHNjcm9sbCA9PT0gMCkge1xuICAgICAgICAgICAgc2V0U2hhZG93KGZhbHNlKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc2V0U2hhZG93KHRydWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfX1cbiAgICAgID5cbiAgICAgICAgPGhlYWRlclxuICAgICAgICAgIGNsYXNzTmFtZT17Y24oc3R5bGVzLmhlYWRlciwge1xuICAgICAgICAgICAgW3N0eWxlcy5oZWFkZXJTaGFkb3ddOiBzaGFkb3csXG4gICAgICAgICAgICBbc3R5bGVzLmhlYWRlcklvc106IGlzSW9zLFxuICAgICAgICAgIH0pfVxuICAgICAgICA+XG4gICAgICAgICAge3RpdGxlICE9PSBudWxsICYmIDxoMSBjbGFzc05hbWU9e3N0eWxlcy50aXRsZX0+e3RpdGxlfTwvaDE+fXsnICd9XG4gICAgICAgICAgPENsb3NlQnV0dG9uIGNsYXNzTmFtZT17c3R5bGVzLmNsb3NlfSBvbkNsaWNrPXtvbkNsb3NlfSAvPlxuICAgICAgICA8L2hlYWRlcj5cbiAgICAgICAgPGRpdiBjbGFzc05hbWU9e3N0eWxlcy5jb250ZW50fT57Y2hpbGRyZW59PC9kaXY+XG4gICAgICA8L2FydGljbGU+XG4gICAgPC9kaXY+XG4gICk7XG59O1xuIiwiZXhwb3J0IHsgZGVmYXVsdCBhcyBCdXR0b24gfSBmcm9tICcuL0J1dHRvbi9CdXR0b24nO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBDbG9zZUJ1dHRvbiB9IGZyb20gJy4vQ2xvc2VCdXR0b24vQ2xvc2VCdXR0b24nO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBTaGFkb3dCb3ggfSBmcm9tICcuL1NoYWRvd0JveC9TaGFkb3dCb3gnO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBQb3J0YWxCb3ggfSBmcm9tICcuL1NoYWRvd0JveC9Qb3J0YWxCb3gnO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBTVkcgfSBmcm9tICcuL1NWRy9TVkcnO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBJY29uIH0gZnJvbSAnLi9TVkcvSWNvbic7XG5leHBvcnQgeyBkZWZhdWx0IGFzIExhenlJbWFnZSB9IGZyb20gJy4vSW1hZ2UvTGF6eUltYWdlJztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgTG9nbyB9IGZyb20gJy4vTG9nby9Mb2dvJztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgTG9hZGVyIH0gZnJvbSAnLi9Mb2FkZXIvTG9hZGVyJztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgQ29udGVudE1vZGFsIH0gZnJvbSAnLi9Db250ZW50TW9kYWwvQ29udGVudE1vZGFsJztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgTm90aWZpY2F0aW9uIH0gZnJvbSAnLi9NaXNjL05vdGlmaWNhdGlvbic7XG5leHBvcnQgeyBkZWZhdWx0IGFzIFNub3cgfSBmcm9tICcuL01pc2MvU25vdyc7XG5cbi8vIEZvcm1cblxuZXhwb3J0IHsgZGVmYXVsdCBhcyBGb3JtIH0gZnJvbSAnLi9Gb3JtL0Zvcm0nO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBGb3JtRmllbGQgfSBmcm9tICcuL0Zvcm0vRm9ybUZpZWxkJztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgRm9ybUZpZWxkc2V0IH0gZnJvbSAnLi9Gb3JtL0Zvcm1GaWVsZHNldCc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIEZvcm1Db250cm9scyB9IGZyb20gJy4vRm9ybS9Gb3JtQ29udHJvbHMnO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBJbnB1dFRleHQgfSBmcm9tICcuL0Zvcm0vSW5wdXRUZXh0JztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgSW5wdXRTZWxlY3QgfSBmcm9tICcuL0Zvcm0vSW5wdXRTZWxlY3QnO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBJbnB1dFRleHRhcmVhIH0gZnJvbSAnLi9Gb3JtL0lucHV0VGV4dGFyZWEnO1xuIiwiaW1wb3J0IGRheWpzIGZyb20gJ0B1dGlscy9kYXlqcyc7XG5cbmV4cG9ydCBjb25zdCBZRUFSOiBudW1iZXIgPSAyMDIwO1xuZXhwb3J0IGNvbnN0IENBTEVOREFSOiBudW1iZXJbXSA9IFtcbiAgMSwgMiwgMywgNCwgNSwgNiwgNywgOCwgOSwgMTAsIDExLCAxMiwgMTMsIDE0LCAxNSwgMTYsIDE3LCAxOCwgMTksIDIwLCAyMSwgMjIsXG4gIDIzLCAyNCxcbl07XG5cbmNvbnN0IFRPREFZID0gcHJvY2VzcyAmJiBwcm9jZXNzLmVudi5BUElfS0VZO1xuZXhwb3J0IGNvbnN0IERBVEVfVE9EQVk6IGRheWpzLkRheWpzID0gVE9EQVkgPyBkYXlqcyhUT0RBWSkgOiBkYXlqcygpO1xuZXhwb3J0IGNvbnN0IERBVEVfVE9EQVlfWkVSTzogZGF5anMuRGF5anMgPSBEQVRFX1RPREFZLnR6KCdBbnRhcmN0aWNhL01jTXVyZG8nKTtcbmV4cG9ydCBjb25zdCBEQVRFX1NUQVJUOiBkYXlqcy5EYXlqcyA9IGRheWpzKCcyMDIwLTEyLTAxJyk7XG5leHBvcnQgY29uc3QgREFURV9FTkQ6IGRheWpzLkRheWpzID0gZGF5anMoJzIwMjAtMTItMjQnKTtcblxuZXhwb3J0IGNvbnN0IFRIRU1FTjogc3RyaW5nW10gPSBbXG4gICdtYW5pZmVzdCcsXG4gICdzaGFyaW5nJyxcbiAgJ3Nob3J0Y3V0cyAvIGJhZGdpbmcnLFxuICAnU2VydmljZVdvcmtlcicsXG4gICdTVyBDYWNoZScsXG4gICdJbmRleGVkREInLFxuICAncGVyc2lzdGVudCBTdG9yYWdlJyxcbiAgJ0JLRyBzeW5jJyxcbiAgJ1B1c2ggTm90aWZpY2F0aW9ucycsXG4gICdQdXNoIFRyaWdnZXInLFxuICAnTWVkaWEgU2Vzc2lvbicsXG4gICduYXRpdmUgZmlsZSBzeXN0ZW0nLFxuICAnV2FrZSBMb2NrJyxcbiAgJ2ZvbnQgYWNjZXNzJyxcbiAgJ09yaWVudGF0aW9uIGxvY2snLFxuICAnTXVsdGkgd2luZG93JyxcbiAgJ2NyZWRlbnRpYWxzJyxcbiAgJ3BheW1lbnRzJyxcbiAgJ1dlYiBNaWRpJyxcbiAgJ3NoYXBlIGRldGVjdGlvbicsXG4gICdjb250YWN0IHBpY2tlcicsXG4gICdzbXMgcmVjaWV2ZXInLFxuICAnUGF3IENsaXBib2FyZCBBUEknLFxuICAnV0FTTScsXG5dO1xuIiwiY29uc3QgY24gPSAoLi4uY2xhc3NlczogQXJyYXk8UmVjb3JkPHN0cmluZywgYm9vbGVhbj4gfCBzdHJpbmc+KTogc3RyaW5nID0+XG4gIGNsYXNzZXNcbiAgICAubWFwKChlbnRyeSkgPT5cbiAgICAgIHR5cGVvZiBlbnRyeSA9PT0gJ3N0cmluZydcbiAgICAgICAgPyBlbnRyeVxuICAgICAgICA6IE9iamVjdC5lbnRyaWVzKGVudHJ5KVxuICAgICAgICAgICAgLmZpbHRlcigoW2NsLCBhcHBlbmRdKSA9PiBhcHBlbmQpXG4gICAgICAgICAgICAubWFwKChbY2xdKSA9PiBjbClcbiAgICAgICAgICAgIC5qb2luKCcgJylcbiAgICApXG4gICAgLmZpbHRlcigoZSkgPT4gZSAhPT0gJycpXG4gICAgLmpvaW4oJyAnKTtcblxuZXhwb3J0IGRlZmF1bHQgY247XG4iLCJpbXBvcnQgeyBzaHVmZmxlLCB0cmFpbGluZ1NsYXNoSXQgfSBmcm9tICdAdXRpbHMvaGVscGVycyc7XG5cbmV4cG9ydCBjb25zdCBhcGlCYXNlID0gdHJhaWxpbmdTbGFzaEl0KHByb2Nlc3MgJiYgcHJvY2Vzcy5lbnYuQVBJX0JBU0UpO1xuZXhwb3J0IGNvbnN0IGFwaUtleSA9IHByb2Nlc3MgJiYgcHJvY2Vzcy5lbnYuQVBJX0tFWTtcbmV4cG9ydCBjb25zdCBhcHBUaXRsZSA9IHByb2Nlc3MgJiYgcHJvY2Vzcy5lbnYuQVBQX1RJVExFO1xuZXhwb3J0IGNvbnN0IGFwcERlc2NyaXB0aW9uID0gcHJvY2VzcyAmJiBwcm9jZXNzLmVudi5BUFBfREVTQ1JJUFRJT047XG5leHBvcnQgY29uc3QgaXNEZXY6IGJvb2xlYW4gPSBwcm9jZXNzICYmIHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAnZGV2ZWxvcG1lbnQnO1xuZXhwb3J0IGNvbnN0IHJlZ2lzdGVyU3cgPSAocHJvY2VzcyAmJiBwcm9jZXNzLmVudi5SRUdJU1RFUl9TVykgfHwgIWlzRGV2O1xuXG5jb25zdCByYW5kb20gPSBmYWxzZTtcbmNvbnN0IHR3b1RvVHdlbnR5dGhyZWUgPSBbXG4gIDIsIDMsIDQsIDUsIDYsIDcsIDgsIDksIDEwLCAxMSwgMTIsIDEzLCAxNCwgMTUsIDE2LCAxNywgMTgsIDE5LCAyMCwgMjEsIDIyLFxuICAyMyxcbl07XG5jb25zdCBzaHVmZmVsZWQgPSByYW5kb21cbiAgPyBzaHVmZmxlKHR3b1RvVHdlbnR5dGhyZWUpXG4gIDogW1xuICAgICAgNiwgMjEsIDEyLCAyMCwgMTQsIDQsIDE5LCAxNiwgMTUsIDIsIDE3LCA5LCA4LCAxMywgMTEsIDUsIDIyLCAxOCwgMywgMjMsXG4gICAgICA3LCAxMCxcbiAgICBdO1xuXG5leHBvcnQgY29uc3QgZGF5c09yZGVyID0gWzEsIC4uLnNodWZmZWxlZCwgMjRdO1xuZXhwb3J0IGNvbnN0IGRheXNPcmRlckNvcnJlY3QgPSBbMSwgLi4udHdvVG9Ud2VudHl0aHJlZSwgMjRdO1xuXG5leHBvcnQgY29uc3QgVklFV19UWVBFUyA9IHtcbiAgTElTVDogJ2xpc3QnLFxuICBDQUxFTkRBUjogJ2NhbGVuZGFyJyxcbn07XG5cbmV4cG9ydCBjb25zdCBTVUJKRUNUUyA9IFtcbiAgJ0FkZCB0byBIb21lc2NyZWVuJyxcbiAgJ1NoYXJpbmcgb24gdGhlIHdlYicsXG4gICdTaG9ydGN1dHMnLFxuICAnU2VydmljZSBXb3JrZXInLFxuICAnU2VydmljZVdvcmtlciBDYWNoZScsXG4gICdJbmRleGVkREInLFxuICAnU3RvcmFnZS1NYW5hZ2VycycsXG4gICdCYWNrZ3JvdW5kLVN5bmMnLFxuICAnUHVzaCBOb3RpZmljYXRpb25zJyxcbiAgJ01lZGlhIFNlc3Npb24gQVBJJyxcbiAgJ1NoYXBlIERldGVjdGlvbiBBUEknLFxuICAnV2FrZSBMb2NrIEFQSScsXG4gICdQYXltZW50IFJlcXVlc3QgQVBJJyxcbiAgJ1ZpYnJhdGlvbicsXG4gICdEdWFsIFNjcmVlbiBTdXBwb3J0JyxcbiAgJ0NvbnRhY3QgUGlja2VyIEFQSScsXG4gICdDcmVkZW50aWFsIE1hbmFnZW1lbnQgQVBJJyxcbiAgJ0ZvbnQgQWNjZXNzIEFQSScsXG4gICdXZWIgTUlESScsXG4gICdGaWxlIFN5c3RlbSBBY2Nlc3MgQVBJJyxcbiAgJ0ZpbGUgSGFuZGxpbmcgQVBJJyxcbiAgJ1dlYiBPVFAgQVBJJyxcbiAgJ0JhZGdpbmcgQVBJJyxcbiAgJ1dBU00nLFxuXTtcbiIsImltcG9ydCBkYXlqcyBmcm9tICdkYXlqcyc7XG5pbXBvcnQgbG9jYWxpemVkRm9ybWF0IGZyb20gJ2RheWpzL3BsdWdpbi9sb2NhbGl6ZWRGb3JtYXQnO1xuaW1wb3J0IHV0YyBmcm9tICdkYXlqcy9wbHVnaW4vdXRjJztcbmltcG9ydCB0aW1lem9uZSBmcm9tICdkYXlqcy9wbHVnaW4vdGltZXpvbmUnO1xuXG5kYXlqcy5leHRlbmQodXRjKTtcbmRheWpzLmV4dGVuZCh0aW1lem9uZSk7XG5kYXlqcy5leHRlbmQobG9jYWxpemVkRm9ybWF0KTtcblxuZXhwb3J0IGRlZmF1bHQgZGF5anM7XG4iLCJpbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xuXG5leHBvcnQgY29uc3QgemVyb1BhZCA9IChudW1iZXI6IG51bWJlciwgbGVuZ3RoOiBudW1iZXIpOiBzdHJpbmcgPT5cbiAgbnVtYmVyLnRvU3RyaW5nKCkucGFkU3RhcnQobGVuZ3RoLCAnMCcpO1xuXG5leHBvcnQgY29uc3Qgd2luZG93UmVzaXplID0gKCkgPT4ge1xuICBjb25zdCB2aCA9IHdpbmRvdy5pbm5lckhlaWdodCAqIDAuMDE7XG4gIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zdHlsZS5zZXRQcm9wZXJ0eSgnLS12aCcsIGAke3ZofXB4YCk7XG59O1xuXG5leHBvcnQgY29uc3QgZ2V0UmFuZG9tTnVtYmVyID0gKG1pbiwgbWF4KSA9PiBNYXRoLnJhbmRvbSgpICogKG1heCAtIG1pbikgKyBtaW47XG5cbmV4cG9ydCBjb25zdCB1bnRyYWlsaW5nU2xhc2hJdCA9IChzdHI6IHN0cmluZyA9ICcnKTogc3RyaW5nID0+XG4gIHN0ci5yZXBsYWNlKC9cXC8kLywgJycpO1xuXG5leHBvcnQgY29uc3QgdHJhaWxpbmdTbGFzaEl0ID0gKHN0cjogc3RyaW5nID0gJ3MnKTogc3RyaW5nID0+XG4gIHVudHJhaWxpbmdTbGFzaEl0KHN0cikgKyAnLyc7XG5cbmV4cG9ydCBjb25zdCBzaHVmZmxlID0gKGl0ZW1zOiBBcnJheTxhbnk+KSA9PiB7XG4gIGNvbnN0IHJlY3VyID0gKGFyciwgY3VycmVudEluZGV4KSA9PiB7XG4gICAgaWYgKGN1cnJlbnRJbmRleCA9PT0gMCkge1xuICAgICAgcmV0dXJuIGFycjtcbiAgICB9XG4gICAgY29uc3QgcmFuZG9tSW5kZXggPSBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiBjdXJyZW50SW5kZXgpO1xuICAgIGNvbnN0IHN3YXAgPSBhcnJbY3VycmVudEluZGV4XTtcbiAgICBhcnJbY3VycmVudEluZGV4XSA9IGFycltyYW5kb21JbmRleF07XG4gICAgYXJyW3JhbmRvbUluZGV4XSA9IHN3YXA7XG4gICAgcmV0dXJuIHJlY3VyKGFyciwgY3VycmVudEluZGV4IC0gMSk7XG4gIH07XG4gIHJldHVybiByZWN1cihcbiAgICBpdGVtcy5tYXAoKHgpID0+IHgpLFxuICAgIGl0ZW1zLmxlbmd0aCAtIDFcbiAgKTtcbn07XG5cbmV4cG9ydCBjb25zdCB1cmxCNjRUb1VpbnQ4QXJyYXkgPSAoYmFzZTY0U3RyaW5nKSA9PiB7XG4gIGNvbnN0IHBhZGRpbmcgPSAnPScucmVwZWF0KCg0IC0gKGJhc2U2NFN0cmluZy5sZW5ndGggJSA0KSkgJSA0KTtcbiAgY29uc3QgYmFzZTY0ID0gKGJhc2U2NFN0cmluZyArIHBhZGRpbmcpXG4gICAgLnJlcGxhY2UoL1xcLS9nLCAnKycpXG4gICAgLnJlcGxhY2UoL18vZywgJy8nKTtcblxuICBjb25zdCByYXdEYXRhID0gd2luZG93LmF0b2IoYmFzZTY0KTtcbiAgY29uc3Qgb3V0cHV0QXJyYXkgPSBuZXcgVWludDhBcnJheShyYXdEYXRhLmxlbmd0aCk7XG5cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCByYXdEYXRhLmxlbmd0aDsgKytpKSB7XG4gICAgb3V0cHV0QXJyYXlbaV0gPSByYXdEYXRhLmNoYXJDb2RlQXQoaSk7XG4gIH1cbiAgcmV0dXJuIG91dHB1dEFycmF5O1xufTtcblxuY29uc3QgUExBVEZPUk0gPSB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyA/IG5hdmlnYXRvci5wbGF0Zm9ybSA6IG51bGw7XG5jb25zdCBVU0VSX0FHRU5UID0gdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgPyBuYXZpZ2F0b3IudXNlckFnZW50IDogJyc7XG5cbmV4cG9ydCBjb25zdCBpc0lvcyA9XG4gIFtcbiAgICAnaVBhZCBTaW11bGF0b3InLFxuICAgICdpUGhvbmUgU2ltdWxhdG9yJyxcbiAgICAnaVBvZCBTaW11bGF0b3InLFxuICAgICdpUGFkJyxcbiAgICAnaVBob25lJyxcbiAgICAnaVBvZCcsXG4gIF0uaW5jbHVkZXMoUExBVEZPUk0pIHx8XG4gIChVU0VSX0FHRU5ULmluY2x1ZGVzKCdNYWMnKSAmJiAnb250b3VjaGVuZCcgaW4gZG9jdW1lbnQpO1xuIiwiaW1wb3J0IHsgYXBwRGVzY3JpcHRpb24sIGFwcFRpdGxlIH0gZnJvbSAnQHV0aWxzL2NvbnN0YW50cyc7XG5cbmV4cG9ydCBjb25zdCBtZXRhVGl0bGUgPSAodGl0bGU6IHN0cmluZyA9ICcnKSA9PlxuICB0aXRsZSA9PT0gJycgPyBgJHthcHBUaXRsZX0g4p2EICR7YXBwRGVzY3JpcHRpb259YCA6IGAke3RpdGxlfSDinYQgJHthcHBUaXRsZX1gO1xuIiwiLyogUHJpc21KUyAxLjIyLjBcbmh0dHBzOi8vcHJpc21qcy5jb20vZG93bmxvYWQuaHRtbCN0aGVtZXM9cHJpc20tdG9tb3Jyb3cmbGFuZ3VhZ2VzPW1hcmt1cCtjc3MrY2xpa2UramF2YXNjcmlwdCtqc29uK3Nhc3Mrc2Nzcyt0eXBlc2NyaXB0K3R5cG9zY3JpcHQmcGx1Z2lucz1saW5lLW51bWJlcnMgKi9cbnZhciBfc2VsZiA9XG4gICAgJ3VuZGVmaW5lZCcgIT0gdHlwZW9mIHdpbmRvd1xuICAgICAgPyB3aW5kb3dcbiAgICAgIDogJ3VuZGVmaW5lZCcgIT0gdHlwZW9mIFdvcmtlckdsb2JhbFNjb3BlICYmXG4gICAgICAgIHNlbGYgaW5zdGFuY2VvZiBXb3JrZXJHbG9iYWxTY29wZVxuICAgICAgPyBzZWxmXG4gICAgICA6IHt9LFxuICBQcmlzbSA9IChmdW5jdGlvbih1KSB7XG4gICAgdmFyIGMgPSAvXFxibGFuZyg/OnVhZ2UpPy0oW1xcdy1dKylcXGIvaSxcbiAgICAgIG4gPSAwLFxuICAgICAgXyA9IHtcbiAgICAgICAgbWFudWFsOiB1LlByaXNtICYmIHUuUHJpc20ubWFudWFsLFxuICAgICAgICBkaXNhYmxlV29ya2VyTWVzc2FnZUhhbmRsZXI6XG4gICAgICAgICAgdS5QcmlzbSAmJiB1LlByaXNtLmRpc2FibGVXb3JrZXJNZXNzYWdlSGFuZGxlcixcbiAgICAgICAgdXRpbDoge1xuICAgICAgICAgIGVuY29kZTogZnVuY3Rpb24gZShuKSB7XG4gICAgICAgICAgICByZXR1cm4gbiBpbnN0YW5jZW9mIE1cbiAgICAgICAgICAgICAgPyBuZXcgTShuLnR5cGUsIGUobi5jb250ZW50KSwgbi5hbGlhcylcbiAgICAgICAgICAgICAgOiBBcnJheS5pc0FycmF5KG4pXG4gICAgICAgICAgICAgID8gbi5tYXAoZSlcbiAgICAgICAgICAgICAgOiBuXG4gICAgICAgICAgICAgICAgICAucmVwbGFjZSgvJi9nLCAnJmFtcDsnKVxuICAgICAgICAgICAgICAgICAgLnJlcGxhY2UoLzwvZywgJyZsdDsnKVxuICAgICAgICAgICAgICAgICAgLnJlcGxhY2UoL1xcdTAwYTAvZywgJyAnKTtcbiAgICAgICAgICB9LFxuICAgICAgICAgIHR5cGU6IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoZSkuc2xpY2UoOCwgLTEpO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgb2JqSWQ6IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAgIGUuX19pZCB8fCBPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwgJ19faWQnLCB7IHZhbHVlOiArK24gfSksIGUuX19pZFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9LFxuICAgICAgICAgIGNsb25lOiBmdW5jdGlvbiB0KGUsIHIpIHtcbiAgICAgICAgICAgIHZhciBhLCBuO1xuICAgICAgICAgICAgc3dpdGNoICgoKHIgPSByIHx8IHt9KSwgXy51dGlsLnR5cGUoZSkpKSB7XG4gICAgICAgICAgICAgIGNhc2UgJ09iamVjdCc6XG4gICAgICAgICAgICAgICAgaWYgKCgobiA9IF8udXRpbC5vYmpJZChlKSksIHJbbl0pKSByZXR1cm4gcltuXTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpIGluICgoYSA9IHt9KSwgKHJbbl0gPSBhKSwgZSkpXG4gICAgICAgICAgICAgICAgICBlLmhhc093blByb3BlcnR5KGkpICYmIChhW2ldID0gdChlW2ldLCByKSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGE7XG4gICAgICAgICAgICAgIGNhc2UgJ0FycmF5JzpcbiAgICAgICAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgICAgICAgKG4gPSBfLnV0aWwub2JqSWQoZSkpLFxuICAgICAgICAgICAgICAgICAgcltuXVxuICAgICAgICAgICAgICAgICAgICA/IHJbbl1cbiAgICAgICAgICAgICAgICAgICAgOiAoKGEgPSBbXSksXG4gICAgICAgICAgICAgICAgICAgICAgKHJbbl0gPSBhKSxcbiAgICAgICAgICAgICAgICAgICAgICBlLmZvckVhY2goZnVuY3Rpb24oZSwgbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgYVtuXSA9IHQoZSwgcik7XG4gICAgICAgICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgICAgICAgYSlcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHJldHVybiBlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0sXG4gICAgICAgICAgZ2V0TGFuZ3VhZ2U6IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgIGZvciAoOyBlICYmICFjLnRlc3QoZS5jbGFzc05hbWUpOyApIGUgPSBlLnBhcmVudEVsZW1lbnQ7XG4gICAgICAgICAgICByZXR1cm4gZVxuICAgICAgICAgICAgICA/IChlLmNsYXNzTmFtZS5tYXRjaChjKSB8fCBbLCAnbm9uZSddKVsxXS50b0xvd2VyQ2FzZSgpXG4gICAgICAgICAgICAgIDogJ25vbmUnO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgY3VycmVudFNjcmlwdDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBpZiAoJ3VuZGVmaW5lZCcgPT0gdHlwZW9mIGRvY3VtZW50KSByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIGlmICgnY3VycmVudFNjcmlwdCcgaW4gZG9jdW1lbnQpIHJldHVybiBkb2N1bWVudC5jdXJyZW50U2NyaXB0O1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCk7XG4gICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgIHZhciBuID0gKC9hdCBbXihcXHJcXG5dKlxcKCguKik6Lis6LitcXCkkL2kuZXhlYyhlLnN0YWNrKSB8fCBbXSlbMV07XG4gICAgICAgICAgICAgIGlmIChuKSB7XG4gICAgICAgICAgICAgICAgdmFyIHQgPSBkb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZSgnc2NyaXB0Jyk7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgciBpbiB0KSBpZiAodFtyXS5zcmMgPT0gbikgcmV0dXJuIHRbcl07XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSxcbiAgICAgICAgICBpc0FjdGl2ZTogZnVuY3Rpb24oZSwgbiwgdCkge1xuICAgICAgICAgICAgZm9yICh2YXIgciA9ICduby0nICsgbjsgZTsgKSB7XG4gICAgICAgICAgICAgIHZhciBhID0gZS5jbGFzc0xpc3Q7XG4gICAgICAgICAgICAgIGlmIChhLmNvbnRhaW5zKG4pKSByZXR1cm4gITA7XG4gICAgICAgICAgICAgIGlmIChhLmNvbnRhaW5zKHIpKSByZXR1cm4gITE7XG4gICAgICAgICAgICAgIGUgPSBlLnBhcmVudEVsZW1lbnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gISF0O1xuICAgICAgICAgIH0sXG4gICAgICAgIH0sXG4gICAgICAgIGxhbmd1YWdlczoge1xuICAgICAgICAgIGV4dGVuZDogZnVuY3Rpb24oZSwgbikge1xuICAgICAgICAgICAgdmFyIHQgPSBfLnV0aWwuY2xvbmUoXy5sYW5ndWFnZXNbZV0pO1xuICAgICAgICAgICAgZm9yICh2YXIgciBpbiBuKSB0W3JdID0gbltyXTtcbiAgICAgICAgICAgIHJldHVybiB0O1xuICAgICAgICAgIH0sXG4gICAgICAgICAgaW5zZXJ0QmVmb3JlOiBmdW5jdGlvbih0LCBlLCBuLCByKSB7XG4gICAgICAgICAgICB2YXIgYSA9IChyID0gciB8fCBfLmxhbmd1YWdlcylbdF0sXG4gICAgICAgICAgICAgIGkgPSB7fTtcbiAgICAgICAgICAgIGZvciAodmFyIGwgaW4gYSlcbiAgICAgICAgICAgICAgaWYgKGEuaGFzT3duUHJvcGVydHkobCkpIHtcbiAgICAgICAgICAgICAgICBpZiAobCA9PSBlKVxuICAgICAgICAgICAgICAgICAgZm9yICh2YXIgbyBpbiBuKSBuLmhhc093blByb3BlcnR5KG8pICYmIChpW29dID0gbltvXSk7XG4gICAgICAgICAgICAgICAgbi5oYXNPd25Qcm9wZXJ0eShsKSB8fCAoaVtsXSA9IGFbbF0pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgcyA9IHJbdF07XG4gICAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgICAoclt0XSA9IGkpLFxuICAgICAgICAgICAgICBfLmxhbmd1YWdlcy5ERlMoXy5sYW5ndWFnZXMsIGZ1bmN0aW9uKGUsIG4pIHtcbiAgICAgICAgICAgICAgICBuID09PSBzICYmIGUgIT0gdCAmJiAodGhpc1tlXSA9IGkpO1xuICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgaVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9LFxuICAgICAgICAgIERGUzogZnVuY3Rpb24gZShuLCB0LCByLCBhKSB7XG4gICAgICAgICAgICBhID0gYSB8fCB7fTtcbiAgICAgICAgICAgIHZhciBpID0gXy51dGlsLm9iaklkO1xuICAgICAgICAgICAgZm9yICh2YXIgbCBpbiBuKVxuICAgICAgICAgICAgICBpZiAobi5oYXNPd25Qcm9wZXJ0eShsKSkge1xuICAgICAgICAgICAgICAgIHQuY2FsbChuLCBsLCBuW2xdLCByIHx8IGwpO1xuICAgICAgICAgICAgICAgIHZhciBvID0gbltsXSxcbiAgICAgICAgICAgICAgICAgIHMgPSBfLnV0aWwudHlwZShvKTtcbiAgICAgICAgICAgICAgICAnT2JqZWN0JyAhPT0gcyB8fCBhW2kobyldXG4gICAgICAgICAgICAgICAgICA/ICdBcnJheScgIT09IHMgfHwgYVtpKG8pXSB8fCAoKGFbaShvKV0gPSAhMCksIGUobywgdCwgbCwgYSkpXG4gICAgICAgICAgICAgICAgICA6ICgoYVtpKG8pXSA9ICEwKSwgZShvLCB0LCBudWxsLCBhKSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICB9LFxuICAgICAgICB9LFxuICAgICAgICBwbHVnaW5zOiB7fSxcbiAgICAgICAgaGlnaGxpZ2h0QWxsOiBmdW5jdGlvbihlLCBuKSB7XG4gICAgICAgICAgXy5oaWdobGlnaHRBbGxVbmRlcihkb2N1bWVudCwgZSwgbik7XG4gICAgICAgIH0sXG4gICAgICAgIGhpZ2hsaWdodEFsbFVuZGVyOiBmdW5jdGlvbihlLCBuLCB0KSB7XG4gICAgICAgICAgdmFyIHIgPSB7XG4gICAgICAgICAgICBjYWxsYmFjazogdCxcbiAgICAgICAgICAgIGNvbnRhaW5lcjogZSxcbiAgICAgICAgICAgIHNlbGVjdG9yOlxuICAgICAgICAgICAgICAnY29kZVtjbGFzcyo9XCJsYW5ndWFnZS1cIl0sIFtjbGFzcyo9XCJsYW5ndWFnZS1cIl0gY29kZSwgY29kZVtjbGFzcyo9XCJsYW5nLVwiXSwgW2NsYXNzKj1cImxhbmctXCJdIGNvZGUnLFxuICAgICAgICAgIH07XG4gICAgICAgICAgXy5ob29rcy5ydW4oJ2JlZm9yZS1oaWdobGlnaHRhbGwnLCByKSxcbiAgICAgICAgICAgIChyLmVsZW1lbnRzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmFwcGx5KFxuICAgICAgICAgICAgICByLmNvbnRhaW5lci5xdWVyeVNlbGVjdG9yQWxsKHIuc2VsZWN0b3IpXG4gICAgICAgICAgICApKSxcbiAgICAgICAgICAgIF8uaG9va3MucnVuKCdiZWZvcmUtYWxsLWVsZW1lbnRzLWhpZ2hsaWdodCcsIHIpO1xuICAgICAgICAgIGZvciAodmFyIGEsIGkgPSAwOyAoYSA9IHIuZWxlbWVudHNbaSsrXSk7IClcbiAgICAgICAgICAgIF8uaGlnaGxpZ2h0RWxlbWVudChhLCAhMCA9PT0gbiwgci5jYWxsYmFjayk7XG4gICAgICAgIH0sXG4gICAgICAgIGhpZ2hsaWdodEVsZW1lbnQ6IGZ1bmN0aW9uKGUsIG4sIHQpIHtcbiAgICAgICAgICB2YXIgciA9IF8udXRpbC5nZXRMYW5ndWFnZShlKSxcbiAgICAgICAgICAgIGEgPSBfLmxhbmd1YWdlc1tyXTtcbiAgICAgICAgICBlLmNsYXNzTmFtZSA9XG4gICAgICAgICAgICBlLmNsYXNzTmFtZS5yZXBsYWNlKGMsICcnKS5yZXBsYWNlKC9cXHMrL2csICcgJykgKyAnIGxhbmd1YWdlLScgKyByO1xuICAgICAgICAgIHZhciBpID0gZS5wYXJlbnRFbGVtZW50O1xuICAgICAgICAgIGkgJiZcbiAgICAgICAgICAgICdwcmUnID09PSBpLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgJiZcbiAgICAgICAgICAgIChpLmNsYXNzTmFtZSA9XG4gICAgICAgICAgICAgIGkuY2xhc3NOYW1lLnJlcGxhY2UoYywgJycpLnJlcGxhY2UoL1xccysvZywgJyAnKSArXG4gICAgICAgICAgICAgICcgbGFuZ3VhZ2UtJyArXG4gICAgICAgICAgICAgIHIpO1xuICAgICAgICAgIHZhciBsID0geyBlbGVtZW50OiBlLCBsYW5ndWFnZTogciwgZ3JhbW1hcjogYSwgY29kZTogZS50ZXh0Q29udGVudCB9O1xuICAgICAgICAgIGZ1bmN0aW9uIG8oZSkge1xuICAgICAgICAgICAgKGwuaGlnaGxpZ2h0ZWRDb2RlID0gZSksXG4gICAgICAgICAgICAgIF8uaG9va3MucnVuKCdiZWZvcmUtaW5zZXJ0JywgbCksXG4gICAgICAgICAgICAgIChsLmVsZW1lbnQuaW5uZXJIVE1MID0gbC5oaWdobGlnaHRlZENvZGUpLFxuICAgICAgICAgICAgICBfLmhvb2tzLnJ1bignYWZ0ZXItaGlnaGxpZ2h0JywgbCksXG4gICAgICAgICAgICAgIF8uaG9va3MucnVuKCdjb21wbGV0ZScsIGwpLFxuICAgICAgICAgICAgICB0ICYmIHQuY2FsbChsLmVsZW1lbnQpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoKF8uaG9va3MucnVuKCdiZWZvcmUtc2FuaXR5LWNoZWNrJywgbCksICFsLmNvZGUpKVxuICAgICAgICAgICAgcmV0dXJuIF8uaG9va3MucnVuKCdjb21wbGV0ZScsIGwpLCB2b2lkICh0ICYmIHQuY2FsbChsLmVsZW1lbnQpKTtcbiAgICAgICAgICBpZiAoKF8uaG9va3MucnVuKCdiZWZvcmUtaGlnaGxpZ2h0JywgbCksIGwuZ3JhbW1hcikpXG4gICAgICAgICAgICBpZiAobiAmJiB1Lldvcmtlcikge1xuICAgICAgICAgICAgICB2YXIgcyA9IG5ldyBXb3JrZXIoXy5maWxlbmFtZSk7XG4gICAgICAgICAgICAgIChzLm9ubWVzc2FnZSA9IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgICAgICBvKGUuZGF0YSk7XG4gICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgIHMucG9zdE1lc3NhZ2UoXG4gICAgICAgICAgICAgICAgICBKU09OLnN0cmluZ2lmeSh7XG4gICAgICAgICAgICAgICAgICAgIGxhbmd1YWdlOiBsLmxhbmd1YWdlLFxuICAgICAgICAgICAgICAgICAgICBjb2RlOiBsLmNvZGUsXG4gICAgICAgICAgICAgICAgICAgIGltbWVkaWF0ZUNsb3NlOiAhMCxcbiAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH0gZWxzZSBvKF8uaGlnaGxpZ2h0KGwuY29kZSwgbC5ncmFtbWFyLCBsLmxhbmd1YWdlKSk7XG4gICAgICAgICAgZWxzZSBvKF8udXRpbC5lbmNvZGUobC5jb2RlKSk7XG4gICAgICAgIH0sXG4gICAgICAgIGhpZ2hsaWdodDogZnVuY3Rpb24oZSwgbiwgdCkge1xuICAgICAgICAgIHZhciByID0geyBjb2RlOiBlLCBncmFtbWFyOiBuLCBsYW5ndWFnZTogdCB9O1xuICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICBfLmhvb2tzLnJ1bignYmVmb3JlLXRva2VuaXplJywgciksXG4gICAgICAgICAgICAoci50b2tlbnMgPSBfLnRva2VuaXplKHIuY29kZSwgci5ncmFtbWFyKSksXG4gICAgICAgICAgICBfLmhvb2tzLnJ1bignYWZ0ZXItdG9rZW5pemUnLCByKSxcbiAgICAgICAgICAgIE0uc3RyaW5naWZ5KF8udXRpbC5lbmNvZGUoci50b2tlbnMpLCByLmxhbmd1YWdlKVxuICAgICAgICAgICk7XG4gICAgICAgIH0sXG4gICAgICAgIHRva2VuaXplOiBmdW5jdGlvbihlLCBuKSB7XG4gICAgICAgICAgdmFyIHQgPSBuLnJlc3Q7XG4gICAgICAgICAgaWYgKHQpIHtcbiAgICAgICAgICAgIGZvciAodmFyIHIgaW4gdCkgbltyXSA9IHRbcl07XG4gICAgICAgICAgICBkZWxldGUgbi5yZXN0O1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgYSA9IG5ldyBpKCk7XG4gICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIHooYSwgYS5oZWFkLCBlKSxcbiAgICAgICAgICAgIChmdW5jdGlvbiBlKG4sIHQsIHIsIGEsIGksIGwpIHtcbiAgICAgICAgICAgICAgZm9yICh2YXIgbyBpbiByKVxuICAgICAgICAgICAgICAgIGlmIChyLmhhc093blByb3BlcnR5KG8pICYmIHJbb10pIHtcbiAgICAgICAgICAgICAgICAgIHZhciBzID0gcltvXTtcbiAgICAgICAgICAgICAgICAgIHMgPSBBcnJheS5pc0FycmF5KHMpID8gcyA6IFtzXTtcbiAgICAgICAgICAgICAgICAgIGZvciAodmFyIHUgPSAwOyB1IDwgcy5sZW5ndGg7ICsrdSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAobCAmJiBsLmNhdXNlID09IG8gKyAnLCcgKyB1KSByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIHZhciBjID0gc1t1XSxcbiAgICAgICAgICAgICAgICAgICAgICBnID0gYy5pbnNpZGUsXG4gICAgICAgICAgICAgICAgICAgICAgZiA9ICEhYy5sb29rYmVoaW5kLFxuICAgICAgICAgICAgICAgICAgICAgIGggPSAhIWMuZ3JlZWR5LFxuICAgICAgICAgICAgICAgICAgICAgIGQgPSBjLmFsaWFzO1xuICAgICAgICAgICAgICAgICAgICBpZiAoaCAmJiAhYy5wYXR0ZXJuLmdsb2JhbCkge1xuICAgICAgICAgICAgICAgICAgICAgIHZhciB2ID0gYy5wYXR0ZXJuLnRvU3RyaW5nKCkubWF0Y2goL1tpbXN1eV0qJC8pWzBdO1xuICAgICAgICAgICAgICAgICAgICAgIGMucGF0dGVybiA9IFJlZ0V4cChjLnBhdHRlcm4uc291cmNlLCB2ICsgJ2cnKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBmb3IgKFxuICAgICAgICAgICAgICAgICAgICAgIHZhciBwID0gYy5wYXR0ZXJuIHx8IGMsIG0gPSBhLm5leHQsIHkgPSBpO1xuICAgICAgICAgICAgICAgICAgICAgIG0gIT09IHQudGFpbCAmJiAhKGwgJiYgeSA+PSBsLnJlYWNoKTtcbiAgICAgICAgICAgICAgICAgICAgICB5ICs9IG0udmFsdWUubGVuZ3RoLCBtID0gbS5uZXh0XG4gICAgICAgICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgICAgICAgIHZhciBrID0gbS52YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICBpZiAodC5sZW5ndGggPiBuLmxlbmd0aCkgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICAgIGlmICghKGsgaW5zdGFuY2VvZiBNKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIHggPSAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCEoYiA9IFcocCwgeSwgbiwgZikpKSBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHcgPSBiLmluZGV4LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIEEgPSBiLmluZGV4ICsgYlswXS5sZW5ndGgsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgUCA9IHk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoUCArPSBtLnZhbHVlLmxlbmd0aDsgUCA8PSB3OyApXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKG0gPSBtLm5leHQpLCAoUCArPSBtLnZhbHVlLmxlbmd0aCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKFAgLT0gbS52YWx1ZS5sZW5ndGgpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICh5ID0gUCksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbS52YWx1ZSBpbnN0YW5jZW9mIE0pXG4gICAgICAgICAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgUyA9IG07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgUyAhPT0gdC50YWlsICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKFAgPCBBIHx8ICdzdHJpbmcnID09IHR5cGVvZiBTLnZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBTID0gUy5uZXh0XG4gICAgICAgICAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB4KyssIChQICs9IFMudmFsdWUubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgeC0tLCAoayA9IG4uc2xpY2UoeSwgUCkpLCAoYi5pbmRleCAtPSB5KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoIShiID0gVyhwLCAwLCBrLCBmKSkpIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHcgPSBiLmluZGV4LFxuICAgICAgICAgICAgICAgICAgICAgICAgICBFID0gYlswXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgTyA9IGsuc2xpY2UoMCwgdyksXG4gICAgICAgICAgICAgICAgICAgICAgICAgIEwgPSBrLnNsaWNlKHcgKyBFLmxlbmd0aCksXG4gICAgICAgICAgICAgICAgICAgICAgICAgIE4gPSB5ICsgay5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgICAgICBsICYmIE4gPiBsLnJlYWNoICYmIChsLnJlYWNoID0gTik7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgaiA9IG0ucHJldjtcbiAgICAgICAgICAgICAgICAgICAgICAgIE8gJiYgKChqID0geih0LCBqLCBPKSksICh5ICs9IE8ubGVuZ3RoKSksIEkodCwgaiwgeCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgQyA9IG5ldyBNKG8sIGcgPyBfLnRva2VuaXplKEUsIGcpIDogRSwgZCwgRSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAobSA9IHoodCwgaiwgQykpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICBMICYmIHoodCwgbSwgTCksXG4gICAgICAgICAgICAgICAgICAgICAgICAgIDEgPCB4ICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZShuLCB0LCByLCBtLnByZXYsIHksIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhdXNlOiBvICsgJywnICsgdSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlYWNoOiBOLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pKGUsIGEsIG4sIGEuaGVhZCwgMCksXG4gICAgICAgICAgICAoZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgICB2YXIgbiA9IFtdLFxuICAgICAgICAgICAgICAgIHQgPSBlLmhlYWQubmV4dDtcbiAgICAgICAgICAgICAgZm9yICg7IHQgIT09IGUudGFpbDsgKSBuLnB1c2godC52YWx1ZSksICh0ID0gdC5uZXh0KTtcbiAgICAgICAgICAgICAgcmV0dXJuIG47XG4gICAgICAgICAgICB9KShhKVxuICAgICAgICAgICk7XG4gICAgICAgIH0sXG4gICAgICAgIGhvb2tzOiB7XG4gICAgICAgICAgYWxsOiB7fSxcbiAgICAgICAgICBhZGQ6IGZ1bmN0aW9uKGUsIG4pIHtcbiAgICAgICAgICAgIHZhciB0ID0gXy5ob29rcy5hbGw7XG4gICAgICAgICAgICAodFtlXSA9IHRbZV0gfHwgW10pLCB0W2VdLnB1c2gobik7XG4gICAgICAgICAgfSxcbiAgICAgICAgICBydW46IGZ1bmN0aW9uKGUsIG4pIHtcbiAgICAgICAgICAgIHZhciB0ID0gXy5ob29rcy5hbGxbZV07XG4gICAgICAgICAgICBpZiAodCAmJiB0Lmxlbmd0aCkgZm9yICh2YXIgciwgYSA9IDA7IChyID0gdFthKytdKTsgKSByKG4pO1xuICAgICAgICAgIH0sXG4gICAgICAgIH0sXG4gICAgICAgIFRva2VuOiBNLFxuICAgICAgfTtcbiAgICBmdW5jdGlvbiBNKGUsIG4sIHQsIHIpIHtcbiAgICAgICh0aGlzLnR5cGUgPSBlKSxcbiAgICAgICAgKHRoaXMuY29udGVudCA9IG4pLFxuICAgICAgICAodGhpcy5hbGlhcyA9IHQpLFxuICAgICAgICAodGhpcy5sZW5ndGggPSAwIHwgKHIgfHwgJycpLmxlbmd0aCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIFcoZSwgbiwgdCwgcikge1xuICAgICAgZS5sYXN0SW5kZXggPSBuO1xuICAgICAgdmFyIGEgPSBlLmV4ZWModCk7XG4gICAgICBpZiAoYSAmJiByICYmIGFbMV0pIHtcbiAgICAgICAgdmFyIGkgPSBhWzFdLmxlbmd0aDtcbiAgICAgICAgKGEuaW5kZXggKz0gaSksIChhWzBdID0gYVswXS5zbGljZShpKSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gYTtcbiAgICB9XG4gICAgZnVuY3Rpb24gaSgpIHtcbiAgICAgIHZhciBlID0geyB2YWx1ZTogbnVsbCwgcHJldjogbnVsbCwgbmV4dDogbnVsbCB9LFxuICAgICAgICBuID0geyB2YWx1ZTogbnVsbCwgcHJldjogZSwgbmV4dDogbnVsbCB9O1xuICAgICAgKGUubmV4dCA9IG4pLCAodGhpcy5oZWFkID0gZSksICh0aGlzLnRhaWwgPSBuKSwgKHRoaXMubGVuZ3RoID0gMCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHooZSwgbiwgdCkge1xuICAgICAgdmFyIHIgPSBuLm5leHQsXG4gICAgICAgIGEgPSB7IHZhbHVlOiB0LCBwcmV2OiBuLCBuZXh0OiByIH07XG4gICAgICByZXR1cm4gKG4ubmV4dCA9IGEpLCAoci5wcmV2ID0gYSksIGUubGVuZ3RoKyssIGE7XG4gICAgfVxuICAgIGZ1bmN0aW9uIEkoZSwgbiwgdCkge1xuICAgICAgZm9yICh2YXIgciA9IG4ubmV4dCwgYSA9IDA7IGEgPCB0ICYmIHIgIT09IGUudGFpbDsgYSsrKSByID0gci5uZXh0O1xuICAgICAgKChuLm5leHQgPSByKS5wcmV2ID0gbiksIChlLmxlbmd0aCAtPSBhKTtcbiAgICB9XG4gICAgaWYgKFxuICAgICAgKCh1LlByaXNtID0gXyksXG4gICAgICAoTS5zdHJpbmdpZnkgPSBmdW5jdGlvbiBuKGUsIHQpIHtcbiAgICAgICAgaWYgKCdzdHJpbmcnID09IHR5cGVvZiBlKSByZXR1cm4gZTtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoZSkpIHtcbiAgICAgICAgICB2YXIgciA9ICcnO1xuICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICBlLmZvckVhY2goZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgICByICs9IG4oZSwgdCk7XG4gICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIHJcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIHZhciBhID0ge1xuICAgICAgICAgICAgdHlwZTogZS50eXBlLFxuICAgICAgICAgICAgY29udGVudDogbihlLmNvbnRlbnQsIHQpLFxuICAgICAgICAgICAgdGFnOiAnc3BhbicsXG4gICAgICAgICAgICBjbGFzc2VzOiBbJ3Rva2VuJywgZS50eXBlXSxcbiAgICAgICAgICAgIGF0dHJpYnV0ZXM6IHt9LFxuICAgICAgICAgICAgbGFuZ3VhZ2U6IHQsXG4gICAgICAgICAgfSxcbiAgICAgICAgICBpID0gZS5hbGlhcztcbiAgICAgICAgaSAmJlxuICAgICAgICAgIChBcnJheS5pc0FycmF5KGkpXG4gICAgICAgICAgICA/IEFycmF5LnByb3RvdHlwZS5wdXNoLmFwcGx5KGEuY2xhc3NlcywgaSlcbiAgICAgICAgICAgIDogYS5jbGFzc2VzLnB1c2goaSkpLFxuICAgICAgICAgIF8uaG9va3MucnVuKCd3cmFwJywgYSk7XG4gICAgICAgIHZhciBsID0gJyc7XG4gICAgICAgIGZvciAodmFyIG8gaW4gYS5hdHRyaWJ1dGVzKVxuICAgICAgICAgIGwgKz1cbiAgICAgICAgICAgICcgJyArXG4gICAgICAgICAgICBvICtcbiAgICAgICAgICAgICc9XCInICtcbiAgICAgICAgICAgIChhLmF0dHJpYnV0ZXNbb10gfHwgJycpLnJlcGxhY2UoL1wiL2csICcmcXVvdDsnKSArXG4gICAgICAgICAgICAnXCInO1xuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICc8JyArXG4gICAgICAgICAgYS50YWcgK1xuICAgICAgICAgICcgY2xhc3M9XCInICtcbiAgICAgICAgICBhLmNsYXNzZXMuam9pbignICcpICtcbiAgICAgICAgICAnXCInICtcbiAgICAgICAgICBsICtcbiAgICAgICAgICAnPicgK1xuICAgICAgICAgIGEuY29udGVudCArXG4gICAgICAgICAgJzwvJyArXG4gICAgICAgICAgYS50YWcgK1xuICAgICAgICAgICc+J1xuICAgICAgICApO1xuICAgICAgfSksXG4gICAgICAhdS5kb2N1bWVudClcbiAgICApXG4gICAgICByZXR1cm4gKFxuICAgICAgICB1LmFkZEV2ZW50TGlzdGVuZXIgJiZcbiAgICAgICAgICAoXy5kaXNhYmxlV29ya2VyTWVzc2FnZUhhbmRsZXIgfHxcbiAgICAgICAgICAgIHUuYWRkRXZlbnRMaXN0ZW5lcihcbiAgICAgICAgICAgICAgJ21lc3NhZ2UnLFxuICAgICAgICAgICAgICBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICAgICAgdmFyIG4gPSBKU09OLnBhcnNlKGUuZGF0YSksXG4gICAgICAgICAgICAgICAgICB0ID0gbi5sYW5ndWFnZSxcbiAgICAgICAgICAgICAgICAgIHIgPSBuLmNvZGUsXG4gICAgICAgICAgICAgICAgICBhID0gbi5pbW1lZGlhdGVDbG9zZTtcbiAgICAgICAgICAgICAgICB1LnBvc3RNZXNzYWdlKF8uaGlnaGxpZ2h0KHIsIF8ubGFuZ3VhZ2VzW3RdLCB0KSksXG4gICAgICAgICAgICAgICAgICBhICYmIHUuY2xvc2UoKTtcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgITFcbiAgICAgICAgICAgICkpLFxuICAgICAgICBfXG4gICAgICApO1xuICAgIHZhciBlID0gXy51dGlsLmN1cnJlbnRTY3JpcHQoKTtcbiAgICBmdW5jdGlvbiB0KCkge1xuICAgICAgXy5tYW51YWwgfHwgXy5oaWdobGlnaHRBbGwoKTtcbiAgICB9XG4gICAgaWYgKFxuICAgICAgKGUgJiZcbiAgICAgICAgKChfLmZpbGVuYW1lID0gZS5zcmMpLFxuICAgICAgICBlLmhhc0F0dHJpYnV0ZSgnZGF0YS1tYW51YWwnKSAmJiAoXy5tYW51YWwgPSAhMCkpLFxuICAgICAgIV8ubWFudWFsKVxuICAgICkge1xuICAgICAgdmFyIHIgPSBkb2N1bWVudC5yZWFkeVN0YXRlO1xuICAgICAgJ2xvYWRpbmcnID09PSByIHx8ICgnaW50ZXJhY3RpdmUnID09PSByICYmIGUgJiYgZS5kZWZlcilcbiAgICAgICAgPyBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdET01Db250ZW50TG9hZGVkJywgdClcbiAgICAgICAgOiB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lXG4gICAgICAgID8gd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSh0KVxuICAgICAgICA6IHdpbmRvdy5zZXRUaW1lb3V0KHQsIDE2KTtcbiAgICB9XG4gICAgcmV0dXJuIF87XG4gIH0pKF9zZWxmKTtcbid1bmRlZmluZWQnICE9IHR5cGVvZiBtb2R1bGUgJiYgbW9kdWxlLmV4cG9ydHMgJiYgKG1vZHVsZS5leHBvcnRzID0gUHJpc20pLFxuICAndW5kZWZpbmVkJyAhPSB0eXBlb2YgZ2xvYmFsICYmIChnbG9iYWwuUHJpc20gPSBQcmlzbSk7XG4oUHJpc20ubGFuZ3VhZ2VzLm1hcmt1cCA9IHtcbiAgY29tbWVudDogLzwhLS1bXFxzXFxTXSo/LS0+LyxcbiAgcHJvbG9nOiAvPFxcP1tcXHNcXFNdKz9cXD8+LyxcbiAgZG9jdHlwZToge1xuICAgIHBhdHRlcm46IC88IURPQ1RZUEUoPzpbXj5cIidbXFxdXXxcIlteXCJdKlwifCdbXiddKicpKyg/OlxcWyg/OltePFwiJ1xcXV18XCJbXlwiXSpcInwnW14nXSonfDwoPyEhLS0pfDwhLS0oPzpbXi1dfC0oPyEtPikpKi0tPikqXFxdXFxzKik/Pi9pLFxuICAgIGdyZWVkeTogITAsXG4gICAgaW5zaWRlOiB7XG4gICAgICAnaW50ZXJuYWwtc3Vic2V0Jzoge1xuICAgICAgICBwYXR0ZXJuOiAvKFxcWylbXFxzXFxTXSsoPz1cXF0+JCkvLFxuICAgICAgICBsb29rYmVoaW5kOiAhMCxcbiAgICAgICAgZ3JlZWR5OiAhMCxcbiAgICAgICAgaW5zaWRlOiBudWxsLFxuICAgICAgfSxcbiAgICAgIHN0cmluZzogeyBwYXR0ZXJuOiAvXCJbXlwiXSpcInwnW14nXSonLywgZ3JlZWR5OiAhMCB9LFxuICAgICAgcHVuY3R1YXRpb246IC9ePCF8PiR8W1tcXF1dLyxcbiAgICAgICdkb2N0eXBlLXRhZyc6IC9eRE9DVFlQRS8sXG4gICAgICBuYW1lOiAvW15cXHM8PidcIl0rLyxcbiAgICB9LFxuICB9LFxuICBjZGF0YTogLzwhXFxbQ0RBVEFcXFtbXFxzXFxTXSo/XV0+L2ksXG4gIHRhZzoge1xuICAgIHBhdHRlcm46IC88XFwvPyg/IVxcZClbXlxccz5cXC89JDwlXSsoPzpcXHMoPzpcXHMqW15cXHM+XFwvPV0rKD86XFxzKj1cXHMqKD86XCJbXlwiXSpcInwnW14nXSonfFteXFxzJ1wiPj1dKyg/PVtcXHM+XSkpfCg/PVtcXHMvPl0pKSkrKT9cXHMqXFwvPz4vLFxuICAgIGdyZWVkeTogITAsXG4gICAgaW5zaWRlOiB7XG4gICAgICB0YWc6IHtcbiAgICAgICAgcGF0dGVybjogL148XFwvP1teXFxzPlxcL10rLyxcbiAgICAgICAgaW5zaWRlOiB7IHB1bmN0dWF0aW9uOiAvXjxcXC8/LywgbmFtZXNwYWNlOiAvXlteXFxzPlxcLzpdKzovIH0sXG4gICAgICB9LFxuICAgICAgJ2F0dHItdmFsdWUnOiB7XG4gICAgICAgIHBhdHRlcm46IC89XFxzKig/OlwiW15cIl0qXCJ8J1teJ10qJ3xbXlxccydcIj49XSspLyxcbiAgICAgICAgaW5zaWRlOiB7XG4gICAgICAgICAgcHVuY3R1YXRpb246IFt7IHBhdHRlcm46IC9ePS8sIGFsaWFzOiAnYXR0ci1lcXVhbHMnIH0sIC9cInwnL10sXG4gICAgICAgIH0sXG4gICAgICB9LFxuICAgICAgcHVuY3R1YXRpb246IC9cXC8/Pi8sXG4gICAgICAnYXR0ci1uYW1lJzoge1xuICAgICAgICBwYXR0ZXJuOiAvW15cXHM+XFwvXSsvLFxuICAgICAgICBpbnNpZGU6IHsgbmFtZXNwYWNlOiAvXlteXFxzPlxcLzpdKzovIH0sXG4gICAgICB9LFxuICAgIH0sXG4gIH0sXG4gIGVudGl0eTogW1xuICAgIHsgcGF0dGVybjogLyZbXFxkYS16XXsxLDh9Oy9pLCBhbGlhczogJ25hbWVkLWVudGl0eScgfSxcbiAgICAvJiN4P1tcXGRhLWZdezEsOH07L2ksXG4gIF0sXG59KSxcbiAgKFByaXNtLmxhbmd1YWdlcy5tYXJrdXAudGFnLmluc2lkZVsnYXR0ci12YWx1ZSddLmluc2lkZS5lbnRpdHkgPVxuICAgIFByaXNtLmxhbmd1YWdlcy5tYXJrdXAuZW50aXR5KSxcbiAgKFByaXNtLmxhbmd1YWdlcy5tYXJrdXAuZG9jdHlwZS5pbnNpZGVbJ2ludGVybmFsLXN1YnNldCddLmluc2lkZSA9XG4gICAgUHJpc20ubGFuZ3VhZ2VzLm1hcmt1cCksXG4gIFByaXNtLmhvb2tzLmFkZCgnd3JhcCcsIGZ1bmN0aW9uKGEpIHtcbiAgICAnZW50aXR5JyA9PT0gYS50eXBlICYmXG4gICAgICAoYS5hdHRyaWJ1dGVzLnRpdGxlID0gYS5jb250ZW50LnJlcGxhY2UoLyZhbXA7LywgJyYnKSk7XG4gIH0pLFxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoUHJpc20ubGFuZ3VhZ2VzLm1hcmt1cC50YWcsICdhZGRJbmxpbmVkJywge1xuICAgIHZhbHVlOiBmdW5jdGlvbihhLCBlKSB7XG4gICAgICB2YXIgcyA9IHt9O1xuICAgICAgKHNbJ2xhbmd1YWdlLScgKyBlXSA9IHtcbiAgICAgICAgcGF0dGVybjogLyhePCFcXFtDREFUQVxcWylbXFxzXFxTXSs/KD89XFxdXFxdPiQpL2ksXG4gICAgICAgIGxvb2tiZWhpbmQ6ICEwLFxuICAgICAgICBpbnNpZGU6IFByaXNtLmxhbmd1YWdlc1tlXSxcbiAgICAgIH0pLFxuICAgICAgICAocy5jZGF0YSA9IC9ePCFcXFtDREFUQVxcW3xcXF1cXF0+JC9pKTtcbiAgICAgIHZhciBuID0ge1xuICAgICAgICAnaW5jbHVkZWQtY2RhdGEnOiB7IHBhdHRlcm46IC88IVxcW0NEQVRBXFxbW1xcc1xcU10qP1xcXVxcXT4vaSwgaW5zaWRlOiBzIH0sXG4gICAgICB9O1xuICAgICAgblsnbGFuZ3VhZ2UtJyArIGVdID0geyBwYXR0ZXJuOiAvW1xcc1xcU10rLywgaW5zaWRlOiBQcmlzbS5sYW5ndWFnZXNbZV0gfTtcbiAgICAgIHZhciB0ID0ge307XG4gICAgICAodFthXSA9IHtcbiAgICAgICAgcGF0dGVybjogUmVnRXhwKFxuICAgICAgICAgICcoPF9fW15dKj8+KSg/OjwhXFxcXFtDREFUQVxcXFxbKD86W15cXFxcXV18XFxcXF0oPyFcXFxcXT4pKSpcXFxcXVxcXFxdPnwoPyE8IVxcXFxbQ0RBVEFcXFxcWylbXl0pKj8oPz08L19fPiknLnJlcGxhY2UoXG4gICAgICAgICAgICAvX18vZyxcbiAgICAgICAgICAgIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICByZXR1cm4gYTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICApLFxuICAgICAgICAgICdpJ1xuICAgICAgICApLFxuICAgICAgICBsb29rYmVoaW5kOiAhMCxcbiAgICAgICAgZ3JlZWR5OiAhMCxcbiAgICAgICAgaW5zaWRlOiBuLFxuICAgICAgfSksXG4gICAgICAgIFByaXNtLmxhbmd1YWdlcy5pbnNlcnRCZWZvcmUoJ21hcmt1cCcsICdjZGF0YScsIHQpO1xuICAgIH0sXG4gIH0pLFxuICAoUHJpc20ubGFuZ3VhZ2VzLmh0bWwgPSBQcmlzbS5sYW5ndWFnZXMubWFya3VwKSxcbiAgKFByaXNtLmxhbmd1YWdlcy5tYXRobWwgPSBQcmlzbS5sYW5ndWFnZXMubWFya3VwKSxcbiAgKFByaXNtLmxhbmd1YWdlcy5zdmcgPSBQcmlzbS5sYW5ndWFnZXMubWFya3VwKSxcbiAgKFByaXNtLmxhbmd1YWdlcy54bWwgPSBQcmlzbS5sYW5ndWFnZXMuZXh0ZW5kKCdtYXJrdXAnLCB7fSkpLFxuICAoUHJpc20ubGFuZ3VhZ2VzLnNzbWwgPSBQcmlzbS5sYW5ndWFnZXMueG1sKSxcbiAgKFByaXNtLmxhbmd1YWdlcy5hdG9tID0gUHJpc20ubGFuZ3VhZ2VzLnhtbCksXG4gIChQcmlzbS5sYW5ndWFnZXMucnNzID0gUHJpc20ubGFuZ3VhZ2VzLnhtbCk7XG4hKGZ1bmN0aW9uKGUpIHtcbiAgdmFyIHQgPSAvKFwifCcpKD86XFxcXCg/OlxcclxcbnxbXFxzXFxTXSl8KD8hXFwxKVteXFxcXFxcclxcbl0pKlxcMS87XG4gIChlLmxhbmd1YWdlcy5jc3MgPSB7XG4gICAgY29tbWVudDogL1xcL1xcKltcXHNcXFNdKj9cXCpcXC8vLFxuICAgIGF0cnVsZToge1xuICAgICAgcGF0dGVybjogL0BbXFx3LV0rW1xcc1xcU10qPyg/Ojt8KD89XFxzKlxceykpLyxcbiAgICAgIGluc2lkZToge1xuICAgICAgICBydWxlOiAvXkBbXFx3LV0rLyxcbiAgICAgICAgJ3NlbGVjdG9yLWZ1bmN0aW9uLWFyZ3VtZW50Jzoge1xuICAgICAgICAgIHBhdHRlcm46IC8oXFxic2VsZWN0b3JcXHMqXFwoKD8hXFxzKlxcKSlcXHMqKSg/OlteKCldfFxcKCg/OlteKCldfFxcKFteKCldKlxcKSkqXFwpKSs/KD89XFxzKlxcKSkvLFxuICAgICAgICAgIGxvb2tiZWhpbmQ6ICEwLFxuICAgICAgICAgIGFsaWFzOiAnc2VsZWN0b3InLFxuICAgICAgICB9LFxuICAgICAgICBrZXl3b3JkOiB7XG4gICAgICAgICAgcGF0dGVybjogLyhefFteXFx3LV0pKD86YW5kfG5vdHxvbmx5fG9yKSg/IVtcXHctXSkvLFxuICAgICAgICAgIGxvb2tiZWhpbmQ6ICEwLFxuICAgICAgICB9LFxuICAgICAgfSxcbiAgICB9LFxuICAgIHVybDoge1xuICAgICAgcGF0dGVybjogUmVnRXhwKFxuICAgICAgICAnXFxcXGJ1cmxcXFxcKCg/OicgKyB0LnNvdXJjZSArICd8KD86W15cXFxcXFxcXFxcclxcbigpXCJcXCddfFxcXFxcXFxcW15dKSopXFxcXCknLFxuICAgICAgICAnaSdcbiAgICAgICksXG4gICAgICBncmVlZHk6ICEwLFxuICAgICAgaW5zaWRlOiB7XG4gICAgICAgIGZ1bmN0aW9uOiAvXnVybC9pLFxuICAgICAgICBwdW5jdHVhdGlvbjogL15cXCh8XFwpJC8sXG4gICAgICAgIHN0cmluZzogeyBwYXR0ZXJuOiBSZWdFeHAoJ14nICsgdC5zb3VyY2UgKyAnJCcpLCBhbGlhczogJ3VybCcgfSxcbiAgICAgIH0sXG4gICAgfSxcbiAgICBzZWxlY3RvcjogUmVnRXhwKCdbXnt9XFxcXHNdKD86W157fTtcIlxcJ118JyArIHQuc291cmNlICsgJykqPyg/PVxcXFxzKlxcXFx7KScpLFxuICAgIHN0cmluZzogeyBwYXR0ZXJuOiB0LCBncmVlZHk6ICEwIH0sXG4gICAgcHJvcGVydHk6IC9bLV9hLXpcXHhBMC1cXHVGRkZGXVstXFx3XFx4QTAtXFx1RkZGRl0qKD89XFxzKjopL2ksXG4gICAgaW1wb3J0YW50OiAvIWltcG9ydGFudFxcYi9pLFxuICAgIGZ1bmN0aW9uOiAvWy1hLXowLTldKyg/PVxcKCkvaSxcbiAgICBwdW5jdHVhdGlvbjogL1soKXt9OzosXS8sXG4gIH0pLFxuICAgIChlLmxhbmd1YWdlcy5jc3MuYXRydWxlLmluc2lkZS5yZXN0ID0gZS5sYW5ndWFnZXMuY3NzKTtcbiAgdmFyIHMgPSBlLmxhbmd1YWdlcy5tYXJrdXA7XG4gIHMgJiZcbiAgICAocy50YWcuYWRkSW5saW5lZCgnc3R5bGUnLCAnY3NzJyksXG4gICAgZS5sYW5ndWFnZXMuaW5zZXJ0QmVmb3JlKFxuICAgICAgJ2luc2lkZScsXG4gICAgICAnYXR0ci12YWx1ZScsXG4gICAgICB7XG4gICAgICAgICdzdHlsZS1hdHRyJzoge1xuICAgICAgICAgIHBhdHRlcm46IC8oXnxbXCInXFxzXSlzdHlsZVxccyo9XFxzKig/OlwiW15cIl0qXCJ8J1teJ10qJykvaSxcbiAgICAgICAgICBsb29rYmVoaW5kOiAhMCxcbiAgICAgICAgICBpbnNpZGU6IHtcbiAgICAgICAgICAgICdhdHRyLXZhbHVlJzoge1xuICAgICAgICAgICAgICBwYXR0ZXJuOiAvPVxccyooPzpcIlteXCJdKlwifCdbXiddKid8W15cXHMnXCI+PV0rKS8sXG4gICAgICAgICAgICAgIGluc2lkZToge1xuICAgICAgICAgICAgICAgIHN0eWxlOiB7XG4gICAgICAgICAgICAgICAgICBwYXR0ZXJuOiAvKFtcIiddKVtcXHNcXFNdKyg/PVtcIiddJCkvLFxuICAgICAgICAgICAgICAgICAgbG9va2JlaGluZDogITAsXG4gICAgICAgICAgICAgICAgICBhbGlhczogJ2xhbmd1YWdlLWNzcycsXG4gICAgICAgICAgICAgICAgICBpbnNpZGU6IGUubGFuZ3VhZ2VzLmNzcyxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHB1bmN0dWF0aW9uOiBbeyBwYXR0ZXJuOiAvXj0vLCBhbGlhczogJ2F0dHItZXF1YWxzJyB9LCAvXCJ8Jy9dLFxuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICdhdHRyLW5hbWUnOiAvXnN0eWxlL2ksXG4gICAgICAgICAgfSxcbiAgICAgICAgfSxcbiAgICAgIH0sXG4gICAgICBzLnRhZ1xuICAgICkpO1xufSkoUHJpc20pO1xuUHJpc20ubGFuZ3VhZ2VzLmNsaWtlID0ge1xuICBjb21tZW50OiBbXG4gICAgeyBwYXR0ZXJuOiAvKF58W15cXFxcXSlcXC9cXCpbXFxzXFxTXSo/KD86XFwqXFwvfCQpLywgbG9va2JlaGluZDogITAgfSxcbiAgICB7IHBhdHRlcm46IC8oXnxbXlxcXFw6XSlcXC9cXC8uKi8sIGxvb2tiZWhpbmQ6ICEwLCBncmVlZHk6ICEwIH0sXG4gIF0sXG4gIHN0cmluZzoge1xuICAgIHBhdHRlcm46IC8oW1wiJ10pKD86XFxcXCg/OlxcclxcbnxbXFxzXFxTXSl8KD8hXFwxKVteXFxcXFxcclxcbl0pKlxcMS8sXG4gICAgZ3JlZWR5OiAhMCxcbiAgfSxcbiAgJ2NsYXNzLW5hbWUnOiB7XG4gICAgcGF0dGVybjogLyhcXGIoPzpjbGFzc3xpbnRlcmZhY2V8ZXh0ZW5kc3xpbXBsZW1lbnRzfHRyYWl0fGluc3RhbmNlb2Z8bmV3KVxccyt8XFxiY2F0Y2hcXHMrXFwoKVtcXHcuXFxcXF0rL2ksXG4gICAgbG9va2JlaGluZDogITAsXG4gICAgaW5zaWRlOiB7IHB1bmN0dWF0aW9uOiAvWy5cXFxcXS8gfSxcbiAgfSxcbiAga2V5d29yZDogL1xcYig/OmlmfGVsc2V8d2hpbGV8ZG98Zm9yfHJldHVybnxpbnxpbnN0YW5jZW9mfGZ1bmN0aW9ufG5ld3x0cnl8dGhyb3d8Y2F0Y2h8ZmluYWxseXxudWxsfGJyZWFrfGNvbnRpbnVlKVxcYi8sXG4gIGJvb2xlYW46IC9cXGIoPzp0cnVlfGZhbHNlKVxcYi8sXG4gIGZ1bmN0aW9uOiAvXFx3Kyg/PVxcKCkvLFxuICBudW1iZXI6IC9cXGIweFtcXGRhLWZdK1xcYnwoPzpcXGJcXGQrXFwuP1xcZCp8XFxCXFwuXFxkKykoPzplWystXT9cXGQrKT8vaSxcbiAgb3BlcmF0b3I6IC9bPD5dPT98WyE9XT0/PT98LS0/fFxcK1xcKz98JiY/fFxcfFxcfD98Wz8qL35eJV0vLFxuICBwdW5jdHVhdGlvbjogL1t7fVtcXF07KCksLjpdLyxcbn07XG4oUHJpc20ubGFuZ3VhZ2VzLmphdmFzY3JpcHQgPSBQcmlzbS5sYW5ndWFnZXMuZXh0ZW5kKCdjbGlrZScsIHtcbiAgJ2NsYXNzLW5hbWUnOiBbXG4gICAgUHJpc20ubGFuZ3VhZ2VzLmNsaWtlWydjbGFzcy1uYW1lJ10sXG4gICAge1xuICAgICAgcGF0dGVybjogLyhefFteJFxcd1xceEEwLVxcdUZGRkZdKVtfJEEtWlxceEEwLVxcdUZGRkZdWyRcXHdcXHhBMC1cXHVGRkZGXSooPz1cXC4oPzpwcm90b3R5cGV8Y29uc3RydWN0b3IpKS8sXG4gICAgICBsb29rYmVoaW5kOiAhMCxcbiAgICB9LFxuICBdLFxuICBrZXl3b3JkOiBbXG4gICAgeyBwYXR0ZXJuOiAvKCg/Ol58fSlcXHMqKSg/OmNhdGNofGZpbmFsbHkpXFxiLywgbG9va2JlaGluZDogITAgfSxcbiAgICB7XG4gICAgICBwYXR0ZXJuOiAvKF58W14uXXxcXC5cXC5cXC5cXHMqKVxcYig/OmFzfGFzeW5jKD89XFxzKig/OmZ1bmN0aW9uXFxifFxcKHxbJFxcd1xceEEwLVxcdUZGRkZdfCQpKXxhd2FpdHxicmVha3xjYXNlfGNsYXNzfGNvbnN0fGNvbnRpbnVlfGRlYnVnZ2VyfGRlZmF1bHR8ZGVsZXRlfGRvfGVsc2V8ZW51bXxleHBvcnR8ZXh0ZW5kc3xmb3J8ZnJvbXxmdW5jdGlvbnwoPzpnZXR8c2V0KSg/PVxccypbXFxbJFxcd1xceEEwLVxcdUZGRkZdKXxpZnxpbXBsZW1lbnRzfGltcG9ydHxpbnxpbnN0YW5jZW9mfGludGVyZmFjZXxsZXR8bmV3fG51bGx8b2Z8cGFja2FnZXxwcml2YXRlfHByb3RlY3RlZHxwdWJsaWN8cmV0dXJufHN0YXRpY3xzdXBlcnxzd2l0Y2h8dGhpc3x0aHJvd3x0cnl8dHlwZW9mfHVuZGVmaW5lZHx2YXJ8dm9pZHx3aGlsZXx3aXRofHlpZWxkKVxcYi8sXG4gICAgICBsb29rYmVoaW5kOiAhMCxcbiAgICB9LFxuICBdLFxuICBudW1iZXI6IC9cXGIoPzooPzowW3hYXSg/OltcXGRBLUZhLWZdKD86X1tcXGRBLUZhLWZdKT8pK3wwW2JCXSg/OlswMV0oPzpfWzAxXSk/KSt8MFtvT10oPzpbMC03XSg/Ol9bMC03XSk/KSspbj98KD86XFxkKD86X1xcZCk/KStufE5hTnxJbmZpbml0eSlcXGJ8KD86XFxiKD86XFxkKD86X1xcZCk/KStcXC4/KD86XFxkKD86X1xcZCk/KSp8XFxCXFwuKD86XFxkKD86X1xcZCk/KSspKD86W0VlXVsrLV0/KD86XFxkKD86X1xcZCk/KSspPy8sXG4gIGZ1bmN0aW9uOiAvIz9bXyRhLXpBLVpcXHhBMC1cXHVGRkZGXVskXFx3XFx4QTAtXFx1RkZGRl0qKD89XFxzKig/OlxcLlxccyooPzphcHBseXxiaW5kfGNhbGwpXFxzKik/XFwoKS8sXG4gIG9wZXJhdG9yOiAvLS18XFwrXFwrfFxcKlxcKj0/fD0+fCYmPT98XFx8XFx8PT98WyE9XT09fDw8PT98Pj4+Pz0/fFstKyovJSZ8XiE9PD5dPT98XFwuezN9fFxcP1xcPz0/fFxcP1xcLj98W346XS8sXG59KSksXG4gIChQcmlzbS5sYW5ndWFnZXMuamF2YXNjcmlwdFtcbiAgICAnY2xhc3MtbmFtZSdcbiAgXVswXS5wYXR0ZXJuID0gLyhcXGIoPzpjbGFzc3xpbnRlcmZhY2V8ZXh0ZW5kc3xpbXBsZW1lbnRzfGluc3RhbmNlb2Z8bmV3KVxccyspW1xcdy5cXFxcXSsvKSxcbiAgUHJpc20ubGFuZ3VhZ2VzLmluc2VydEJlZm9yZSgnamF2YXNjcmlwdCcsICdrZXl3b3JkJywge1xuICAgIHJlZ2V4OiB7XG4gICAgICBwYXR0ZXJuOiAvKCg/Ol58W14kXFx3XFx4QTAtXFx1RkZGRi5cIidcXF0pXFxzXXxcXGIoPzpyZXR1cm58eWllbGQpKVxccyopXFwvKD86XFxbKD86W15cXF1cXFxcXFxyXFxuXXxcXFxcLikqXXxcXFxcLnxbXi9cXFxcXFxbXFxyXFxuXSkrXFwvW2dpbXl1c117MCw2fSg/PSg/Olxcc3xcXC9cXCooPzpbXipdfFxcKig/IVxcLykpKlxcKlxcLykqKD86JHxbXFxyXFxuLC47On0pXFxdXXxcXC9cXC8pKS8sXG4gICAgICBsb29rYmVoaW5kOiAhMCxcbiAgICAgIGdyZWVkeTogITAsXG4gICAgICBpbnNpZGU6IHtcbiAgICAgICAgJ3JlZ2V4LXNvdXJjZSc6IHtcbiAgICAgICAgICBwYXR0ZXJuOiAvXihcXC8pW1xcc1xcU10rKD89XFwvW2Etel0qJCkvLFxuICAgICAgICAgIGxvb2tiZWhpbmQ6ICEwLFxuICAgICAgICAgIGFsaWFzOiAnbGFuZ3VhZ2UtcmVnZXgnLFxuICAgICAgICAgIGluc2lkZTogUHJpc20ubGFuZ3VhZ2VzLnJlZ2V4LFxuICAgICAgICB9LFxuICAgICAgICAncmVnZXgtZmxhZ3MnOiAvW2Etel0rJC8sXG4gICAgICAgICdyZWdleC1kZWxpbWl0ZXInOiAvXlxcL3xcXC8kLyxcbiAgICAgIH0sXG4gICAgfSxcbiAgICAnZnVuY3Rpb24tdmFyaWFibGUnOiB7XG4gICAgICBwYXR0ZXJuOiAvIz9bXyRhLXpBLVpcXHhBMC1cXHVGRkZGXVskXFx3XFx4QTAtXFx1RkZGRl0qKD89XFxzKls9Ol1cXHMqKD86YXN5bmNcXHMqKT8oPzpcXGJmdW5jdGlvblxcYnwoPzpcXCgoPzpbXigpXXxcXChbXigpXSpcXCkpKlxcKXxbXyRhLXpBLVpcXHhBMC1cXHVGRkZGXVskXFx3XFx4QTAtXFx1RkZGRl0qKVxccyo9PikpLyxcbiAgICAgIGFsaWFzOiAnZnVuY3Rpb24nLFxuICAgIH0sXG4gICAgcGFyYW1ldGVyOiBbXG4gICAgICB7XG4gICAgICAgIHBhdHRlcm46IC8oZnVuY3Rpb24oPzpcXHMrW18kQS1aYS16XFx4QTAtXFx1RkZGRl1bJFxcd1xceEEwLVxcdUZGRkZdKik/XFxzKlxcKFxccyopKD8hXFxzKSg/OlteKCldfFxcKFteKCldKlxcKSkrPyg/PVxccypcXCkpLyxcbiAgICAgICAgbG9va2JlaGluZDogITAsXG4gICAgICAgIGluc2lkZTogUHJpc20ubGFuZ3VhZ2VzLmphdmFzY3JpcHQsXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBwYXR0ZXJuOiAvW18kYS16XFx4QTAtXFx1RkZGRl1bJFxcd1xceEEwLVxcdUZGRkZdKig/PVxccyo9PikvaSxcbiAgICAgICAgaW5zaWRlOiBQcmlzbS5sYW5ndWFnZXMuamF2YXNjcmlwdCxcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIHBhdHRlcm46IC8oXFwoXFxzKikoPyFcXHMpKD86W14oKV18XFwoW14oKV0qXFwpKSs/KD89XFxzKlxcKVxccyo9PikvLFxuICAgICAgICBsb29rYmVoaW5kOiAhMCxcbiAgICAgICAgaW5zaWRlOiBQcmlzbS5sYW5ndWFnZXMuamF2YXNjcmlwdCxcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIHBhdHRlcm46IC8oKD86XFxifFxcc3xeKSg/ISg/OmFzfGFzeW5jfGF3YWl0fGJyZWFrfGNhc2V8Y2F0Y2h8Y2xhc3N8Y29uc3R8Y29udGludWV8ZGVidWdnZXJ8ZGVmYXVsdHxkZWxldGV8ZG98ZWxzZXxlbnVtfGV4cG9ydHxleHRlbmRzfGZpbmFsbHl8Zm9yfGZyb218ZnVuY3Rpb258Z2V0fGlmfGltcGxlbWVudHN8aW1wb3J0fGlufGluc3RhbmNlb2Z8aW50ZXJmYWNlfGxldHxuZXd8bnVsbHxvZnxwYWNrYWdlfHByaXZhdGV8cHJvdGVjdGVkfHB1YmxpY3xyZXR1cm58c2V0fHN0YXRpY3xzdXBlcnxzd2l0Y2h8dGhpc3x0aHJvd3x0cnl8dHlwZW9mfHVuZGVmaW5lZHx2YXJ8dm9pZHx3aGlsZXx3aXRofHlpZWxkKSg/IVskXFx3XFx4QTAtXFx1RkZGRl0pKSg/OltfJEEtWmEtelxceEEwLVxcdUZGRkZdWyRcXHdcXHhBMC1cXHVGRkZGXSpcXHMqKVxcKFxccyp8XFxdXFxzKlxcKFxccyopKD8hXFxzKSg/OlteKCldfFxcKFteKCldKlxcKSkrPyg/PVxccypcXClcXHMqXFx7KS8sXG4gICAgICAgIGxvb2tiZWhpbmQ6ICEwLFxuICAgICAgICBpbnNpZGU6IFByaXNtLmxhbmd1YWdlcy5qYXZhc2NyaXB0LFxuICAgICAgfSxcbiAgICBdLFxuICAgIGNvbnN0YW50OiAvXFxiW0EtWl0oPzpbQS1aX118XFxkeD8pKlxcYi8sXG4gIH0pLFxuICBQcmlzbS5sYW5ndWFnZXMuaW5zZXJ0QmVmb3JlKCdqYXZhc2NyaXB0JywgJ3N0cmluZycsIHtcbiAgICAndGVtcGxhdGUtc3RyaW5nJzoge1xuICAgICAgcGF0dGVybjogL2AoPzpcXFxcW1xcc1xcU118XFwkeyg/Oltee31dfHsoPzpbXnt9XXx7W159XSp9KSp9KSt9fCg/IVxcJHspW15cXFxcYF0pKmAvLFxuICAgICAgZ3JlZWR5OiAhMCxcbiAgICAgIGluc2lkZToge1xuICAgICAgICAndGVtcGxhdGUtcHVuY3R1YXRpb24nOiB7IHBhdHRlcm46IC9eYHxgJC8sIGFsaWFzOiAnc3RyaW5nJyB9LFxuICAgICAgICBpbnRlcnBvbGF0aW9uOiB7XG4gICAgICAgICAgcGF0dGVybjogLygoPzpefFteXFxcXF0pKD86XFxcXHsyfSkqKVxcJHsoPzpbXnt9XXx7KD86W157fV18e1tefV0qfSkqfSkrfS8sXG4gICAgICAgICAgbG9va2JlaGluZDogITAsXG4gICAgICAgICAgaW5zaWRlOiB7XG4gICAgICAgICAgICAnaW50ZXJwb2xhdGlvbi1wdW5jdHVhdGlvbic6IHtcbiAgICAgICAgICAgICAgcGF0dGVybjogL15cXCR7fH0kLyxcbiAgICAgICAgICAgICAgYWxpYXM6ICdwdW5jdHVhdGlvbicsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgcmVzdDogUHJpc20ubGFuZ3VhZ2VzLmphdmFzY3JpcHQsXG4gICAgICAgICAgfSxcbiAgICAgICAgfSxcbiAgICAgICAgc3RyaW5nOiAvW1xcc1xcU10rLyxcbiAgICAgIH0sXG4gICAgfSxcbiAgfSksXG4gIFByaXNtLmxhbmd1YWdlcy5tYXJrdXAgJiZcbiAgICBQcmlzbS5sYW5ndWFnZXMubWFya3VwLnRhZy5hZGRJbmxpbmVkKCdzY3JpcHQnLCAnamF2YXNjcmlwdCcpLFxuICAoUHJpc20ubGFuZ3VhZ2VzLmpzID0gUHJpc20ubGFuZ3VhZ2VzLmphdmFzY3JpcHQpO1xuKFByaXNtLmxhbmd1YWdlcy5qc29uID0ge1xuICBwcm9wZXJ0eTogeyBwYXR0ZXJuOiAvXCIoPzpcXFxcLnxbXlxcXFxcIlxcclxcbl0pKlwiKD89XFxzKjopLywgZ3JlZWR5OiAhMCB9LFxuICBzdHJpbmc6IHsgcGF0dGVybjogL1wiKD86XFxcXC58W15cXFxcXCJcXHJcXG5dKSpcIig/IVxccyo6KS8sIGdyZWVkeTogITAgfSxcbiAgY29tbWVudDogeyBwYXR0ZXJuOiAvXFwvXFwvLip8XFwvXFwqW1xcc1xcU10qPyg/OlxcKlxcL3wkKS8sIGdyZWVkeTogITAgfSxcbiAgbnVtYmVyOiAvLT9cXGJcXGQrKD86XFwuXFxkKyk/KD86ZVsrLV0/XFxkKyk/XFxiL2ksXG4gIHB1bmN0dWF0aW9uOiAvW3t9W1xcXSxdLyxcbiAgb3BlcmF0b3I6IC86LyxcbiAgYm9vbGVhbjogL1xcYig/OnRydWV8ZmFsc2UpXFxiLyxcbiAgbnVsbDogeyBwYXR0ZXJuOiAvXFxibnVsbFxcYi8sIGFsaWFzOiAna2V5d29yZCcgfSxcbn0pLFxuICAoUHJpc20ubGFuZ3VhZ2VzLndlYm1hbmlmZXN0ID0gUHJpc20ubGFuZ3VhZ2VzLmpzb24pO1xuIShmdW5jdGlvbihlKSB7XG4gIChlLmxhbmd1YWdlcy5zYXNzID0gZS5sYW5ndWFnZXMuZXh0ZW5kKCdjc3MnLCB7XG4gICAgY29tbWVudDoge1xuICAgICAgcGF0dGVybjogL14oWyBcXHRdKilcXC9bXFwvKl0uKig/Oig/Olxccj9cXG58XFxyKVxcMVsgXFx0XSsuKykqL20sXG4gICAgICBsb29rYmVoaW5kOiAhMCxcbiAgICB9LFxuICB9KSksXG4gICAgZS5sYW5ndWFnZXMuaW5zZXJ0QmVmb3JlKCdzYXNzJywgJ2F0cnVsZScsIHtcbiAgICAgICdhdHJ1bGUtbGluZSc6IHtcbiAgICAgICAgcGF0dGVybjogL14oPzpbIFxcdF0qKVtAKz1dLisvbSxcbiAgICAgICAgaW5zaWRlOiB7IGF0cnVsZTogLyg/OkBbXFx3LV0rfFsrPV0pL20gfSxcbiAgICAgIH0sXG4gICAgfSksXG4gICAgZGVsZXRlIGUubGFuZ3VhZ2VzLnNhc3MuYXRydWxlO1xuICB2YXIgdCA9IC9cXCRbLVxcd10rfCNcXHtcXCRbLVxcd10rXFx9LyxcbiAgICBhID0gW1xuICAgICAgL1srKlxcLyVdfFs9IV09fDw9P3w+PT98XFxiKD86YW5kfG9yfG5vdClcXGIvLFxuICAgICAgeyBwYXR0ZXJuOiAvKFxccyspLSg/PVxccykvLCBsb29rYmVoaW5kOiAhMCB9LFxuICAgIF07XG4gIGUubGFuZ3VhZ2VzLmluc2VydEJlZm9yZSgnc2FzcycsICdwcm9wZXJ0eScsIHtcbiAgICAndmFyaWFibGUtbGluZSc6IHtcbiAgICAgIHBhdHRlcm46IC9eWyBcXHRdKlxcJC4rL20sXG4gICAgICBpbnNpZGU6IHsgcHVuY3R1YXRpb246IC86LywgdmFyaWFibGU6IHQsIG9wZXJhdG9yOiBhIH0sXG4gICAgfSxcbiAgICAncHJvcGVydHktbGluZSc6IHtcbiAgICAgIHBhdHRlcm46IC9eWyBcXHRdKig/OlteOlxcc10rICo6Lip8OlteOlxcc10rLiopL20sXG4gICAgICBpbnNpZGU6IHtcbiAgICAgICAgcHJvcGVydHk6IFtcbiAgICAgICAgICAvW146XFxzXSsoPz1cXHMqOikvLFxuICAgICAgICAgIHsgcGF0dGVybjogLyg6KVteOlxcc10rLywgbG9va2JlaGluZDogITAgfSxcbiAgICAgICAgXSxcbiAgICAgICAgcHVuY3R1YXRpb246IC86LyxcbiAgICAgICAgdmFyaWFibGU6IHQsXG4gICAgICAgIG9wZXJhdG9yOiBhLFxuICAgICAgICBpbXBvcnRhbnQ6IGUubGFuZ3VhZ2VzLnNhc3MuaW1wb3J0YW50LFxuICAgICAgfSxcbiAgICB9LFxuICB9KSxcbiAgICBkZWxldGUgZS5sYW5ndWFnZXMuc2Fzcy5wcm9wZXJ0eSxcbiAgICBkZWxldGUgZS5sYW5ndWFnZXMuc2Fzcy5pbXBvcnRhbnQsXG4gICAgZS5sYW5ndWFnZXMuaW5zZXJ0QmVmb3JlKCdzYXNzJywgJ3B1bmN0dWF0aW9uJywge1xuICAgICAgc2VsZWN0b3I6IHtcbiAgICAgICAgcGF0dGVybjogLyhbIFxcdF0qKVxcUyg/OixbXixcXHJcXG5dK3xbXixcXHJcXG5dKikoPzosW14sXFxyXFxuXSspKig/OiwoPzpcXHI/XFxufFxccilcXDFbIFxcdF0rXFxTKD86LFteLFxcclxcbl0rfFteLFxcclxcbl0qKSg/OixbXixcXHJcXG5dKykqKSovLFxuICAgICAgICBsb29rYmVoaW5kOiAhMCxcbiAgICAgIH0sXG4gICAgfSk7XG59KShQcmlzbSk7XG4oUHJpc20ubGFuZ3VhZ2VzLnNjc3MgPSBQcmlzbS5sYW5ndWFnZXMuZXh0ZW5kKCdjc3MnLCB7XG4gIGNvbW1lbnQ6IHsgcGF0dGVybjogLyhefFteXFxcXF0pKD86XFwvXFwqW1xcc1xcU10qP1xcKlxcL3xcXC9cXC8uKikvLCBsb29rYmVoaW5kOiAhMCB9LFxuICBhdHJ1bGU6IHtcbiAgICBwYXR0ZXJuOiAvQFtcXHctXSsoPzpcXChbXigpXStcXCl8W14oXSkqPyg/PVxccytbeztdKS8sXG4gICAgaW5zaWRlOiB7IHJ1bGU6IC9AW1xcdy1dKy8gfSxcbiAgfSxcbiAgdXJsOiAvKD86Wy1hLXpdKy0pP3VybCg/PVxcKCkvaSxcbiAgc2VsZWN0b3I6IHtcbiAgICBwYXR0ZXJuOiAvKD89XFxTKVteQDt7fSgpXT8oPzpbXkA7e30oKV18I1xce1xcJFstXFx3XStcXH0pKyg/PVxccypcXHsoPzpcXH18XFxzfFtefV0rWzp7XVtefV0rKSkvbSxcbiAgICBpbnNpZGU6IHtcbiAgICAgIHBhcmVudDogeyBwYXR0ZXJuOiAvJi8sIGFsaWFzOiAnaW1wb3J0YW50JyB9LFxuICAgICAgcGxhY2Vob2xkZXI6IC8lWy1cXHddKy8sXG4gICAgICB2YXJpYWJsZTogL1xcJFstXFx3XSt8I1xce1xcJFstXFx3XStcXH0vLFxuICAgIH0sXG4gIH0sXG4gIHByb3BlcnR5OiB7XG4gICAgcGF0dGVybjogLyg/OlstXFx3XXxcXCRbLVxcd118I1xce1xcJFstXFx3XStcXH0pKyg/PVxccyo6KS8sXG4gICAgaW5zaWRlOiB7IHZhcmlhYmxlOiAvXFwkWy1cXHddK3wjXFx7XFwkWy1cXHddK1xcfS8gfSxcbiAgfSxcbn0pKSxcbiAgUHJpc20ubGFuZ3VhZ2VzLmluc2VydEJlZm9yZSgnc2NzcycsICdhdHJ1bGUnLCB7XG4gICAga2V5d29yZDogW1xuICAgICAgL0AoPzppZnxlbHNlKD86IGlmKT98Zm9yd2FyZHxmb3J8ZWFjaHx3aGlsZXxpbXBvcnR8dXNlfGV4dGVuZHxkZWJ1Z3x3YXJufG1peGlufGluY2x1ZGV8ZnVuY3Rpb258cmV0dXJufGNvbnRlbnQpXFxiL2ksXG4gICAgICB7IHBhdHRlcm46IC8oICspKD86ZnJvbXx0aHJvdWdoKSg/PSApLywgbG9va2JlaGluZDogITAgfSxcbiAgICBdLFxuICB9KSxcbiAgUHJpc20ubGFuZ3VhZ2VzLmluc2VydEJlZm9yZSgnc2NzcycsICdpbXBvcnRhbnQnLCB7XG4gICAgdmFyaWFibGU6IC9cXCRbLVxcd10rfCNcXHtcXCRbLVxcd10rXFx9LyxcbiAgfSksXG4gIFByaXNtLmxhbmd1YWdlcy5pbnNlcnRCZWZvcmUoJ3Njc3MnLCAnZnVuY3Rpb24nLCB7XG4gICAgJ21vZHVsZS1tb2RpZmllcic6IHtcbiAgICAgIHBhdHRlcm46IC9cXGIoPzphc3x3aXRofHNob3d8aGlkZSlcXGIvaSxcbiAgICAgIGFsaWFzOiAna2V5d29yZCcsXG4gICAgfSxcbiAgICBwbGFjZWhvbGRlcjogeyBwYXR0ZXJuOiAvJVstXFx3XSsvLCBhbGlhczogJ3NlbGVjdG9yJyB9LFxuICAgIHN0YXRlbWVudDogeyBwYXR0ZXJuOiAvXFxCISg/OmRlZmF1bHR8b3B0aW9uYWwpXFxiL2ksIGFsaWFzOiAna2V5d29yZCcgfSxcbiAgICBib29sZWFuOiAvXFxiKD86dHJ1ZXxmYWxzZSlcXGIvLFxuICAgIG51bGw6IHsgcGF0dGVybjogL1xcYm51bGxcXGIvLCBhbGlhczogJ2tleXdvcmQnIH0sXG4gICAgb3BlcmF0b3I6IHtcbiAgICAgIHBhdHRlcm46IC8oXFxzKSg/OlstKypcXC8lXXxbPSFdPXw8PT98Pj0/fGFuZHxvcnxub3QpKD89XFxzKS8sXG4gICAgICBsb29rYmVoaW5kOiAhMCxcbiAgICB9LFxuICB9KSxcbiAgKFByaXNtLmxhbmd1YWdlcy5zY3NzLmF0cnVsZS5pbnNpZGUucmVzdCA9IFByaXNtLmxhbmd1YWdlcy5zY3NzKTtcbiEoZnVuY3Rpb24oZSkge1xuICAoZS5sYW5ndWFnZXMudHlwZXNjcmlwdCA9IGUubGFuZ3VhZ2VzLmV4dGVuZCgnamF2YXNjcmlwdCcsIHtcbiAgICAnY2xhc3MtbmFtZSc6IHtcbiAgICAgIHBhdHRlcm46IC8oXFxiKD86Y2xhc3N8ZXh0ZW5kc3xpbXBsZW1lbnRzfGluc3RhbmNlb2Z8aW50ZXJmYWNlfG5ld3x0eXBlKVxccyspKD8ha2V5b2ZcXGIpW18kYS16QS1aXFx4QTAtXFx1RkZGRl1bJFxcd1xceEEwLVxcdUZGRkZdKig/Olxccyo8KD86W148Pl18PCg/OltePD5dfDxbXjw+XSo+KSo+KSo+KT8vLFxuICAgICAgbG9va2JlaGluZDogITAsXG4gICAgICBncmVlZHk6ICEwLFxuICAgICAgaW5zaWRlOiBudWxsLFxuICAgIH0sXG4gICAga2V5d29yZDogL1xcYig/OmFic3RyYWN0fGFzfGFzc2VydHN8YXN5bmN8YXdhaXR8YnJlYWt8Y2FzZXxjYXRjaHxjbGFzc3xjb25zdHxjb25zdHJ1Y3Rvcnxjb250aW51ZXxkZWJ1Z2dlcnxkZWNsYXJlfGRlZmF1bHR8ZGVsZXRlfGRvfGVsc2V8ZW51bXxleHBvcnR8ZXh0ZW5kc3xmaW5hbGx5fGZvcnxmcm9tfGZ1bmN0aW9ufGdldHxpZnxpbXBsZW1lbnRzfGltcG9ydHxpbnxpbnN0YW5jZW9mfGludGVyZmFjZXxpc3xrZXlvZnxsZXR8bW9kdWxlfG5hbWVzcGFjZXxuZXd8bnVsbHxvZnxwYWNrYWdlfHByaXZhdGV8cHJvdGVjdGVkfHB1YmxpY3xyZWFkb25seXxyZXR1cm58cmVxdWlyZXxzZXR8c3RhdGljfHN1cGVyfHN3aXRjaHx0aGlzfHRocm93fHRyeXx0eXBlfHR5cGVvZnx1bmRlZmluZWR8dmFyfHZvaWR8d2hpbGV8d2l0aHx5aWVsZClcXGIvLFxuICAgIGJ1aWx0aW46IC9cXGIoPzpzdHJpbmd8RnVuY3Rpb258YW55fG51bWJlcnxib29sZWFufEFycmF5fHN5bWJvbHxjb25zb2xlfFByb21pc2V8dW5rbm93bnxuZXZlcilcXGIvLFxuICB9KSksXG4gICAgZGVsZXRlIGUubGFuZ3VhZ2VzLnR5cGVzY3JpcHQucGFyYW1ldGVyO1xuICB2YXIgbiA9IGUubGFuZ3VhZ2VzLmV4dGVuZCgndHlwZXNjcmlwdCcsIHt9KTtcbiAgZGVsZXRlIG5bJ2NsYXNzLW5hbWUnXSxcbiAgICAoZS5sYW5ndWFnZXMudHlwZXNjcmlwdFsnY2xhc3MtbmFtZSddLmluc2lkZSA9IG4pLFxuICAgIGUubGFuZ3VhZ2VzLmluc2VydEJlZm9yZSgndHlwZXNjcmlwdCcsICdmdW5jdGlvbicsIHtcbiAgICAgICdnZW5lcmljLWZ1bmN0aW9uJzoge1xuICAgICAgICBwYXR0ZXJuOiAvIz9bXyRhLXpBLVpcXHhBMC1cXHVGRkZGXVskXFx3XFx4QTAtXFx1RkZGRl0qXFxzKjwoPzpbXjw+XXw8KD86W148Pl18PFtePD5dKj4pKj4pKj4oPz1cXHMqXFwoKS8sXG4gICAgICAgIGdyZWVkeTogITAsXG4gICAgICAgIGluc2lkZToge1xuICAgICAgICAgIGZ1bmN0aW9uOiAvXiM/W18kYS16QS1aXFx4QTAtXFx1RkZGRl1bJFxcd1xceEEwLVxcdUZGRkZdKi8sXG4gICAgICAgICAgZ2VuZXJpYzogeyBwYXR0ZXJuOiAvPFtcXHNcXFNdKy8sIGFsaWFzOiAnY2xhc3MtbmFtZScsIGluc2lkZTogbiB9LFxuICAgICAgICB9LFxuICAgICAgfSxcbiAgICB9KSxcbiAgICAoZS5sYW5ndWFnZXMudHMgPSBlLmxhbmd1YWdlcy50eXBlc2NyaXB0KTtcbn0pKFByaXNtKTtcbiEoZnVuY3Rpb24oRSkge1xuICB2YXIgbiA9IC9cXGIoPzpBQ1R8QUNUSUZTVUJ8Q0FSUkFZfENBU0V8Q0xFQVJHSUZ8Q09BfENPQV9JTlR8Q09OU1RBTlRTfENPTlRFTlR8Q1VSfEVESVRQQU5FTHxFRkZFQ1R8RVhUfEZJTEV8RkxVSURURU1QTEFURXxGT1JNfEZSQU1FfEZSQU1FU0VUfEdJRkJVSUxERVJ8R01FTlV8R01FTlVfRk9MRE9VVHxHTUVOVV9MQVlFUlN8R1B8SE1FTlV8SFJVTEVSfEhUTUx8SUVOVnxJRlNVQnxJTUFHRXxJTUdNRU5VfElNR01FTlVJVEVNfElNR1RFWFR8SU1HX1JFU09VUkNFfElOQ0xVREVfVFlQT1NDUklQVHxKU01FTlV8SlNNRU5VSVRFTXxMTEx8TE9BRF9SRUdJU1RFUnxOT3xQQUdFfFJFQ09SRFN8UkVTVE9SRV9SRUdJU1RFUnxURU1QTEFURXxURVhUfFRNRU5VfFRNRU5VSVRFTXxUTUVOVV9MQVlFUlN8VVNFUnxVU0VSX0lOVHxfR0lGQlVJTERFUnxnbG9iYWx8Z2xvYmFsU3RyaW5nfGdsb2JhbFZhcilcXGIvO1xuICAoRS5sYW5ndWFnZXMudHlwb3NjcmlwdCA9IHtcbiAgICBjb21tZW50OiBbXG4gICAgICB7IHBhdHRlcm46IC8oXnxbXlxcXFxdKVxcL1xcKltcXHNcXFNdKj8oPzpcXCpcXC98JCkvLCBsb29rYmVoaW5kOiAhMCB9LFxuICAgICAge1xuICAgICAgICBwYXR0ZXJuOiAvKF58W15cXFxcOj0gXFx0XXwoPzpefFtePSBcXHRdKVsgXFx0XSspXFwvXFwvLiovLFxuICAgICAgICBsb29rYmVoaW5kOiAhMCxcbiAgICAgICAgZ3JlZWR5OiAhMCxcbiAgICAgIH0sXG4gICAgICB7IHBhdHRlcm46IC8oXnxbXlwiJ10pIy4qLywgbG9va2JlaGluZDogITAsIGdyZWVkeTogITAgfSxcbiAgICBdLFxuICAgIGZ1bmN0aW9uOiBbXG4gICAgICB7XG4gICAgICAgIHBhdHRlcm46IC88SU5DTFVERV9UWVBPU0NSSVBUOlxccypzb3VyY2VcXHMqPVxccyooPzpcIlteXCJcXHJcXG5dKlwifCdbXidcXHJcXG5dKicpXFxzKj4vLFxuICAgICAgICBpbnNpZGU6IHtcbiAgICAgICAgICBzdHJpbmc6IHtcbiAgICAgICAgICAgIHBhdHRlcm46IC9cIlteXCJcXHJcXG5dKlwifCdbXidcXHJcXG5dKicvLFxuICAgICAgICAgICAgaW5zaWRlOiB7IGtleXdvcmQ6IG4gfSxcbiAgICAgICAgICB9LFxuICAgICAgICAgIGtleXdvcmQ6IHsgcGF0dGVybjogL0lOQ0xVREVfVFlQT1NDUklQVC8gfSxcbiAgICAgICAgfSxcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIHBhdHRlcm46IC9AaW1wb3J0XFxzKig/OlwiW15cIlxcclxcbl0qXCJ8J1teJ1xcclxcbl0qJykvLFxuICAgICAgICBpbnNpZGU6IHsgc3RyaW5nOiAvXCJbXlwiXFxyXFxuXSpcInwnW14nXFxyXFxuXSonLyB9LFxuICAgICAgfSxcbiAgICBdLFxuICAgIHN0cmluZzoge1xuICAgICAgcGF0dGVybjogL14oW149XSo9WzwgXT8pKD86KD8hXVxcbikuKSovLFxuICAgICAgbG9va2JlaGluZDogITAsXG4gICAgICBpbnNpZGU6IHtcbiAgICAgICAgZnVuY3Rpb246IC97XFwkLip9LyxcbiAgICAgICAga2V5d29yZDogbixcbiAgICAgICAgbnVtYmVyOiAvXlswLTldKyQvLFxuICAgICAgICBwdW5jdHVhdGlvbjogL1ssfDpdLyxcbiAgICAgIH0sXG4gICAgfSxcbiAgICBrZXl3b3JkOiBuLFxuICAgIG51bWJlcjogeyBwYXR0ZXJuOiAvWzAtOV0rXFxzKlsuez1dLywgaW5zaWRlOiB7IG9wZXJhdG9yOiAvWy57PV0vIH0gfSxcbiAgICB0YWc6IHsgcGF0dGVybjogL1xcLj9bXFx3LVxcXFxdK1xcLj8vLCBpbnNpZGU6IHsgcHVuY3R1YXRpb246IC9cXC4vIH0gfSxcbiAgICBwdW5jdHVhdGlvbjogL1t7fVtcXF07KCksLjp8XS8sXG4gICAgb3BlcmF0b3I6IC9bPD5dPT98WyE9XT0/PT98LS0/fFxcK1xcKz98JiY/fFxcfFxcfD98Wz8qL35eJV0vLFxuICB9KSxcbiAgICAoRS5sYW5ndWFnZXMudHNjb25maWcgPSBFLmxhbmd1YWdlcy50eXBvc2NyaXB0KTtcbn0pKFByaXNtKTtcbiEoZnVuY3Rpb24oKSB7XG4gIGlmICgndW5kZWZpbmVkJyAhPSB0eXBlb2Ygc2VsZiAmJiBzZWxmLlByaXNtICYmIHNlbGYuZG9jdW1lbnQpIHtcbiAgICB2YXIgbyA9ICdsaW5lLW51bWJlcnMnLFxuICAgICAgYSA9IC9cXG4oPyEkKS9nLFxuICAgICAgZSA9IChQcmlzbS5wbHVnaW5zLmxpbmVOdW1iZXJzID0ge1xuICAgICAgICBnZXRMaW5lOiBmdW5jdGlvbihlLCBuKSB7XG4gICAgICAgICAgaWYgKCdQUkUnID09PSBlLnRhZ05hbWUgJiYgZS5jbGFzc0xpc3QuY29udGFpbnMobykpIHtcbiAgICAgICAgICAgIHZhciB0ID0gZS5xdWVyeVNlbGVjdG9yKCcubGluZS1udW1iZXJzLXJvd3MnKTtcbiAgICAgICAgICAgIGlmICh0KSB7XG4gICAgICAgICAgICAgIHZhciBpID0gcGFyc2VJbnQoZS5nZXRBdHRyaWJ1dGUoJ2RhdGEtc3RhcnQnKSwgMTApIHx8IDEsXG4gICAgICAgICAgICAgICAgciA9IGkgKyAodC5jaGlsZHJlbi5sZW5ndGggLSAxKTtcbiAgICAgICAgICAgICAgbiA8IGkgJiYgKG4gPSBpKSwgciA8IG4gJiYgKG4gPSByKTtcbiAgICAgICAgICAgICAgdmFyIHMgPSBuIC0gaTtcbiAgICAgICAgICAgICAgcmV0dXJuIHQuY2hpbGRyZW5bc107XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICByZXNpemU6IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICB1KFtlXSk7XG4gICAgICAgIH0sXG4gICAgICAgIGFzc3VtZVZpZXdwb3J0SW5kZXBlbmRlbmNlOiAhMCxcbiAgICAgIH0pLFxuICAgICAgdCA9IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgcmV0dXJuIGVcbiAgICAgICAgICA/IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlXG4gICAgICAgICAgICA/IGdldENvbXB1dGVkU3R5bGUoZSlcbiAgICAgICAgICAgIDogZS5jdXJyZW50U3R5bGUgfHwgbnVsbFxuICAgICAgICAgIDogbnVsbDtcbiAgICAgIH0sXG4gICAgICBuID0gdm9pZCAwO1xuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdyZXNpemUnLCBmdW5jdGlvbigpIHtcbiAgICAgIChlLmFzc3VtZVZpZXdwb3J0SW5kZXBlbmRlbmNlICYmIG4gPT09IHdpbmRvdy5pbm5lcldpZHRoKSB8fFxuICAgICAgICAoKG4gPSB3aW5kb3cuaW5uZXJXaWR0aCksXG4gICAgICAgIHUoQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCgncHJlLicgKyBvKSkpKTtcbiAgICB9KSxcbiAgICAgIFByaXNtLmhvb2tzLmFkZCgnY29tcGxldGUnLCBmdW5jdGlvbihlKSB7XG4gICAgICAgIGlmIChlLmNvZGUpIHtcbiAgICAgICAgICB2YXIgbiA9IGUuZWxlbWVudCxcbiAgICAgICAgICAgIHQgPSBuLnBhcmVudE5vZGU7XG4gICAgICAgICAgaWYgKFxuICAgICAgICAgICAgdCAmJlxuICAgICAgICAgICAgL3ByZS9pLnRlc3QodC5ub2RlTmFtZSkgJiZcbiAgICAgICAgICAgICFuLnF1ZXJ5U2VsZWN0b3IoJy5saW5lLW51bWJlcnMtcm93cycpICYmXG4gICAgICAgICAgICBQcmlzbS51dGlsLmlzQWN0aXZlKG4sIG8pXG4gICAgICAgICAgKSB7XG4gICAgICAgICAgICBuLmNsYXNzTGlzdC5yZW1vdmUobyksIHQuY2xhc3NMaXN0LmFkZChvKTtcbiAgICAgICAgICAgIHZhciBpLFxuICAgICAgICAgICAgICByID0gZS5jb2RlLm1hdGNoKGEpLFxuICAgICAgICAgICAgICBzID0gciA/IHIubGVuZ3RoICsgMSA6IDEsXG4gICAgICAgICAgICAgIGwgPSBuZXcgQXJyYXkocyArIDEpLmpvaW4oJzxzcGFuPjwvc3Bhbj4nKTtcbiAgICAgICAgICAgIChpID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc3BhbicpKS5zZXRBdHRyaWJ1dGUoXG4gICAgICAgICAgICAgICdhcmlhLWhpZGRlbicsXG4gICAgICAgICAgICAgICd0cnVlJ1xuICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgKGkuY2xhc3NOYW1lID0gJ2xpbmUtbnVtYmVycy1yb3dzJyksXG4gICAgICAgICAgICAgIChpLmlubmVySFRNTCA9IGwpLFxuICAgICAgICAgICAgICB0Lmhhc0F0dHJpYnV0ZSgnZGF0YS1zdGFydCcpICYmXG4gICAgICAgICAgICAgICAgKHQuc3R5bGUuY291bnRlclJlc2V0ID1cbiAgICAgICAgICAgICAgICAgICdsaW5lbnVtYmVyICcgK1xuICAgICAgICAgICAgICAgICAgKHBhcnNlSW50KHQuZ2V0QXR0cmlidXRlKCdkYXRhLXN0YXJ0JyksIDEwKSAtIDEpKSxcbiAgICAgICAgICAgICAgZS5lbGVtZW50LmFwcGVuZENoaWxkKGkpLFxuICAgICAgICAgICAgICB1KFt0XSksXG4gICAgICAgICAgICAgIFByaXNtLmhvb2tzLnJ1bignbGluZS1udW1iZXJzJywgZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KSxcbiAgICAgIFByaXNtLmhvb2tzLmFkZCgnbGluZS1udW1iZXJzJywgZnVuY3Rpb24oZSkge1xuICAgICAgICAoZS5wbHVnaW5zID0gZS5wbHVnaW5zIHx8IHt9KSwgKGUucGx1Z2lucy5saW5lTnVtYmVycyA9ICEwKTtcbiAgICAgIH0pO1xuICB9XG4gIGZ1bmN0aW9uIHUoZSkge1xuICAgIGlmIChcbiAgICAgIDAgIT1cbiAgICAgIChlID0gZS5maWx0ZXIoZnVuY3Rpb24oZSkge1xuICAgICAgICB2YXIgbiA9IHQoZSlbJ3doaXRlLXNwYWNlJ107XG4gICAgICAgIHJldHVybiAncHJlLXdyYXAnID09PSBuIHx8ICdwcmUtbGluZScgPT09IG47XG4gICAgICB9KSkubGVuZ3RoXG4gICAgKSB7XG4gICAgICB2YXIgbiA9IGVcbiAgICAgICAgLm1hcChmdW5jdGlvbihlKSB7XG4gICAgICAgICAgdmFyIG4gPSBlLnF1ZXJ5U2VsZWN0b3IoJ2NvZGUnKSxcbiAgICAgICAgICAgIHQgPSBlLnF1ZXJ5U2VsZWN0b3IoJy5saW5lLW51bWJlcnMtcm93cycpO1xuICAgICAgICAgIGlmIChuICYmIHQpIHtcbiAgICAgICAgICAgIHZhciBpID0gZS5xdWVyeVNlbGVjdG9yKCcubGluZS1udW1iZXJzLXNpemVyJyksXG4gICAgICAgICAgICAgIHIgPSBuLnRleHRDb250ZW50LnNwbGl0KGEpO1xuICAgICAgICAgICAgaSB8fFxuICAgICAgICAgICAgICAoKChpID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc3BhbicpKS5jbGFzc05hbWUgPVxuICAgICAgICAgICAgICAgICdsaW5lLW51bWJlcnMtc2l6ZXInKSxcbiAgICAgICAgICAgICAgbi5hcHBlbmRDaGlsZChpKSksXG4gICAgICAgICAgICAgIChpLmlubmVySFRNTCA9ICcwJyksXG4gICAgICAgICAgICAgIChpLnN0eWxlLmRpc3BsYXkgPSAnYmxvY2snKTtcbiAgICAgICAgICAgIHZhciBzID0gaS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS5oZWlnaHQ7XG4gICAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgICAoaS5pbm5lckhUTUwgPSAnJyksXG4gICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBlbGVtZW50OiBlLFxuICAgICAgICAgICAgICAgIGxpbmVzOiByLFxuICAgICAgICAgICAgICAgIGxpbmVIZWlnaHRzOiBbXSxcbiAgICAgICAgICAgICAgICBvbmVMaW5lckhlaWdodDogcyxcbiAgICAgICAgICAgICAgICBzaXplcjogaSxcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pXG4gICAgICAgIC5maWx0ZXIoQm9vbGVhbik7XG4gICAgICBuLmZvckVhY2goZnVuY3Rpb24oZSkge1xuICAgICAgICB2YXIgaSA9IGUuc2l6ZXIsXG4gICAgICAgICAgbiA9IGUubGluZXMsXG4gICAgICAgICAgciA9IGUubGluZUhlaWdodHMsXG4gICAgICAgICAgcyA9IGUub25lTGluZXJIZWlnaHQ7XG4gICAgICAgIChyW24ubGVuZ3RoIC0gMV0gPSB2b2lkIDApLFxuICAgICAgICAgIG4uZm9yRWFjaChmdW5jdGlvbihlLCBuKSB7XG4gICAgICAgICAgICBpZiAoZSAmJiAxIDwgZS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgdmFyIHQgPSBpLmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NwYW4nKSk7XG4gICAgICAgICAgICAgICh0LnN0eWxlLmRpc3BsYXkgPSAnYmxvY2snKSwgKHQudGV4dENvbnRlbnQgPSBlKTtcbiAgICAgICAgICAgIH0gZWxzZSByW25dID0gcztcbiAgICAgICAgICB9KTtcbiAgICAgIH0pLFxuICAgICAgICBuLmZvckVhY2goZnVuY3Rpb24oZSkge1xuICAgICAgICAgIGZvciAoXG4gICAgICAgICAgICB2YXIgbiA9IGUuc2l6ZXIsIHQgPSBlLmxpbmVIZWlnaHRzLCBpID0gMCwgciA9IDA7XG4gICAgICAgICAgICByIDwgdC5sZW5ndGg7XG4gICAgICAgICAgICByKytcbiAgICAgICAgICApXG4gICAgICAgICAgICB2b2lkIDAgPT09IHRbcl0gJiZcbiAgICAgICAgICAgICAgKHRbcl0gPSBuLmNoaWxkcmVuW2krK10uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkuaGVpZ2h0KTtcbiAgICAgICAgfSksXG4gICAgICAgIG4uZm9yRWFjaChmdW5jdGlvbihlKSB7XG4gICAgICAgICAgdmFyIG4gPSBlLnNpemVyLFxuICAgICAgICAgICAgdCA9IGUuZWxlbWVudC5xdWVyeVNlbGVjdG9yKCcubGluZS1udW1iZXJzLXJvd3MnKTtcbiAgICAgICAgICAobi5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnKSxcbiAgICAgICAgICAgIChuLmlubmVySFRNTCA9ICcnKSxcbiAgICAgICAgICAgIGUubGluZUhlaWdodHMuZm9yRWFjaChmdW5jdGlvbihlLCBuKSB7XG4gICAgICAgICAgICAgIHQuY2hpbGRyZW5bbl0uc3R5bGUuaGVpZ2h0ID0gZSArICdweCc7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxuICB9XG59KSgpO1xuIl0sInNvdXJjZVJvb3QiOiIifQ==